import { Button } from '@buffet/button';
import eventTracker from '@buffet/event-tracker';
import { FooterUserAgreement, TransitionableFooter } from '@buffet/user-agreement';
import { Restaurant } from 'gca-react-components/src/redux-modules/currentContext';
import React from 'react';
import { FormattedMessage } from 'react-intl';
import { connect } from 'react-redux';
import BackButton from 'shared-react-atomic-ui/BackButton';
import { gaTrackTypes, getAgreementTypeForPos } from '../constants';
import { getAgreementContext } from '../constants';
import { AsyncStatus } from '../store/AsyncState';
import { selectors as posSelectors, updateDisplayState } from '../store/onboarding/onboarding';
import { fetchUserAgreement } from '../store/onboarding/userAgreement';
import {
  FetchAgreementDetailsParams,
  OnboardingDisplayStateName,
  State,
  SupportedPosBrand,
  UserAgreementData,
} from '../store/types';

import './OnboardingFooter.scss';

interface SP {
  displayState: OnboardingDisplayStateName;
  isAgreementSigned: boolean;
  restaurant: Restaurant;
  savingPosBrandToRideStatus: AsyncStatus;
  selectedPos: SupportedPosBrand;
}

interface DP {
  updateAgreement: ({ params, result }: { params: FetchAgreementDetailsParams, result: UserAgreementData }) => void;
  updateDisplayState: (payload: OnboardingDisplayStateName) => void;
}

type Props = SP & DP;

class OnboardingFooter extends React.Component<Props> {

  public render() {
    const show =
      !!this.props.selectedPos.Id
      && this.props.displayState !== 'nextSteps'
      && (this.props.savingPosBrandToRideStatus === 'init' || this.props.savingPosBrandToRideStatus === 'done');

    return this.props.isAgreementSigned ? (
      <TransitionableFooter
        className="onboarding__footer"
        show={show}
      >
        <div className="onboarding__footer__content">
          <FormattedMessage id="posSelect.alreadySigned" />
          <Button
            className="onboarding-footer__button"
            type="button"
            onClick={this.nextPageHandler}
            theme="primary"
          >
            <FormattedMessage id="posSelect.nextBtn" />
          </Button>
        </div>
      </TransitionableFooter>
    ) : (
      <FooterUserAgreement
        show={show}
        persistentFooter={true}
        agreementType={getAgreementTypeForPos(this.props.selectedPos.Id)}
        context={getAgreementContext(this.props.restaurant.rid)}
        contextName={this.props.restaurant.name}
        onAgreeSuccess={this.acceptUserAgreementHandler}
      >
        <BackButton onClick={this.handleBack}>
          <FormattedMessage id="nextSteps.back" />
        </BackButton>
      </FooterUserAgreement>
    );
  }

  private handleBack = () => {
    this.props.updateDisplayState('landing');
    eventTracker.sendEvent({
      action: gaTrackTypes.actions.nagivate,
      category: gaTrackTypes.category,
      label: 'pos-select:back',
    });
  };

  private nextPageHandler = () => {
    eventTracker.sendEvent({
      action: gaTrackTypes.actions.nagivate,
      category: gaTrackTypes.category,
      label: 'pos-select:next',
    });
    this.props.updateDisplayState('nextSteps');
  };

  private acceptUserAgreementHandler = () => {
    eventTracker.sendEvent({
      action: gaTrackTypes.actions.submit,
      category: gaTrackTypes.category,
      label: 'pos-select:accept-agreement',
    });

    // synthetically trigger the done action on fetchUserAgreement to keep the apps agreement state in synch
    this.props.updateAgreement({
      params: { rid: this.props.restaurant.rid, agreementTypes: [] },
      result: { isSigned: true, displayState: 'nextSteps' },
    });
  };
}

const mapState = (state: State): SP => ({
  displayState: state.onBoarding.displayState,
  isAgreementSigned: posSelectors.isAgreementSigned(state),
  restaurant: state.currentContext.restaurant,
  savingPosBrandToRideStatus: state.onBoarding.savePosBrandStatus.status,
  selectedPos: state.onBoarding.selectedPos,
});

const mapDispatch = {
  updateAgreement: fetchUserAgreement.done,
  updateDisplayState,
};

export default connect<SP, DP, {}>(
  mapState,
  mapDispatch,
)(OnboardingFooter);

export { OnboardingFooter as PureOnboardingFooter, Props };
