import { SupportedPosBrandsIds } from '../types';
import {
  deselectPosBrand,
  displayStateReducer,
  selectors,
  selectPosBrand,
  selectPosBrandReducer,
  updateDisplayState,
  updatePosBrand,
} from './onboarding';
import { posBrandMocks, setupState } from './onboarding.mocks';
import { fetchUserAgreement } from './userAgreement';

describe('onBoarding action creators', () => {
  describe('selectPosBrand', () => {
    it('should take a PosBrand to update the selectedPos on state', () => {
      const payload = posBrandMocks[0];
      const actual = selectPosBrand(payload);
      expect(actual).toEqual({ payload, type: 'SELECT_POS_BRAND' });
    });
  });

  describe('update pos brand', () => {
    it('should take a PosBrand to update the selectedPos on state (and will not save to salesforce)', () => {
      const payload = posBrandMocks[0];
      const actual = updatePosBrand(payload);
      expect(actual).toEqual({ payload, type: 'UPDATE_POS_BRAND' });
    });
  });

  describe('updateDisplayState', () => {
    it('should take a string to update the display state', () => {
      const payload = 'posSelect';
      const actual = updateDisplayState(payload);
      expect(actual).toEqual({ payload, type: 'UPDATE_DISPLAY_STATE' });
    });
  });

  describe('deselectPosBrand', () => {
    it('should fire the deselectPosBrand action', () => {
      const actual = deselectPosBrand();
      expect(actual).toEqual({ type: 'DESELECT_POS_BRAND' });
    });
  });
});

describe('onBoarding selectors', () => {
  describe('getSupportedPosBrands', () => {
    it('should return an empty array if there is no data in the supportedPos state', () => {
      const testState = setupState();

      expect(selectors.getSupportedPosBrands(testState)).toEqual([]);
    });

    it('should return an array of PosBrands if it is on data in the supportedPos state', () => {
      const testState = setupState({
        fetchSupportedPosStatus: {
          data: posBrandMocks,
          status: 'done',
        },
      });

      expect(selectors.getSupportedPosBrands(testState)).toEqual(posBrandMocks);
    });

    it('should return empty array when there is an error', () => {
      const testState = setupState({
        fetchSupportedPosStatus: {
          data: { error: 'something went wrong' },
          status: 'failed',
        },
      });

      expect(selectors.getSupportedPosBrands(testState)).toEqual([]);
    });
  });

  describe('isAppLoading', () => {
    describe('is loading when', () => {
      it('context is loading', () => {
        const testState = setupState(undefined, { isFetching: true });

        expect(selectors.isAppLoading(testState)).toBe(true);
      });

      it('ride primary products and ride restaurant data is loading', () => {
        const testState = setupState(
          {
            fetchPosRideDataStatus: {
              data: undefined,
              status: 'started',
            },
          },
          { isFetching: false },
        );

        expect(selectors.isAppLoading(testState)).toBe(true);
      });

      it('when pos is inactive but agreement is loading', () => {
        const testState = setupState(
          {
            fetchPosRideDataStatus: {
              data: {},
              status: 'done',
            },
            fetchUserAgreementStatus: {
              data: undefined,
              status: 'started',
            },
          },
          { isFetching: false },
        );

        expect(selectors.isAppLoading(testState)).toBe(true);
      });
    });

    describe('is done loading when', () => {
      it('context, primary product, and resturant data is done and pos is active so UAS is never called', () => {
        const testState = setupState(
          {
            fetchPosRideDataStatus: {
              data: {},
              status: 'done',
            },
            fetchUserAgreementStatus: {
              data: undefined,
              status: 'init',
            },
          },
          { isFetching: false },
        );

        expect(selectors.isAppLoading(testState)).toBe(false);
      });
      it('context, primary product, and restaurant data user agreement done', () => {
        const testState = setupState(
          {
            fetchPosRideDataStatus: {
              data: {},
              status: 'done',
            },
            fetchUserAgreementStatus: {
              data: {},
              status: 'done',
            },
          },
          { isFetching: false },
        );

        expect(selectors.isAppLoading(testState)).toBe(false);
      });
    });
  });

  describe('isAgreementSigned', () => {
    it('should return false if fetchUserAgreementStatus is not done', () => {
      const testState = setupState();

      expect(selectors.isAgreementSigned(testState)).toEqual(false);
    });

    it('should return true if fetchUserAgreementStatus data is true', () => {
      const testState = setupState({
        fetchUserAgreementStatus: {
          data: true,
          status: 'done',
        },
      });

      expect(selectors.isAgreementSigned(testState)).toEqual(true);
    });

    it('should return false if fetchUserAgreementStatus data is false', () => {
      const testState = setupState({
        fetchUserAgreementStatus: {
          data: false,
          status: 'done',
        },
      });

      expect(selectors.isAgreementSigned(testState)).toEqual(false);
    });
  });
});

describe('onBoarding reducers', () => {
  describe('selectPosBrand', () => {
    it('should update the selectedPos with the payload', () => {
      const action = { type: selectPosBrand.type, payload: posBrandMocks[0] };
      const expected = posBrandMocks[0];
      const actual = selectPosBrandReducer(posBrandMocks[1], action);

      expect(actual).toEqual(expected);
    });

    it('should update the pos brand (but will not save to salesforce)', () => {
      const action = { type: updatePosBrand.type, payload: posBrandMocks[0] };
      const expected = posBrandMocks[0];
      const actual = selectPosBrandReducer(posBrandMocks[1], action);

      expect(actual).toEqual(expected);
    });
  });

  describe('deselectPosBrand', () => {
    it('should clear out the pos brand', () => {
      const action = { type: deselectPosBrand.type };
      const actual = selectPosBrandReducer(posBrandMocks[1], action);

      expect(actual).toEqual({ Id: SupportedPosBrandsIds.unselected, Name: '' });
    });
  });

  describe('updateDisplayState', () => {
    it('should update the displayState with the payload', () => {
      const action = { type: updateDisplayState.type, payload: 'posSelect' };
      const expected = 'posSelect';
      const actual = displayStateReducer('landing', action);

      expect(actual).toEqual(expected);
    });

    it('should set display to whatever the user agreement decided to set it to', () => {
      const action = {
        payload: { params: 1701, result: { isSigned: true, displayState: 'active' } },
        type: fetchUserAgreement.done.type,
      };
      const actual = displayStateReducer('landing', action);

      expect(actual).toBe('active');
    });
  });
});
