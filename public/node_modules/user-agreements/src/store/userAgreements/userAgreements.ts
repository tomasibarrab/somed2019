import {
  FETCH_CONTEXT_USER_SUCCESS,
  selectors as ccSelectors,
} from 'gca-react-components/src/redux-modules/currentContext';
import { combineEpics } from 'redux-observable';
import { createSelector } from 'reselect';
import { AjaxError, AjaxResponse } from 'rxjs/observable/dom/AjaxObservable';
import { Action, actionCreatorFactory, Failure } from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';
import AsyncStatus from '../../AsyncStatus';
import '../commonRxjs';
import {
  Epic,
  State,
  Store,
} from '../types';
import { initUserAgreements } from './userAgreements.fixture';
import {
  AcceptTermsDTO,
  AgreementIdType,
  AgreementState,
  AgreementStepName,
  AppointmentDateDTO,
  ConfirmPageDisplayState,
  PricingItem,
  PricingItemCategories,
  TermsAndConditionsItem,
  UpdateUserAgreementDTO,
  UserAgreementsDTO,
  UserAgreementsState,
} from './userAgreements.types';


// ---------------------------------------------------------------------------------------------------------------------
// Actions
// ---------------------------------------------------------------------------------------------------------------------

const actionCreator = actionCreatorFactory('USER_AGREEMENTS');

export const fetchUserAgreements = actionCreator.async<AgreementIdType, UserAgreementsDTO, {}>('FETCH_USER_AGREEMENTS');
// tslint:disable-next-line:max-line-length
export const updateAppointmentScheduled = actionCreator.async<AgreementIdType, UserAgreementsDTO, {}>('UPDATE_APPOINTMENT_SCHEDULED');
// tslint:disable-next-line:max-line-length
export const updateAgreementState = actionCreator.async<UpdateUserAgreementDTO, UserAgreementsDTO, {}>('UPDATE_USER_AGREEMENTS');
export const acceptTerms = actionCreator.async<{}, UserAgreementsDTO, {}>('ACCEPT_TERMS');
export const pageScrolledToBottom = actionCreator('PAGE_SCROLLED_TO_BOTTOM');
export const resetUserAgreements = actionCreator('RESET_USER_AGREEMENTS');
export const showPrintPage = actionCreator<boolean>('SHOW_PRINT_PAGE');
export const emailContractOwner = actionCreator('EMAIL_CONTRACT_OWNER');

export const actions = {
  acceptTerms,
  emailContractOwner,
  fetchUserAgreements,
  pageScrolledToBottom,
  resetUserAgreements,
  showPrintPage,
  updateAgreementState,
  updateAppointmentScheduled,
};


// ---------------------------------------------------------------------------------------------------------------------
// Selectors
// ---------------------------------------------------------------------------------------------------------------------

export const getFetchStatus = (state: State): AsyncStatus => {
  return state.userAgreements.fetchStatus;
}

export const isForbidden = (state: State): boolean => {
  return state.userAgreements.fetchError ? state.userAgreements.fetchError.status === 403 : false;
}

export const getUpdateAppointmentScheduledStatus = (state: State): AsyncStatus => {
  return state.userAgreements.updateAppointmentScheduledStatus;
}

export const getUpdateStatus = (state: State): AsyncStatus => {
  return state.userAgreements.updateStatus;
}

export const getAcceptStatus = (state: State): AsyncStatus => {
  return state.userAgreements.acceptStatus;
}

export const getAnyAsyncFailed = (state: State): boolean => {
  return getUpdateStatus(state) === AsyncStatus.Failed || getAcceptStatus(state) === AsyncStatus.Failed;
}

export const getUserAgreements = (state: State): UserAgreementsDTO => {
  if (!state.userAgreements.userAgreement) {
    throw new Error('UserAgreement not defined');
  }

  return state.userAgreements.userAgreement;
};

export const getTermsAndConditions = (state: State): TermsAndConditionsItem[] => {
  const userAgreements: UserAgreementsDTO = getUserAgreements(state);
  if (!userAgreements.termsAndConditions || !userAgreements.termsAndConditions.length) {
    throw new Error('termsAndConditions not defined');
  }

  return userAgreements.termsAndConditions;
};

export const getCurrentPage = (state: State): AgreementStepName => {
  let componentName;
  const printPage = state.userAgreements.printPage;

  if (state.userAgreements.viewAgreement) {
    componentName = AgreementStepName.Print;
  } else {
    switch (state.userAgreements.userAgreement.agreementState) {
      case AgreementState.AgreementCreated:
      case AgreementState.AgreementUpdated:
        componentName = AgreementStepName.PricingDetails;
        break;
      case AgreementState.PricingAccepted:
        componentName = AgreementStepName.TermsAndConditions;
        break;
      case AgreementState.TermsAccepted:
        componentName = hasSchedulingData(state) ? AgreementStepName.Scheduling : getPrintOrConfirmStepName(printPage);
        break;
      case AgreementState.AppointmentScheduled:
        componentName = getPrintOrConfirmStepName(printPage);
        break;
      case AgreementState.AgreementExpired:
      case AgreementState.AgreementRenegotiated:
      default:
        componentName = AgreementStepName.AgreementInvalid;
    }
  }

  return componentName;
}

const getPrintOrConfirmStepName = (printPage: boolean): AgreementStepName => {
  return printPage ? AgreementStepName.Print : AgreementStepName.Confirm;
}

export const wasAppointmentJustScheduled =
  (state: State): boolean => (state.userAgreements.wasAppointmentJustScheduled);

export const getConfirmPageDisplayState =
  (state: State): ConfirmPageDisplayState => {
    if (state.userAgreements.wasAppointmentJustScheduled) {
      return 'Scheduled_RedirectedFromScheduling';
    } else if (hasSchedulingData(state)) {
      return 'Scheduled_LoadedFromUrl';
    } else {
      return 'Unscheduled_SchedulingSkipped';
    }
  };

export const isAgreementView = (state: State): boolean => state.userAgreements.viewAgreement;

export const getAgreementId = createSelector(
  getUserAgreements,
  (ua: UserAgreementsDTO) => ua.agreementId,
);

export const getAgreementState = createSelector(
  getUserAgreements,
  (ua: UserAgreementsDTO) => ua.agreementState,
);

export const getEntityInfo = createSelector(
  getUserAgreements,
  (ua: UserAgreementsDTO) => ua.entityInfo,
);

export const getContractOwner = createSelector(
  getUserAgreements,
  (ua: UserAgreementsDTO) => ua.contractOwner,
);

export const getCustomerInfo = createSelector(
  getUserAgreements,
  (ua: UserAgreementsDTO) => ua.customerInfo,
);

export const getAppointmentDate = createSelector(
  getUserAgreements,
  (ua: UserAgreementsDTO) => ua.appointmentDate,
);

export const getOpportunityId = createSelector(
  getUserAgreements,
  (ua: UserAgreementsDTO) => ua.salesforce.opportunityId,
);

export const getPricingByCategory = createSelector(
  getUserAgreements,
  (ua: UserAgreementsDTO) => {

    const pricingByCategory: PricingItemCategories = {
      covers: [],
      oneTime: [],
      recurring: [],
    }

    if (ua.pricingDetails.pricingItems && ua.pricingDetails.pricingItems.length > 0) {
      ua.pricingDetails.pricingItems.map((lineItem: PricingItem) => {
        if (lineItem.billingRecurrence === 'one time') {
          pricingByCategory.oneTime.push(lineItem);
        } else if (lineItem.feeType === 'covers') {
          pricingByCategory.covers.push(lineItem);
        } else {
          pricingByCategory.recurring.push(lineItem);
        }
      })
    }

    return pricingByCategory;
  },
);

export const isAppLoadFailed = createSelector(
  ccSelectors.fetchFailed,
  getFetchStatus,
  getUpdateAppointmentScheduledStatus,
  isForbidden,
  (
    isCurrentContextFetchFailed: boolean,
    fetchStatus: AsyncStatus,
    updateAppointmentScheduledStatus: AsyncStatus,
    // tslint:disable-next-line:no-shadowed-variable
    isForbidden: boolean,
  ) => (
    isCurrentContextFetchFailed
    || fetchStatus.isFailed() && !isForbidden
    || updateAppointmentScheduledStatus.isFailed() && !isForbidden
  ),
);

export const isAppLoading = createSelector(
  ccSelectors.isFetching,
  getFetchStatus,
  getUpdateAppointmentScheduledStatus,
  wasAppointmentJustScheduled,
  (
    isCurrentContextFetching: boolean,
    fetchStatus: AsyncStatus,
    updateAppointmentScheduledStatus: AsyncStatus,
    // tslint:disable-next-line:no-shadowed-variable
    wasAppointmentJustScheduled: boolean,
  ) => (
    isCurrentContextFetching
    || !wasAppointmentJustScheduled && (fetchStatus.isStarted() || fetchStatus.isInitial())
    // tslint:disable-next-line:max-line-length
    || wasAppointmentJustScheduled && (updateAppointmentScheduledStatus.isStarted() || updateAppointmentScheduledStatus.isInitial())
  ),
);

export const hasSchedulingData = createSelector(
  getUserAgreements,
  (ua: UserAgreementsDTO) => ua.schedulingLink === 'SKIP_SCHEDULING' ? false : true,
);

export const getNumberOfSteps = createSelector(
  hasSchedulingData,
  (shouldSchedule: boolean): number => {
  return shouldSchedule ? 3 : 2;
});

export const selectors = {
  getAgreementId,
  getAgreementState,
  getAnyAsyncFailed,
  getConfirmPageDisplayState,
  getContractOwner,
  getCurrentPage,
  getCustomerInfo,
  getFetchStatus,
  getNumberOfSteps,
  getOpportunityId,
  getPricingByCategory,
  getTermsAndConditions,
  getUpdateAppointmentScheduledStatus,
  getUpdateStatus,
  getUserAgreements,
  hasSchedulingData,
  isAgreementView,
  isAppLoadFailed,
  isAppLoading,
  isForbidden,
};


// ---------------------------------------------------------------------------------------------------------------------
// Epics
// ---------------------------------------------------------------------------------------------------------------------

export const triggerFetchUserAgreementsEpic: Epic = (action$, store) => action$
  .ofType(FETCH_CONTEXT_USER_SUCCESS)
  .filter(() => !store.getState().userAgreements.wasAppointmentJustScheduled)
  .map(() => fetchUserAgreements.started({ agreementId: store.getState().userAgreements.agreementId }));

export const triggerAppointmentScheduledEpic: Epic = (action$, store) => action$
  .ofType(FETCH_CONTEXT_USER_SUCCESS)
  .filter(() => store.getState().userAgreements.wasAppointmentJustScheduled)
  .map(() => updateAppointmentScheduled.started({ agreementId: store.getState().userAgreements.agreementId }));

export const fetchUserAgreementsEpic: Epic = (action$, store, { api }) => action$
  .filter(fetchUserAgreements.started.match)
  .mergeMap(({ payload }: Action<AgreementIdType>) =>
    api
      .fetchUserAgreements(payload.agreementId, !isAgreementView(store.getState()))
      .map((userAgreement: UserAgreementsDTO) =>
        fetchUserAgreements.done({
          params: payload,
          result: userAgreement,
        }),
      )
      .catch(err => [fetchUserAgreements.failed({ params: payload, error: err })]),
    );

/**
 * Solution for extracting a query string value from the `window.location.search` string. `URL.searchParams` would be a
 * much cleaner solution, but is not supported by any version of ie.
 *
 * @see https://stackoverflow.com/questions/9870512/how-to-obtain-the-query-string-from-the-current-url-with-javascript
 * @param key query string key to retrieve a value for
 * @return query string value, or empty string if there is not a matching key
 */
export function getQueryStringValue(key: string): string {
  return decodeURIComponent(
    window.location.search.replace(
      new RegExp('^(?:.*[&\\?]' +
        encodeURIComponent(key).replace(/[\.\+\*]/g, '\\$&') +
        '(?:\\=([^&]*))?)?.*$', 'i'), '$1'));
}

export function createAppointmentDateDTO(store: Store): AppointmentDateDTO {
  let appointmentDate = getQueryStringValue('event_start_time');
  appointmentDate = appointmentDate.length ? appointmentDate : '';

  return {
    agreementId: store.getState().userAgreements.agreementId,
    appointmentDate,
  };
}

export const appointmentScheduledEpic: Epic = (action$, store, { api }) => action$
  .filter(updateAppointmentScheduled.started.match)
  .mergeMap(({ payload }: Action<AgreementIdType>) =>
    api
      .appointmentScheduled(createAppointmentDateDTO(store))
      .map((response: AjaxResponse) =>
        updateAppointmentScheduled.done({
          params: payload,
          result: response.response,
        }),
      )
      .catch(err => [updateAppointmentScheduled.failed({ params: payload, error: err })]),
    );

export const updateAgreementStateEpic: Epic = (action$, store, { api }) => action$
  .filter(updateAgreementState.started.match)
  .mergeMap(({ payload }: Action<UpdateUserAgreementDTO>) =>
    api
      .updateAgreementState(payload)
      .map((response: AjaxResponse) =>
        updateAgreementState.done({
          params: payload,
          result: response.response,
        }),
      )
      .catch(err => [updateAgreementState.failed({ params: payload, error: err })]),
    );

export function createAcceptDTO(store: Store): AcceptTermsDTO {
  const userAgreement: UserAgreementsDTO = store.getState().userAgreements.userAgreement;

  return {
    agreementId: userAgreement.agreementId,
    clientEmail: userAgreement.customerInfo.email,
    signedVersions: userAgreement.termsAndConditions.map((tc: TermsAndConditionsItem) => tc.version),
  };
}

export const acceptTermsEpic: Epic = (action$, store, { api }) => action$
  .filter(acceptTerms.started.match)
  .map(() => createAcceptDTO(store))
  .mergeMap((acceptTermsPayload: AcceptTermsDTO) =>
    api
      .acceptTerms(acceptTermsPayload)
      .map((response: AjaxResponse) =>
        acceptTerms.done({
          params: acceptTermsPayload,
          result: response.response,
        }),
      )
      .catch(err => [acceptTerms.failed({ params: acceptTermsPayload, error: err })]),
    );

export const userAgreementsEpic = combineEpics(
  acceptTermsEpic,
  appointmentScheduledEpic,
  fetchUserAgreementsEpic,
  triggerAppointmentScheduledEpic,
  triggerFetchUserAgreementsEpic,
  updateAgreementStateEpic,
);


// ---------------------------------------------------------------------------------------------------------------------
// Reducers
// ---------------------------------------------------------------------------------------------------------------------

export const initialState: UserAgreementsState = {
  acceptStatus: AsyncStatus.Initial,
  agreementId: !!getQueryStringValue('utm_campaign').length
    ? getQueryStringValue('utm_campaign')
    : window.location.pathname.split('/')[3],
  fetchError: null,
  fetchStatus: AsyncStatus.Initial,
  isPageScrolledToBottom: false,
  printPage: false,
  updateAppointmentScheduledStatus: AsyncStatus.Initial,
  updateStatus: AsyncStatus.Initial,
  userAgreement: initUserAgreements(),
  viewAgreement: window.location.pathname.split('/')[4] === 'view' ? true : false,
  wasAppointmentJustScheduled: getQueryStringValue('utm_campaign').length !== 0,
}

export const userAgreementsReducer = reducerWithInitialState(initialState)
  .case(fetchUserAgreements.started, state => ({ ...state, fetchStatus: AsyncStatus.Started }))
  .case(fetchUserAgreements.done, (state, payload) => ({
    ...state,
    fetchStatus: AsyncStatus.Done,
    userAgreement: payload.result,
  }))
  .case(
    fetchUserAgreements.failed,
    (state: UserAgreementsState, payload: Failure<AgreementIdType, AjaxError>) => ({
      ...state,
      fetchError: payload.error,
      fetchStatus: AsyncStatus.Failed,
    }),
  )
  .case(updateAppointmentScheduled.started, (state: UserAgreementsState) => ({
    ...state,
    updateAppointmentScheduledStatus: AsyncStatus.Started,
  }))
  .case(updateAppointmentScheduled.done, (state: UserAgreementsState, payload) => ({
    ...state,
    updateAppointmentScheduledStatus: AsyncStatus.Done,
    userAgreement: payload.result,
  }))
  .case(updateAppointmentScheduled.failed, (state: UserAgreementsState) => ({
    ...state,
    updateAppointmentScheduledStatus: AsyncStatus.Failed,
  }))
  .case(updateAgreementState.started, (state: UserAgreementsState) => ({
    ...state,
    updateStatus: AsyncStatus.Started,
  }))
  .case(updateAgreementState.done, (state: UserAgreementsState, payload) => ({
    ...state,
    isPageScrolledToBottom: false,
    updateStatus: AsyncStatus.Done,
    userAgreement: payload.result,
  }))
  .case(updateAgreementState.failed, (state: UserAgreementsState) => ({
    ...state,
    updateStatus: AsyncStatus.Failed,
  }))
  .case(acceptTerms.started, (state: UserAgreementsState) => ({
    ...state,
    acceptStatus: AsyncStatus.Started,
  }))
  .case(acceptTerms.done, (state: UserAgreementsState, payload) => ({
    ...state,
    acceptStatus: AsyncStatus.Done,
    userAgreement: payload.result,
  }))
  .case(acceptTerms.failed, (state: UserAgreementsState) => ({
    ...state,
    acceptStatus: AsyncStatus.Failed,
  }))
  .case(pageScrolledToBottom, (state: UserAgreementsState) => ({
    ...state,
    isPageScrolledToBottom: true,
  }))
  .case(resetUserAgreements, (state: UserAgreementsState) => ({
    ...state,
    acceptStatus: AsyncStatus.Initial,
    updateStatus: AsyncStatus.Initial,
  }))
  .case(showPrintPage, (state: UserAgreementsState, payload) => ({
    ...state,
    printPage: payload,
  }));
