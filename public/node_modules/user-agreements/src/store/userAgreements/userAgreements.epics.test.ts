import configureMockStore from 'redux-mock-store';
import { ActionsObservable } from 'redux-observable';
import { Observable } from 'rxjs';

import { Action } from '../types';
import {
  acceptTermsEpic,
  actions,
  appointmentScheduledEpic,
  createAcceptDTO,
  createAppointmentDateDTO,
  fetchUserAgreementsEpic,
  getQueryStringValue,
  initialState,
  updateAgreementStateEpic,
} from './userAgreements';
import {
  AcceptTermsDTO,
  AgreementState,
  AppointmentDateDTO,
  UpdateUserAgreementDTO,
  UserAgreementsDTO,
} from './userAgreements.types';

const mockStore = configureMockStore();

// tslint:disable-next-line:no-var-requires
const mockData: UserAgreementsDTO =  require('../../../fixtures/UserAgreementsMock');

const state = {
  currentContext: {
    restaurant: {
      rid: 123,
    },
  },
  userAgreements: { ...initialState },
};

const mockedApi = {
  acceptTerms: (acceptTermsPayload: AcceptTermsDTO): Observable<{ response: UserAgreementsDTO }> =>
    Observable.of({ response: mockData }),
  appointmentScheduled: (appointmentDatePayload: AppointmentDateDTO): Observable<{ response: UserAgreementsDTO }> =>
    Observable.of({ response: mockData }),
  fetchUserAgreements: ({ agreementId }: { agreementId: string }): Observable<{ response: UserAgreementsDTO }> =>
    Observable.of({ response: mockData}),
  updateAgreementState: (updateUserAgreement: UpdateUserAgreementDTO): Observable<{ response: UserAgreementsDTO }> =>
    Observable.of({ response: mockData }),
}

const mockedFailedApi = {
  acceptTerms: (acceptTermsPayload: AcceptTermsDTO): Observable<{ response: { error: any } }> =>
    Observable.of({ response: { params: acceptTermsPayload, error: '404' } }),
  appointmentScheduled: (appointmentDatePayload: AppointmentDateDTO): Observable<{ response: { error: any } }> =>
    Observable.of({ response: { params: appointmentDatePayload, error: '404' } }),
  fetchUserAgreements: ({ agreementId }: { agreementId: string }): Observable<{ response: { error: any } }> =>
    Observable.of({ response: { params: '123', error: '404' } }),
  updateAgreementState: (updateUserAgreement: UpdateUserAgreementDTO): Observable<{ response: { error: any } }> =>
    Observable.of({ response: { params: updateUserAgreement, error: '404' } }),
}

describe('User Agreements epic', () => {
  let oldLocation;

  beforeAll(() => {
    // as per https://github.com/facebook/jest/issues/5124
    oldLocation = window.location;
    delete window.location;
    window.location = {
      ...oldLocation,
      search: '?event_type_name=Test&event_start_time=2018-08-24T12%3A30%3A00-07%3A00',
    };
  });

  afterAll(() => {
    window.location = oldLocation;
  });

  it('should fetch a User Agreement', () => {
    const payload = { agreementId: '123' };
    const output$ = fetchUserAgreementsEpic(
      ActionsObservable.of(actions.fetchUserAgreements.started(payload)),
      mockStore(state),
      { api: mockedApi as any},
    );
    output$.toArray().subscribe((acts: Action[]) => {
      expect(acts).toHaveLength(1);
      expect(acts[0].type).toBe(actions.fetchUserAgreements.done.type);
    });
  });

  it('should fail to fetch a User Agreement', () => {
    const payload = { params: { agreementId: '123'}, error: '404' };
    const output$ = fetchUserAgreementsEpic(
      ActionsObservable.of(actions.fetchUserAgreements.failed(payload)),
      mockStore(state),
      { api: mockedFailedApi as any },
    );
    output$.toArray().subscribe((error: Action[]) => {
      expect(error).toHaveLength(0);
    });
  });

  it('should update a User Agreement', () => {
    const payload = { agreementId: '123', agreementState: AgreementState.PricingAccepted };
    const output$ = updateAgreementStateEpic(
      ActionsObservable.of(actions.updateAgreementState.started(payload)),
      mockStore(state),
      { api: mockedApi as any },
    );
    output$.toArray().subscribe((acts: Action[]) => {
      expect(acts).toHaveLength(1);
      expect(acts[0].type).toBe(actions.updateAgreementState.done.type);
    });
  });

  it('should fail to update a User Agreement', () => {
    const payload = { params: { agreementId: '123', agreementState: AgreementState.PricingAccepted }, error: '404' };
    const output$ = updateAgreementStateEpic(
      ActionsObservable.of(actions.updateAgreementState.failed(payload)),
      mockStore(state),
      { api: mockedFailedApi as any },
    );
    output$.toArray().subscribe((error: Action[]) => {
      expect(error).toHaveLength(0);
    });
  });

  it('should create an AcceptTermsDTO', () => {
    const agreementId = 123;
    const email = 'bob@bob.com';

    const modifiedState = {
      ...state,
      userAgreements: {
        ...state.userAgreements,
        userAgreement: {
          ...state.userAgreements.userAgreement,
          agreementId,
          customerInfo: {
            ...state.userAgreements.userAgreement.customerInfo,
            email,
          },
          termsAndConditions: [{ version: 1 }, { version: 2 }, { version: 3 }],
        },
      },
    };

    const store = mockStore(modifiedState);
    const expectedDTO = {
      agreementId: 123,
      clientEmail: email,
      signedVersions: [1, 2, 3],
    };

    expect(createAcceptDTO(store)).toEqual(expectedDTO);
  });

  it('should accept a User Agreement', () => {
    const payload = {};
    const output$ = acceptTermsEpic(
      ActionsObservable.of(actions.acceptTerms.started(payload)),
      mockStore(state),
      { api: mockedApi as any },
    );
    output$.toArray().subscribe((acts: Action[]) => {
      expect(acts).toHaveLength(1);
      expect(acts[0].type).toBe(actions.acceptTerms.done.type);
    });
  });

  it('should fail to accept a User Agreement', () => {
    const payload = { params: { clientEmail: 'bob@bob.com', signedVersions: [1] }, error: '404' };
    const output$ = acceptTermsEpic(
      ActionsObservable.of(actions.acceptTerms.failed(payload)),
      mockStore(state),
      { api: mockedFailedApi as any },
    );
    output$.toArray().subscribe((error: Action[]) => {
      expect(error).toHaveLength(0);
    });
  });

  describe('getQueryStringValue', () => {

    it('should get a non-url encoded parameter', () => {
      expect(getQueryStringValue('event_type_name')).toEqual('Test');
    });

    it('should get an url encoded parameter', () => {
      expect(getQueryStringValue('event_start_time')).toEqual('2018-08-24T12:30:00-07:00');
    });

    it('should get an empty string for an undefined property', () => {
      expect(getQueryStringValue('foo')).toEqual('');
    });
  });

  it('should create an AppointmentDateDTO', () => {
    const appointmentState = { ...state, userAgreements: { ...state.userAgreements, agreementId: 123 } };
    const appointmentStore = mockStore(appointmentState);
    const expectedDTO = {
      agreementId: 123,
      appointmentDate: '2018-08-24T12:30:00-07:00',
    };

    expect(createAppointmentDateDTO(appointmentStore)).toEqual(expectedDTO);
  });

  it('should update appointment scheduled', () => {
    const payload = { agreementId: '123' };
    const output$ = appointmentScheduledEpic(
      ActionsObservable.of(actions.updateAppointmentScheduled.started(payload)),
      mockStore(state),
      { api: mockedApi as any },
    );
    output$.toArray().subscribe((acts: Action[]) => {
      expect(acts).toHaveLength(1);
      expect(acts[0].type).toBe(actions.updateAppointmentScheduled.done.type);
    });
  });

  it('should fail to update appointment scheduled', () => {
    const payload = { params: { agreementId: '123' }, error: '404' };
    const output$ = appointmentScheduledEpic(
      ActionsObservable.of(actions.updateAppointmentScheduled.failed(payload)),
      mockStore(state),
      { api: mockedFailedApi as any },
    );
    output$.toArray().subscribe((error: Action[]) => {
      expect(error).toHaveLength(0);
    });
  });

});
