import React from 'react';
import { UserAgreement } from './UserAgreement';
import { IntlProvider, registerMessages } from '@buffet/intl';
import mock from 'xhr-mock';
import {
  mockGetAgreement,
  mockCreateAgreement,
  mockSignAgreement,
  AGREEMENT_TYPE,
  AGREEMENT_CONTEXT,
  AGREEMENT_CONTEXT_NAME,
} from '../fixtures/setupMocks';
import unsignedAgreementMock from '../fixtures/unsignedUserAgreement';
import signedAgreementMock from '../fixtures/signedUserAgreement';

import { render, fireEvent, wait } from 'react-testing-library';

const messages = require('../translations/en-US/user-agreement.json');
const AGREE_TEXT = 'Next';

describe('UserAgreement', async () => {
  const renderComponent = async () => {
    const onAgreeSuccess = jest.fn();
    const onInitialized = jest.fn();
    const renderResult = render(
      <IntlProvider>
        <UserAgreement
          agreementType={AGREEMENT_TYPE}
          context={AGREEMENT_CONTEXT}
          contextName={AGREEMENT_CONTEXT_NAME}
          onInitialized={onInitialized}
          onAgreeSuccess={onAgreeSuccess}
        />
      </IntlProvider>
    );
    return { onAgreeSuccess, onInitialized, renderResult };
  };

  beforeAll(() => {
    registerMessages({ ['en-US']: messages });
    jest.useFakeTimers();
  });

  beforeEach(() => {
    mock.setup();
  });

  afterEach(() => {
    mock.teardown();
  });

  describe('during initialization', () => {
    it('should show loading state when initializing', async () => {
      mockGetAgreement(500, {}, true);
      const { renderResult } = await renderComponent();

      // Test unreliable because <Button> does not properly implement test-id
      // renderResult.getByTestId('loading-spinner');
      // Test will pass on any disabled button present
      const loadingSpinner = renderResult.container.querySelector('button:disabled');
      expect(loadingSpinner).toBeTruthy();
    });
  });

  describe('initialization failed', async () => {
    it('should see error message when fetch agreement API call fails', async () => {
      mockGetAgreement(500);
      const { renderResult } = await renderComponent();

      await wait(() => {
        renderResult.getByTestId('error-message');
      });

      const checkbox = renderResult.queryByTestId('agreement-checkbox');
      const button = renderResult.queryByText(AGREE_TEXT);
      const viewTermsButton = renderResult.queryByText('POS Integration Addendum');
      expect(checkbox).toBe(null);
      expect(button).toBe(null);
      expect(viewTermsButton).toBe(null);
    });

    it('should see error message when create agreement API call fails', async () => {
      mockGetAgreement(404);
      mockCreateAgreement(500);
      const { renderResult } = await renderComponent();

      await wait(() => {
        renderResult.getByTestId('error-message');
      });

      const checkbox = renderResult.queryByTestId('agreement-checkbox');
      const button = renderResult.queryByText(AGREE_TEXT);
      const viewTermsButton = renderResult.queryByText('POS Integration Addendum');
      expect(checkbox).toBe(null);
      expect(button).toBe(null);
      expect(viewTermsButton).toBe(null);
    });
  });

  describe('initialization creates new unsigned agreement', async () => {
    it('should see initialized agreement component', async () => {
      mockGetAgreement(404);
      mockCreateAgreement(201, unsignedAgreementMock.agreementDetails);
      const { onInitialized, renderResult } = await renderComponent();

      await wait(() => {
        renderResult.getByTestId('agreement-checkbox');
        renderResult.getByText(AGREE_TEXT);
        renderResult.getByText('POS Integration Addendum');

        expect(onInitialized).toHaveBeenCalledWith(unsignedAgreementMock);
      });
    });
  });

  describe('after init, when agreement starts unsigned,', async () => {
    it('should call callback after submit complete', async () => {
      mockGetAgreement(200, unsignedAgreementMock);
      mockSignAgreement(200, signedAgreementMock.agreementDetails);
      const { renderResult, onAgreeSuccess } = await renderComponent();

      await wait(() => {
        renderResult.getByTestId('agreement-checkbox');
        renderResult.getByText(AGREE_TEXT);
        renderResult.getByText('POS Integration Addendum');
      });

      const checkbox = renderResult.getByTestId('agreement-checkbox');
      const button = renderResult.getByText(AGREE_TEXT);

      fireEvent.click(checkbox);
      fireEvent.click(button);

      await wait(() => expect(onAgreeSuccess).toHaveBeenCalledWith(signedAgreementMock));
    });

    // unclear what the error display should be for this
    xit('should show error message if submit fails', async () => {
      mockGetAgreement(200, unsignedAgreementMock);
      mockSignAgreement(500, {}, false);
      const { renderResult, onAgreeSuccess } = await renderComponent();

      await wait(() => {
        renderResult.getByTestId('agreement-checkbox');
        renderResult.getByText(AGREE_TEXT);
        renderResult.getByText('POS Integration Addendum');
      });

      const checkbox = renderResult.getByTestId('agreement-checkbox');
      const button = renderResult.getByText(AGREE_TEXT);

      fireEvent.click(checkbox);
      fireEvent.click(button);

      await wait(() => renderResult.getByTestId('error-message'));
      expect(onAgreeSuccess).not.toHaveBeenCalled();
    });
  });

  describe('when agreement starts signed,', async () => {
    // TODO: Future PR, no signed state yet
  });
});
