import {
  Fieldset,
  InputField,
  LabelGroup,
  ModalWrapper,
  Panel,
  PublishButton,
  TextAreaField,
} from 'gca-react-components';
import PropTypes from 'prop-types';
import * as React from 'react';
import { InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';
import { Prompt } from 'react-router-dom';
import { Field, FieldArray, FormErrors, formValueSelector, InjectedFormProps, reduxForm } from 'redux-form';
import testEmail from '../../common/testEmail';
import { postPrivateDining, resetError } from '../../store/privatedining/privatedining';
import { PrivateDining, PrivateDiningData, Status } from '../../store/privatedining/privatedining.types';
import { initialValuesSelector, privateDiningFormDefaults } from '../../store/privatedining/privateDiningForm';
import { Dispatch, State } from '../../store/types';
import PhotoController from './Photo/PhotoController';
import Rooms from './Rooms';

import './EnabledV2.scss';

export const FORM_NAME = 'privateDining';
export const enum Fields {
  LargestCapacity = 'largestCapacity',
  PartyShortDescription = 'partyShortDescription',
  PartyLongDescription = 'partyLongDescription',
  PrivateDiningMenu = 'privateDiningMenu',
  PrivatePartyContact = 'privatePartyContact',
  PrivatePartyEmail = 'privatePartyEmail',
  PrivatePartyPhone = 'privatePartyPhone',
  PrivatePartyPhoneExt = 'privatePartyPhoneExt',
}

export const pdFormValueSelector = formValueSelector(FORM_NAME);

interface SP {
  initialValues: PrivateDiningData;
  privateDining: PrivateDining;
}

interface DP {
  resetError(): void;
}

export type BaseProps = DP & SP & InjectedIntlProps;
export type FormProps = InjectedFormProps<PrivateDiningData, BaseProps>;
export type Props = BaseProps & FormProps;

// Trim whitespace from beginning of email string, do not trim end because email field
// can contain multiple email addresses separated by a semi-colon
const trimLeft = (value: string) => value && value.replace(/^\s+/, '');

class PrivateDiningEnabled extends React.Component<Props> {
  public static childContextTypes = {
    showValidationWhenPristine: PropTypes.bool,
  };

  public getChildContext() {
    return {
      // When initializing the form, validate (and show errors) only if the form is not empty
      showValidationWhenPristine: !this.props.privateDining.isFormEmpty,
    };
  }

  // TODO: Move this into a shared component
  public componentDidMount() {
    window.onbeforeunload = () => {
      if (!this.props.pristine) {
        return this.props.intl.formatMessage({ id: 'app.unpublished' });
      }

      return undefined;
    };
  }

  public componentWillUnmount() {
    window.onbeforeunload = () => undefined;
  }

  public render() {
    const {
      handleSubmit,
      dirty,
      pristine,
      intl: { formatMessage },
      valid,
    } = this.props;
    const getLabel = (message: string): string => formatMessage({ id: `privatedining.enabled.v2.${message}` });
    const headerContent = (
      <div className="gca-header-content">
        <PublishButton
          buttonText={formatMessage({ id: 'privatedining.form.publish' })}
          successText={formatMessage({ id: 'privatedining.form.publish.success' })}
          onClick={handleSubmit}
          busy={this.props.privateDining.postStatus === Status.Started}
          disabled={pristine || !valid}
          success={this.props.privateDining.postStatus === Status.Done}
          successDuration={5000}
        />
      </div>
    );

    const errorModal = (
      <div>
        <ModalWrapper
          onConfirm={() => {
            this.props.resetError();
          }}
          onCancel={() => {
            this.props.resetError();
          }}
          includeCancelButton={false}
          confirmButtonText={formatMessage({ id: 'privatedining.form.publish.error.modal.ok' })}
          title={formatMessage({ id: 'privatedining.form.publish.error.modal.title' })}
        >
          {formatMessage({ id: 'privatedining.form.publish.error.modal.message' })}
        </ModalWrapper>
      </div>
    );

    return (
      <Panel title={formatMessage({ id: 'privatedining.title' })} headerContent={headerContent}>
        {this.props.privateDining.postStatus === Status.Failed ? errorModal : null}
        <Prompt when={dirty} message={formatMessage({ id: 'app.unpublished' })} />
        <form onSubmit={handleSubmit} className="private-dining-form">
          <Fieldset legend={getLabel('section.contact.title')} description={getLabel('section.contact.description')}>
            <LabelGroup label={getLabel('fields.name')}>
              <InputField name={Fields.PrivatePartyContact} />
            </LabelGroup>

            <LabelGroup label={getLabel('fields.email')}>
              <InputField name={Fields.PrivatePartyEmail} normalize={trimLeft} />
            </LabelGroup>

            <div className="phone">
              <LabelGroup label={getLabel('fields.phone')}>
                <InputField name={Fields.PrivatePartyPhone} />
              </LabelGroup>

              <LabelGroup label={getLabel('fields.phone.ext')}>
                <InputField name={Fields.PrivatePartyPhoneExt} maxLength={5} />
              </LabelGroup>
            </div>
          </Fieldset>

          <Fieldset legend={getLabel('section.info.title')} description={getLabel('section.info.listing.description')}>
            <LabelGroup label={getLabel('fields.listing.description')}>
              <TextAreaField name={Fields.PartyShortDescription} max={300} rows={5} />
            </LabelGroup>

            <LabelGroup label={getLabel('fields.profile.description')}>
              <TextAreaField name={Fields.PartyLongDescription} max={1000} rows={7} />
            </LabelGroup>

            <LabelGroup label={getLabel('fields.url')}>
              <InputField name={Fields.PrivateDiningMenu} />
            </LabelGroup>

            <LabelGroup label={getLabel('fields.capacity')}>
              <InputField type="number" name={Fields.LargestCapacity} className="capacity-input" />
            </LabelGroup>

            {/* Disable Private Dining Photo Section - https://opentable.atlassian.net/browse/UTC-285
              <LabelGroup label={getLabel('fields.photo')}>
                <Field name="photo" component={PhotoController} height={120} width={120} />
              </LabelGroup>
            */}
          </Fieldset>

          <FieldArray name="rooms" component={Rooms} {/*  :(  */ ...{} as any} />
        </form>
      </Panel>
    );
  }
}

/* Phone regex excerpted from here:
  https://stackoverflow.com/questions/16699007/regular-expression-to-match-standard-10-digit-phone-number
  [^(]*       # Only allow left paren at the beginning of the Area Code.
  (\d{3})     # GROUP 2: The Area Code. Required.
  [-. )]*     # Allow certain non numeric characters between the Area Code and the Exchange number
  (\d{3})     # GROUP 3: The Exchange number. Required.
  [-. ]*      # Allow certain non numeric characters between the Exchange number and the Subscriber number.
  (\d{4})     # Group 4: The Subscriber Number. Required.
  $           # Don't allow any character after the subscriber number
*/
const phoneRegEx: RegExp = /^[(]*(\d{3})[-. )]*(\d{3})[-. ]*(\d{4})$/;

// email address field can contain multiple email addresses delimited by a semi-colon
const isEmailValid = (email: string) => email.split(/\s*;\s*/).every(emailAddr => testEmail(emailAddr));

const isPhoneValid = (phone: string) => phoneRegEx.test(phone);

type PrivateDiningFormErrors = FormErrors<{
  largestCapacity?: string;
  partyShortDescription?: string;
  partyLongDescription?: string;
  privateDiningMenu?: string;
  privatePartyContact?: string;
  privatePartyEmail?: string;
  privatePartyPhone?: string;
  rooms?: object[];
}>;

const validate = (formValues: PrivateDiningData): PrivateDiningFormErrors => {
  const errors: any = {};

  if (formValues.largestCapacity <= 0 || formValues.largestCapacity > 99999) {
    errors.largestCapacity = 'Required';
  }

  if (formValues.partyShortDescription.length === 0) {
    errors.partyShortDescription = 'Required';
  }

  if (formValues.partyLongDescription.length === 0) {
    errors.partyLongDescription = 'Required';
  }

  if (formValues.privateDiningMenu.length > 250) {
    errors.privateDiningMenu = 'Required';
  }

  if (
    formValues.privatePartyEmail.length > 510 ||
    formValues.privatePartyEmail.length <= 0 ||
    !isEmailValid(formValues.privatePartyEmail)
  ) {
    errors.privatePartyEmail = 'Required';
  }

  if (
    formValues.privatePartyPhone.length < 10 ||
    formValues.privatePartyPhone.length > 13 ||
    !isPhoneValid(formValues.privatePartyPhone)
  ) {
    errors.privatePartyPhone = 'Required';
  }

  if (!formValues.privatePartyContact.length || formValues.privatePartyContact.length > 100) {
    errors.privatePartyContact = 'Required';
  }

  const roomArrayErrors: any[] = [];
  formValues.rooms.forEach((room, idx) => {
    const roomErrors: any = {};

    if (idx === 0 || room.active) {
      if (room.roomName.length <= 0 || room.roomName.length > 100) {
        roomErrors.roomName = 'room name not valid';
        roomArrayErrors[idx] = roomErrors;
      }

      if (room.roomDescription.length <= 0) {
        roomErrors.roomDescription = 'room description not valid';
        roomArrayErrors[idx] = roomErrors;
      }

      if (room.seatedSize <= 0 || room.seatedSize > 99999) {
        roomErrors.seatedSize = 'room seated capacity not valid';
        roomArrayErrors[idx] = roomErrors;
      }

      if (room.standingSize <= 0 || room.standingSize > 99999) {
        roomErrors.standingSize = 'room standing capacity not valid';
        roomArrayErrors[idx] = roomErrors;
      }
    }
  });

  if (roomArrayErrors.length) {
    errors.rooms = [...roomArrayErrors];
  }

  return errors;
};

const ReduxPrivateDiningEnabled = reduxForm<PrivateDiningData, BaseProps>({
  enableReinitialize: true,
  form: FORM_NAME,
  keepDirtyOnReinitialize: true,
  onSubmit: (values, dispatch) => {
    dispatch(postPrivateDining.started(privateDiningFormDefaults(values)));
  },
  validate,
})(PrivateDiningEnabled);

const mapState = (state: State) => {
  return {
    initialValues: initialValuesSelector(state),
    privateDining: state.privateDining,
  };
};

const mapDispatchToProps = {
  resetError,
};

export default connect(
  mapState,
  mapDispatchToProps,
)(injectIntl(ReduxPrivateDiningEnabled));
