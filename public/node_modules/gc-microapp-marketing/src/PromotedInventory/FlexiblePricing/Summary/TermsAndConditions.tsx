import { Button } from 'gca-react-components';
import { CheckboxFinalField, InputFinalField } from 'gca-react-components/src/finalform-fields';
import { selectors, User } from 'gca-react-components/src/redux-modules/currentContext';
import React, { Component, SFC } from 'react';
import { Form } from 'react-final-form';
import { FormattedMessage } from 'react-intl';
import { connect } from 'react-redux';
import FinalFieldFocusTracker from '../../../Gifts/FinalFieldFocusTracker';
import '../../../Gifts/TermsAndConditions/TermsAndConditions.scss';
import validateGiftsTermsForm from '../../../Gifts/TermsAndConditions/validate';
import { actions } from '../../../store/flexiblepricing/flexiblepricing';
import { TermsType } from '../../../store/flexiblepricing/flexiblepricing.types';
import { ClickOrInteractPayload } from '../../../store/gifts/gifts.types';
import { State } from '../../../store/types';
import { LINK_TO_FLEXIBLE_PRICING_TERMS_V1 } from '../../constants';

interface TermsFormValues {
  name: string;
  email: string;
  restaurantLegalName: string;
}

export type TermsFVWithBrowserInfo = TermsFormValues & { browserInfo: string };

interface SP {
  user: User;
  sendingSettings: boolean;
}

interface DP {
  clickOrInteract: (payload: ClickOrInteractPayload) => void;
}

interface OP {
  termsType: TermsType;
  confirm: (formAndBrowserData: TermsFVWithBrowserInfo) => void;
}

type Props = SP & DP & OP;

export class TermsAndConditions extends Component<Props> {
  private addBrowserInfoAndConfirm: (formValues: TermsFormValues) => void;

  constructor(props: Props) {
    super(props);
    this.addBrowserInfoAndConfirm = (formValues: TermsFormValues) => {
      const platform = require('platform');
      const { name, version, layout, os, description }: any = platform;
      const browserInfo = JSON.stringify({ name, version, layout, os, description });
      const withBrowserInfo = { ...formValues, browserInfo, agreed: undefined };
      this.props.confirm(withBrowserInfo);
    };
  }

  public render() {
    const { user, clickOrInteract, termsType, sendingSettings } = this.props;
    const userEmail = user.userName;
    /* i18n nightmare next line */
    const userFullName = `${user.firstName} ${user.lastName}`;
    const initialValues = {
      agreed: false,
      email: userEmail,
      name: userFullName,
    };

    const clientHasRead = (
      <FormattedMessage
        id="flexiblepricing.summary.terms_and_conditions.client_has_read"
        values={{
          'opentable-client-agreement-link': (
            <a href={LINK_TO_FLEXIBLE_PRICING_TERMS_V1} target="_blank">
              <FormattedMessage id="guestcampaigns.terms.flexible_pricing_terms_and_conditions" />
            </a>
          ),
        }}
      />
    );

    let acceptButtonMessageId = 'flexiblepricing.summary.switch_to_flexible_pricing';

    if (termsType === TermsType.Edit) {
      acceptButtonMessageId = 'flexiblepricing.summary.make_changes';
    }

    return (
      <Form
        onSubmit={this.addBrowserInfoAndConfirm}
        initialValues={initialValues}
        validate={validateGiftsTermsForm}
        render={({ handleSubmit, active, valid }) => (
          <form onSubmit={handleSubmit} className="terms-and-conditions-form gifts">
            <InputFieldAndLabel
              name="name"
              className="name"
              data-testid="name"
              messageIdSuffix="your_name"
              sublabelId="gifts.terms.must_be_authorized"
            />
            <div className="email">
              <FormattedMessage id="guestcampaigns.terms.your_email" tagName="label" />
              <span>{(initialValues as any).email}</span>
            </div>
            <InputFieldAndLabel
              name="restaurantLegalName"
              className="restaurant-legal-name"
              data-testid="restaurant-legal-name"
              messageIdSuffix="restaurant_legal_name"
            />
            <FinalFieldFocusTracker
              trackFocus={true}
              trackBlur={true}
              fieldName="restaurantLegalName"
              formattedFieldName="Restaurant Legal Name"
              active={active}
              clickOrInteract={clickOrInteract}
              pageName="Terms & Conditions"
            />
            <CheckboxFieldAndLabel name="agreed" className="agreed" label={clientHasRead as any} />
            <Button
              theme="publish"
              type="button"
              htmlType="submit"
              className="agree-and-publish"
              data-testid="agree-and-sign-up-button"
              disabled={!valid || sendingSettings}
              busy={sendingSettings}
              onClick={() => {
                clickOrInteract({
                  action: 'Click',
                  props: { name: 'Publish', page: 'Terms & Conditions' },
                });
              }}
            >
              <FormattedMessage id={acceptButtonMessageId} />
            </Button>
          </form>
        )}
      />
    );
  }
}

const mapState = (state: State) => ({
  sendingSettings: state.flexiblePricing.sendingSettings,
  user: selectors.user(state),
});

const mapDispatch = {
  clickOrInteract: actions.clickOrInteract,
};

export default connect<SP, DP, OP>(mapState, mapDispatch)(TermsAndConditions);

interface InputFieldAndLabelProps {
  name: string;
  className?: string;
  disabled?: boolean;
  messageIdSuffix: string;
  sublabelId?: string;
  onFocus?: () => void;
}
const InputFieldAndLabel: SFC<InputFieldAndLabelProps> = ({
  name,
  className,
  disabled,
  messageIdSuffix,
  sublabelId,
  onFocus,
}) => (
  <div className={className}>
    <FormattedMessage id={`guestcampaigns.terms.${messageIdSuffix}`} tagName="label" />
    <InputFinalField name={name} autoComplete="off" disabled={disabled || false} onFocus={onFocus} />
    {sublabelId && <FormattedMessage id={sublabelId} tagName="span" />}
  </div>
);

interface CheckboxAndLabelFieldProps {
  name: string;
  className?: string;
  label: string;
}
const CheckboxFieldAndLabel: SFC<CheckboxAndLabelFieldProps> = ({ name, className, label }: any) => {
  return <CheckboxFinalField name={name} className={className} label={label} />;
};
