import './TermsAndConditions.scss';

import { Button, Checkbox, Chevron, Input } from 'gca-react-components';
import { selectors, User } from 'gca-react-components/src/redux-modules/currentContext';
import React, { Component, SFC } from 'react';
import { FormattedMessage } from 'react-intl';
import { connect } from 'react-redux';
import { Field, InjectedFormProps, reduxForm } from 'redux-form';

import { actions } from '../../store/campaigns/campaigns';
import {
    CampaignPricingInformation, Incentive, TermsAndConditionsLink, UserFacingCampaignInformation,
} from '../../store/campaigns/campaigns.types';
import { State } from '../../store/types';
import { formatCurrency } from '../CampaignsList/helpers/format-number-locale';
import { TERMS_AND_CONDITIONS_FORM_NAME } from '../constants';
import ReadOnlyDraftCampaign from './ReadOnlyDraftCampaign';
import { validate } from './validate-terms';

interface TermsFormValues {
  name: string;
  email: string;
  restaurantLegalName: string;
}

export type TermsFVWithBrowserInfo = TermsFormValues & { browserInfo: string };

interface SP {
  user: User;
}

interface DP {
  clickCallToAction: (data: any) => void;
}

interface OP {
  confirm: (formAndBrowserData: TermsFVWithBrowserInfo) => void;
  detailsOpen?: boolean;
  campaign: UserFacingCampaignInformation & CampaignPricingInformation;
  linkToTerms: TermsAndConditionsLink;
  incentive?: Incentive;
  isApproval?: boolean;
}

type Props = SP & DP & OP;

interface ComponentState {
  detailsOpen: boolean;
}

export class TermsAndConditions extends Component<Props, ComponentState> {
  private form: any;

  constructor(props: Props) {
    super(props);
    this.state = {
      detailsOpen: props.detailsOpen || false,
    };

    const addBrowserInfoAndConfirm = (formValues: TermsFormValues) => {
      const platform = require('platform');
      const { name, version, layout, os, description }: any = platform;
      const browserInfo = JSON.stringify({ name, version, layout, os, description });
      const withBrowserInfo = { ...formValues, browserInfo };
      this.props.confirm(withBrowserInfo);
    };

    this.form = makeDecoratedForm(addBrowserInfoAndConfirm);
  }

  public toggle = () => {
    this.setState(prevState => ({
      detailsOpen: !prevState.detailsOpen,
    }));
  };

  public render() {
    const { campaign, incentive, user, linkToTerms, clickCallToAction, isApproval } = this.props;
    const { detailsOpen } = this.state;
    const userEmail = user.userName;
    /* i18n nightmare next line */
    const userFullName = `${user.firstName} ${user.lastName}`;
    const initialValues = {
      agreed: false,
      email: userEmail,
      name: userFullName,
    };

    const legalLink = (
      <a
        href={linkToTerms.link}
        onClick={() =>
          clickCallToAction({
            name: linkToTerms.id
              .split('.')
              .pop()!
              .replace(/_/g, ' '),
            page: 'Terms And Conditions',
          })
        }
        target="_blank"
      >
        <FormattedMessage id={linkToTerms.id} />
      </a>
    );

    return (
      <>
        <div className="toggle-readonly-campaign-details" onClick={this.toggle}>
          <FormattedMessage id="guestcampaigns.list.campaigndetails" />
          <Chevron direction={detailsOpen ? 'up' : 'down'} />
        </div>
        {detailsOpen && <ReadOnlyDraftCampaign campaign={campaign} incentive={incentive} />}
        {isApproval && (
          <FormattedMessage
            id="guestcampaigns.terms.approve.description"
            tagName="p"
            values={{
              'opentable-client-agreement-link': legalLink,
              price: (({ pricingTier: { currencyCode, price } }) => formatCurrency(price, currencyCode))(campaign),
            }}
          />
        )}
        <this.form
          initialValues={initialValues}
          campaignType={campaign.type}
          legalLink={legalLink}
          isApproval={isApproval}
        />
      </>
    );
  }
}

const mapState = (state: State) => ({
  user: selectors.user(state),
});

const mapDispatch = {
  clickCallToAction: actions.clickCallToAction,
};

export default connect<SP, DP, OP>(
  mapState,
  mapDispatch,
)(TermsAndConditions);

const TermsAndConditionsForm: SFC<
  InjectedFormProps & {
    labelForTerms: string;
    legalLink: string;
    isApproval: boolean;
  }
> = ({ handleSubmit, valid, initialValues, isApproval, legalLink }) => {
  const clientHasRead = (
    <FormattedMessage
      id="guestcampaigns.terms.client_has_read"
      values={{
        'opentable-client-agreement-link': legalLink,
      }}
    />
  );

  return (
    <form onSubmit={handleSubmit} className="terms-and-conditions-form">
      <Field
        name="name"
        component={renderInputFieldAndLabel as any}
        props={
          {
            className: 'name',
            messageIdSuffix: 'your_name',
            subtext: isApproval ? 'guestcampaigns.terms.authorized' : false,
          } as any
        }
      />
      <div className="email">
        <FormattedMessage id="guestcampaigns.terms.your_email" tagName="label" />
        <span>{(initialValues as any).email}</span>
      </div>
      <Field
        name="restaurantLegalName"
        component={renderInputFieldAndLabel as any}
        props={{ className: 'restaurant-legal-name', messageIdSuffix: 'restaurant_legal_name' } as any}
      />
      <Field
        name="agreed"
        component={renderCheckboxAndLabel as any}
        type="checkbox"
        props={{ className: 'agreed', label: clientHasRead } as any}
      />
      <Button theme="publish" type="button" htmlType="submit" className="agree-and-publish" disabled={!valid}>
        <FormattedMessage id="guestcampaigns.terms.agree_and_publish" />
      </Button>
    </form>
  );
};

const makeDecoratedForm = (onSubmit: (formValues: TermsFormValues) => void) =>
  reduxForm<TermsFormValues, any, any>({
    form: TERMS_AND_CONDITIONS_FORM_NAME,
    onSubmit,
    validate,
  })(TermsAndConditionsForm);

const renderInputFieldAndLabel = ({ meta, input, className, disabled, messageIdSuffix, subtext }: any) => {
  const { touched, error } = meta;

  return (
    <div className={className}>
      <FormattedMessage id={`guestcampaigns.terms.${messageIdSuffix}`} tagName="label" />
      <Input {...input} autoComplete="off" disabled={disabled} valid={!(touched && error)} />
      {subtext && <FormattedMessage tagName="p" id={subtext} />}
    </div>
  );
};

const renderCheckboxAndLabel = ({ input, className, label }: any) => {
  const { onChange, value } = input;

  return <Checkbox onClick={onChange} checked={value} className={className} label={label} />;
};
