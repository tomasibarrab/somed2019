import { Button } from 'gca-react-components';
import * as React from 'react';
import { FormattedMessage, injectIntl } from 'react-intl';

import { LabeledCheckbox } from '@buffet/checkbox';
import { Input } from '@buffet/input';

import { CurrentBudgetType, PatchBudgetPayload } from '../../../store/campaigns/campaigns.types';
import { defaultCurrency } from '../../constants';
import { formatCurrency } from '../helpers/format-number-locale';
import { getId } from './EditBudgetModal';
import styles from './EditBudgetModal.module.css';

interface Props {
  campaignId: string;
  confirm: (payload: PatchBudgetPayload) => void;
  currentBudget: CurrentBudgetType;
  currentUserEmail: string;
  intl: any;
}

export function BudgetEditorImpl({
  campaignId,
  confirm,
  currentBudget: { cap, credits, price, spend },
  currentUserEmail,
  intl,
}: Props) {
  // Constants
  const CURRENCY_SYMBOL = '$';
  const { formatMessage } = intl;
  const currentMonthString = new Date().toLocaleString('en-us', { month: 'long' });

  // Helper functions
  function coversFromBudgetNumber(input: number): number {
    let newCovers = 0;
    if (input > 1 && input > price) {
      newCovers = Math.floor(input / price);
    }
    return newCovers;
  }

  function getCoversFromInput(input: string): string {
    const budget = parseInt(input, 10);
    return budget ? coversFromBudgetNumber(budget).toString() : '0';
  }

  function resetToOriginalBudgetIfErrorState(): void {
    if (errorText || +value === 0) {
      setValue(cap.toString());
      setCovers(getCoversFromInput(cap.toString()));
      setErrorText('');
    }
  }

  const isANumber = (str: string): boolean => !isNaN(+str);
  const isDigitsOnly = (str: string): boolean => /^(\d+)$/.test(str);

  // init local state
  const [value, setValue] = React.useState(cap.toString());
  const [errorText, setErrorText] = React.useState('');
  const [hasBudget, setHasBudget] = React.useState(cap > 0);
  const [covers, setCovers] = React.useState(coversFromBudgetNumber(cap).toString());

  const coverPrice = formatCurrency(price, defaultCurrency, price % 1 === 0);
  const isBudgetValueUnchanged = cap === +value;

  function handleChange(ev: React.ChangeEvent): void {
    const target = ev.currentTarget as HTMLInputElement;
    const { value: val } = target;
    let newValue = val;
    if (isANumber(val)) {
      newValue = isDigitsOnly(val) ? val : val.substring(0, val.length - 1);
      setValue(newValue);
      setCovers(getCoversFromInput(newValue));
    }

    let errText = '';
    if (!isDigitsOnly(newValue) || !newValue.length) {
      errText = formatMessage({ id: getId('error_enter_number') });
    } else if (+newValue !== 0 && +newValue < spend) {
      errText = formatMessage(
        { id: getId('has_already_been_spent') },
        { price: formatCurrency(spend, defaultCurrency, spend % 1 === 0) },
      );
    }
    setErrorText(errText);
  }

  function handleBlur(): void {
    if (isBudgetValueUnchanged) {
      setErrorText(formatMessage({ id: getId('error_different_than_original') }));
    } else if (value === '0') {
      resetToOriginalBudgetIfErrorState();
      setHasBudget(false);
    }
  }

  function handleLimitChange(): void {
    resetToOriginalBudgetIfErrorState();
    setHasBudget(!hasBudget);
  }

  function handleSubmit(): void {
    confirm({
      campaignId,
      changedByUser: currentUserEmail,
      monthlyBudget: hasBudget ? +value : 0,
    });
  }

  function getIsButtonDisabled(): boolean {
    if (!hasBudget) {
      return false;
    } else if (errorText !== '' || isBudgetValueUnchanged) {
      return true;
    }
    return false;
  }

  const isButtonDisabled = getIsButtonDisabled();

  const {
    applyButton,
    budgetSection,
    budgetSectionCurrencySymbol,
    budgetSectionDisabled,
    budgetSectionField,
    budgetSectionInput,
    budgetSectionInputWrapper,
    budgetSectionMessage,
    budgetSectionMessageDisabled,
    budgetNoteSectionError,
    budgetNoteSection,
    budgetNoteSectionMessage,
    bottomSpacingLarge,
    bottomSpacingMedium,
    checkboxInput,
    checkboxSubtext,
  } = styles;

  return (
    <>
      <p className={bottomSpacingMedium}>
        <FormattedMessage id={getId('description')} />
      </p>
      <FormattedMessage id={getId('monthly_budget')} tagName="strong" />
      <section className={hasBudget ? budgetSection : budgetSectionDisabled} data-testid="budget-section">
        <div className={budgetSectionField}>
          <label className={budgetSectionInputWrapper}>
            <span className={budgetSectionCurrencySymbol}>{CURRENCY_SYMBOL}</span>
            <Input
              data-testid="budget-textbox"
              className={budgetSectionInput}
              value={value}
              onChange={handleChange}
              onBlur={handleBlur}
              disabled={!hasBudget}
              maxLength={6}
              type="text"
              pattern="^\d+$"
              valid={errorText === ''}
            />
          </label>
          <p
            data-testid="total-covers-message"
            className={
              errorText ? [budgetSectionMessageDisabled, budgetSectionMessage].join(' ') : budgetSectionMessage
            }
          >
            <FormattedMessage
              id={getId('total_for_up_to')}
              values={{
                numCovers: (
                  <FormattedMessage
                    id={getId('num_covers')}
                    values={{
                      coverCount: covers,
                    }}
                    tagName="strong"
                  />
                ),
                price: coverPrice,
              }}
            />
          </p>
        </div>
        <div className={budgetNoteSection}>
          <p className={budgetNoteSectionError}>{errorText}</p>
          <p className={budgetNoteSectionMessage}>
            <FormattedMessage
              id={getId('your_budget_may_be_exceeded')}
              values={{
                percent: 5,
              }}
            />
          </p>
        </div>
      </section>
      {!isNaN(spend) && (
        <p className={bottomSpacingLarge}>
          <FormattedMessage
            id={getId('your_spend_so_far')}
            values={{
              numCovers: (
                <strong>
                  <FormattedMessage
                    id={getId('num_covers')}
                    values={{
                      coverCount: coversFromBudgetNumber(spend),
                    }}
                  />
                </strong>
              ),
              price: <strong>{formatCurrency(spend, defaultCurrency, spend % 1 === 0)}</strong>,
            }}
          />
        </p>
      )}
      <LabeledCheckbox
        data-testid="no-budget-checkbox"
        id={checkboxInput}
        className={checkboxInput}
        label={
          <span>
            <FormattedMessage id={getId('no_budget')} />
            {credits > 0 && (
              <>
                <br />
                <span className={[bottomSpacingLarge, checkboxSubtext].join(' ')}>
                  <FormattedMessage
                    id={getId('you_still_get_price_credits_in_month')}
                    values={{
                      month: currentMonthString,
                      price: <strong>{formatCurrency(credits, defaultCurrency, credits % 1 === 0)}</strong>,
                    }}
                  />
                </span>
              </>
            )}
          </span>
        }
        onClick={handleLimitChange}
        checked={!hasBudget}
      />
      <Button
        className={applyButton}
        theme="primary"
        onClick={handleSubmit}
        disabled={isButtonDisabled}
        data-testid="apply-button"
      >
        <FormattedMessage id={getId('apply')} />
      </Button>
    </>
  );
}

export const BudgetEditor = injectIntl(BudgetEditorImpl);
