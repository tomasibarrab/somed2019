// tslint:disable:max-line-length
import configureMockStore from 'redux-mock-store';
import { createEpicMiddleware } from 'redux-observable';
import { Observable } from 'rxjs';
import { of } from 'rxjs/observable/of';
import { actions, giftsEpic, reducer } from './gifts';
import { GiftsPageType } from './gifts.types';

/* eslint-disable max-len */
describe('gifts redux-module', () => {
  const defaultState = {
    currentContext: {
      restaurant: {
        rid: 268852,
      },
    },
  };
  const exampleUrl = 'http://example.com';

  describe('gifts reducer', () => {
    let initialState;
    beforeEach(() => {
      initialState = {
        error: false,
        loading: false,
        pageType: GiftsPageType.UrlEntryPage,
        patchPending: false,
        success: false,
      };
    });

    it('should handle open and close terms modal', () => {
      const openAction = actions.openTermsModal({ url: exampleUrl });
      let newState = reducer(initialState, openAction);
      const expectedOpen = {
        ...initialState,
        modal: {
          proposedUrl: exampleUrl,
        },
      };
      expect(newState).toEqual(expectedOpen);

      const closeAction = actions.closeTermsModal();
      newState = reducer(newState, closeAction);

      expect(newState).toEqual(initialState);
    });

    it('should handle fetchGiftsUrl started and done (Exisitng URL case)', () => {
      const startedAction = actions.fetchGiftsUrl.started(undefined);
      let newState = reducer(initialState, startedAction);
      const expectedStarted = {
        ...initialState,
        loading: true,
      };

      const doneAction = actions.fetchGiftsUrl.done({ result: { url: exampleUrl }, params: undefined });
      newState = reducer(newState, doneAction);
      const expectedDone = {
        ...initialState,
        loading: false,
        pageType: GiftsPageType.UrlEntryPage,
        success: true,
        url: exampleUrl,
      };

      expect(newState).toEqual(expectedDone);
    });

    it('should handle fetchGiftsUrl.done (no URL case)', () => {
      const doneAction = actions.fetchGiftsUrl.done({ result: { url: false }, params: undefined });
      const newState = reducer(initialState, doneAction);
      const expectedDone = {
        ...initialState,
        loading: false,
        pageType: GiftsPageType.LandingPage,
        success: true,
        url: undefined,
      };

      expect(newState).toEqual(expectedDone);
    });

    it('should handle fetchGiftsUrl.failed', () => {
      const failedAction = actions.fetchGiftsUrl.failed({ error: true, params: undefined });
      const newState = reducer(initialState, failedAction);
      const expected = {
        ...initialState,
        error: true,
        loading: false,
      };

      expect(newState).toEqual(expected);
    });

    it('should handle patchGiftsUrl started and done', () => {
      const startedAction = actions.patchGiftsUrl.started(undefined);
      let newState = reducer(initialState, startedAction);
      const expectedStarted = {
        ...initialState,
        patchPending: true,
      };

      expect(newState).toEqual(expectedStarted);
      // Don't need full payload to test reducer
      const doneAction = actions.patchGiftsUrl.done({ result: true, params: { url: exampleUrl } } as any);
      newState = reducer(newState, doneAction);
      const expectedDone = {
        ...initialState,
        patchPending: false,
        url: exampleUrl,
      };

      expect(newState).toEqual(expectedDone);
    });

    it('should handle patchGiftsUrl failed', () => {
      // don't need full payload to test reducer
      const failedAction = actions.patchGiftsUrl.failed({ error: true, params: {} } as any);
      const newState = reducer(initialState, failedAction);
      const expected = {
        ...initialState,
        error: true,
      };

      expect(newState).toEqual(expected);
    });

    it('should handle showPage', () => {
      const action = actions.showPage({ pageType: GiftsPageType.LandingPage });
      const newState = reducer(initialState, action);
      const expected = {
        ...initialState,
        pageType: GiftsPageType.LandingPage,
      };

      expect(newState).toEqual(expected);
    });
  });

  describe('epics', () => {
    let testStore;

    const state = {
      ...defaultState,
    };

    const patchPayload = {
      approvalInfo: {
        email:
          'The approval info object passes untouched through this epic and is included for illustrative purposes only',
      },
      isEdit: false,
      url: exampleUrl,
    };

    test('patchGiftsUrlEpic calls api.patchGiftsUrl and emits showPage if !payload.isEdit', () => {
      const patchGiftsUrl = jest.fn(arg => of({}));
      const dependencies = { api: { patchGiftsUrl } };
      const rootEpic = (action$, store) => giftsEpic(action$, store, dependencies as any);
      const epicMiddleware = createEpicMiddleware(rootEpic);

      const mockStore = configureMockStore([epicMiddleware]);
      testStore = mockStore(state);
      testStore.dispatch(actions.patchGiftsUrl.started(patchPayload as any));

      expect(patchGiftsUrl).toHaveBeenCalledWith(268852, patchPayload);
      expect(testStore.getActions()[1].type).toEqual('GIFTS/PATCH_DONE');
      expect(testStore.getActions()[2].type).toEqual('GIFTS/SHOW_PAGE');
    });

    test("patchGiftsUrlEpic calls api.patchGiftsUrl and doesn't emit showPage if payload.isEdit", () => {
      const patchGiftsUrl = jest.fn(arg => of({}));
      const dependencies = { api: { patchGiftsUrl } };
      const rootEpic = (action$, store) => giftsEpic(action$, store, dependencies as any);
      const epicMiddleware = createEpicMiddleware(rootEpic);

      const mockStore = configureMockStore([epicMiddleware]);
      testStore = mockStore(state);
      const isEditPatchPayload = {
        ...patchPayload,
        isEdit: true,
      };
      testStore.dispatch(actions.patchGiftsUrl.started(isEditPatchPayload as any));

      expect(patchGiftsUrl).toHaveBeenCalledWith(268852, isEditPatchPayload);
      expect(testStore.getActions()[1].type).toEqual('GIFTS/PATCH_DONE');
      expect(testStore.getActions().length).toEqual(2);
    });

    test('patchGiftsUrlEpic emits FAILED action if api call fails', () => {
      const patchGiftsUrl = jest.fn(arg => Observable.throw('error'));
      const dependencies = { api: { patchGiftsUrl } };
      const rootEpic = (action$, store) => giftsEpic(action$, store, dependencies as any);
      const epicMiddleware = createEpicMiddleware(rootEpic);

      const mockStore = configureMockStore([epicMiddleware]);
      testStore = mockStore(state);
      testStore.dispatch(actions.patchGiftsUrl.started(patchPayload as any));

      expect(testStore.getActions()[1].type).toEqual('GIFTS/PATCH_FAILED');
    });

    test('fetchGiftsUrlEpic calls api, emits fetchGiftsUrl.done if successful', () => {
      const fetchGiftsUrl = jest.fn(arg => of({ url: exampleUrl }));
      const dependencies = { api: { fetchGiftsUrl } };
      const rootEpic = (action$, store) => giftsEpic(action$, store, dependencies as any);
      const epicMiddleware = createEpicMiddleware(rootEpic);

      const mockStore = configureMockStore([epicMiddleware]);
      testStore = mockStore(state);
      testStore.dispatch(actions.fetchGiftsUrl.started(undefined));

      expect(fetchGiftsUrl).toHaveBeenCalled();

      expect(testStore.getActions()[1].type).toEqual('GIFTS/FETCH_DONE');
    });

    test('fetchGiftsUrl emits FAILED action if api call fails', () => {
      const fetchGiftsUrl = jest.fn(arg => Observable.throw('error'));
      const dependencies = { api: { fetchGiftsUrl } };
      const rootEpic = (action$, store) => giftsEpic(action$, store, dependencies as any);
      const epicMiddleware = createEpicMiddleware(rootEpic);

      const mockStore = configureMockStore([epicMiddleware]);
      testStore = mockStore(state);

      testStore.dispatch(actions.fetchGiftsUrl.started(undefined));

      expect(fetchGiftsUrl).toHaveBeenCalled();

      expect(testStore.getActions()[1].type).toEqual('GIFTS/FETCH_FAILED');
    });
  });
});
