import { selectors } from 'gca-react-components/src/redux-modules/currentContext';
import merge from 'gca-react-components/src/utils/merge';

import '../commonRxjs';

import { Observable } from 'rxjs/Observable';
import { forkJoin } from 'rxjs/observable/forkJoin';

import isEqual from 'lodash/isEqual';
import pickBy from 'lodash/pickBy';

import { combineEpics } from 'redux-observable';
import { Action, actionCreatorFactory, Success } from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';
import { Epic, State, Store } from '../types';

import { SalesForceLead } from '../salesforce/salesforce.types';
import { mapFetchToStore, mapFormToDTO, mergePostResponseAndFormToStore } from './mappers';
import {
  Photo,
  PrivateDining,
  PrivateDiningData,
  PrivateDiningDataDTO,
  PrivateDiningResponse,
  Room,
  Status,
} from './privatedining.types';
import { emptyForm, privateDiningEnabledFixture, privateDiningFixture } from './privateDiningFixture';

// --------------------------------- //
// Actions
// --------------------------------- //

const actionCreator = actionCreatorFactory('PRIVATE_DINING');

export const fetchPrivateDiningEnabled = actionCreator.async<{}, { enabled: boolean }>('FETCH_ENABLED');
export const fetchPrivateDining = actionCreator.async<
  {},
  { isFormEmpty: boolean; privateDiningData: PrivateDiningData }
>('FETCH_DATA');
export const fetchPrivateDiningPhoto = actionCreator.async<{ roomId: number }, Photo>('FETCH_PHOTO');
export const fetchPrivateDiningThumbnail = actionCreator.async<{}, Photo>('FETCH_THUMBNAIL');
export const postPrivateDining = actionCreator.async<PrivateDiningData, PrivateDiningResponse>('POST_DATA');
export const postPrivateDiningPhotos = actionCreator.async<null, null>('POST_PHOTO');
export const resetError = actionCreator('RESET_ERROR');

// --------------------------------- //
// Reducers
// --------------------------------- //

export const privateDiningEnabledReducer = reducerWithInitialState(privateDiningEnabledFixture)
  .case(fetchPrivateDiningEnabled.started, state => ({ ...state, loading: true, error: false }))
  .case(fetchPrivateDiningEnabled.done, (state, { result }) => ({
    ...state,
    enabled: result.enabled,
    error: false,
    loading: false,
  }))
  .case(fetchPrivateDiningEnabled.failed, state => ({ ...state, loading: false, error: true }));

export const privateDiningReducer = reducerWithInitialState(privateDiningFixture)
  .case(fetchPrivateDining.started, state => ({
    ...state,
    error: false,
    isFormEmpty: false,
    loading: true,
  }))
  .case(fetchPrivateDining.done, (state, { result }) => ({
    ...state,
    error: false,
    isFormEmpty: result.isFormEmpty,
    loading: false,
    privateDiningData: result.privateDiningData,
  }))
  .case(fetchPrivateDining.failed, state => ({
    ...state,
    error: true,
    isFormEmpty: false,
    loading: false,
  }))
  .case(fetchPrivateDiningPhoto.started, state => ({ ...state, loading: true }))
  .case(fetchPrivateDiningPhoto.done, (state, { params, result }) => {
    if (state.privateDiningData === null) {
      throw new Error('Something has gone horribly wrong.');
    }

    const newRooms = state.privateDiningData.rooms.map(room =>
      room.roomId === params.roomId ? { ...room, photo: result } : room,
    );

    return merge(state, {
      privateDiningData: {
        rooms: newRooms,
      },
    });
  })
  .case(fetchPrivateDiningThumbnail.started, state => ({ ...state, loading: true }))
  .case(fetchPrivateDiningThumbnail.done, (state, result) => {
    return merge(state, {
      privateDiningData: {
        photo: result.result,
      },
    });
  })
  .case(postPrivateDining.started, (state: PrivateDining) => ({ ...state, postStatus: Status.Started }))
  .case(postPrivateDining.done, (state, { params, result }) => {
    return merge(state, {
      postStatus: Status.Done,
      privateDiningData: result.privateDiningData,
    });
  })
  .case(postPrivateDining.failed, (state: PrivateDining) => ({ ...state, postStatus: Status.Failed }))
  .case(postPrivateDiningPhotos.done, state => {
    if (state.privateDiningData === null) {
      throw new Error('How have we gotten here without data?');
    }

    /**
     * Any photos with localUrls will be posted on every publish.
     * To avoid this, we clear the localUrl and move copy it over pendingUrl
     */
    const { localUrl, pendingUrl } = state.privateDiningData.photo;
    return merge(state, {
      postStatus: Status.Done,
      privateDiningData: {
        photo: {
          localUrl: null,
          pendingUrl: localUrl || pendingUrl,
        },
        rooms: state.privateDiningData.rooms.map(room =>
          merge(room, {
            photo: {
              localUrl: null,
              pendingUrl: room.photo.localUrl || room.photo.pendingUrl,
            },
          }),
        ),
      },
    });
  })
  .case(resetError, (state: PrivateDining) => ({ ...state, postStatus: Status.Init }));

// --------------------------------- //
// Selectors
// --------------------------------- //
export function privateDiningSelector(state: State): null | PrivateDiningData {
  if (state.privateDining.privateDiningData !== null) {
    return state.privateDining.privateDiningData;
  }

  return null;
}

function getRooms(state: State): Room[] {
  if (state.privateDining.privateDiningData === null || state.privateDining.privateDiningData.rooms.length === 0) {
    return [];
  }

  return state.privateDining.privateDiningData.rooms;
}

// --------------------------------- //
// Epics
// --------------------------------- //

export const fetchPrivateDiningEnabledEpic: Epic = (action$, store, { api }) =>
  action$.ofType(fetchPrivateDiningEnabled.started.type).switchMap(() => {
    const rid = selectors.rid(store.getState());
    return api
      .fetchPrivateDiningEnabled({ rid })
      .map((response: any) =>
        fetchPrivateDiningEnabled.done({
          params: {},
          result: { enabled: response.enabled },
        }),
      )
      .catch(() => [fetchPrivateDiningEnabled.failed({ params: {}, error: {} })]);
  });

const isFormEmpty = (pdData: PrivateDiningDataDTO): boolean => {
  const dataWithoutRid: any = pickBy(pdData, (value: any, key: string) => key !== 'rid');
  const emptyFormWithPhone = { ...emptyForm, privatePartyPhone: 'x' };
  return isEqual(dataWithoutRid, emptyForm) || isEqual(dataWithoutRid, emptyFormWithPhone);
};

export const fetchPrivateDiningEpic: Epic = (action$, store, { api }) =>
  action$.ofType(fetchPrivateDining.started.type).switchMap(() => {
    const rid = selectors.rid(store.getState());
    return api
      .fetchPrivateDiningDTO({ rid })
      .map((response: PrivateDiningDataDTO) =>
        fetchPrivateDining.done({
          params: {},
          result: {
            isFormEmpty: isFormEmpty(response),
            privateDiningData: mapFetchToStore(response),
          },
        }),
      )
      .catch(() => [fetchPrivateDining.failed({ params: {}, error: {} })]);
  });

export const postPrivateDiningEpic: Epic = (action$, store, { api }) =>
  action$.ofType(postPrivateDining.started.type).switchMap(({ payload }: Action<PrivateDiningData>) => {
    const state = store.getState();
    const rid = selectors.rid(state);
    const email = selectors.currentContext(state).user.userName; // userName: user's email address
    const body = mapFormToDTO(payload, email);

    return api
      .postPrivateDiningDTO({ rid, body })
      .map(({ response }: { response: PrivateDiningDataDTO }) =>
        postPrivateDining.done({
          params: payload,
          result: { privateDiningData: mergePostResponseAndFormToStore(response, payload) },
        }),
      )
      .catch(() => [postPrivateDining.failed({ params: payload, error: {} })]);
  });

export const fetchPrivateDiningPhotoEpic: Epic = (action$, store, { api }) =>
  action$.ofType(fetchPrivateDining.done.type).switchMap(() => {
    const state = store.getState();
    const rid = selectors.rid(state);
    const rooms = getRooms(state);

    return Observable.from(rooms).mergeMap((room: Room) => {
      const url = `/admin/api/restaurant/${rid}/private-dining/room/${room.roomId}/photo`;
      const basePayload = {
        params: { roomId: room.roomId },
        result: {
          error: false,
          liveUrl: room.imageURL,
          loading: false,
          localUrl: null,
          pendingUrl: null,
        },
      };

      return api
        .fetchPhoto(url)
        .map((imgUrl: string) =>
          fetchPrivateDiningPhoto.done(
            merge(basePayload, {
              result: {
                pendingUrl: url,
              },
            }),
          ),
        )
        .catch(() => [fetchPrivateDiningPhoto.done(basePayload)]);
    });
  });

export const postPrivateDiningPhotosEpic: Epic = (action$, store, { api }) =>
  action$
    .ofType(postPrivateDining.done.type)
    .switchMap(({ payload: { result } }: Action<Success<PrivateDiningData, PrivateDiningResponse>>) => {
      const state = store.getState();
      const rid = selectors.rid(state);
      const pdData = result.privateDiningData;

      const postRequests = pdData.rooms
        .filter((room: Room) => room.photo.localUrl !== null)
        .map((room: Room) => {
          if (room.photo.localUrl === null) {
            throw new Error('Photo localUrl should not be null. Something has gone horribly wrong.');
          }

          return api.postPhoto(rid, room.roomId, room.photo.localUrl);
        });

      if (pdData.photo.localUrl) {
        if (pdData.requestId === null) {
          throw new Error('RequestId should not be null. Something has gone horribly wrong.');
        }

        postRequests.push(api.postThumbnail(rid, pdData.requestId, pdData.photo.localUrl));
      }

      if (postRequests.length > 0) {
        return forkJoin(...postRequests)
          .map((response: any) => postPrivateDiningPhotos.done({ params: null, result: null }))
          .catch(() => [postPrivateDiningPhotos.failed({ params: null, error: null })]);
      }

      return [postPrivateDiningPhotos.done({ params: null, result: null })];
    });

export const fetchPrivateDiningThumbnailEpic: Epic = (action$, store, { api }) =>
  action$.ofType(fetchPrivateDining.done.type).switchMap(() => {
    const state = store.getState();
    if (state.privateDining.privateDiningData === null) {
      throw new Error('Private Dining is null, and it shouldnt be');
    }

    const requestId = state.privateDining.privateDiningData.requestId;
    const basePayload = {
      params: {},
      result: {
        error: false,
        liveUrl: state.privateDining.privateDiningData.privateDiningThumbnailURL,
        loading: false,
        localUrl: null,
        pendingUrl: null,
      },
    };

    if (requestId === null) {
      return [fetchPrivateDiningThumbnail.done(basePayload)];
    }

    const rid = selectors.rid(state);
    const url = `/admin/api/restaurant/${rid}/private-dining/thumbnail/${requestId}`;
    return api
      .fetchPhoto(url)
      .map((imgUrl: string) =>
        fetchPrivateDiningThumbnail.done(
          merge(basePayload, {
            result: {
              pendingUrl: url,
            },
          }),
        ),
      )
      .catch(() => [fetchPrivateDiningThumbnail.done(basePayload)]);
  });

export const privateDiningEpic = combineEpics(
  fetchPrivateDiningEnabledEpic,
  fetchPrivateDiningEpic,
  fetchPrivateDiningPhotoEpic,
  fetchPrivateDiningThumbnailEpic,
  postPrivateDiningEpic,
  postPrivateDiningPhotosEpic,
);
