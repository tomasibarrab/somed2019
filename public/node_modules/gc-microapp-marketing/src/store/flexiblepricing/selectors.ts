import get from 'lodash/get';
import isNumber from 'lodash/isNumber';
import isString from 'lodash/isString';
import { createSelector } from 'reselect';
import { State } from '../types';
import {
  ActiveContractPrices,
  Days,
  FlexiblePricingState,
  FromType,
  OldFromTypes,
  OldPrices,
  PlanType,
  PriceByPlan,
  PricingInfo,
  PricingLevels,
  SummaryType,
  Times,
  VisibilitySchedule,
  VisibilitySettingsBackButtonType,
  VisibilitySettingsResponse,
  VisibilityType,
  VisibilityTypePrices,
} from './flexiblepricing.types';

/*
MOTIVATION:
  - To stop creating new objects every time a component re-renders, using new XYZModel(...);
  - To be able to pick which pieces of information we want out of the state, and get only it,
    without other additional information (and use these in mapStateToProps)
    - Increase readability by a component's Props interface definition having only the pieces
      or derived/computed values it actually needs from the state
    - Increase ease of testing by not requiring a full schedule/pricing info/ etc to test a
      component that only needs the price of restref covers (As an example)
    - Isolated helper functions
  - Memoization of each of these functions (that we get for free from Reselect) means that
    ideally the derived/computed parts will only be computed once if the values from which
    they are derived do not change
  - Changing the shape of the state results in changes to selectors hopefully instead of changes to
    all the components using the part of the state that was changed, and all of the tests that
    are mocking the state/shape of the state
    - Another issue is needing to mock the state for tests. I would like to export the unconnected
      component and test it, and maybe test mapStateToProps as well if we really want the coverage
      of using these selectors. And of course we should test the selectors themselves.
      It is "exporting for testing only" but I belive we have very good reasons to do so which
      include not having to constantly mock the state and all the boilerplate that goes with it.
*/

const getFlexiblePricing = (state: State) => state.flexiblePricing;

// Flex, Standard: Expected
export const getExpectedPricingInfo = createSelector(
  getFlexiblePricing,
  (flexiblePricing: FlexiblePricingState) => {
    return get(flexiblePricing, 'pricingInfo.data', {});
  },
);

export const getCurrencyCode = createSelector(
  getExpectedPricingInfo,
  (pricingInfo: PricingInfo): string => pricingInfo.currencyCode,
);

// Flex and Active
export const getActiveContractPrices = createSelector(
  getFlexiblePricing,
  (flexiblePricingState: FlexiblePricingState) => flexiblePricingState.activeContract.data,
);

/* Typescript not being mad here belies the fact that pricingInfo could be undefined,
  but we will never render the components that use this (hopefully!) until it is
  defined - right now nothing except a loading spinner renders when pricing info has
  not been fetched. */
export const getExpectedDirectPricePerCover = createSelector(
  getExpectedPricingInfo,
  (pricingInfo: PricingInfo) => pricingInfo[FromType.Direct][PlanType.FlexiblePricing],
);

export const getNewIncreasedVisibilityPricePerCover = createSelector(
  getExpectedPricingInfo,
  (pricingInfo: PricingInfo) => pricingInfo[FromType.Discovery][PricingLevels.Increase],
);

export const getOldPrices = createSelector(
  getExpectedPricingInfo,
  (pricingInfo: PricingInfo): OldPrices => {
    const oldPrices: OldPrices = {
      [OldFromTypes.RestRef]: pricingInfo[FromType.RestRef][PlanType.CurrentPrice],
      [OldFromTypes.OpenTable]: pricingInfo[FromType.Direct][PlanType.CurrentPrice],
    };

    if (pricingInfo.system) {
      oldPrices.system = pricingInfo.system[PlanType.CurrentPrice];
    }

    return oldPrices;
  },
);

export const getExpectedFlatFee = createSelector(
  getExpectedPricingInfo,
  (pricingInfo: PricingInfo): boolean => {
    return get(pricingInfo[FromType.RestRef], 'flatFee', false);
  },
);

export const getExpectedSystemFee = createSelector(
  getExpectedPricingInfo,
  (pricingInfo: PricingInfo) => pricingInfo.system,
);

export const getTotals = createSelector(
  [getExpectedPricingInfo, getCurrencyCode, getExpectedFlatFee, getExpectedSystemFee],
  (pricingInfo: PricingInfo, currencyCode: string, flatFee: boolean, systemFee: PriceByPlan) => {
    const totals = {
      [PlanType.CurrentPrice]: {
        amount: 0,
        currencyCode,
      },
      [PlanType.FlexiblePricing]: {
        amount: 0,
        currencyCode,
      },
    };

    Object.values(FromType).forEach((fromType: FromType) => {
      const { covers, ...planPrices } = pricingInfo[fromType];
      Object.values(PlanType).forEach((planType: PlanType) => {
        if (fromType === FromType.RestRef && flatFee) {
          totals[planType].amount += planPrices[planType].amount;
        } else {
          totals[planType].amount += covers * planPrices[planType].amount;
        }
      });
    });

    if (systemFee) {
      totals[PlanType.CurrentPrice].amount += systemFee[PlanType.CurrentPrice].amount;
      totals[PlanType.FlexiblePricing].amount += systemFee[PlanType.FlexiblePricing].amount;
    }

    return totals;
  },
);

export const getDifference = createSelector(
  [getTotals, getCurrencyCode],
  (totals: any, currencyCode: string) => {
    return {
      amount: totals[PlanType.CurrentPrice].amount - totals[PlanType.FlexiblePricing].amount,
      currencyCode,
    };
  },
);

export const getVisibilitySettings = createSelector(
  getFlexiblePricing,
  (flexiblePricing: FlexiblePricingState) => flexiblePricing.visibilitySettings.data,
);

export const getCurrentVersion = createSelector(
  getVisibilitySettings,
  (visibilitySettings: VisibilitySettingsResponse | undefined) =>
    visibilitySettings && visibilitySettings.currentVersion,
);

export const getExpectedDiscoveryPrices = createSelector(
  getExpectedPricingInfo,
  (pricingInfo: PricingInfo): VisibilityTypePrices => {
    const discoveryPricingInfo = pricingInfo[FromType.Discovery];
    const {
      [PlanType.FlexiblePricing]: standard,
      [PricingLevels.Increase]: increase,
      [PricingLevels.Reduce]: reduce,
    } = discoveryPricingInfo;

    return {
      [VisibilityType.Standard]: standard,
      [VisibilityType.Increase]: increase,
      [VisibilityType.Reduce]: reduce,
    };
  },
);

export const getFormVisibilitySettings = createSelector(
  getFlexiblePricing,
  (flexiblePricing: FlexiblePricingState) => flexiblePricing.formVisibilitySettings,
);

/* We don't "delete" the increase or reduce settings in the case that the schedule is empty but the object containing
that schedule is still there. PI service handles not sending it back to us in that case */
export const getFormVisibilitySettingsWithDisables = createSelector(
  getFormVisibilitySettings,
  formVisSettings => {
    if (!formVisSettings) {
      return undefined;
    }
    const formVisSettingsWithDisables = Object.assign({}, formVisSettings);

    if (!formVisSettings!.enable.increase) {
      formVisSettingsWithDisables.increase = undefined;
    } else {
      if (!formVisSettings!.enable.monthlyBudget || get(formVisSettings, 'increase.monthlyBudget.amount', 0) === 0) {
        /* TODO since we are initializing FormVisSettings to always have a complete object for each
      vis. level and switching them on/off with other flat parts of the state,
      change the type to reflect that each of these is no longer optional,

      then we can stop using these exclamation points all the time */
        formVisSettingsWithDisables.increase = {
          ...formVisSettingsWithDisables.increase!,
          monthlyBudget: undefined,
        };
      }
    }

    if (!formVisSettings!.enable.reduce) {
      formVisSettingsWithDisables.reduce = undefined;
    }

    return formVisSettingsWithDisables;
  },
);

const isScheduleEmpty = (schedule: VisibilitySchedule) => {
  let hasTimes = false;

  Object.values(Days).forEach(day => {
    Object.values(Times).forEach(time => {
      hasTimes = hasTimes || get(schedule, `${day}.${time}`, false);
    });
  });

  return !hasTimes;
};

export const getShownVisibilitySettings = createSelector(
  getVisibilitySettings,
  getFormVisibilitySettingsWithDisables,
  (visSettings, formVisSettingsWithDisables) => {
    return formVisSettingsWithDisables || visSettings;
  },
);

export const getMonthlyBudget = createSelector(
  getShownVisibilitySettings,
  visibilitySettings => get<any, string>(visibilitySettings, 'increase.monthlyBudget'),
);

export const getFormMonthlyBudget = createSelector(
  getFormVisibilitySettings,
  visibilitySettings => {
    const value = get<any, string>(visibilitySettings, 'increase.monthlyBudget');
    return value;
  },
);

export const getFormMonthlyBudgetEnabled = createSelector(
  getFormVisibilitySettings,
  visibilitySettings => get<any, string, boolean>(visibilitySettings, 'enable.monthlyBudget', false),
);

export const getPartialVisibility = createSelector(
  getShownVisibilitySettings,
  shownVisiblitySettings => {
    const { standard, reduce } = shownVisiblitySettings!;
    let hasFullCoverage = true;
    Object.values(Days).forEach(day => {
      Object.values(Times).forEach(time => {
        hasFullCoverage =
          hasFullCoverage &&
          (get(standard, `schedule.${day}.${time}`, false) || get(reduce, `schedule.${day}.${time}`, false));
      });
    });
    return !hasFullCoverage;
  },
);

export const getSummaryType = createSelector(
  getVisibilitySettings,
  getFormVisibilitySettings,
  (visSettings, formVisSettings) => {
    if (visSettings && formVisSettings) {
      return SummaryType.PreCommitEdit;
    }
    if (formVisSettings) {
      return SummaryType.PreCommitFirstRun;
    }
    return SummaryType.ShowExisting;
  },
);

export const hasVisibilitySettings = createSelector(
  getVisibilitySettings,
  visSettings => {
    return visSettings !== undefined;
  },
);

const createActiveContractPricesObjectFromPricingInfo = (pricingInfo: PricingInfo): ActiveContractPrices => ({
  currencyCode: get(pricingInfo, 'currencyCode', 'USD'),
  discoveryIncreased: get(pricingInfo, 'discovery.increasePrice.amount', null),
  discoveryReduced: get(pricingInfo, 'discovery.decreasePrice.amount', null),
  discoveryStandard: get(pricingInfo, 'discovery.flexPrice.amount', null),
  otreso: get(pricingInfo, 'otreso.flexPrice.amount', null),
  restref: get(pricingInfo, 'restRef.flexPrice.amount', null),
  systemFee: get(pricingInfo, 'system.flexPrice.amount', undefined),
});

// Shown means Expected prices when they aren't signed up, and Actual prices
// when they have signed up.
export const getShownFlexPrices = createSelector(
  hasVisibilitySettings,
  getActiveContractPrices,
  getExpectedPricingInfo,
  (hasSettings, activeContractPrices, pricingInfo): ActiveContractPrices => {
    /* If there are Actual visibility settings, then we should return
      those settings or an empty object or some other thing to reflect
      that the prices are updating.

      If there are not any Actual Visibility settings, then we should
      instead return the expected prices from the Pricing Info object
      that we got from PI service at the start of the app.
    */

    if (hasSettings) {
      return activeContractPrices;
    }
    return createActiveContractPricesObjectFromPricingInfo(pricingInfo);
  },
);

export const getInUseDiscoveryPriceRange = createSelector(
  getShownVisibilitySettings,
  getShownFlexPrices,
  (shownVisibilitySettings, shownFlexPrices) => {
    const { discoveryReduced, discoveryIncreased, discoveryStandard } = shownFlexPrices;
    let minPrice = discoveryStandard; // could be undefined if prices are updating
    let maxPrice = discoveryStandard; // could be undefined if prices are updating

    const { increase, reduce } = shownVisibilitySettings!;

    if (increase && !isScheduleEmpty(increase.schedule)) {
      maxPrice = discoveryIncreased;
    }

    if (reduce && !isScheduleEmpty(reduce.schedule)) {
      minPrice = discoveryReduced;
    }

    return {
      maxPrice, // both could be undefined
      minPrice,
    };
  },
);

export const getIsUpdatingPricing = createSelector(
  hasVisibilitySettings,
  getActiveContractPrices,
  getInUseDiscoveryPriceRange,
  (hasSettings, activePrices, inUseDiscoveryPriceRange) => {
    if (hasSettings) {
      const { currencyCode, otreso } = activePrices;
      const { minPrice, maxPrice } = inUseDiscoveryPriceRange;

      const allPricesPresent = isString(currencyCode) && isNumber(otreso) && isNumber(minPrice) && isNumber(maxPrice);
      return !allPricesPresent;
    }
    return false;
  },
);

export const getVisibilitySettingsBackButtonType = createSelector(
  getVisibilitySettings,
  getFormVisibilitySettings,
  (visSettings, formVisSettings) => {
    if (visSettings && formVisSettings) {
      return VisibilitySettingsBackButtonType.ToSummaryPage;
    }
    return VisibilitySettingsBackButtonType.ToEducationPage;
  },
);

export const getPageType = createSelector(
  getFlexiblePricing,
  (flexiblePricing: FlexiblePricingState) => flexiblePricing.pageType,
);

export default {
  getActiveContractPrices,
  getCurrencyCode,
  getDifference,
  getExpectedDirectPricePerCover,
  getExpectedDiscoveryPrices,
  getExpectedFlatFee,
  getExpectedPricingInfo,
  getInUseDiscoveryPriceRange,
  getIsUpdatingPricing,
  getMonthlyBudget,
  getNewIncreasedVisibilityPricePerCover,
  getPartialVisibility,
  getShownFlexPrices,
  getTotals,
  getVisibilitySettings,
};
