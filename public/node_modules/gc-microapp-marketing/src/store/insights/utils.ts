import moment from 'moment';

/* stolen from gc-microapp-reporting */
// tslint:disable:object-literal-sort-keys

/*
 - parameter: date object [startDate, endDate], period type ['previous-period', 'last-year']
 - return: date object [comparativeStartDate, comparativeEndDate]
*/
export const comparativeDateSelector = (dates: any, periodType = 'previous-period') => {
  // we only handle the start date and end date with standard date string formatted: e.g. '2017-03-31'

  if (
    dates === null ||
    typeof dates === 'undefined' ||
    !moment(dates.startDate, 'YYYY-MM-DD', true).isValid() ||
    !moment(dates.endDate, 'YYYY-MM-DD', true).isValid()
  ) {
    throw new Error(`startDate and endDate must exist and be formatted YYYY-MM-DD, but were not: ${dates}`);
  }

  const startDate = moment(dates.startDate, 'YYYY-MM-DD');
  const endDate = moment(dates.endDate, 'YYYY-MM-DD');
  const days = endDate.diff(dates.startDate, 'days');

  // same day last year
  const getSameDayLastYear = (date: any, period: any) => {
    const temp = date.add(-52, 'weeks');
    const startD = temp.format('YYYY-MM-DD');
    const endD = temp.add(period, 'days').format('YYYY-MM-DD');

    return {
      comparativeStartDate: startD,
      comparativeEndDate: endD,
    };
  };

  // same date last year
  const getSameDateLastYear = (date: any, period: any) => {
    const temp = date.add(-1, 'year');
    const startD = temp.format('YYYY-MM-DD');
    const endD = temp.add(period, 'days').format('YYYY-MM-DD');

    return {
      comparativeStartDate: startD,
      comparativeEndDate: endD,
    };
  };

  // previous period
  const getPreviousPeriod = (date: any, period: any) => {
    const temp = date.add(-1, 'day');
    const endD = temp.format('YYYY-MM-DD');
    const startD = temp.add(-period, 'days').format('YYYY-MM-DD');

    return {
      comparativeStartDate: startD,
      comparativeEndDate: endD,
    };
  };

  if (periodType === 'last-year') {
    return getSameDayLastYear(startDate, days);
  } else if (periodType === 'last-year-to-date') {
    return getSameDateLastYear(startDate, days);
  } else if (periodType === 'previous-period') {
    return getPreviousPeriod(startDate, days);
  }

  throw new Error('periodType must be one of "last-year" or "previous-period"');
};

export const dateGranularity = (dates: any) => {
  // we only handle the start date and end date with standard date string formatted: e.g. '2017-03-31'
  if (
    dates === null ||
    typeof dates === 'undefined' ||
    !moment(dates.startDate, 'YYYY-MM-DD', true).isValid() ||
    !moment(dates.endDate, 'YYYY-MM-DD', true).isValid() ||
    moment(dates.endDate, 'YYYY-MM-DD').diff(dates.startDate, 'days') < 0
  ) {
    return null;
  }

  const startDate = moment(dates.startDate, 'YYYY-MM-DD');
  const endDate = moment(dates.endDate, 'YYYY-MM-DD');
  const daysDiff = endDate.diff(startDate, 'days');

  if (daysDiff === 0) {
    return 'HOUR';
  } else if (daysDiff > 0 && daysDiff < 32) {
    return 'DAY';
  } else if (daysDiff > 31 && daysDiff < 169) {
    return 'WEEK';
  } else if (daysDiff > 168 && daysDiff < 731) {
    return 'MONTH';
  }

  return 'YEAR';
};

export const columnGranularity = ({ dates, columns }: { dates: any; columns: any }) => {
  const dayCount = moment(dates.endDate).diff(moment(dates.startDate), 'days') + 1; // +1 to be inclusive of day 1

  const filteredCols = columns.map((col: any) => {
    // 1-7 days: Days
    if (dayCount <= 7) {
      const colDate = moment(col.id, 'YYYY-MM-DD');
      const dayOfWeek = moment(col.id).format('ddd');
      return {
        ...col,
        label: [dayOfWeek, colDate.format('MMM YYYY')],
      };
    }

    // 7-31 days: Weeks (every Sunday)
    if (dayCount <= 31) {
      if (moment(col.id, 'YYYY-MM-DD').weekday() === 0) {
        return col;
      }
      return {
        ...col,
        label: '',
      };
    }

    // 99-168 days: Months
    if (dayCount <= 99) {
      if (moment(col.id, 'YYYY-MM-DD').weekday() === 0) {
        return col;
      }
      return {
        ...col,
        label: '',
      };
    }

    // 99-168 days: Months
    if (dayCount <= 182) {
      const startOfMonth = moment(col.id, 'YYYY-MM-DD').startOf('month');
      const colDate = moment(col.id, 'YYYY-MM-DD');
      if (colDate.isSame(startOfMonth, 'day')) {
        return {
          ...col,
          label: colDate.format('MMM YYYY'),
        };
      }
      return {
        ...col,
        label: '',
      };
    }

    // 6-14 months: Months (handled by 99-168 days: Months)
    // if (dayCount <= 425) {
    //   return col;
    // }

    // 14-24 months: Month defined every year
    if (dayCount <= 425) {
      const startOfMonth = moment(col.id, 'YYYY-MM-DD').startOf('month');
      const colDate = moment(col.id, 'YYYY-MM-DD');
      if (colDate.isSame(startOfMonth, 'day')) {
        return {
          ...col,
          label: colDate.format('MMM YYYY'),
        };
      }
      return {
        ...col,
        label: '',
      };
    }

    if (dayCount > 425) {
      const startOfYear = moment(col.id, 'YYYY-MM-DD').startOf('year');
      const colDate = moment(col.id, 'YYYY-MM-DD');
      if (colDate.isSame(startOfYear, 'day')) {
        return {
          ...col,
          label: colDate.format('YYYY'),
        };
      }
      return {
        ...col,
        label: '',
      };
    }

    return col;
  });

  return filteredCols;
};

export const showGranularityLabel = (granularity: any, col: any, granuCount: any) => {
  if (granularity === 'DAY' && granuCount < 8) {
    const colDate = moment(col.id, 'YYYY-MM-DD');
    const dayOfWeek = moment(col.id).format('ddd');
    return {
      ...col,
      label: [dayOfWeek, colDate.format('MMM YYYY')],
    };
  } else if (granularity === 'DAY' || granularity === 'WEEK') {
    return col;
  } else if (granularity === 'MONTH') {
    const colDate = moment(col.id, 'YYYY-MM-DD');
    return {
      ...col,
      label: colDate.format('MMM YYYY'),
    };
  } else if (granularity === 'YEAR') {
    const colDate = moment(col.id, 'YYYY-MM-DD');
    return {
      ...col,
      label: colDate.format('YYYY'),
    };
  }
  return {
    ...col,
    label: '',
  };
};

export const getGranularityLabels = (granularity: any, columns: any) => {
  if (!columns) {
    return null;
  }

  const granuCount = columns.length;
  let step = Math.floor(granuCount / 7);
  if (granuCount % 7 !== 0) {
    step = step === 0 || granuCount <= 7 ? 1 : step + 1;
  }
  let index = 0;
  const granuLabels = columns.map((col: any) => {
    const result =
      index % step ? showGranularityLabel('', col, granuCount) : showGranularityLabel(granularity, col, granuCount);
    index += 1;
    return result;
  });

  return granuLabels;
};

export const getCurrentGranularity = (dateTimeAtRestaurant: any, granularity: any, columns: any) =>
  columns &&
  columns.find((col: any) => {
    if (!col) {
      return false;
    }
    const dateToday = moment(dateTimeAtRestaurant, 'YYYY-MM-DDTHH:mm:ss.SSS');
    switch (granularity) {
      case 'YEAR':
        return dateToday.isSame(col.id, 'year');
      case 'MONTH':
        return dateToday.isSame(col.id, 'month');
      case 'WEEK':
        return dateToday.isSame(col.id, 'week');
      case 'DAY':
      default:
        return dateToday.isSame(col.id, 'day');
    }
  });

/**
 * get y-axis helper for visualisations
 */
export const getYAxisHelper = (intl: any) => ({
  axis: {
    y: {
      commaLargeValues: true,
      commaLargeValuesUtil: (num: any) => intl.formatNumber(num),
    },
  },
});

/*
 - parameter: pass in restaurant datetime string
 - return: date string.  If restaurant date was not ready
 -         then return computer date,
 -         otherwise return restaurant date
*/
export const getToday = (restaurantDatetime: any) =>
  restaurantDatetime ? moment(restaurantDatetime).format('YYYY-MM-DD') : moment.utc().format('YYYY-MM-DD');

/*
 - parameter:
 -          today: string of today datetime. e.g. '2018-09-18T13:33:25.306628'
 -          type: ['thisWeek', 'lastMonth', 'last30Days']
 -          isOccupancy: different 'thisWeek' with other reports
 - return: start and end date string based on today and type
*/
export const getStartEndDates = (today: any, type = 'thisWeek', isOccupancy = false) => {
  const dateStr = getToday(today);
  const currentDate = moment(dateStr).isValid && moment(dateStr);
  if (!currentDate) {
    return null;
  }

  switch (type) {
    case 'thisWeek': {
      const startDate = isOccupancy
        ? currentDate
            .clone()
            .subtract(3, 'days')
            .format('YYYY-MM-DD')
        : currentDate
            .clone()
            .startOf('isoWeek')
            .format('YYYY-MM-DD');
      const endDate = isOccupancy
        ? currentDate
            .clone()
            .add(3, 'days')
            .format('YYYY-MM-DD')
        : currentDate
            .clone()
            .endOf('isoWeek')
            .format('YYYY-MM-DD');
      return { startDate, endDate };
    }
    case 'last30Days': {
      const startDate = currentDate
        .clone()
        .subtract(30, 'days')
        .format('YYYY-MM-DD');
      const endDate = currentDate
        .clone()
        .subtract(1, 'days')
        .format('YYYY-MM-DD');
      return { startDate, endDate };
    }
    case 'lastMonth': {
      const startDate = currentDate
        .clone()
        .subtract(1, 'months')
        .startOf('month')
        .format('YYYY-MM-DD');
      const endDate = currentDate
        .clone()
        .subtract(1, 'months')
        .endOf('month')
        .format('YYYY-MM-DD');
      return { startDate, endDate };
    }
    default:
      return null;
  }
};

/*
  Format date and time
  @type
  - time
  - full
  - short
  - momentjs locale formats
*/
export const formatLocaleDateTime = (date, locale = 'en-US', type = 'LLL', includeYear = false) => {
  const localeDate = moment.utc(date).locale(locale);

  if (!date || !localeDate.isValid()) {
    return '';
  }

  let time = localeDate.format('LT');
  time = time.replace('AM', 'am');
  time = time.replace('PM', 'pm');

  switch (type) {
    case 'time':
      return time;
    case 'full':
      return `${localeDate.format('LL')} ${time}`;
    case 'short':
      return `${localeDate.format('ll')} ${time}`;
    case 'shortDate': {
      const dateOnly = localeDate.format('ll');

      if (includeYear) {
        return dateOnly;
      }
      return dateOnly.replace(new RegExp(`[^\.]?${localeDate.format('YYYY')}.?`), '').replace(',', '');
    }
    case 'longDate': {
      const dateOnly = localeDate.format('LL');

      if (includeYear) {
        return dateOnly;
      }

      return dateOnly.replace(new RegExp(`[^\.]?${localeDate.format('YYYY')}.?`), '').replace(',', '');
    }
    case 'excel-standard':
      return `${localeDate.format('YYYY-MM-DD HH:mm')}`;
    default:
      return localeDate.format(type);
  }
};
