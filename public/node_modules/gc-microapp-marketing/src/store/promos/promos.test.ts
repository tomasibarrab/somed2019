/* tslint:disable */
import configureMockStore from 'redux-mock-store';
import { createEpicMiddleware } from 'redux-observable';
import { of } from 'rxjs/observable/of';

import {
  initialState as initialPromosState,
  isFeatured,
  isSeasonal,
  isJoined,
  isUnjoined,
  featuredPromos,
  getFlashMessage,
  resetFlashMessage,
  unjoinedFeaturedPromos,
  joinedFeaturedPromos,
  seasonalPromos,
  unjoinedSeasonalPromos,
  joinedSeasonalPromos,
  cancelEditPromo,
  editPromo,
  ensurePromos,
  fetchPromos,
  fetchPromosEpic,
  ensurePromosEpic,
  promosReducer,
  updatePromo,
} from './promos';
import promosFixture from '../../../internals/fixtures/promosFixture';
import { mapFetchToStore } from './mapFetchToStore';

describe('promos reducer', () => {
  it('cancelEditPromo', () => {
    const action = { type: cancelEditPromo.type };
    const mockState = {};
    const expectedResult = { currentPromoId: null, saveStatus: 'init' };

    expect(promosReducer(mockState, action)).toEqual(expectedResult);
  });

  it('editPromo', () => {
    const currentPromoId = 1;
    const action = { type: editPromo.type, payload: currentPromoId };
    const mockState = {};
    const expectedResult = { currentPromoId };

    expect(promosReducer(mockState, action)).toEqual(expectedResult);
  });

  it('fetchPromos.started', () => {
    const action = { type: fetchPromos.started.type };
    const mockState = { promos: {} };
    const expectedResult = { ...mockState, fetchStatus: 'open' };

    expect(promosReducer(mockState, action)).toEqual(expectedResult);
  });

  it('fetchPromos.done', () => {
    const payload = {
      params: {},
      result: {
        id: 21,
        promos: [{ id: 1007, name: 'apromo', type: 'Seasonal',
      }],
      },
    };
    const action = { type: fetchPromos.done.type, payload };
    const mockState = {};
    const expectedResult = { ...mockState, fetchStatus: 'success', ...payload.result };

    expect(promosReducer(mockState, action)).toEqual(expectedResult);
  });

  it('fetchPromos.failed', () => {
    const action = { type: fetchPromos.failed.type };
    const mockState = { promos: {} };
    const expectedResult = { ...mockState, fetchStatus: 'failure' };

    expect(promosReducer(mockState, action)).toEqual(expectedResult);
  });

  it('resetFlashMessage', () => {
    const action = { type: resetFlashMessage.type };
    const mockState = { flashMessage: 'published' };
    const expectedResult = { flashMessage: null };

    expect(promosReducer(mockState, action)).toEqual(expectedResult);
  });

  it('updatePromos.done', () => {
    const id = 5;
    const currentPromo = { id, foo: 'taco' };
    const updatedPromo = { id, foo: 'banana' };

    const action = {
      type: updatePromo.done.type,
      payload: {
        params: {},
        result: {
          id,
          ...updatedPromo,
        },
      },
    };

    const mockState = {
      ...initialPromosState,
      saveStatus: 'open',
      promos: {
        [id]: currentPromo,
      },
    };

    const expectedResult = {
      ...initialPromosState,
      flashMessage: 'saved',
      promos: {
        [id]: updatedPromo,
      },
      saveStatus: 'success',
    };

    expect(promosReducer(mockState, action)).toEqual(expectedResult);
  });

  describe('getFlashMessage', () => {
    it('should return published if no promo-restaurant mapping exists', () => {
      const currentPromo = { promoRestaurant: null };
      const newPromo = { promoRestaurant: null };

      expect(getFlashMessage(currentPromo, newPromo)).toEqual('published');
    });

    it('should return removed if the promo-restaurant mapping is explicitely null', () => {
      const currentPromo = { promoRestaurant: {} };
      const newPromo = { promoRestaurant: null };

      expect(getFlashMessage(currentPromo, newPromo)).toEqual('removed');
    });

    it('should return saved in all other cases', () => {
      const currentPromo = { promoRestaurant: {} };
      const newPromo = { promoRestaurant: {} };

      expect(getFlashMessage(currentPromo, newPromo)).toEqual('saved');
    });
  });
});

describe('fetchPromosEpic', () => {
  const state = {
    currentContext: {
      restaurant: {
        rid: 123,
      },
    },
  };

  const mockpromo = id => ({
    id,
    name: `promo ${id}`,
    promo: {
      displayLinkDates: {
        start: '2017-01-01',
        end: '2017-01-01',
      },
      eventDates: {
        start: '2017-01-01',
        end: '2017-01-01',
      },
    },
  });

  const mockPromos = {
    promos: [mockpromo(1), mockpromo(2)],
  };

  const mockFetchPromos = () => of(mockPromos);
  const dependencies = { api: { fetchPromos: mockFetchPromos } };
  const rootEpic = (action$, store) => fetchPromosEpic(action$, store, dependencies);
  const epicMiddleware = createEpicMiddleware(rootEpic);
  const mockStore = configureMockStore([epicMiddleware]);

  it('should fetch promos', () => {
    // setup store with default empty promos
    const store = mockStore({
      ...state,
      promos: initialPromosState, // returns initial state
    });

    store.dispatch(fetchPromos.started({}));

    expect(store.getActions()).toEqual([
      fetchPromos.started({}),
      fetchPromos.done({ params: {}, result: mapFetchToStore(mockPromos) }),
    ]);
  });
});

describe('ensurePromosEpic', () => {
  const state = {
    currentContext: {
      restaurant: {
        rid: 123,
      },
    },
  };

  const mockPromos = {
    promos: [{ id: 1, name: 'promo 1' }, { id: 2, name: 'promo 2' }],
  };

  const mockFetchPromos = () => [mockPromos];
  const dependencies = { api: { fetchPromos: mockFetchPromos } };
  const rootEpic = (action$, store) => ensurePromosEpic(action$, store, dependencies);
  const epicMiddleware = createEpicMiddleware(rootEpic);
  const mockStore = configureMockStore([epicMiddleware]);

  let store;

  afterEach(() => {
    epicMiddleware.replaceEpic(rootEpic);
  });

  it('should fetch promos when no promos present', () => {
    // setup store with default empty promos
    store = mockStore({
      ...state,
      promos: initialPromosState,
    });

    store.dispatch(ensurePromos());

    expect(store.getActions()).toEqual([ensurePromos(), fetchPromos.started({})]);
  });

  it('should not fetch promos when promos already loaded', () => {
    // setup store with default promos
    store = mockStore({
      ...state,
      promos: {
        fetchStatus: 'success',
      },
    });

    store.dispatch(ensurePromos());

    expect(store.getActions()).toEqual([ensurePromos()]);
  });
});

// boolean helper functions
//
describe('promos boolean functions', () => {
  it('isFeatured returns true for featured promo', () => {
    expect(isFeatured(promosFixture.promos[4])).toEqual(true);
  });

  it('isFeatured returns false for seasonal promo', () => {
    expect(isFeatured(promosFixture.promos[0])).toEqual(false);
  });

  // isSeasonal
  it('isSeasonal returns true for seasonal promo', () => {
    expect(isSeasonal(promosFixture.promos[0])).toEqual(true);
  });

  it('isSeasonal returns false for featured promo', () => {
    expect(isSeasonal(promosFixture.promos[4])).toEqual(false);
  });

  // isJoined
  it('isJoined returns false for nulls', () => {
    expect(isJoined({ promoRestaurant: null })).toEqual(false);
  });

  it('isJoined returns false for inActive promoRestaurant', () => {
    expect(isJoined(promosFixture.promos[0])).toEqual(false);
  });

  it('isJoined returns true for Active promoRestaurant', () => {
    expect(isJoined(promosFixture.promos[2])).toEqual(true);
  });

  // isUnjoined
  it('isUnjoined returns false for nulls', () => {
    expect(isUnjoined({ promoRestaurant: null })).toEqual(true);
  });

  it('isUnjoined returns true for inActive promoRestaurant', () => {
    expect(isUnjoined(promosFixture.promos[0])).toEqual(true);
  });

  it('isUnjoined returns false for Active promoRestaurant', () => {
    expect(isUnjoined(promosFixture.promos[2])).toEqual(false);
  });
});

describe('promos selectors', () => {
  // create mock state
  const mockState = {
    currentContext: {
      isFetching: false,
      fetchFailed: false,
      error: null,
      user: null,
      restaurant: null,
    },
    form: null,
    language: {
      locale: 'en-us',
    },
    featureToggles: {},
    promos: promosFixture,
  };

  // featured
  it('joinedFeaturedPromos returns 1', () => {
    expect(joinedFeaturedPromos(mockState).length).toEqual(1);
  });

  it('unjoinedFeaturedPromos returns 7', () => {
    expect(unjoinedFeaturedPromos(mockState).length).toEqual(7);
  });

  it('featuredPromos returns map of 1 joined 7 unjoined', () => {
    const promosMap = featuredPromos(mockState);
    expect(promosMap.joinedPromos.length).toEqual(1);
    expect(promosMap.unjoinedPromos.length).toEqual(7);
  });

  // seasonal
  it('joinedSeasonalPromos returns 1', () => {
    expect(joinedSeasonalPromos(mockState).length).toEqual(1);
  });

  it('unjoinedSeasonalPromos returns 9', () => {
    expect(unjoinedSeasonalPromos(mockState).length).toEqual(9);
  });

  it.skip('unjoinedSeasonalPromos sorts in asc order', () => {
    // this test fails occasionally?
    const promos = unjoinedSeasonalPromos(mockState);
    expect(promos.length).toEqual(9);

    const promoIds = promos.map(p => p.id);

    // reordered to be asc by EventStartDate and some dates bumped 1 year
    expect(promoIds).toEqual([102, 228, 355, 77, 85, 1, 728, 6, 4]);
  });

  it('seasonalPromos returns 10', () => {
    const promosMap = seasonalPromos(mockState);
    expect(promosMap.joinedPromos.length).toEqual(1);
    expect(promosMap.unjoinedPromos.length).toEqual(9);
  });
});
