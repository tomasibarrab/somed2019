#!/usr/bin/env node

const Promise = require('bluebird');
const _ = require('lodash');
const fullApiClient = require('../api/api-client');
const fakeApiClient = require('../api/fake-client');
const utils = require('../../utils/utils');
const { getProfileSettings } = require('../config/getVersionApiSettings');
const { getDeployVersion, getManifestFile } = require('gca-mono/lib/load-local-package');

const commandName = 'Registry promote';

function microAppExists(apiClient, appName, host) {
  return apiClient
    .microAppExists({ appName, host })
    .then(() =>
      console.info(`${commandName}: Microapp "${appName}" entry exists, continuing to the version promotion on ${host}.`))
    .catch(reason =>
      Promise.reject(`${commandName}: Error checking existence of microapp "${appName}" on ${host} - ${reason}`)
    );
}

function microAppVersionExists(apiClient, appName, host, deployVersion) {
  console.info(`${commandName}: Check if version ${deployVersion} exists for ${appName} on host ${host}`);
  return apiClient
    .microAppVersionExists({ appName, host, deployVersion })
    .then(() =>
      console.info(`${commandName}: Microapp version "${appName}@${deployVersion}" exists on ${host}.`)
    )
    .catch(reason =>
      Promise.reject(`${commandName}: Error checking existence of microapp version  "${appName}@${deployVersion}" on ${host}. - ${reason}`),
    );
}

function promoteVersionToEnvironment({ appName, host, deployVersion, envName, creator, apiClient }) {
  console.info(`${commandName}: Promoting ${appName}@${deployVersion} to environment "${envName}" on ${host}`);
  return apiClient
    .promoteMicroAppVersion({ appName, host, environment: envName, deployVersion, creator })
    .then(() =>
      console.info(`${commandName}: Successfully promoted ${appName}@${deployVersion} to environment "${envName}" on ${host}`)
    )
    .catch(reason =>
      Promise.reject(`${commandName}: Error promoting ${appName}@${deployVersion} to environment "${envName}" on ${host} - ${reason}`),
    );
}

function promoteVersionToMultipleEnvironments(environmentConfigs) {
  // needs to update sync, to avoid collisions (TODO: review if there is a way to avoid this at the server)
  console.info(`${commandName}: Promoting to multiple environments ...`);
  return Promise.map(environmentConfigs, promoteVersionToEnvironment, { concurrency: 1 });
}

module.exports = async function (profile, isDryRun) {
  const apiClient = isDryRun ? fakeApiClient : fullApiClient;
  const { name: appName } = getManifestFile();
  const deployVersion = getDeployVersion(profile);
  const environments = getProfileSettings(profile);

  console.log(`${commandName}: ${appName} to ${deployVersion} on ${profile}`);

  // For each unique server host ('http://www.qa.url', 'http://www.prod.url'),
  // Check that the microapp exists, and a specific version of the microapp exists
  const uniqueHosts = _.uniq(_.map(environments, 'host'));
  const perHostPrechecks = uniqueHosts.reduce((prechecks, host) => [
    ...prechecks,
    () => microAppExists(apiClient, appName, host),
    () => microAppVersionExists(apiClient, appName, host, deployVersion),
  ], []);

  // Prepare settings for each API call for an Environment
  console.log(`Preparing to publish for the following enviroments: `);
  const environmentConfigs = environments.map(environment => {
    console.log('Env: ', environment);
    return {
      appName,
      envName: environment.name,
      host: environment.host,
      deployVersion,
      creator: 'TeamCity',
      apiClient,
    };
  });


  utils.requireTeamCity(`${commandName}: Cancelling version promotion... can only run from TeamCity.`);
  utils
    .promiseQueue([
      ...perHostPrechecks,
      () => promoteVersionToMultipleEnvironments(environmentConfigs),
    ])
    .then(response => {
      const envNames = _.map(environments, 'name').join(', ');
      console.info(
        `${commandName}: promoted microapp version "${appName}@${deployVersion}" to environments [${envNames}], using profile "${profile}"`,
      );
    })
    .catch(reason => {
      utils.fatal(`${commandName}: while promoting microapp "${appName}@${deployVersion}" for profile "${profile}"`, reason);
    });
};
