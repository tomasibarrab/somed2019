#!/usr/bin/env node

const { createClient: createS3Client } = require('s3');
const _ = require('lodash');
const utils = require('../../utils/utils');
const getS3UploadParams = require('../config/getS3UploadParams');
const { dryExplanation } = require('../../utils/dryRunLog');

// AWS_ACCESS_KEY_ID & AWS_SECRET_ACCESS_KEY are required directly by the underlying `aws-sdk`.
const { AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY } = process.env;

/**
 * Detects if a given destination on S3 is empty of content or not.
 * The function returns a Promise resolved with true if the destination is empty, false otherwise
 * @param {*} client The S3 client to use
 * @param {*} s3Params The parameters describing the S3 destination: { Bucket: string, Prefix: string }
 */
function detectDestinationIsEmpty(client, s3Params) {
  return new Promise((resolve) => {
    console.log(`Check s3 destination: ${s3Params.Bucket}/${s3Params.Prefix}`);

    const checker = client.listObjects({ s3Params: { ...s3Params, MaxKeys: 10 }, recursive: false });
    checker.on('data', (data) => {
      checker.abort();
      if (data.Contents && data.Contents.length > 1) {
        console.log(`Destination: ${s3Params.Bucket}/${s3Params.Prefix} has ${data.Contents.length} items: destination is NOT EMPTY.`);
        resolve(false); // The destination is not empty
      } else {
        console.log(`Destination: ${s3Params.Bucket}/${s3Params.Prefix} has 0 items: it is empty.`);
        resolve(true); // The destination is empty.
      }
    });
    // if we get an error we assume (in this context) is because the destination does not exists
    checker.on('error', (err) => {
      console.log(`Destination: ${s3Params.Bucket}/${s3Params.Prefix} has error: ${err.message}.`);
      checker.abort();
      resolve(true); // The destination does not exists hence is empty.
    })
  });
}

/**
 * Upload a local directory to a S3 destination.
 * The function return a promise that resolve once the upload is complete.
 * @param {*} client The S3 client to use
 * @param {*} params The parameters describing the local directory and the
 *                   S3 destination: { localDir: string, s3Params: { Bucket: string, Prefix: string } }
 */
function uploadMicroapp(client, params) {
  return new Promise((resolve, reject) => {
    const uploader = client.uploadDir(params);
    uploader.on('error', (err) => reject(err));
    uploader.on('end', () => resolve());
  });
}

/**
 * Trigger an upload of microapp to S3
 * @param {*} s3Bucket destination bucket name in S3
 * @param {*} s3BucketBasePath destination path within the bucket
 * @param {*} name name of the microapp
 * @param {*} buildNumber version number as a string of the microapp
 * @param {*} isDryRun if true, do not actually upload to S3, just pretend that you did
 */
function startUpload(s3Bucket, s3BucketBasePath, name, buildNumber, isDryRun) {
  const DIST = 'dist';
  if (_.isEmpty(s3Bucket)) utils.fatal('Missing S3_BUCKET value.');
  if (_.isEmpty(s3BucketBasePath)) utils.fatal('Missing a valid S3 bucket base path.');
  if (_.isEmpty(AWS_ACCESS_KEY_ID)) utils.fatal('Missing AWS_ACCESS_KEY_ID env value.');
  if (_.isEmpty(AWS_SECRET_ACCESS_KEY)) utils.fatal('Missing AWS_SECRET_ACCESS_KEY value.');

  const fullS3Client = createS3Client({});
  const mockS3Client = {
    listObjects: fullS3Client.listObjects.bind(fullS3Client),
    uploadDir: (params) => ({
      on: (condition, callback) => {
        if (condition === 'end') {
          dryExplanation('s3-upload');
          callback();
        }
      }
    }),
  }

  const client = isDryRun === false ? fullS3Client : mockS3Client;
  const params = {
    localDir: DIST,
    s3Params: {
      Bucket: s3Bucket,
      Prefix: `${s3BucketBasePath}/${name}/${buildNumber}`,
    },
  };
  const fullPath = `${s3Bucket}/${s3BucketBasePath}/${name}/${buildNumber}`;

  // Before we upload anything we make sure there is no existing microapp on this location
  detectDestinationIsEmpty(client, params.s3Params)
    .then((destIsEmpty) => {
      if (destIsEmpty) {
        console.log(`Uploading microapp "${name}@${buildNumber}" to S3 "${fullPath}"...`);
        console.log(JSON.stringify(params, null, 2));
        return uploadMicroapp(client, params);
      } else {
        // We fail here without printing out a message that will trigger TC to consider the build process as failed.
        utils.fatal(
          `NOT UPLOADED: Microapp ${name} ${buildNumber} already in S3: "${fullPath}".`,
          new Error(`Destination "${params.s3Params.s3Bucket}/${params.s3Params.Prefix}" not empty.`)
        );
      }
    })
    .then(() => {
      console.log(
        `Success "${name}@${buildNumber}" uploaded to S3 bucket "${fullPath}"`,
      );
    })
    .catch((err) => {
      utils.fatal(
        `Failed uploading microapp version "${name}@${buildNumber}" to S3 bucket "${fullPath}"`,
        err,
      );
    });
}

module.exports = function (isDryRun) {
  const { buildNumber, package, s3 } = getS3UploadParams();

  utils.requireTeamCity('Cancelling S3 upload... can only run from TeamCity.');
  startUpload(s3.bucket, s3.prefix, package.name, buildNumber, isDryRun);
};
