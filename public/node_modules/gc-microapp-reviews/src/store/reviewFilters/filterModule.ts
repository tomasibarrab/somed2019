import get from 'lodash/get';
import isEqual from 'lodash/isEqual';
import last from 'lodash/last';
import { createSelector } from 'reselect';

import 'rxjs/add/operator/map';
import 'rxjs/add/operator/mergeMap';

// tslint:disable:max-line-length
export interface Config<V> {
  /** The action type to dispatch during apply() */
  APPLY: string;
  /** The action type to dispatch during apply() */
  BLUR: string;
  /** The action type to dispatch during cancel() */
  CANCEL: string;
  /** The action type to dispatch during focus() */
  FOCUS: string;
  /** The initial value of the filter */
  initialValue: V;
  /** The path within the store that this filter's reducer will be registered */
  path: string[];
  /** The action type to dispatch during set() */
  SET: string;
  /** The action type that indicates a search has been performed successfully with these filters */
  SUCCESS: string;
  /** A function called before a value is set in the reducer. This is intended only as a development aid, and set() will throw if this function fails */
  integrityCheck?(payload: V): boolean;
  /** A function to determine the validity of current/potential reducer value */
  validate?(payload: V): boolean;
}

export function create<V>(o: Config<V>) {
  interface State {
    current: V;
    focused: boolean;
    pending: V;
    pristine: boolean;
  }

  const { path, validate = () => true, integrityCheck = () => true, APPLY, BLUR, CANCEL, FOCUS, SET, SUCCESS } = o;

  const name = last(path);

  if (!integrityCheck(o.initialValue)) {
    throw new Error(`Initial value of ${o.path.join('.')} does not pass integrity check`);
  }

  const initialState = {
    current: o.initialValue,
    focused: false,
    pending: o.initialValue,
    pristine: true,
  };

  interface BaseAction {
    type: string;
    target: string;
  }
  interface SetAction extends BaseAction {
    payload: V;
    applyOnSet: boolean;
  }
  type Action = BaseAction | SetAction;

  const actions = {
    apply: () => ({ type: APPLY, target: name }),
    blur: () => ({ type: BLUR, target: name }),
    cancel: () => ({ type: CANCEL, target: name }),
    focus: () => ({ type: FOCUS, target: name }),
    set: (payload: V, applyOnSet = false) => {
      // Dev only, if this throws in prod something's gone horribly wrong
      if (!integrityCheck(payload)) {
        throw new Error(`${payload} does not pass integrity check`);
      }

      return { type: SET, target: name, applyOnSet, payload };
    },
  };

  const baseSelector = (state: any) => get(state, path);
  const jsSelector = createSelector(baseSelector, base => base);
  const validSelector = createSelector(jsSelector, values => validate(values.pending));
  const changedSelector = createSelector(jsSelector, js => !isEqual(js.current, js.pending));
  const selector = createSelector(jsSelector, validSelector, changedSelector, (js, valid, changed) =>
    Object.assign({}, js, { valid, changed }),
  );

  // Action type handlers
  function apply(state: State, { target }: Action) {
    if (target !== name) {
      return state;
    }
    const pending = state.pending;
    const focused = !validate(pending);
    return { ...state, focused };
  }

  function blur(state: State, { target }: Action) {
    if (target !== name) {
      return state;
    }
    const current = state.current;
    const pending = state.pending;
    const pristine = isEqual(current, pending);
    return { ...state, pristine };
  }

  function cancel(state: State) {
    const current = state.current;
    const pending = state.pending;

    // Immutable does a shallow diff, so only "reset" the pending value if it has actually changed
    return isEqual(current, pending)
      ? { ...state, focused: false }
      : { ...state, pending: state.current, focused: false, pristine: true };
  }

  function focus(state: State, { target }: Action) {
    if (target !== name) {
      return cancel(state);
    }
    return { ...state, focused: true };
  }

  function isSetAction(action: Action): action is SetAction {
    return (action as SetAction).payload !== undefined;
  }

  function set(state: State, action: Action) {
    if (!isSetAction(action)) {
      return state;
    }

    const { target, payload, applyOnSet } = action;

    if (target !== name) {
      return state;
    }

    if (!integrityCheck(payload)) {
      throw new Error(`${payload} does not pass integrity check`);
    }

    return { ...state, pending: payload, focused: applyOnSet ? !validate(payload) : state.focused };
  }

  // Primary reducer function
  const reducer = (state = initialState, action: Action) => {
    switch (action.type) {
      case APPLY:
        return apply(state, action);
      case BLUR:
        return blur(state, action);
      case CANCEL:
        return cancel(state);
      case FOCUS:
        return focus(state, action);
      case SET:
        return set(state, action);
      case SUCCESS:
        return {
          ...state,
          current: state.pending,
        };
      default:
        return state;
    }
  };

  return { initialState, reducer, actions, selector };
}
