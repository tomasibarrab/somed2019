import keyBy from 'lodash/keyBy';
import pickBy from 'lodash/pickBy';
import { Action, actionCreatorFactory, Success } from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';

import { Epic } from '../../store/types';

// --------------------------------- //
// Types
// --------------------------------- //

export type ReportsDTO = Report[];

export const enum ReportFrequency {
  Daily = 'Daily',
  Monthly = 'Monthly',
  Weekly = 'Weekly',
}

export const enum ReportType {
  Detailed = 'Detailed',
  RatingsOnly = 'RatingsOnly',
}

export interface Report {
  ReportId: string;
  Archived?: boolean;
  Frequency: ReportFrequency;
  Recipients: string[];
  RestaurantIds: number[];
  Type: ReportType;
}

export interface NewReport extends Report {
  Creator: string;
}

export interface UpdatedReport extends Report {
  Editor: string;
}

export interface Reports {
  [reportId: string]: Report;
}

export interface ReportsState {
  deleteFailure: boolean;
  editActiveId: null | string;
  editNewReportOpen: boolean;
  fetchFailed: boolean;
  isCreating: boolean;
  isDeleting: boolean;
  isFetching: boolean;
  isUpdating: boolean;
  newReport: Report;
  reportIds: string[];
  reports: Reports;
  updateFailed: boolean;
}

// --------------------------------- //
// Actions
// --------------------------------- //

const actionCreator = actionCreatorFactory('REPORTS');

export const fetchReports = actionCreator.async<{}, ReportsDTO>('FETCH');
export const addReport = actionCreator.async<NewReport, Report>('ADD');
export const updateReport = actionCreator.async<UpdatedReport, Report>('UPDATE');
export const initDeleteReport = actionCreator<string>('INIT_DELETE');
export const deleteReport = actionCreator.async<{ reportId: string }, {}>('DELETE');
export const editReportActiveUpdate = actionCreator<string | null>('EDIT_ACTIVE');
export const editNewReportToggle = actionCreator('TOGGLE_NEW');

// --------------------------------- //
// Reducer
// --------------------------------- //

import { transformArrayToObject } from '../../utils/reducer-helpers';

const newReport: Report = {
  Frequency: ReportFrequency.Daily,
  Recipients: [],
  ReportId: 'new',
  RestaurantIds: [],
  Type: ReportType.RatingsOnly,
};

const initialState: ReportsState = {
  deleteFailure: false,
  editActiveId: null,
  editNewReportOpen: false,
  fetchFailed: false,
  isCreating: false,
  isDeleting: false,
  isFetching: false,
  isUpdating: false,
  newReport,
  reportIds: [],
  reports: {},
  updateFailed: false,
};

export const reportsReducer = reducerWithInitialState(initialState)
  .case(fetchReports.started, state => ({
    ...state,
    fetchFailed: false,
    isFetching: true,
  }))
  .case(fetchReports.done, (state, { result }) => ({
    ...state,
    fetchFailed: false,
    isFetching: false,
    reportIds: result.filter(report => report.Archived !== true).map(report => report.ReportId),
    reports: {
      ...state.reports,
      ...keyBy(result, 'ReportId'),
    },
  }))
  .case(fetchReports.failed, state => ({
    ...state,
    fetchFailed: true,
    isFetching: false,
  }))
  .cases([addReport.started, updateReport.started], state => ({
    ...state,
    isUpdating: true,
    updateFailed: false,
  }))
  .case(addReport.done, (state, { result }) => ({
    ...state,
    editActiveId: null,
    isCreating: false,
    isUpdating: false,
    reportIds: [result.ReportId].concat(state.reportIds),
    reports: {
      ...state.reports,
      [result.ReportId]: result,
    },
    updateFailed: false,
  }))
  .case(updateReport.done, (state, { result }) => ({
    ...state,
    editActiveId: null,
    isCreating: false,
    isUpdating: false,
    reports: {
      ...state.reports,
      [result.ReportId]: result,
    },
    updateFailed: false,
  }))
  .cases([addReport.failed, updateReport.failed], state => ({
    ...state,
    isUpdating: false,
    updateFailed: true,
  }))
  .case(deleteReport.started, state => ({
    ...state,
    deleteFailed: false,
    isDeleting: true,
  }))
  .case(deleteReport.done, (state, { params }) => ({
    ...state,
    deleteFailed: false,
    isDeleting: false,
    reportIds: state.reportIds.filter(reportId => params.reportId !== reportId),
    reports: pickBy(state.reports, report => params.reportId !== report.ReportId) as Reports,
  }))
  .case(deleteReport.failed, state => ({
    ...state,
    deleteFailed: true,
    isDeleting: false,
  }))
  .case(editReportActiveUpdate, (state, id) => ({ ...state, editActiveId: id }))
  .case(editNewReportToggle, state => ({
    ...state,
    editActiveId: null,
    isCreating: !state.isCreating,
  }));

// --------------------------------- //
// Epics
// --------------------------------- //

import { Observable } from 'rxjs/Observable';

import 'rxjs/add/observable/of';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/do';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/mapTo';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/takeUntil';

import { closeModal, confirmCloseModal, openModal } from '../modals/modals';

export const fetchReportsEpic: Epic = (action$, store, { api }) =>
  action$.filter(fetchReports.started.match).switchMap(() => {
    const rid = store.getState().currentContext.restaurant.rid;

    return api
      .fetchReports({ rid })
      .map((reports: Report[]) => fetchReports.done({ params: {}, result: reports }))
      .catch(() => Observable.of(fetchReports.failed({ params: {}, error: {} })));
  });

function mapCreatedReportToStore(report: NewReport, id: string) {
  const mappedReport = { ...report };
  delete mappedReport.Creator;
  mappedReport.ReportId = id;

  return mappedReport;
}

export const addReportEpic: Epic = (action$, store, { api }) =>
  action$.filter(addReport.started.match).switchMap(({ payload: report }) => {
    const rid = store.getState().currentContext.restaurant.rid;

    return api
      .addReport({ rid, report })
      .map(response =>
        addReport.done({ params: report, result: mapCreatedReportToStore(report, response.response.id) }),
      )
      .catch((error: string) => [addReport.failed({ params: report, error }), openModal({ modal: 'ERROR' })]);
  });

export const updateReportEpic: Epic = (action$, store, { api }) =>
  action$.filter(updateReport.started.match).switchMap(({ payload: report }) => {
    const rid = store.getState().currentContext.restaurant.rid;

    return api
      .updateReport({ rid, report })
      .map(() => updateReport.done({ params: report, result: report }))
      .catch((error: string) => [updateReport.failed({ params: report, error }), openModal({ modal: 'ERROR' })]);
  });

export const deleteReportEpic: Epic = action$ =>
  action$
    .filter(initDeleteReport.match)
    .map(({ payload: modalPayload }) => openModal({ modal: 'DELETE_REPORT', modalPayload }));

export const confirmDeleteReportEpic: Epic = action$ =>
  action$
    .filter(openModal.match)
    .filter(action => action.payload.modal === 'DELETE_REPORT')
    .switchMap(({ payload: { modalPayload } }) =>
      (action$.takeUntil(action$.filter(closeModal.match)) as any)
        .filter(confirmCloseModal.match)
        .mapTo(deleteReport.started(modalPayload)),
    );

export const deleteReportRequestEpic: Epic = (action$, store, { api }) =>
  action$.filter(deleteReport.started.match).switchMap(({ payload: { reportId } }) => {
    const { currentContext, reports } = store.getState();
    const report = reports.reports[reportId];
    const rid = currentContext.restaurant.rid;
    const userEmail = currentContext.user.userName;

    /**
     * While not supported in GCA, reports may include multiple RIDs.
     * What appears to be a "delete" operation in GCA is either:
     * A) Removing the current RID from the reports' RestaurantIds list.
     * B) Archiving the report if this is the only RID in the list.
     */
    const RestaurantIds =
      report.RestaurantIds.length > 1 ? report.RestaurantIds.filter(id => id !== rid) : report.RestaurantIds;

    const Archived = RestaurantIds.length === 1 && RestaurantIds[0] === rid;

    const updatedReport: UpdatedReport = {
      ...report,
      Archived,
      Editor: userEmail,
      RestaurantIds,
    };

    return api
      .updateReport({ rid, report: updatedReport })
      .map(() => deleteReport.done({ params: { reportId }, result: {} }))
      .catch((error: string) => [deleteReport.failed({ params: { reportId }, error }), openModal({ modal: 'ERROR' })]);
  });
