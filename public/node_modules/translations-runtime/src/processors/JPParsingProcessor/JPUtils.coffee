module.exports = (_, JPWordRules) ->

  new class JPUtils

    constructor: ->
      @NO_BREAK_SPACE = "\uFEFF"
      @WORD_BREAK_SPACE = "\u200B"

    isEnglish: (word) ->
      # This will return false if word does not exist
      if typeof word is "undefined" then return false
      /[a-zA-Z]/.test(word)

    isGCWord: (word) ->
      JPWordRules.guestCenterNames[word]

    isSymbol: (word) ->
      # May need to be updated with more symbols over time. So far
      # just testing for symbol anywhere in word seems to be working, since
      # parser splits most symbols out as individual words to begin with.
      /[\,-\/#!Â©{}$%\^&\*;:\-`]/.test(word)

    isEnglishOrSymbol: (word) ->
      @isEnglish(word) or @isSymbol(word)

    isEnglishOrSymbolOrNumber: (word) ->
      @isEnglishOrSymbol(word) or @isNumber(word)

    isNumber: (word) ->
      /[0-9]/.test(word)

    isSymbolOrNumber: (word) ->
      @isSymbol(word) or @isNumber(word)

    isJpOpenParen: (word) ->
      JPWordRules.jpOpenParen[word]

    shouldAddToPrevious: (partOfSpeech) ->
      JPWordRules.addToPrevious[partOfSpeech]

    wordExists: (word) ->
      word?.length

    glueCharacters: (word) ->
      word.split("").join(@NO_BREAK_SPACE)

    getJpOpenParenJoin: (nextWord) ->
      if @isEnglishOrSymbol(nextWord) then @NO_BREAK_SPACE else ""

    getJpToJpJoin: (wordObj) ->
      if @shouldAddToPrevious wordObj.part_of_speech then @NO_BREAK_SPACE else @WORD_BREAK_SPACE

    combineWithNextWord: (word, nextWord, sentenceObj, i) ->
      @setWord sentenceObj, i+1, word + nextWord
      return ""

    setWord: (sentenceObj, index, value) ->
      sentenceObj[index]?['word'] = value

    existsAndIsNotJp: (word) ->
      @wordExists(word) and @isEnglishOrSymbolOrNumber(word)

    isJp: (word) ->
      # Have to arrive at this conclusion by inference bc no good regex exists
      @wordExists(word) and not @isEnglishOrSymbolOrNumber(word)
