module.exports = (Processor, TranslationPaths, Promise, fs, path, _, Logger) ->

  class HarnessSmartlingClientLocalesProcessor extends Processor

    run: ->
      @mergedContents = {}
      if @shouldRun(@context, @config)
        @getBundles()
      else
        Promise.reject(new Error("HarnessSmartlingClientLocalesProcessor called with invalid context or config."))

    getBundles: ->
      getBundleConfigAndCallbackWith = @getBundleConfigAndCallbackWith(@getBundle)
      return Promise
        .reduce(_.values(@context?.bundles), getBundleConfigAndCallbackWith, "")
        .then =>
          @context.result = @mergedContents
        .catch @handleError

    shouldRun: (context, config) ->
      context?.bundles and context?.locale and config?.forEach is "locale"

    getBundleConfigAndCallbackWith: (afterBundleConfigCallback) =>
      (ignore, bundle) =>
        afterBundleConfigCallback @getBundleConfig(bundle)

    getBundleConfig: (bundle) =>
      bundleConfig = _.extend {}, bundle
      bundleConfig.savedToProjectFolder ?= path.join(TranslationPaths.root, bundle?.projectId)
      bundleConfig.savedToFileFolder ?= path.join(bundleConfig.savedToProjectFolder, bundle?.fileUri)
      bundleConfig.savedToFile ?= path.join(bundleConfig.savedToFileFolder, "#{@context?.locale}.json")
      bundleConfig

    isAlreadyDownloaded: (bundleConfig) ->
      isAlreadyDownloaded = false
      try
        isAlreadyDownloaded = fs.statSync(bundleConfig?.savedToFile)?.isFile()
      catch error
      return isAlreadyDownloaded

    getBundle: (bundleConfig) =>
      return @getBundleContent(bundleConfig)
        .then(@deleteSmartlingKey)
        .then(@mergeBundleContentToMemo)
        .then(@cleanupDownloads)
        .catch(@handleError)

    getBundleContent: (bundleConfig) ->
      bundleConfigAndContent = undefined
      try
        if @isAlreadyDownloaded(bundleConfig)
          bundleContent = JSON.parse(fs.readFileSync(bundleConfig?.savedToFile, "utf-8"))
          bundleConfigAndContent = Promise.resolve _.extend {}, { bundle: bundleConfig }, { content: bundleContent }
        else
          throw new Error("Unable to get bundle content; file #{bundleConfig?.savedToFile} does not exist.")
      catch error
        @cleanupDownloads({ bundle: bundleConfig })
        bundleConfigAndContent = Promise.reject error
      bundleConfigAndContent

    deleteSmartlingKey: (bundleConfigAndContent) =>
      delete bundleConfigAndContent?.content?.smartling
      return bundleConfigAndContent

    mergeBundleContentToMemo: (bundleConfigAndContent) =>
      _.extend @mergedContents, bundleConfigAndContent?.content
      return bundleConfigAndContent

    cleanupDownloads: (bundleConfigAndContent) =>
      @cleanupCurrentLocaleFile(bundleConfigAndContent?.bundle?.savedToFile)
      @cleanupTempFoldersIfEmpty(bundleConfigAndContent?.bundle?.savedToFileFolder, bundleConfigAndContent?.bundle?.savedToProjectFolder)
      return null

    cleanupCurrentLocaleFile: (savedToFile) ->
      try
        fs.unlinkSync(savedToFile)
      catch error
      return null

    cleanupTempFoldersIfEmpty: (savedToFileFolder, savedToProjectFolder) ->
      [savedToFileFolder, savedToProjectFolder].forEach (savedToFolder) ->
        try
          if fs.statSync(savedToFolder)?.isDirectory() and fs.readdirSync(savedToFolder).length is 0
            fs.rmdirSync(savedToFolder)
        catch error
      return null

    handleError: (error) =>
      Logger.error "Harness Smartling Client Locales Processor - get locale download error"
      Promise.reject(error)
