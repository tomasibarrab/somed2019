
module.exports = (ProcessorQueue, _, Promise, $injector, Logger) ->

  availableProcessors = $injector.getRegex(/Processor$/)

  class TranslationsDownload

    @DefaultDependencyProcessor: {
      name: "HarnessSmartlingClientDependencies"
      config: {
        forEach: "dependency"
      }
    }
    @ProcessorAliases:
      SmartlingDownload: TranslationsDownload.DefaultDependencyProcessor

    @download: (manifest) ->
      return new TranslationsDownload(manifest).download()

    constructor: (@manifest) ->
      @DefaultDependencyProcessor = TranslationsDownload.DefaultDependencyProcessor
      @ProcessorAliases = TranslationsDownload.ProcessorAliases

    download: ->
      return Promise.map(@manifest.dependencies, @createForDependency)
        .then =>
          Promise.map(@manifest.locales, @createForLocale)
            .catch -> Promise.reject(arguments[0])
        .catch -> Promise.reject(arguments[0])

    createForDependency: (bundle) =>
      context = {
        bundle: bundle
        localeIds: @manifest.locales
      }
      processors = @getProcessors(context, @isDependencyProcessor)
      return ProcessorQueue.run(context, processors)
        .catch -> Promise.reject(arguments[0])

    createForLocale: (locale) =>
      context = {
        locale
        bundles: @manifest.dependencies
      }
      processors = @getProcessors(context, @isLocaleProcessor)
      return ProcessorQueue.run(context, processors)
        .then (localeContents) => {
          @manifest
          locale
          localeContents
        }
        .catch -> Promise.reject(arguments[0])

    getProcessors: (context, filterBy) ->
      createProcessorBound = (processor) =>
        @createProcessor(context, processor)
      processorsConfig = @mapProcessors(filterBy)
      processors = _.compact(_.map(processorsConfig, createProcessorBound))
      return processors

    createProcessor: (context, processor) =>
      processorName = @getProcessorName(processor)
      processorClass = availableProcessors[processorName]
      unless processorClass
        Logger.error "#{processorName} does not exist"
        return undefined
      return new processorClass(context, processor.config)

    mapProcessors: (filterBy=@isLocaleProcessor) ->
      _(@manifest.processors)
        .map(@mapProcessorAlias)
        .filter(filterBy)
        .uniq((processor) -> processor.name)
        .value()

    mapProcessorAlias: (possibleAliasProcessor) =>
      realProcessor = @ProcessorAliases?[possibleAliasProcessor.name]
      if realProcessor then realProcessor else possibleAliasProcessor

    isLocaleProcessor: (processor) =>
      processor?.config?.forEach is "locale"

    isDependencyProcessor: (processor) =>
      processor?.config?.forEach is "dependency"

    getProcessorName: (processor) ->
      "#{@getProcessorNameByAlias(processor.name)}Processor"

    getProcessorNameByAlias: (possibleAliasProccessorName) ->
      realProcessorName = @ProcessorAliases?[possibleAliasProccessorName]?.name
      if realProcessorName then realProcessorName else possibleAliasProccessorName
