import {
  buildDataRequest,
  buildDataRequests,
  parseUrl,
  toQueryString,
  validateRidInput,
} from '../utils';

jest.mock('../config');

describe('buildDataRequest', () => {
  it('should find the TEST request', () => {
    const urlResult = buildDataRequest('TEST', '1');
    expect(urlResult).toBeDefined();
    expect(urlResult.url).toEqual('/test/1');
  });

  it('should not find the TESTS request', () => {
    const urlResult = buildDataRequest('TESTS', '1');
    expect(urlResult).not.toBeDefined();
  });

});

describe('buildDataRequests', () => {

  test('Should make a URL for "test" type', () => {
    const urlResults = buildDataRequests('test', '1');
    expect(urlResults).toBeInstanceOf(Array);
    expect(urlResults.length).toBe(1);
    expect(urlResults[0].url).toEqual('/test/1');
  })

  test('Should fail to make a URL for "tests" type', () => {
    const urlResults = buildDataRequests('tests', '1');
    expect(urlResults).toBeInstanceOf(Array);
    expect(urlResults.length).toBe(0);
  })

});


describe('psrseUrl', () => {

  test('replace a parameter', () => {
    const parsedUrl = parseUrl('/{anyPar}', 'test');
    expect(parsedUrl).toEqual('/test');
  })

  test('replace a parameter', () => {
    const parsedUrl = parseUrl('/no/replace/in/this/path', 'test');
    expect(parsedUrl).toEqual('/no/replace/in/this/path');
  })

});

describe('validateRidInput', () => {

  test('valid input', () => {
    const validRid = {
      id: null,
      input: '1234',
      touched: true,
    };
    expect( validateRidInput(validRid) ).toBe(true);
  });

  test('invalid input', () => {
    const validRid = {
      id: null,
      input: 'ab1234',
      touched: true,
    };
    expect( validateRidInput(validRid) ).toBe(false);
  });


  test('untouched input', () => {
    const validRid = {
      id: null,
      input: 'ab1234',
      touched: false,
    };
    expect( validateRidInput(validRid) ).toBe(true);
  });
});

describe('toQueryString', () => {

  test('Convert a simple object with 2 valid properties', () => {
    const props = {
      prop1: 'value1',
      prop2: 'value2',
    };
    expect(toQueryString(props)).toEqual('?prop1=value1&prop2=value2');
  });

  test('Convert a simple object with 2 properties but 1 is invalid', () => {
    const props = {
      prop1: '',
      prop2: 'value2',
    };
    expect(toQueryString(props)).toEqual('?prop2=value2');
  });

  test('Convert a simple object with 2 properties both  is invalid', () => {
    const props = {
      prop1: '',
      prop2: undefined,
    };
    expect(toQueryString(props)).toEqual('');
  });

  test('Convert a simple object with 3 properties and one set to be ignored', () => {
    const props = {
      prop1: 'val1',
      prop2: 'val2',
      prop3: 'val3',
    };
    expect(toQueryString(props, ['prop3'])).toEqual('?prop1=val1&prop2=val2');
  });

  test('Convert a simple object with 3 properties and all are set to be ignored', () => {
    const props = {
      prop1: 'val1',
      prop2: 'val2',
      prop3: 'val3',
    };
    expect(toQueryString(props, ['prop3', 'prop1', 'prop2'])).toEqual('');
  });

});
