/**
 * Dom element selector - only selects elements that are visible
 * @param selector
 * @param visibleOnly
 */
const getElement = (selector: string, visibleOnly: boolean = false) => {
  const domElem = document.querySelector(selector);

  if (!domElem) {
    return null;
  }

  const elemRect = domElem.getBoundingClientRect();

  if (visibleOnly && !elemRect.width && !elemRect.height) {
    return null;
  }

  return domElem;
};

/**
 * Map an x between 0-1 to 0-1 using a sin/cos function
 * @param x
 */
// const easeInOutSin = x => ((Math.sin((x - 1 / 2) * Math.PI) + 1) / 2);
const easeInOutCos = (x: number) => ((Math.cos((x - 1) * Math.PI) + 1) / 2);

/**
 * Calculates number of frames (steps) for requested duration
 * @param duration
 */
const getTotalSteps = (duration: number) => {
  const targetFrameRateMs = 1000 / 60; // => ms per frame
  return Math.round(duration / targetFrameRateMs); // => number of frames based on duration and target framerate
};

/**
 * Gets current page scroll - fixes for multiple browsers
 */
export const getPageY = () => (
  (document.documentElement && document.documentElement.scrollTop)
  || document.body.scrollTop
);

interface SmoothScrollOptions {
  target?: string;
  duration?: number;
  offset?: number;
  callback?: () => void;
}

/**
 * Smoothly scroll the page to an element or an absolute value.
 * @param to
 * @param target
 * @param duration
 * @param callback
 * @param offset
 */
export const smoothScrollTo = (
  to: number | string,
  {
    target,
    duration = 500,
    offset = 0,
    callback = () => undefined,
  }: SmoothScrollOptions = {},
): void => {
  // what element should we scroll?
  const targetElement = target && getElement(target) || window;

  // gets the final value of the scroll (i.e. desired scroll position)
  const getFreshDestination = () => {
    // either an absolute value (in px)...
    if (typeof to === 'number') {
      return to + offset;
    }

    // ...or an element on the page
    const domElem = getElement(to);

    if (!domElem) {
      return false;
    }

    // get element's absolute position
    const elemRect = domElem.getBoundingClientRect();

    // a simple case
    if (targetElement === window) {
      const bodyRect = document.body.getBoundingClientRect();

      // return that element's absolute position inside the page (body)
      // if the body is offset from the window, subtract that from the calculation
      // optionally, offset the scroll position with desired fixed amount
      return elemRect.top - bodyRect.top + offset;
    }

    // a bit more complex case: need to get element's absolute position inside the target container
    const targetRect = (targetElement as Element).getBoundingClientRect();

    // element's absolute position inside the target element is calculated from:
    // - element's absolute position from the window
    // - subtract target's absolute position from the window => element's absolute position from target
    // - add target's already scrolled value
    // - optionally, offset the scroll position with desired fixed amount
    return elemRect.top - targetRect.top + (targetElement as Element).scrollTop + offset;
  };

  // get the scroll destination (in px)
  const yDest = getFreshDestination();

  // stop if no final destination found
  if (yDest === false) {
    return;
  }

  // calculate scroll diff (current vs destination, value is in pixels)
  const initialY = targetElement !== window ? (targetElement as Element).scrollTop : getPageY();
  let yDiff = yDest - initialY;

  // no scroll diff => no scroll => stop & callback
  if (!yDiff) {
    callback();
    return;
  }

  // get total number of frames (steps)
  const totalSteps = getTotalSteps(duration);

  let currentStep = 1;

  // calculates
  const doStep = () => {
    // halfway through...
    if (currentStep === Math.round(totalSteps / 2)) {
      // get fresh value for scroll destination
      const newYDest = getFreshDestination();
      // if destination moved
      if (newYDest !== false && newYDest !== yDest) {
        // recalculate diff
        yDiff = newYDest - initialY;
      }
    }

    // calculate the scroll position for current frame (step)
    const stepY = initialY + yDiff * easeInOutCos(currentStep / totalSteps);

    // scroll to that position
    if (typeof targetElement.scrollTo === 'function') {
      // use scrollTo() function if element supports it
      targetElement.scrollTo(0, stepY);
    } else if (typeof (targetElement as Element).scrollTop !== 'undefined') {
      // set scrollTop value (IE & Edge)
      (targetElement as Element).scrollTop = stepY;
    }

    // do next step on next browser frame, or finish with the callback
    if (currentStep < totalSteps) {
      currentStep += 1;
      window.requestAnimationFrame(doStep);
    } else {
      callback();
    }
  };

  window.requestAnimationFrame(doStep);
};
