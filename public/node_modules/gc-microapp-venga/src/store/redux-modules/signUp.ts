import { combineReducers } from 'redux';
import { createSelector } from 'reselect';
import { actionCreatorFactory } from 'typescript-fsa';

import { AsyncState, asyncStateReducer } from 'shared-react-utils/asyncStateReducer';

import 'rxjs/add/observable/of';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/takeUntil';

import {
  Epic,
  PrimaryProduct,
  PrimaryProductsResponse,
  State,
  StatusResponse,
} from '../types';


// ---------------------------------------------------------------------------------------------------------------------
// actions
// ---------------------------------------------------------------------------------------------------------------------

const createAction = actionCreatorFactory();
const fetchIsSignedUp = createAction.async<number, PrimaryProductsResponse, any>('IS_SIGNED_UP_STATE');
const fetchIsActive = createAction.async<number, StatusResponse, any>('IS_ACTIVE_STATE');

export const actions = {
  fetchIsActive,
  fetchIsSignedUp,
};


// ---------------------------------------------------------------------------------------------------------------------
// epics
// ---------------------------------------------------------------------------------------------------------------------

const fetchIsSignedUpEpic: Epic = (action$, store, { api }) =>
  action$
    .filter(fetchIsSignedUp.started.match)
    .switchMap(({ payload: rid }) => // rename payload to rid (because that's what it is)
        api.fetchIsSignedUp(rid)
          .flatMap(result => [
            fetchIsSignedUp.done({ params: rid, result }),
          ])
          .catch(error => [
            fetchIsSignedUp.failed({ params: rid, error }),
          ]),
    );

const fetchIsActiveEpic: Epic = (action$, store, { api }) =>
  action$
    .filter(fetchIsActive.started.match)
    .switchMap(({ payload }) =>
      api.fetchIsActive(payload)
        .flatMap(result => [
          fetchIsActive.done({ params: payload, result }),
        ])
        .catch(error => [
          // TODO: remove the fake .done() and return the .failed()
          fetchIsActive.done({ params: payload, result: { responseStatus: 'ok', isOn: true } }),
          // fetchIsActive.failed({ params: payload, error }),
        ]),
    );

export const epics = {
  fetchIsActiveEpic,
  fetchIsSignedUpEpic,
};


// ---------------------------------------------------------------------------------------------------------------------
// reducers
// ---------------------------------------------------------------------------------------------------------------------

export interface SignUpState {
  isSignedUp: AsyncState<PrimaryProduct[], 'products'>;
  isActive: AsyncState<boolean>;
}

export const reducer = combineReducers<SignUpState>({
  isActive: asyncStateReducer(fetchIsActive, payload => payload.result.isOn),
  isSignedUp: asyncStateReducer(fetchIsSignedUp, payload => payload.result.primaryProducts, 'products'),
});


// ---------------------------------------------------------------------------------------------------------------------
// selectors
// ---------------------------------------------------------------------------------------------------------------------

const isVengaProduct = (product: PrimaryProduct) => (
  product.product === 'Venga whatevs...' // TODO: check for actual Venga products
  && product.status === 'Active'
);

const baseSelector = (state: State) => state.signUp;

const isSignedUpState = createSelector(
  baseSelector,
  state => (state.isSignedUp.products || []).some(isVengaProduct),
);

const isSignedUpStatus = createSelector(
  baseSelector,
  state => state.isSignedUp.status,
);

const isActiveState = createSelector(
  baseSelector,
  state => state.isActive.data,
);

const isActiveStatus = createSelector(
  baseSelector,
  state => state.isActive.status,
);

export const selectors = {
  isActiveState,
  isActiveStatus,
  isSignedUpState,
  isSignedUpStatus,
};
