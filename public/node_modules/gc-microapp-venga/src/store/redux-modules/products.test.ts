import {
  activePricesAndSignedUAFixture,
  activePricesAndUnsignedUAFixture,
  availablePricesAndUnsignedUAFixture,
  availablePricesFailedHostSelectedFixture,
  availablePricesFailedReviewManagerSelectedFixture,
  availablePricesFixture,
  availablePricesHostSelectedFixture,
  availablePricesReviewManagerSelectedFixture,
  defaultPricingMock,
  initialStateFixture,
  missingPricesFixture,
  modifiedPricingMock,
  pendingPricesAndSignedUAFixture,
  pricingBundleResponse,
  productAvailablePrice,
  productsLoadingAllFixture,
  productsLoadingPricesFixture,
  productsLoadingUAFixture,
  productUnsignedUA,
  reviewManagerPricingMock,
} from '../../../fixtures/products-store-mocks';

import {
  actions,
  initialSelectedProduct,
  ProductsState,
  selectedProductReducer,
  selectors,
} from './products';

import {
  AgreementType,
  State,
} from '../types';


// ====== helper functions ======
const state = (productsState: ProductsState): State => ({
  currentContext: undefined,
  featureToggles: undefined,
  language: undefined,
  leadGen: undefined,
  products: productsState,
  signUp: undefined,
});
// ====== end helper functions ======


describe('products', () => {
  describe('actions', () => {
    describe('selectProduct', () => {
      it('should create a selectProduct action that takes an AgreementType', () => {
        const generatedAction = actions.selectProduct(AgreementType.venga_integration_host);
        const expectedActionObject = { payload: AgreementType.venga_integration_host, type: 'SELECT_PRODUCT' };

        expect(generatedAction).toEqual(expectedActionObject);
      });
    });

    describe('updateAgreement', () => {
      it('should create a updateAgreement action that takes a payload', () => {
        const payload = {
          agreement: { source: 'UAS', isSigned: false },
          product: AgreementType.venga_integration_host,
        };
        const generatedAction = actions.updateAgreement(payload);
        const expectedActionObject = { payload, type: 'UPDATE_AGREEMENT' };

        expect(generatedAction).toEqual(expectedActionObject);
      });
    });
  });

  describe('selectors', () => {
    it('isActiveProduct should be true only when there is an active product in the list', () => {
      expect(selectors.isActiveProduct(state(initialStateFixture))).toEqual(false);
      expect(selectors.isActiveProduct(state(productsLoadingAllFixture))).toEqual(false);
      expect(selectors.isActiveProduct(state(availablePricesFixture))).toEqual(false);
      expect(selectors.isActiveProduct(state(availablePricesAndUnsignedUAFixture))).toEqual(false);

      expect(selectors.isActiveProduct(state(activePricesAndSignedUAFixture))).toEqual(true);
      expect(selectors.isActiveProduct(state(activePricesAndUnsignedUAFixture))).toEqual(true);
    });

    it('isUASigned should be true only when there is a signed UA', () => {
      expect(selectors.isUASigned(state(initialStateFixture))).toEqual(false);
      expect(selectors.isUASigned(state(productsLoadingAllFixture))).toEqual(false);
      expect(selectors.isUASigned(state(productsLoadingUAFixture))).toEqual(false);
      expect(selectors.isUASigned(state(availablePricesAndUnsignedUAFixture))).toEqual(false);
      expect(selectors.isUASigned(state(activePricesAndUnsignedUAFixture))).toEqual(false);

      expect(selectors.isUASigned(state(pendingPricesAndSignedUAFixture))).toEqual(true);
      expect(selectors.isUASigned(state(activePricesAndSignedUAFixture))).toEqual(true);
    });

    /*it('legalEntity', () => {

    });

    it('productsBasePrices', () => {

    });

    it('productsErrors', () => {

    });

    it('productsLoading', () => {

    });

    it('productsPriceBundles', () => {

    });

    it('productsValidPrices', () => {

    });
    */

    it('selectedProductOneTimePrice', () => {
      expect(selectors.selectedProductOneTimePrice(state(availablePricesHostSelectedFixture)))
        .toEqual(defaultPricingMock[1]);

      expect(selectors.selectedProductOneTimePrice(state(availablePricesReviewManagerSelectedFixture)))
        .toEqual(reviewManagerPricingMock[1]);
    });

    /*
    it('selectedProductPriceBundle', () => {

    });
    */

    it('selectedProductSubscriptionPrice', () => {
      expect(selectors.selectedProductSubscriptionPrice(state(availablePricesHostSelectedFixture)))
        .toEqual(defaultPricingMock[0]);

      expect(selectors.selectedProductSubscriptionPrice(state(availablePricesReviewManagerSelectedFixture)))
        .toEqual(reviewManagerPricingMock[0]);
    });

    it('should return undefined when pricing fetch fails', () => {
      expect(selectors.selectedProductOneTimePrice(state(availablePricesFailedReviewManagerSelectedFixture)))
        .toBeUndefined();

      expect(selectors.selectedProductSubscriptionPrice(state(availablePricesFailedReviewManagerSelectedFixture)))
        .toBeUndefined();

      expect(selectors.selectedProductOneTimePrice(state(availablePricesFailedHostSelectedFixture)))
        .toBeUndefined();

      expect(selectors.selectedProductSubscriptionPrice(state(availablePricesFailedHostSelectedFixture)))
        .toBeUndefined();
    })


    /*
    it('signedUAEmail', () => {

    });*/

  });

  describe('reducers', () => {
    describe('selectedProduct', () => {
      it('should set selectedProduct', () => {
        const action = actions.selectProduct(AgreementType.venga_integration_host);
        const finalState = selectedProductReducer(initialSelectedProduct, action);

        expect(finalState).toEqual(AgreementType.venga_integration_host);
      });
    });
  });
});
