import { Icon } from '@buffet/icon';
import { BaseAgreementDTO, FooterUserAgreement } from '@buffet/user-agreement';
import { Restaurant } from 'gca-react-components/src/redux-modules/currentContext';
import { LangLocale } from 'gca-react-components/src/redux-modules/languageProvider';
import React, { useCallback, useEffect } from 'react';
import { FormattedMessage } from 'react-intl';
import { connect } from 'react-redux';
import { Redirect, RouteComponentProps, withRouter } from 'react-router-dom';
import BackButton from 'shared-react-atomic-ui/BackButton';

import { AppRoutes } from '../common/App/AppRoutes';
import { getContextUrn } from '../helpers/appHelpers';
import { formatProductPrice } from '../helpers/pricing';
import { eventTracker, trackingCategory, trackingEvents } from '../helpers/tracking';
import { longAgreementType, validShortAgreementType } from '../helpers/typeHelpers';
import {
  actions as productsActions,
  selectors as productsSelectors,
  UpdateAgreementPayload,
} from '../store/redux-modules/products';
import { AgreementType, PricedAddOn, Pricing, ShortAgreementType, State } from '../store/types';

import './SignUpPage.scss';

interface SP {
  locale: LangLocale;
  legalEntity: string | undefined;
  restaurant: Restaurant;
  selectedProduct: AgreementType | null;
  selectedProductSubscriptionPrice: Pricing | undefined;
  selectedProductOneTimePrice: Pricing | undefined;
  selectedProductPriceBundle: PricedAddOn | undefined;
}

interface DP {
  selectProduct: (payload: AgreementType) => void;
  updateAgreement: (payload: UpdateAgreementPayload) => void;
}

interface PageRouteParams {
  product_name?: ShortAgreementType;
}

type Props = SP & DP & RouteComponentProps<PageRouteParams>;

const SignUpPageView = ({
  locale,
  legalEntity,
  selectedProduct,
  selectedProductPriceBundle,
  selectedProductSubscriptionPrice,
  selectedProductOneTimePrice,
  selectProduct,
  updateAgreement,
  restaurant,
  history,
  match: { params },
}: Props) => {
  /* Callback handlers */
  const handleBackClick = useCallback(() => {
    eventTracker.sendEvent({
      action: trackingEvents.signUpPage.action,
      category: trackingCategory,
      label: trackingEvents.signUpPage.labels.back,
    });

    history.goBack();
  }, []);

  const handleAgreeSuccess = useCallback((agreement: BaseAgreementDTO) => {
    if (selectedProduct) {
      eventTracker.sendEvent({
        action: trackingEvents.signUpPage.action,
        category: trackingCategory,
        label: trackingEvents.signUpPage.labels.signComplete,
      });

      updateAgreement({ product: selectedProduct, agreement });
      history.goBack();
    }
  }, [selectedProduct, updateAgreement]);

  const handleUAComponentInitialized = useCallback((agreement: BaseAgreementDTO) => {
    if (selectedProduct) {
      updateAgreement({ product: selectedProduct, agreement });
    }
  }, [selectedProduct, updateAgreement]);

  const handleAgreementIntent = useCallback((isChecked) => {
    eventTracker.sendEvent({
      action: trackingEvents.signUpPage.action,
      category: trackingCategory,
      label: isChecked
        ? trackingEvents.signUpPage.labels.checkboxChecked
        : trackingEvents.signUpPage.labels.checkboxUnchecked,
    });
  }, []);

  const handleViewAgreement = useCallback(() => {
    eventTracker.sendEvent({
      action: trackingEvents.signUpPage.action,
      category: trackingCategory,
      label: trackingEvents.signUpPage.labels.showTerms,
    });
  }, []);

  const handleHideAgreement = useCallback(() => {
    eventTracker.sendEvent({
      action: trackingEvents.signUpPage.action,
      category: trackingCategory,
      label: trackingEvents.signUpPage.labels.hideTerms,
    });
  }, []);

  const handleAgreementConfirm = useCallback(() => {
    eventTracker.sendEvent({
      action: trackingEvents.signUpPage.action,
      category: trackingCategory,
      label: trackingEvents.signUpPage.labels.sign,
    });
  }, []);

  // manage deep-linking into this page
  useEffect(() => {
    // 1. redirect to home when:
    // - params.product_name is not set
    // - params.product_name is set, but it's not valid
    // 2. set requested product when:
    // - params.product_name is set and valid, but selectedProduct is not set
    // - params.product_name is set and valid, but selectedProduct is different

    if (!params.product_name || !validShortAgreementType(params.product_name)) {
      history.push(AppRoutes.Root);
    } else if (longAgreementType(params.product_name) !== selectedProduct) {
      selectProduct(longAgreementType(params.product_name));
    }
  }, [selectedProduct, params.product_name, selectProduct]);

  // temporarily render null while selecting a valid agreement type
  if (!selectedProduct) {
    return null;
  }

  // if we do have a selected product, but no associated product bundle, redirect to home
  if (!selectedProductPriceBundle) {
    return <Redirect to={AppRoutes.Root} />;
  }

  return (
    <div className="venga-page signup-page">
      <div className="page-content">
        <h1 className="page-title">
          <FormattedMessage id="venga.signup.title" />
        </h1>
        <div className="pricing-section">
          <h2>
            <Icon iconId="amenities" className="section-icon" /><FormattedMessage id="venga.signup.restaurant" />
          </h2>
          <ul>
            <li>{restaurant.name}</li>
            <li><FormattedMessage id="venga.signup.legalEntity" /> {legalEntity ? legalEntity : ''}</li>
          </ul>
        </div>
        <div className="pricing-section">
          <h2>
            <Icon iconId="giftCard" className="section-icon" /><FormattedMessage id="venga.signup.package" />
          </h2>
          <h3>{selectedProductPriceBundle.bundleCategory} {selectedProductPriceBundle.bundleDisplayName}</h3>
          <ul>
            <li>
              <FormattedMessage
                id="venga.signup.recurring"
                values={{ price: formatProductPrice(selectedProductSubscriptionPrice, locale) }}
              />
            </li>
            <li>
              <FormattedMessage
                id="venga.signup.installation"
                values={{ price: formatProductPrice(selectedProductOneTimePrice, locale) }}
              />
            </li>
          </ul>
          <p className="footnote">
            <FormattedMessage id="venga.signup.footnote" />
          </p>
        </div>
        <div className="pricing-section">
          <h2>
            <Icon iconId="payment" className="section-icon" /><FormattedMessage id="venga.signup.billing" />
          </h2>
          <p>
            <FormattedMessage id="venga.signup.billingExplanation" />
          </p>
        </div>
      </div>
      <FooterUserAgreement
        agreementType={selectedProduct}
        context={getContextUrn(restaurant.rid)}
        contextName={restaurant.name}
        show={true}
        onAgreeSuccess={handleAgreeSuccess}
        onInitialized={handleUAComponentInitialized}
        pricing={selectedProductPriceBundle.bundleDetails}
        onAgreeIntent={handleAgreementIntent}
        onViewAgreement={handleViewAgreement}
        onHideAgreement={handleHideAgreement}
        onAgreeConfirm={handleAgreementConfirm}
        className="footer"
      >
        <BackButton onClick={handleBackClick}>
            <FormattedMessage id="venga.signup.back" />
        </BackButton>
      </FooterUserAgreement>
    </div>
  );
};

const mapState = (state: State): SP => ({
  legalEntity: productsSelectors.legalEntity(state),
  locale: state.language.locale,
  restaurant: state.currentContext.restaurant,
  selectedProduct: state.products.selectedProduct,
  selectedProductOneTimePrice: productsSelectors.selectedProductOneTimePrice(state),
  selectedProductPriceBundle: productsSelectors.selectedProductPriceBundle(state),
  selectedProductSubscriptionPrice: productsSelectors.selectedProductSubscriptionPrice(state),
});

const mapDispatch = {
  selectProduct: productsActions.selectProduct,
  updateAgreement: productsActions.updateAgreement,
};

const SignUpPage = connect<SP, DP, RouteComponentProps<{}>>(mapState, mapDispatch)(SignUpPageView);

export default withRouter(SignUpPage);
export { SignUpPageView as PureSignUpPage };
