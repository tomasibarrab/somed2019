const _ = require('lodash');
const chalk = require('chalk');
const fs = require('fs');
const git = require('./git');

const LOCK_FILE = './mono.lock';

function getEmptyLockData() {
  return {
    packages: {},
  };
}

function getLockData() {
  try {
    fs.accessSync(LOCK_FILE);
  } catch (e) {
    return getEmptyLockData();
  }

  const file = fs.readFileSync(LOCK_FILE, {
    encoding: 'utf8',
  });

  const lines = file.split('\n');
  const json = lines.slice(3).join('');

  return JSON.parse(json);
}

function sortMap(map) {
  const array = [];

  for (const name in map) {
    array.push({
      name,
      version: map[name],
    });
  }

  array.sort((a, b) => a.name > b.name);

  return array.reduce((sortedMap, pkg) => ({ ...sortedMap, [pkg.name]: pkg.version }), {});
}

function generateLockFile(lockData) {
  return `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# mono lockfile v1

${JSON.stringify(lockData, null, '  ')}`;
}

function isTeamCity() {
  const { TEAMCITY_VERSION } = process.env;
  return !_.isEmpty(TEAMCITY_VERSION);
}

async function writeLockData(packages) {
  if (!isTeamCity()) {
    return;
  }

  const currentpackages = getLockData().packages;
  const packageMap = packages.reduce((map, pkg) => ({ ...map, [pkg.name]: pkg.localVersion }), currentpackages);
  const newPackageData = sortMap(packageMap);
  const newLockData = {
    packages: newPackageData,
  };

  // if (git.getStagedFiles().length > 0) {
  //   console.log(chalk.red('\nThere are currently staged git changes. Aborting lock file write.\n'));
  //   process.exit(1);
  // }

  fs.writeFileSync(LOCK_FILE, generateLockFile(newLockData), {
    encoding: 'utf8',
  });

  console.log(`Git: Staging ${LOCK_FILE}`);
  git.stage({ path: LOCK_FILE });

  console.log('Git: committing');
  git.commit({ message: 'Publish' });

  console.log('Git: Pushing to origin:master');
  git.pushOriginMaster();
}

module.exports = {
  getLockData,
  writeLockData,
};
