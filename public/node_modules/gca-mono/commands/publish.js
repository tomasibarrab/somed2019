const packageInfo = require('../lib/get-publish-info');
const runInAll = require('../lib/run-in-all');
const lock = require('../lib/lock');
const {
  printPackages,
  printPackagesStatus,
  printPackagesUpload,
  printPackagesPromoteTesting,
  printPackagesPromoteProduction,
  printPackagesPhaseStatus
} = require('../lib/print');
const { getMonoPackageConfig } = require('../lib/config');
const { header } = require('gca-logging-helpers');
const chalk = require('chalk');

const commandName = 'Mono publish';

/**
 * Merge two app lists making sure there are no duplicates
 * it favors items in the second list.
 * @param {*} firstList
 * @param {*} secondList
 */
const mergeApps = (firstList, secondList) => {
  const filteredFirstList = filterOutApps(firstList, secondList);
  return [...filteredFirstList, ...secondList];
}

/**
 * produce a new list of app from the sourceList without
 * items found in the itemsToRemove list
 * @param {*} sourceList
 * @param {*} itemsToRemove
 */
const filterOutApps = (sourceList, itemsToRemove) => {
  if (!itemsToRemove || itemsToRemove.length === 0) {
    return [...sourceList];
  }
  return sourceList.filter(item =>
    itemsToRemove.find(itemToRemove =>
      itemToRemove.name === item.name) === undefined
  );
}

/**
 * Add items to a sourceList without creating duplicates
 */
const addToAppList = (sourceList, itemsToAdd) => {
  if (!itemsToAdd || itemsToAdd.length == 0) {
    return sourceList;
  }
  let newList = Array.from(sourceList);
  itemsToAdd.forEach(failedItem => {
    if (sourceList.find(sourceItem => sourceItem.name === failedItem.name) === undefined) {
      newList.push(failedItem)
    }
  });
  return newList;
}

async function runTasks(packages, tasks, isDryRun) {
  let failedApps = [];
  for (const task of tasks) {
    console.log(`##teamcity[blockOpened name='${task}']`);
    const failedInTask = await runInAll({ packages, command: task, isDryRun });
    failedApps = addToAppList(failedApps, failedInTask);
    console.log(`##teamcity[blockClosed name='${task}']`);
  }
  return failedApps;
}


async function execUploadHook(appsToUpload, { upload }, isDryRun) {
  console.log("##teamcity[blockOpened name='upload hook']");
  const failedUploadApps = await runTasks(appsToUpload, upload, isDryRun);
  console.log("##teamcity[blockClosed name='upload hook']");

  const succeedUploadApps = filterOutApps(appsToUpload, failedUploadApps);

  console.log("##teamcity[blockOpened name='lock-file']");
  if (!isDryRun) {
    lock.writeLockData(succeedUploadApps);
  }
  console.log("##teamcity[blockClosed name='lock-file']");

  printPackagesPhaseStatus('upload', 'uploadStatus', succeedUploadApps, failedUploadApps)

  return failedUploadApps;
}


async function execRegistryPromoteHook(appsToPromote, taskList, profileName, isDryRun) {

  console.log(`##teamcity[blockOpened name='promote ${profileName} hook']`);
  const failedPromoteApps = await runTasks(appsToPromote, taskList, isDryRun);
  console.log(`##teamcity[blockClosed name='promote ${profileName} hook']`);

  const succeedPromoteApps = filterOutApps(appsToPromote, failedPromoteApps);

  printPackagesPhaseStatus(`promote ${profileName}`, 'promoteStatus', succeedPromoteApps, failedPromoteApps);


  return failedPromoteApps;
}

const publishCommand = async function (argv) {
  // Use this flag to run a simpler pipeline without publishing
  const isDryRun = argv.dry || argv.dryRun || argv.prePublish;

  // Information on each application
  const allApps = await packageInfo();

  // All packages that have changed their version in package.json
  const pendingApps = await packageInfo({ pending: true });

  // All packages that have a versionProd in package.json
  const registryApps = await packageInfo({ isRegistryApp: true });
  // Apps that have been initialized in version API, but don't have a prod version defined yet

  // Define list of apps that should run each step
  let tryToTestApps = mergeApps(pendingApps, registryApps);
  let tryToUploadApps = await packageInfo({ shouldUpload: true });
  let tryToPromoteTestingApps = await packageInfo({ shouldPromoteTesting: true });
  let tryToPromoteProductionApps = await packageInfo({ shouldPromoteProduction: true });

  // Configurable arrays of command names to run during each step of the publish flow
  const monoConfig = getMonoPackageConfig();

  console.log(header('Starting Mono publish', { top: 1, bottom: 1 }));

  console.log(header(`${commandName}: Apps with a new package.json version will UPLOAD.`, { top: 1 }));
  printPackagesUpload(allApps);

  console.log(header(`${commandName}: Apps with a changed Testing or Production version will PROMOTE.`, { top: 1 }));
  printPackagesPromoteTesting(registryApps);
  printPackagesPromoteProduction(registryApps);
  console.log('\n');

  // ----------------------------
  // All Tests
  // ----------------------------

  console.log("##teamcity[blockOpened name='tests hook']");
  const failedTestingPackages = await runTasks(tryToTestApps, monoConfig.tests, isDryRun);
  console.log("##teamcity[blockClosed name='tests hook']");

  // Filter out all the apps that failed Testing phase from future phases
  tryToUploadApps = filterOutApps(tryToUploadApps, failedTestingPackages);
  tryToPromoteTestingApps = filterOutApps(tryToPromoteTestingApps, failedTestingPackages);
  tryToPromoteProductionApps = filterOutApps(tryToPromoteProductionApps, failedTestingPackages);

  if (failedTestingPackages.length > 0) {
    console.log(header(`${commandName}: These packages were pending but failed their test steps.`, { top: 1 }));
    printPackages(failedTestingPackages);
  }

  // -----------------------------------------------
  // Build & Upload
  // -----------------------------------------------
  let failedToUploadApps = [];
  if (tryToUploadApps.length <= 0) {
    console.log(chalk.green(`${commandName}: There are no packages that can be Built/Uploaded. Done.`));
  } else {
    if (isDryRun === true) {
      console.log(header(`${commandName}: (Dry Run) The following packages would be uploaded, but actual uploading is being suppressed.`, { top: 1 }));
      printPackagesStatus(tryToUploadApps, 'willUpload', true);
    }
    failedToUploadApps = await execUploadHook(tryToUploadApps, monoConfig, isDryRun);
  }

  // ------------------------------------------------
  // Promote Testing (Registry Only)
  // ------------------------------------------------
  let failedToPromoteTestingApps = [];
  tryToPromoteTestingApps = filterOutApps(tryToPromoteTestingApps, failedToUploadApps);
  if (tryToPromoteTestingApps.length <= 0) {
    console.log(chalk.green(`${commandName}:  No registry apps are eligible to PROMOTE to Testing. Done.`));
  } else {
    if (isDryRun === true) {
      console.log(header(`${commandName}: (Dry Run) The following registry app would be considered for deployment to TESTING, but actual deploy is being suppressed.`, { top: 1 }));
      printPackagesStatus(tryToPromoteTestingApps, 'willPromoteTesting', true);
    }
    failedToPromoteTestingApps = await execRegistryPromoteHook(tryToPromoteTestingApps, monoConfig.registryPromoteTesting, 'testing', isDryRun);
  }

  // ------------------------------------------------
  // Promote Production (Registry Only)
  // ------------------------------------------------
  let failedToPromoteProductionApps = [];
  tryToPromoteProductionApps = filterOutApps(tryToPromoteProductionApps, failedToUploadApps);
  tryToPromoteProductionApps = filterOutApps(tryToPromoteProductionApps, failedToPromoteTestingApps);
  if (tryToPromoteProductionApps.length <= 0) {
    console.log(chalk.green(`${commandName}: No registry apps are eligible to PROMOTE to Production`));
  } else {
    if (isDryRun === true) {
      console.log(header(`${commandName}: (Dry Run) The following registry app would be considered for deployment to PRODUCTION, but actual deploy is being suppressed.`, { top: 1 }));
      printPackagesStatus(tryToPromoteProductionApps, 'willPromoteProduction', true);
    }
    failedToPromoteProductionApps = await execRegistryPromoteHook(tryToPromoteProductionApps, monoConfig.registryPromoteProduction, 'production', isDryRun);
  }

  // Fails if any Promote fails
  if (failedToPromoteTestingApps.length > 0 || failedToPromoteProductionApps.length > 0) {
    process.exit(1);
  }
}

module.exports = {
  command: 'publish',
  describe: '',
  builder(yargs) {
    return yargs.positional('command', {
      describe: 'Yarn command to run',
      type: 'string',
    });
  },
  handler: publishCommand,
};



