import range from 'lodash.range';

/**
 * colourSet()
 * Returns an array of colour hex strings
 * @param hex - Hexadecimal string e.g. '#0000FF' or '0000FF'
 * @param variance - Incremental luminance in percentage, lighter (positive) or darker (negative) e.g. 0.1, -0.25
 * @param set - Number of sets to return in array
 */
const colourSet = (hex: string, variance: number = 0.1, set: number = 5): string[] => {
  if (!hex) {
    throw new Error('hexadecimal is not defined');
  }

  // tslint:disable-next-line
  let _variance = 0;

  return range(set).reduce((prev: string[]) => {
    const colour = colourShade(hex, _variance);
    _variance += variance;
    return [...prev, colour];
  }, []);
};

/**
 * colourShade()
 * Returns a colour hex string with defined luminance (in percentage)
 * @param hex - Hexadecimal string e.g. '#0000FF' or '0000FF'
 * @param lum - Luminance in percentage, lighter (positive) or darker (negative) e.g. 0.1, -0.25
 */
const colourShade = (hex: string, lum: number = 0) => {
  const luminance = lum;
  const set = 3;
  let hexadecimal = String(hex).replace(/[^0-9a-f]/gi, '');

  if (hexadecimal.length < 6) {
    hexadecimal = hexadecimal[0] + hexadecimal[0] + hexadecimal[1] + hexadecimal[1] + hexadecimal[2] + hexadecimal[2];
  }

  const rgb = range(set)
    .reduce((prev: string, curr: number): string => {
      const c = parseInt(hexadecimal.substr(curr * 2, 2), 16);
      const roundedC = Math.round(Math.min(Math.max(0, c + (c * luminance)), 255)).toString(16);
      const partial = (`00${roundedC}`).substr(roundedC.length);

      return `${prev}${partial}`;
    }, '');

  return `#${rgb.toUpperCase()}`;
};

/**
 * hexToRgb()
 * Converts Hexadecimal string to RGB object
 * @param hex - Hexadecimal string. Accepts shorthand
 */
const hexToRgb = (hex: string) => {
  if (!hex) {
    throw new Error('Invalid hex');
  }

  const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;

  // tslint:disable
  // @ts-ignore
  const _hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
  // tslint:enable
  const rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(_hex);

  if (rgb) {
    // Allow non-alphabetical sorting of rgb.
    // tslint:disable
    return {
      r: parseInt(rgb[1], 16),
      g: parseInt(rgb[2], 16),
      b: parseInt(rgb[3], 16),
    };
    // tslint:enable
  }
  return null;
};

/**
 * rgbToHex()
 * Converts RGB(A) to Hexadecimal string
 * @param rgba - RGB or RGBA string. Ignores alpha. e.g. rgba(10, 12, 13, 1)
 */
const rgbToHex = (rgba: string) => {
  if (!rgba) {
    throw new Error('Invalid RGB(A)');
  }

  const rgb = rgba.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
  if (rgb && rgb.length === 4) {
    const str = (`0${parseInt(rgb[1], 10).toString(16)}`).slice(-2) +
    (`0${parseInt(rgb[2], 10).toString(16)}`).slice(-2) +
    (`0${parseInt(rgb[3], 10).toString(16)}`).slice(-2);
    return `#${str.toUpperCase()}`;
  }

  return null;
};

export {
  colourSet,
  colourShade,
  hexToRgb,
  rgbToHex,
};
