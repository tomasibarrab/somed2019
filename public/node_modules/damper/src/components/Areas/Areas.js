import React from 'react';
import PropTypes from 'prop-types';
import deepMerge from 'lodash.merge';
import { Group } from '../index';
import { Area } from '../Area';
import {
  AreaPointsHelper,
  HighlightHelper,
  VerticalLocationHelper,
} from '../Helpers/';

import {
  assignPartialTheme,
  getAreas,
  getAnimationMode,
  generateId,
} from '../../utils/';

import { AnimateSlideOffset, ISlideProps } from '../SlideController';

class Areas extends React.Component {
  static propTypes = {
    animation: PropTypes.string.isRequired,
    actions: PropTypes.shape({
      onMouseOver: PropTypes.func,
      onMouseOut: PropTypes.func,
      onClick: PropTypes.func,
    }),
    activeInnerArea: PropTypes.object.isRequired,
    columns: PropTypes.array.isRequired,
    data: PropTypes.array,
    theme: PropTypes.object.isRequired,
    helper: PropTypes.object.isRequired,
  }

  static defaultProps = {
    actions: {
      onMouseOver: () => {},
      onMouseOut: () => {},
      onClick: () => {},
    },
    data: null,
  }

  constructor(props) {
    super(props);

    this.state = {
      activeInfo: null,
      mouseState: {
        id: null,
        flag: null, // isOver === true
      },
    };

    this.onMouseClickEvent = this.onMouseClickEvent.bind(this);
    this.onMouseOverEvent = this.onMouseOverEvent.bind(this);
    this.onMouseOutEvent = this.onMouseOutEvent.bind(this);

    this.getPathProps = this.getPathProps.bind(this);
    this.updateMouseEvents = this.updateMouseEvents.bind(this);
    this.renderArea = this.renderArea.bind(this);
    this.getLocationInfo = this.getLocationInfo.bind(this);
    this.getAnimationState = this.getAnimationState.bind(this);
  }

  onMouseClickEvent(getLocationInfo) {
    return ({ id, x, y }) => {
      const activeInfo = getLocationInfo({ x, y, id });

      this.props.actions.onClick(activeInfo);

      this.setState((prevState) => ({
        ...prevState,
        activeInfo: undefined,
      }));
    };
  }

  onMouseOverEvent(getLocationInfo) {
    return ({
      id,
      flag,
      x,
      y,
    }) => {
      const activeInfo = getLocationInfo({ x, y, id });

      this.props.actions.onMouseOver(activeInfo);

      this.setState((prevState) => ({
        ...prevState,
        activeInfo,
        mouseState: {
          id,
          flag,
        },
      }));
    };
  }

  onMouseOutEvent(getLocationInfo) {
    return ({
      id,
      flag,
      x,
      y,
    }) => {
      const activeInfo = getLocationInfo({ x, y, id });

      this.props.actions.onMouseOut(activeInfo);

      this.setState((prevState) => ({
        ...prevState,
        activeInfo: undefined,
        mouseState: {
          id,
          flag,
        },
      }));
    };
  }

  getLocationInfo(animData) {
    return ({ x, y, id }) => {
      const { scales } = this.props.activeInnerArea;
      const { columns, theme } = this.props;
      const { area } = theme;
      const location = {
        x: Math.round(x),
        y: Math.round(y),
      };

      if (area.snap.some((v) => v !== 'auto' && Number.isNaN(parseFloat(v)))) {
        throw new Error('Only numbers or "auto" values are accepted');
      }

      // Find parent and area info
      const areaParent = animData.find((v) => v.data.some((currArea) => currArea.id === id));
      const areaPoint = (areaParent) ? areaParent.data.find((v) => v.id === id) : undefined;

      // Get the range using D3 x scale
      const range = columns.map((v, index) => {
        const xLoc = scales.x(index);
        const xLocMin = scales.x(index);
        const xLocMax = scales.x(index + 1);
        const portion = (xLocMax - xLocMin) / 2;
        // If auto, snap is 50%
        const min = (area.snap[0] === 'auto') ? xLocMin - portion : xLoc - area.snap[0];
        const max = (area.snap[1] === 'auto') ? xLocMax - portion : xLocMin + area.snap[1];
        return {
          id: v.id,
          x: xLoc,
          min,
          max,
        };
      });

      // Find out if x matches the range
      // If range has only one datapoint, just return the only range
      const column = (range.length === 1) ? range[0] : range.find((v) => x > v.min && x < v.max);

      // Get y based on the x location found
      const colY = (areaParent && column) ? areaPoint.data.find((v) => v.key === column.id) : undefined;
      const colYIndex = (areaParent && column) ? areaPoint.data.findIndex((v) => v.key === column.id) : undefined;

      // Find out percentage along cols
      let percentageAlongColumns = null;
      if (colYIndex) {
        percentageAlongColumns = colYIndex / areaPoint.data.length;
      }

      const getColYVal = () => {
        if (colY.style) {
          return typeof (colY.style.y0) === 'object' ? colY.style.y0.val : colY.style.y0;
        }
        return null;
      };

      return {
        data: {
          id: areaPoint.id,
          parentId: areaParent.id,
        },
        id: (column) ? column.id : null,
        location: {
          ...location,
          colX: (column) ? column.x : null, // Return snap x
          colY: (colY) ? getColYVal() : null, // Return snap y
          percentageAlongColumns,
        },
      };
    };
  }

  getPathProps(
    activeInnerArea,
    animation,
    columns,
    data,
    theme,
  ) {
    const graphType = 'area';
    const { x, yInverted } = activeInnerArea.scales;

    if (!data) {
      return [];
    }

    // Render empty data sets
    // If receives empty data, animate previous data to 0 (in this case, max height as we need to animate down not up)
    // if (data.length <= 0) {
    //   return this.constructEmptyPathProps();
    // }

    // Render with available data set
    if (data.length && columns.length) {
      const animData = data.map((graph) => {
        const getYValue = (sets, key, limiter) => {
          const keys = Object.keys(sets);
          return keys.reduce((prev, curr, index) => {
            const total = prev;
            if (index < limiter) {
              return total + sets[curr];
            }
            return total;
          }, 0);
        };

        const groupData = getAreas({ data: graph.data, columns, id: graph.id });

        const graphData = graph.data.map((v, i) => {
          const styles = assignPartialTheme({ theme, keys: [graphType], customTheme: v.styles });
          const sets = groupData.data.map((set, index) => {

            // The value of this point
            const setValue = set.data[v.id];

            // The value of this point + previous point, this creates the stack
            const combinedValue = setValue + getYValue(set.data, v, i);

            const y0 = yInverted(combinedValue);
            const y1 = yInverted(getYValue(set.data, v, i));

            return ({
              key: set.id,
              style: {
                x: x(index),
                y0,
                y1: animation.animate ? y1 : y1, // @TODO Animation toggle
                val: setValue > 0 ? combinedValue : 0,
              },
            });
          });

          return {
            id: v.id,
            styles,
            isMouseOver: false,
            isInteractive: false,
            data: sets,
          };
        });

        return {
          id: graph.id,
          group: graph.group,
          data: graphData,
        };
      });

      return animData;
    }

    return [];
  }

  getAnimationState(animationSetting) {
    // @TODO: onchange is currently set as true. We need to allow animation when onchange and not oninit
    const isAnimated = (typeof getAnimationMode(animationSetting) === 'boolean') ? getAnimationMode(animationSetting) : false;

    return {
      mode: animationSetting,
      animate: isAnimated,
    };
  }

  getHelperTheme({ theme, helper }) {
    const helperTheme = assignPartialTheme({ theme, keys: ['helpers'] });

    const customStyles = Object.keys(helper).reduce((prev, curr) => ({
      ...prev,
      [curr]: helper[curr].styles || {},
    }), {});

    helperTheme.helpers.area = deepMerge({}, helperTheme.helpers.area, customStyles);

    return helperTheme;
  }

  // Checks for mouseover events for every area. Mouseover events should reflect if it has multiple areas as a group or not
  // If it is a grouped (e.g. stacked graph), mouse events on one of the areas should update the others as well.
  updateMouseEvents(animationData, id, flag) {
    if (animationData && animationData.length && id) {
      const parent = animationData.find((i) => i.data.some((v) => v.id === id));
      const parentId = parent ? parent.id : null;

      const animData = animationData.map((parent) => {
        const _parent = parent;
        if (_parent.id === parentId) {
          return {
            ..._parent,
            data: _parent.data.map((child) => {
              const _child = child;
              if (_parent.group) {
                _child.isMouseOver = flag;
              } else if (_child.id === id) {
                _child.isMouseOver = flag;
              }
              return {
                ..._child,
              };
            }),
          };
        }
        return {
          ..._parent,
        };
      });

      return animData;
    }

    return animationData;
  }

  constructEmptyPathProps() {
    //   const animData = this.state.animData.map((graph) => ({
    //     ...graph,
    //     data: graph.data.map((set) => { // eslint-disable-line
    //       return {
    //         ...set,
    //         isInteractive: true, // mark to true to tell this graph is empty
    //         data: set.data.map((point) => {
    //           const y = yInverted(activeInnerArea.height);
    //           return {
    //             ...point,
    //             style: {
    //               ...point.style,
    //               y0: y,
    //               y1: y,
    //             },
    //           };
    //         }),
    //       };
    //     }),
    //   }));

    //   return animData;
  }

  renderArea({
    animation,
    areaData,
    getLocationInfo,
    helperTheme,
    index,
  }) {
    const { activeInnerArea } = this.props;

    if (!areaData) {
      return null;
    }

    // Pass mouse events only if there is data
    const actions = areaData.isInteractive
      ? {}
      : {
        onMouseClickEvent: this.onMouseClickEvent(getLocationInfo),
        onMouseOverEvent: this.onMouseOverEvent(getLocationInfo),
        onMouseOutEvent: this.onMouseOutEvent(getLocationInfo),
      };

    let theme = areaData.styles;

    // Parse helper theme into Area
    if (Object.keys(helperTheme).length > 0) {
      theme = {
        ...helperTheme,
        ...areaData.styles,
      };
    }

    return (
      <Area
        activeInnerArea={activeInnerArea}
        animation={animation}
        id={areaData.id}
        index={index}
        key={`area-${areaData.id}`}
        data={areaData.data}
        theme={theme}
        isMouseOver={areaData.isMouseOver}
        isInteractive={areaData.isInteractive}
        {...actions}
      />
    );
  }

  render() {
    const {
      activeInnerArea,
      columns,
      data,
      helper,
      slideProps,
      theme,
    } = this.props;

    const helperTheme = this.getHelperTheme(this.props);
    const animation = this.getAnimationState(this.props.animation);

    let animData = this.getPathProps(
      activeInnerArea,
      animation,
      columns,
      data,
      theme,
    );

    const getLocationInfoFunc = this.getLocationInfo(animData);

    animData = this.updateMouseEvents(animData, this.state.mouseState.id, this.state.mouseState.flag);

    if (!animData.length) {
      return null;
    }

    let xOffset = 0;
    let clipPathProps;

    if (slideProps && !slideProps.isDisabled) {
      xOffset = slideProps.offset;
      clipPathProps = {
        clipPath: 'url(#mask)',
      };
    }

    const animateSlideOffsetProps = {
      pose: 'pose',
      poseKey: xOffset,
      xOffset,
    }

    return (
      <g {...clipPathProps}>
        <AnimateSlideOffset {...animateSlideOffsetProps}>
          <Group id={`areas${generateId()}`}>
            <HighlightHelper
              activeInnerArea={activeInnerArea}
              animation={animation}
              columns={columns}
              helper={helper.highlight}
              helperTheme={helperTheme}
            />
            {animData.map((area) => (
              <Group
                id={`${area.id}-${generateId()}`}
                key={`${area.id}`}
                transform={`translate(0 ${activeInnerArea.top})`}
              >
                { area.data.map((areaData, index) => this.renderArea({
                  animation,
                  areaData,
                  getLocationInfo: getLocationInfoFunc,
                  helperTheme,
                  index,
                })) }
                <AreaPointsHelper
                  area={area}
                  animation={animation}
                  helper={helper.points}
                  helperTheme={helperTheme}
                  key={`${area.id}`}
                />
              </Group>
            ))}
            <VerticalLocationHelper
              activeInfo={this.state.activeInfo}
              activeInnerArea={activeInnerArea}
              animation={animation}
              animData={animData}
              helper={helper.vertical}
              helperTheme={helperTheme}
            />
          </Group>
        </AnimateSlideOffset>
      </g>
    );
  }
}

export { Areas };
