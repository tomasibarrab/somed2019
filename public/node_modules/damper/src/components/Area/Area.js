import React from 'react';
import PropTypes from 'prop-types';
import { PoseGroup } from 'react-pose';
import { Group, Circle, AnimatedCircle, Path, AnimatedPath } from '../../components';
import { generatePathData } from '../../utils';

class Area extends React.Component {
  static propTypes = {
    animation: PropTypes.object.isRequired,
    activeInnerArea: PropTypes.object.isRequired,
    id: PropTypes.string.isRequired,
    index: PropTypes.number,
    data: PropTypes.array.isRequired,
    theme: PropTypes.object.isRequired,
    isInteractive: PropTypes.bool,
    isMouseOver: PropTypes.bool,
    onMouseClickEvent: PropTypes.func,
    onMouseOverEvent: PropTypes.func,
    onMouseOutEvent: PropTypes.func,
  };

  static defaultProps = {
    index: 0,
    isMouseOver: false,
    isInteractive: false,
    onMouseClickEvent: () => {},
    onMouseOverEvent: () => {},
    onMouseOutEvent: () => {},
  }

  constructor(props) {
    super(props);

    this.getComponentTheme = this.getComponentTheme.bind(this);
    this.renderArea = this.renderArea.bind(this);
    this.getMouseLocation = this.getMouseLocation.bind(this);
    this.getMouseActions = this.getMouseActions.bind(this);
    this.generateAreaGraph = this.generateAreaGraph.bind(this);
    this.generateLineGraph = this.generateLineGraph.bind(this);
  }

  getComponentTheme() {
    const { theme, isMouseOver } = this.props;

    return {
      cursor: theme.area.cursor,
      fill: isMouseOver ? theme.common.mouseOver.fill : theme.common.fill,
      fillOpacity: isMouseOver ? theme.common.mouseOver.fillOpacity : theme.common.fillOpacity,
      strokeWidth: theme.common.strokeWidth,
      strokeOpacity: isMouseOver ? theme.common.mouseOver.strokeOpacity : theme.common.strokeOpacity,
      strokeDasharray: theme.common.strokeDasharray,
      stroke: isMouseOver ? theme.common.mouseOver.stroke : theme.common.stroke,
      radius: theme.area.single.radius,
      eventFill: theme.area.path.eventFill,
      eventFillOpacity: theme.area.path.eventFillOpacity,
      eventStroke: theme.area.path.eventStroke,
      eventStrokeOpacity: theme.area.path.eventOpacity,
      eventStrokeWidth: theme.area.path.eventStrokeWidth,
    };
  }

  setMouseEvent(id, flag) {
    const events = this.state.events.map((v) => {
      const item = v;
      if (item.id === id) {
        item.isMouseOver = flag;
        return item;
      }
      return item;
    });
    this.setState({
      events,
    });
  }

  getMouseLocation(e) {
    const findAncestor = (el, sel) => {
      while ((el = el.parentElement) && !((el.matches || el.matchesSelector).call(el,sel))); // eslint-disable-line
      return el;
    };

    const parentSVG = findAncestor(e.target, 'svg');
    const x = e.clientX - parentSVG.getBoundingClientRect().left;
    const y = e.clientY - parentSVG.getBoundingClientRect().top;
    return { x, y };
  }

  getMouseActions() {
    const { id } = this.props;
    return {
      onClick: (e) => {
        const mouseLoc = this.getMouseLocation(e);
        this.props.onMouseClickEvent({
          id,
          ...mouseLoc,
        });
      },
      onMouseOver: (e) => {
        const mouseLoc = this.getMouseLocation(e);
        this.props.onMouseOverEvent({
          id,
          flag: true,
          ...mouseLoc,
        });
      },
      onMouseMove: (e) => {
        const mouseLoc = this.getMouseLocation(e);
        this.props.onMouseOverEvent({
          id,
          flag: true,
          ...mouseLoc,
        });
      },
      onMouseOut: (e) => {
        const mouseLoc = this.getMouseLocation(e);
        this.props.onMouseOutEvent({
          id,
          flag: false,
          ...mouseLoc,
        });
      },
    };
  }

  updateMouseEvents({ data }) {
    const events = data.map((v) => ({
      id: v.id,
      isMouseOver: false,
    }));
    this.setState({
      events,
    });
  }

  // Graph for a single point data
  generateCircle(dataPoint, actions, style) {
    const { animation, theme } = this.props;

    const setData = dataPoint;
    const props = {
      cx: setData.style.x,
      cy: setData.style.y0,
      r: style.radius,
      style: {
        fill: style.fill,
        fillOpacity: style.fillOpacity,
        strokeWidth: style.strokeWidth,
        strokeOpacity: style.strokeOpacity,
        strokeDasharray: style.strokeDasharray,
        stroke: style.stroke,
      },
      ...actions,
    };

    if (animation.animate) {
      const animatedProps = {
        ...props,
        key: 1,
        poseKey: props,
        dotsVal: {
          ...props,
          index: 1,
          theme: theme.area.single,
        },
      };
      return (
        <PoseGroup animateOnMount>
          <AnimatedCircle {...animatedProps} />
        </PoseGroup>
      );
    }

    return (<Circle {...props} />);
  }

  generateAreaGraph(dataPointStyle, actions, style) {
    const {
      animation,
      theme,
      index,
      id,
    } = this.props;
    const pathData = generatePathData(dataPointStyle, theme);

    const props = {
      ...actions,
      key: id,
      id,
      d: pathData,
      style,
    };

    if (animation.animate) {
      const animatedProps = {
        ...props,
        pose: 'pose',
        poseKey: dataPointStyle,
        posePathVal: {
          data: dataPointStyle,
          index,
          theme,
        },
      };

      return (
        <PoseGroup animateOnMount>
          <AnimatedPath {...animatedProps} />
        </PoseGroup>
      );
    }
    return <Path {...props} />;
  }

  generateLineGraph(dataPointStyle, actions, style) {
    const {
      animation,
      theme,
      index,
      id,
    } = this.props;
    const pathData = generatePathData(dataPointStyle, theme);
    const hiddenStyle = {
      fill: style.eventFill,
      fillOpacity: style.eventFillOpacity,
      stroke: style.eventStroke,
      strokeOpacity: style.eventStrokeOpacity,
      strokeWidth: style.eventStrokeWidth,
    };
    const labelPathHidden = `path_hidden_${id}`;
    const labelPathVisual = `path_visual_${id}`;
    const labelPathGroup = `path_group_${id}`;
    const props = {
      d: pathData,
    };


    if (animation.animate) {
      const animatedProps = {
        ...props,
        pose: 'pose',
        poseKey: dataPointStyle,
        posePathVal: {
          data: dataPointStyle,
          index,
          theme,
        },
      };
      return (
        <Group key={labelPathGroup}>
          <PoseGroup animateOnMount>
            <AnimatedPath
              key={labelPathHidden}
              id={labelPathHidden}
              style={hiddenStyle}
              {...actions}
              {...animatedProps}
            />
            <AnimatedPath
              key={labelPathVisual}
              id={labelPathVisual}
              style={{
                ...style,
                pointerEvents: 'none',
              }}
              {...animatedProps}
            />
          </PoseGroup>
        </Group>
      );
    }

    return (
      <Group key={labelPathGroup}>
        <Path
          id={labelPathHidden}
          style={hiddenStyle}
          {...actions}
          {...props}
        />
        <Path
          id={labelPathVisual}
          style={{
            ...style,
            pointerEvents: 'none',
          }}
          {...props}
        />
      </Group>
    );
  }

  renderArea(dataPointStyle) {
    const { theme } = this.props;
    const hasData = dataPointStyle.some((d) => d.style.val > 0);

    if (!hasData) {
      return null;
    }

    const actions = this.getMouseActions();
    const style = this.getComponentTheme();

    // If there is only one data point, do not render path and use circle instead
    if (dataPointStyle.length === 1) {
      return this.generateCircle(dataPointStyle[0], actions, style);
    }

    /*
      If area is a line graph, an extra invisible path is added to
      allow extra space for mouse events
    */
    const isArea = (typeof theme.common.fill !== 'undefined' && theme.common.fill !== 'transparent');

    if (!isArea) {
      return this.generateLineGraph(dataPointStyle, actions, style);
    }

    return this.generateAreaGraph(dataPointStyle, actions, style);
  }

  render() {
    const { id, data } = this.props;

    return (
      <Group id={`areagroup-${id}`}>
        { this.renderArea(data) }
      </Group>
    );
  }
}

export { Area };
