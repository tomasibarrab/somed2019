import React from 'react';
import PropTypes from 'prop-types';
import deepMerge from 'lodash.merge';
import isObject from 'lodash.isobject';
import { PoseGroup } from 'react-pose';
import { Circle, AnimatedCircle, Group } from '../../index';

class AreaPointsHelper extends React.Component {
  static propTypes = {
    animation: PropTypes.object.isRequired,
    area: PropTypes.object.isRequired,
    helper: PropTypes.object.isRequired,
    helperTheme: PropTypes.object.isRequired,
  }

  static defaultProps = {
  }

  renderHelper() {
    if (!this.props.area) {
      return null;
    }
    const { helper, helperTheme, animation, area } = this.props;
    const areaPathPoints = area.data.map((set) => {
      const areaId = set.id;
      return set.data.map((point, index) => {
        // Allow callback for dots helper to support custom styling or show/hide dots
        /*
          Points helper callback
          @param {string} areaId - parent ID of a point
          @param {string} id - ID of a point
          @returns {(boolean|Object)} Returns a true or false or an Object.
          true - renders all points
          false - hides all points
          Object - custom styling of a point or points
        */
        let dotsStylesOverWrite = deepMerge({}, helperTheme, set.styles);

        if (typeof helper.callback === 'function') {
          const helperStylesOverwrite = helper.callback(areaId, point.key);
          if (isObject(helperStylesOverwrite) || typeof helperStylesOverwrite === 'boolean') {
            if (typeof helperStylesOverwrite === 'boolean') {
              if (!helperStylesOverwrite) {
                return null;
              }
            } else if (isObject(helperStylesOverwrite)) {
              const callbackStyle = deepMerge({}, dotsStylesOverWrite.helpers.area.points, helperStylesOverwrite);

              dotsStylesOverWrite = {
                ...dotsStylesOverWrite,
                helpers: {
                  area: {
                    ...dotsStylesOverWrite.helpers,
                    points: callbackStyle,
                  },
                },
              };
            }
          } else {
            throw new Error('Returned value needs to be a valid object or a boolean');
          }
        }

        const dotProps = {
          cx: point.style.x,
          cy: point.style.y0,
          r: dotsStylesOverWrite.helpers.area.points.radius,
          opacity: dotsStylesOverWrite.helpers.area.points.opacity,
          style: dotsStylesOverWrite.helpers.area.points,
        };

        const animatedDotProps = {
          ...dotProps,
          key: index,
          poseKey: dotProps,
          dotsVal: {
            ...dotProps,
            index,
          },
        }

        if (animation.animate) {
          return <AnimatedCircle {...animatedDotProps}  />
        }

        return <Circle {...dotProps} />
      });
    });

    if (animation.animate) {
      return (
        <PoseGroup animateOnMount>
          { areaPathPoints }
        </PoseGroup>
      );
    }

    return (
      <Group>
        { areaPathPoints }
      </Group>
    );
  }

  render() {
    const { helper, area } = this.props;
    if (!helper.show) {
      return null;
    }

    return (
      <Group id={`areapoints-${area.id}`}>
        { this.renderHelper() }
      </Group>
    );
  }
}

export { AreaPointsHelper };
