import React from 'react';
import PropTypes from 'prop-types';
import isObject from 'lodash.isobject';
import deepMerge from 'lodash.merge';
import flattenDeep from 'lodash.flattendeep';
import {
  generateId,
} from '../../../utils/';
import { Group } from '../../index';

class VerticalLocationHelper extends React.Component {
  static propTypes = {
    activeInfo: PropTypes.object,
    activeInnerArea: PropTypes.object.isRequired,
    animation: PropTypes.object.isRequired,
    animData: PropTypes.array.isRequired,
    helper: PropTypes.object.isRequired,
    helperTheme: PropTypes.object.isRequired,
  }

  static defaultProps = {
    activeInfo: undefined,
  }

  renderHelper() {
    if (
      typeof (this.props.activeInfo) === 'undefined' ||
      this.props.activeInfo === null ||
      typeof (this.props.activeInfo.data) === 'undefined'
    ) {
      return null;
    }

    const { height } = this.props.activeInnerArea;
    const {
      activeInfo,
      animation,
      animData,
      helperTheme,
      helper,
    } = this.props;

    const { data, id } = activeInfo;

    const getAreaData = () => {
      if (!helper.ignoreGroup) {
        return animData.map((v) => v.data);
      }
      const singleArea = animData.find((v) => data.parentId === v.id);
      return singleArea.data;
    };
    const parentArea = flattenDeep(getAreaData());

    // Default Line Props styling
    const lineProps = {
      x: 0,
      y: 0,
      height,
      width: helperTheme.helpers.area.vertical.line.width,
      fill: helperTheme.helpers.area.vertical.line.fill,
      opacity: helperTheme.helpers.area.vertical.line.opacity,
      style: {
        pointerEvents: 'none',
        mixBlendMode: 'multiply',
      },
    };

    const helperDots = parentArea
      .map((set) => {
        const points = set.data.find((point) => point.key === id);

        // Overwrites styling from helper
        const graphOverwrite = deepMerge({}, helperTheme, set.styles);

        // Allow callback for vertical helper to support custom styling
        /*
          Vertical helper callback
          @param {string} areaId - parent ID of a point
          @param {string} id - ID of a point
          @returns {(boolean|Object)} Returns a true or false or an Object.
          true - Not in use for now
          false - Not in use for now
          Object - custom styling of a point or points
        */
        let verticalStylesOverWrite = graphOverwrite;
        if (typeof helper.callback === 'function') {
          const helperStylesOverwrite = helper.callback(set.id, points.key);
          if (isObject(helperStylesOverwrite) || typeof helperStylesOverwrite === 'boolean') {
            if (typeof helperStylesOverwrite === 'boolean') {
              // Do nothing for now. Just return default styling unless we need to overwrite something using boolean
            } else if (isObject(helperStylesOverwrite)) {
              const callbackStyle = deepMerge({}, verticalStylesOverWrite.helpers.area.vertical, helperStylesOverwrite)
              verticalStylesOverWrite = {
                ...verticalStylesOverWrite,
                helpers: {
                  area: {
                    ...verticalStylesOverWrite.helpers,
                    vertical: callbackStyle,
                  },
                },
              };
            }
          } else {
            throw new Error('Returned value needs to be a valid object or a boolean');
          }
        }

        return {
          data: points,
          styles: verticalStylesOverWrite,
        };
      })
      .map((set) => {
        const { data: setData, styles } = set;

        if (!setData) {
          return null;
        }
        const dotProps = {
          cx: setData.style.x,
          cy: setData.style.y0,
          r: styles.helpers.area.vertical.dot.radius,
          opacity: styles.helpers.area.vertical.dot.opacity,
          style: {
            stroke: styles.helpers.area.vertical.dot.stroke,
            strokeWidth: styles.helpers.area.vertical.dot.strokeWidth,
            fill: styles.helpers.area.vertical.dot.fill,
            pointerEvents: 'none',
          },
        };

        // Overwrites for Line Props if there is a callback
        const lineWidth = lineProps.width > 1 ? lineProps.width / 2 : lineProps.width;
        lineProps.x = setData.style.x - lineWidth;
        lineProps.fill = styles.helpers.area.vertical.line.fill;
        lineProps.opacity = styles.helpers.area.vertical.line.opacity;

        return (
          <circle
            key={generateId()}
            {...dotProps}
          />
        );
      });

    const helperLine = (<rect {...lineProps} />);

    return (
      <React.Fragment>
        { helperLine }
        { helperDots }
      </React.Fragment>
    );
  }


  render() {
    const { top } = this.props.activeInnerArea;
    const { helper } = this.props;
    if (!helper.show) {
      return null;
    }

    return (
      <Group transform={`translate(0 ${top})`}>
        { this.renderHelper() }
      </Group>
    );
  }
}

export { VerticalLocationHelper };
