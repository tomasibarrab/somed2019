import React from 'react';
import { SlideNav } from './SlideNav';

interface IProps {
  children: React.ReactElement<any, any>;
  columnPadding: number;
  columnWidth: number;
  controllerPadding: {
    left: number;
    right: number;
    top: number;
  };
  isDisabled?: boolean;
  offset: number;
  yOffset: number;
  slideDistance: number;
}

interface IState {
  maxOffset: number | null;
  offset: number;
  windowWidth: number | null;
}

class SlideController extends React.Component<IProps, IState> {
  private svgRef: React.RefObject<HTMLInputElement>;

  static defaultProps = {
    columnPadding: 0,
    controllerPadding: {
      left: 50,
      right: 0,
      top: 28,
    },
    offset: 0,
    slideDistance: 33,
    yOffset: 0,
  }

  state = {
    maxOffset: this.getMaxOffset(),
    offset: 0,
    windowWidth: null,
  }

  constructor(props: IProps) {
    super(props);

    this.svgRef = React.createRef();
    this.onNext = this.onNext.bind(this);
    this.onPrev = this.onPrev.bind(this);
    this.updateDimensions = this.updateDimensions.bind(this);
  }

  getMaxOffset(): number {
    const { children, columnPadding, columnWidth } = this.props;
    const svgWidth = this.svgRef && this.svgRef.current && this.svgRef.current.offsetWidth || 0;
    const child = React.Children.only(children);

    const minGraphWidth = this.getMinWidth({
      columnCount: child.props.columns.length,
      columnPadding,
      columnWidth,
      padding: child.props.padding,
    });

    const negativeMinGraphWidth = minGraphWidth * -1;
    const halfColumnWidth = columnWidth / 2;
    const visualisationArea = svgWidth - child.props.padding.left;

    return ((negativeMinGraphWidth - halfColumnWidth) + visualisationArea) - child.props.columnOffsets.right;
  }

  updateDimensions(): void {
    this.setState((prevState) => ({
      ...prevState,
      maxOffset: this.getMaxOffset(),
      windowWidth: window.innerWidth,
    }));
  }

  componentDidMount(): void {
    this.updateDimensions();
    window.addEventListener("resize", this.updateDimensions);
  }

  componentWillUnmount(): void {
    window.removeEventListener("resize", this.updateDimensions);
  }

  getMinWidth({ columnCount, columnPadding, columnWidth }: { columnCount: number; columnPadding: number; columnWidth: number; columnOffsets?: { left: number, right: number; }, padding: { left: number, right: number; } }): number {
    return (columnCount * (columnWidth + columnPadding));
  }

  getChildProps(child: React.ReactElement<any>): any {
    const { offset, windowWidth } = this.state;
    const { columnPadding, columnWidth, isDisabled } = this.props;

    const props = {
      containerWidth: this.svgRef && this.svgRef.current && this.svgRef.current.offsetWidth,
      isDisabled,
      minWidth: this.getMinWidth({
        columnCount: child.props.columns.length,
        columnPadding,
        columnWidth,
        padding: child.props.padding,
      }),
      offset,
      windowWidth,
    }

    return {
      slideProps: props,
    }
  }

  renderChildren(): React.ReactNode {
    const renderChild = (child: React.ReactElement<any>) => React.cloneElement(child, this.getChildProps(child));
    return React.Children.map(this.props.children, renderChild);
  }

  getSlideDistance(currentOffset: number, direction: 'next' | 'prev'): number {
    const { slideDistance } = this.props;
    const { maxOffset } = this.state;

    const svgWidth = this.svgRef && this.svgRef.current && this.svgRef.current.offsetWidth || 0;
    const offset = svgWidth * (slideDistance / 100);

    // Go next, constrained to the width of the graph (don't overshoot ends)
    if (direction === 'next') {
      const nextOffset = currentOffset - offset;

      if (nextOffset < maxOffset) {
        return maxOffset
      }

      return nextOffset;
    }

    // Go prev, constrained to graph size
    const prevOffset = currentOffset + offset;
    return prevOffset > 0 ? 0 : prevOffset;
  }

  onNext(): void {
    this.setState((prevState) => ({
      ...prevState,
      offset: this.getSlideDistance(prevState.offset, 'next'),
    }));
  }

  //tslint:disable-next-line
  onPrev(): void {
    this.setState((prevState) => ({
      ...prevState,
      offset: this.getSlideDistance(prevState.offset, 'prev'),
    }));
  }

  hideSlideNav(): boolean {
    const { children, columnPadding, columnWidth } = this.props;
    const child = React.Children.only(children);
    const svgWidth = this.svgRef && this.svgRef.current && this.svgRef.current.offsetWidth;

    if (svgWidth) {
      const minGraphWidth = this.getMinWidth({
        columnCount: child.props.columns.length,
        columnPadding,
        columnWidth,
        padding: child.props.padding,
      });

      if (minGraphWidth > svgWidth) {
        return false;
      }
    }

    return true;
  }

  render(): React.ReactNode {
    if (this.props.isDisabled) {
      return this.props.children;
    }

    const { maxOffset } = this.state;
    const hideSlideNav = this.hideSlideNav();

    const containerStyles: React.CSSProperties = {
      overflow: 'hidden',
      position: 'relative',
      width: '100%',
    };

    return (
      <div
        ref={this.svgRef}
        style={containerStyles}
      >
        <SlideNav
          id="storybook"
          isVisible
          padding={this.props.controllerPadding}
          next={{
            isDisabled: hideSlideNav || this.state.offset === maxOffset,
            onClick: this.onNext,
          }}
          prev={{
            isDisabled: hideSlideNav || this.state.offset === 0,
            onClick: this.onPrev,
          }}
        />
        { this.renderChildren() }
      </div>
    );
  }
}

export { SlideController };
