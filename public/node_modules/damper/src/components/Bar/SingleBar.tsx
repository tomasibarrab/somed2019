import React from 'react';

import { AnimatedRect, Rect } from '../Svg/Rect';
import { AnimatedRoundedRect, RoundedRect } from '../Svg/RoundedRect';

import { colourShade, rgbToHex } from '../../utils';
import { generateRoundedRectPath } from '../../utils/general/generateRoundedRectPath';
import { getPositiveOrZero } from '../../utils/general/getPositiveOrZero';

type SVGElement = React.ComponentType | React.ForwardRefExoticComponent<React.RefAttributes<any>>;

interface IProps {
  actions?: {
    onClick?(): void;
    onMouseOver?(data: any, computedLocation: any): void;
    onMouseOut?(): void;
  };
  data: {
    value: number;
    theme?: {
      hoverFill: string;
      hoverStroke: string;
      style: React.CSSProperties;
    };
  };
  hostRef: any;
  id: string;
  index: number;
  isAnimated: boolean;
  isHovered: boolean;
  isInteractive: boolean;
  scale?(val: number): number;
  theme: {
    default: {
      fill: string;
      width: number;
      cursor: 'pointer' | 'cursor';
    };
    easing: {
      opacity: string;
      x: string;
    };
  };
  xOffset: number;
  yOffset: number;
}

export class SingleBar extends React.Component<IProps> {
  static defaultProps = {
    actions: undefined,
    hostRef: undefined,
    index: 0,
    isAnimated: true,
    isHovered: false,
    isInteractive: true,
    scale: undefined,
    xOffset: 0,
    yOffset: 0,
  }

  getColorShade(col: string): string {
    let color: string | null = col;

    if (color[0] !== '#') {
      color = rgbToHex(col);
    }

    if (color) {
      return colourShade(color, -0.15);
    }

    return col;
  }

  getHoverValue(styleHoverCol?: string, themeHoverCol?: string): string {
    if (styleHoverCol && styleHoverCol !== 'transparent') {
      if (themeHoverCol) {
        return themeHoverCol;
      }

      return this.getColorShade(styleHoverCol);
    }

    return 'transparent';
  }

  /**
   * gets the fill/stroke color for the bar during hover
   * Will use theme hovers if they're available. Will
   * fall back to dimming 15% if they're not
   */
  getHoverColor(style: any): any {
    const { theme } = this.props.data;

    if (theme) {
      return {
        ...style,
        fill: this.getHoverValue(style.fill, theme.hoverFill),
        stroke: this.getHoverValue(style.stroke, theme.hoverStroke),
      };
    }

    return style;
  }

  /**
   * Returns the height of the bar using scale if available
   */
  getHeight(heightValue: number): number {
    const { scale } = this.props;
    let height = heightValue;

    if (scale) {
      height = scale(heightValue);
    }

    return getPositiveOrZero(height);
  }

  /**
   * Merges bar defined styles with the default / passed in styles
   */
  getStyles(): any {
    const { data, theme } = this.props;
    let styles: any = theme.default;

    // Merge bar theme and prop-provided theme
    if (data && data.theme && data.theme.style) {
      styles = {
        ...styles,
        ...data.theme.style,
      };
    }

    styles = this.addInteractiveStyles(styles);

    return styles;
  }

  /**
   * Returns the y-location of the bar
   */
  getY(barHeight: number): number {
    const { yOffset } = this.props;
    return ((barHeight * -1) + yOffset);
  }

  /**
   * returns the x-location of the bar
   */
  getX(barWidth: number): number {
    const { xOffset } = this.props;
    return ((barWidth / 2) * -1) + xOffset;
  }

  /**
   * @TODO: Finish actions
   * returns the rect actions
   */
  getActions(computedLocation: any): any {
    const { actions, data } = this.props;

    if (!actions) {
      return {}
    }

    const getOnMouseOver = () => {
      if (actions.onMouseOver) {
        return () => actions.onMouseOver && actions.onMouseOver(data, computedLocation);
      }

      return undefined;
    };

    return {
      ...actions,
      onMouseOver: getOnMouseOver(),
    };
  }

  /**
   * returns the props for the rect
   */
  getProps(): any {
    const {
      data,
      index,
      isAnimated,
      isHovered,
    } = this.props;

    let style = this.getStyles();

    const { width } = style;
    let height = this.getHeight(data.value);

    const x = this.getX(style.width);
    let y = this.getY(height);

    /**
     * If the bar is stroked offset the y and height to
     * push it above the bottom axis
     */
    ({ height, y } = this.offsetYForStrokeWidth(style.strokeWidth, height, y));

    style = this.hideStrokeFromBase(style, width, height);

    if (isHovered) {
      style = this.getHoverColor(style);
    }

    let barProps: {
      actions: any;
      key: string;
      pose?: string;
      poseKey?: any;
      rectPoseVals?: any;
      style: any;
      width: number;
      x: number;
    } = {
      actions: this.getActions({
        height,
        width,
        x,
        y,
      }),
      key: `single-bar--${index}`,
      style,
      width,
      x,
    };

    const rectPoseVals = {
      height,
      index,
      y,
    };

    if (isAnimated) {
      barProps = {
        ...barProps,
        pose: 'pose',
        poseKey: rectPoseVals.height,
        rectPoseVals,
      };
    } else {
      barProps = {
        ...barProps,
        ...rectPoseVals,
      };
    }

    return barProps;
  }

  /**
   * Gets the rect component based on props.
   * This could either be one of four props;
   * - Rect
   * - AnimatedRect
   * - RoundedRect
   * - AnimatedRoundedRect
   */
  getRectComponent(props: any): { RectComponent: SVGElement; rectProps: any; } {
    let rectProps = props;
    let RectComponent: SVGElement = Rect;

    /**
     * If the bar is animated, replace with a pose-animated rect
     */
    if (this.props.isAnimated) {
      RectComponent = AnimatedRect;
    }

    /**
     * If bar has rounding, replace it with the rounded bar component
     */
    if (rectProps.style.rounding && rectProps.style.rounding > 0) {
      const heightIsZero = rectProps.rectPoseVals && rectProps.rectPoseVals.height === 0;

      RectComponent = RoundedRect;

      rectProps = {
        ...rectProps,
        rounding: rectProps.style.rounding,
        style: {
          ...rectProps.style,
          strokeWidth: heightIsZero ? 0 : rectProps.style.strokeWidth,
        },
      }

      rectProps = {
        ...rectProps,
        d: generateRoundedRectPath(rectProps),
      }

      if (this.props.isAnimated) {
        RectComponent = AnimatedRoundedRect;
      }
    }

    return {
      RectComponent,
      rectProps,
    };
  }

  /**
   * sets the bar cursor based on interactivity
   */
  addInteractiveStyles(theme: any): any {
    const { actions } = this.props;
    let cursor = 'default';

    if (actions && actions.onClick) {
      cursor = 'pointer';
    }

    return {
      ...theme,
      cursor,
    };
  }

  /**
   * Transforms the y and height values to take into account
   * the stroke width
   */
  offsetYForStrokeWidth(strokeWidth: number | string, heightVal: number, yVal: number): { height: number, y: number } {
    let height = heightVal;
    let y = yVal;

    let strokeInt;

    if (typeof strokeWidth === 'string') {
      strokeInt = parseInt(strokeWidth, 10);
    }

    if (typeof strokeWidth === 'number') {
      strokeInt = strokeWidth;
    }

    if (strokeInt && strokeInt > 0) {
      const strokedTransform = strokeInt;

      height = getPositiveOrZero(height - strokedTransform);
      y += getPositiveOrZero((strokedTransform / 2));
    }

    return { height, y };
  }

  /**
   * Hides the stroke from the bottom of the bar if its
   * index is more than 0.
   * If index is more than 0 it's implied that it's stacked
   * and is *not* at the bottom of the stack
   */
  // tslint:disable-next-line
  hideStrokeFromBase(s: any, width = 0, height = 0): any {
    const { index } = this.props;
    const style = s;

    // Ensures the dashed line stops at the bottom of the right hand border
    // otherwise it can overhang
    const calculateDashArray = ({
      strokeDashArray,
      strokeLineLength,
      topAndRightLength,
      bottomLength,
    }: {
      strokeDashArray: any,
      strokeLineLength: number,
      topAndRightLength: any,
      bottomLength: any,
    }) => {
      let lineLength = strokeLineLength;

      return strokeDashArray
        .map((da: any) => {
          let daLength = da;

          // Conditionals to tell if the line is either longer than top right or longer than the
          // top right AND bottom border lengths combined
          const lineLongerThanTopAndRight = (lineLength + da) > topAndRightLength;
          const lineLongerThanTopRightBottom = (lineLength + da) > bottomLength;

          // If the line is within the bottom area switch to 1px spacing, this will force it
          // to switch to blank before it's noticable
          if (lineLongerThanTopAndRight && !lineLongerThanTopRightBottom) {
            daLength = 1;
          }

          lineLength += daLength;

          return daLength;
        });
    };

    // Creates a dashed stroke top, right, left. No bottom.
    const createStroke = (strokeDashArray: number[]) => {

      // Max length of the stroke line
      const maxStrokeLength = (height * 2) + (width * 2);

      // Current length of the stroke line
      let strokeLineLength = 0;
      const dashArray = [];

      // Lengths of top+right border and top+right+bottom border
      const topAndRightLength = (width + height);
      const bottomLength = topAndRightLength + width;

      // While our stroke line is less than the border length of the bar
      // tslint:disable
      while (strokeLineLength <= maxStrokeLength) {
        strokeLineLength = dashArray.reduce((acc, d) => acc + d, 0);

        if (strokeLineLength > topAndRightLength && strokeLineLength < bottomLength) {
          dashArray.push(0); // Line width is 0
          dashArray.push(width); // Space width is the full width of the bar (to create an empty bottom border)
        } else {
          const strokedLine = calculateDashArray({
            strokeDashArray,
            strokeLineLength,
            topAndRightLength,
            bottomLength,
          });

          strokedLine.forEach((da: any) => dashArray.push(da));
        }
      }
      // tslint:enable

      return dashArray;
    };

    if (style.stroke && style.strokeDasharray && index !== 0) {
      // Regex the dashArray value
      const pxRegex = /(\dpx)/gm;
      const match = pxRegex.exec(style.strokeDasharray);

      if (Array.isArray(match) && match.length) {
        const strokeDashArray = match.map((m) => parseInt(m, 10));
        const dashArray = createStroke(strokeDashArray);

        // Overwrite strokedasharray value to explicitly define each stroke/gap width
        const strokeDashArrayString = dashArray.map((distance) => `${distance}px`).join(' ');

        // tslint:disable-next-line
        style.strokeDasharray = strokeDashArrayString;
      }
    }

    return style;
  }

  render(): React.ReactElement {
    const { rectProps, RectComponent } = this.getRectComponent(this.getProps());

    return (
      <RectComponent {...rectProps} />
    );
  }
}
