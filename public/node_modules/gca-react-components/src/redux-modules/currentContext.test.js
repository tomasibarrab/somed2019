import configureMockStore from 'redux-mock-store';
import { createEpicMiddleware } from 'redux-observable';
import { fromJS } from 'immutable';

import {
  actions,
  types,
  selectors,
  currentContextEpic,
  currentContextReducer,
  initialState
} from './currentContext';

describe('currentContext redux module', () => {
  describe('modals reducer', () => {
    it('should return the state passed into the reducer, regardless, when the action type is unmatched', () => {
      const initial = { test: true };
      const actual = currentContextReducer(initial, { type: 'NO_MATCH' });
      expect(actual).toEqual(initial);
    });

    it('should set the loading state when fetching current context', () => {
      const expected = { asyncCount: 0, isFetching: true, fetchFailed: false, error: null };
      const action = { type: types.FETCH_CURRENT_CONTEXT_REQUEST };
      const actual = currentContextReducer(initialState, action);

      expect(actual).toEqual(expected);
    });

    it('should set the loading/error states when fetching current context fails', () => {
      const error = { message: 'test-error' };
      const initial = { asyncCount: 0, isFetching: true, fetchFailed: false };
      const expected = { asyncCount: 0, isFetching: false, fetchFailed: true, error };
      const action = { type: types.FETCH_CURRENT_CONTEXT_FAILURE, error };
      const actual = currentContextReducer(initial, action);

      expect(actual).toEqual(expected);
    });

    it('should set the user object on the store when current context fetch succeeds', () => {
      const payload = { user: { name: 'test' } };

      const expected = {
        ...initialState,
        isFetching: false,
        user: { name: 'test' }
      };

      const action = { type: types.FETCH_CURRENT_CONTEXT_SUCCESS, payload };
      const actual = currentContextReducer(initialState, action);

      expect(actual).toEqual(expected);
    });

    it('should set the restaurant object on the store when current context fetch succeeds', () => {
      const payload = { restaurant: { rid: 123 } };

      const expected = {
        ...initialState,
        isFetching: false,
        restaurant: { rid: 123 }
      };

      const action = { type: types.FETCH_CURRENT_CONTEXT_SUCCESS, payload };
      const actual = currentContextReducer(initialState, action);

      expect(actual).toEqual(expected);
    });
  });

  describe('currentContext action creators', () => {
    it('fetchCurrentContext should return the correct type with no payload', () => {
      expect(actions.fetchCurrentContext()).toEqual(
        { type: types.FETCH_CURRENT_CONTEXT_REQUEST });
    });

    it('fetchCurrentContextSucceeded should return the correct type with no payload', () => {
      const payload = { user: {}, restaurant: { rid: 123 } };
      expect(actions.fetchCurrentContextSucceeded(payload)).toEqual({
        type: types.FETCH_CURRENT_CONTEXT_SUCCESS,
        payload,
      });
    });

    it('fetchCurrentContextFailed should return the correct type with no payload', () => {
      const error = { message: 'test-error' };
      expect(actions.fetchCurrentContextFailed(error)).toEqual(
        { type: types.FETCH_CURRENT_CONTEXT_FAILURE, error });
    });
  });
});

describe('selectors', () => {
  const state = {
    currentContext: {
      user: { name: 'test' },
      restaurant: { rid: 123, productType: 'Guest_Center' },
      fetchFailed: false,
      isFetching: false,
    },
  };

  const immutableState = fromJS({
    currentContext: {},
  }).set('currentContext', {
    user: { name: 'test' },
    restaurant: { rid: 123, productType: 'Guest_Center' },
    fetchFailed: false,
    isFetching: false,
  });

  it('should select entire currentContext subtree from regular Object', () => {
    const actual = selectors.currentContext(state);
    expect(actual).toEqual(state.currentContext);
  });

  it('should select entire currentContext subtree from immutable Object', () => {
    const actual = selectors.currentContext(immutableState);
    expect(actual).toEqual(state.currentContext);
  });

  it('should select restaurant from subtree from regular Object', () => {
    const actual = selectors.restaurant(state);
    expect(actual).toEqual({ rid: 123, productType: 'Guest_Center' });
  });

  it('should select restaurant from subtree from immutable Object', () => {
    const actual = selectors.restaurant(immutableState);
    expect(actual).toEqual({ rid: 123, productType: 'Guest_Center' });
  });

  it('should select rid from subtree from regular Object', () => {
    const actual = selectors.rid(state);
    expect(actual).toEqual(123);
  });

  it('should select rid from subtree from immutable Object', () => {
    const actual = selectors.rid(immutableState);
    expect(actual).toEqual(123);
  });

  it('should select product type from subtree from regular Object', () => {
    const actual = selectors.productType(state);
    expect(actual).toEqual('Guest_Center');
  });

  it('should select product type from subtree from immutable Object', () => {
    const actual = selectors.productType(immutableState);
    expect(actual).toEqual('Guest_Center');
  });

  it('should select user from subtree from regular Object', () => {
    const actual = selectors.user(state);
    expect(actual).toEqual({ name: 'test' });
  });

  it('should select user from subtree from immutable Object', () => {
    const actual = selectors.user(immutableState);
    expect(actual).toEqual({ name: 'test' });
  });

  it('should select isFetching from subtree from regular Object', () => {
    const actual = selectors.isFetching(state);
    expect(actual).toEqual(false);
  });

  it('should select isFetching from subtree from immutable Object', () => {
    const actual = selectors.isFetching(immutableState);
    expect(actual).toEqual(false);
  });

  it('should select fetchFailed from subtree from regular Object', () => {
    const actual = selectors.fetchFailed(state);
    expect(actual).toEqual(false);
  });

  it('should select fetchFailed from subtree from immutable Object', () => {
    const actual = selectors.fetchFailed(immutableState);
    expect(actual).toEqual(false);
  });
});

describe.skip('fetch currentContext Epic', () => {
  const payload = { user: { name: 'test' } };
  const fetchCurrentContext = () => payload;
  const dependencies = { api: { fetchCurrentContext } };

  const rootEpic = (action$, store) => currentContextEpic(action$, store, dependencies);
  const epicMiddleware = createEpicMiddleware(rootEpic);
  const mockStore = configureMockStore([epicMiddleware]);

  let store;
  beforeEach(() => {
    store = mockStore(initialState);
  });

  afterEach(() => {
    epicMiddleware.replaceEpic(rootEpic);
  });

  it('fetch currentContext should succeed', () => {
    store.dispatch(actions.fetchCurrentContext());

    expect(store.getActions()).toEqual(
      [actions.fetchCurrentContext(), actions.fetchCurrentContextSucceeded(payload)]);
  });
});

describe.skip('fetch currentContext Epic Error', () => {
  const error = { Error: 'test-error' };
  const fetchCurrentContext = () => { throw (error); };
  const dependencies = { api: { fetchCurrentContext } };

  const rootEpic = (action$, store) => currentContextEpic(action$, store, dependencies);
  const epicMiddleware = createEpicMiddleware(rootEpic);
  const mockStore = configureMockStore([epicMiddleware]);

  let store;
  beforeEach(() => {
    store = mockStore(initialState);
  });

  afterEach(() => {
    epicMiddleware.replaceEpic(rootEpic);
  });

  it('fetch currentContext should fail', () => {
    store.dispatch(actions.fetchCurrentContext());

    expect(store.getActions()).toEqual(
      [actions.fetchCurrentContext(), actions.fetchCurrentContextFailed(error)]);
  });
});

// This timeout was (temporarily) removed from the epic
// When the timeout is restored - the test still has to be updated - it wasn't working as expected
describe.skip('fetch currentContext Epic time out Error', () => {
  const error = { Error: 'timeout-error' };
  const payload = [
    { user: { name: 'test' } },
    { restaurant: { rid: 123 } }
  ];

  // timer set to *longer* than the timeout defined in the epic
  // *** setTimeout doesn't have any effect and the action succeeds (should time out and fail)
  const fetchCurrentContext = () => setTimeout(() => payload, 3000);

  const dependencies = { api: { fetchCurrentContext } };

  const rootEpic = (action$, store) => currentContextEpic(action$, store, dependencies);
  const epicMiddleware = createEpicMiddleware(rootEpic);
  const mockStore = configureMockStore([epicMiddleware]);

  let store;
  beforeEach(() => {
    store = mockStore(initialState);
    jest.useFakeTimers();
  });

  afterEach(() => {
    epicMiddleware.replaceEpic(rootEpic);
  });

  it('fetch currentContext should throw a timeout error', () => {
    store.dispatch(actions.fetchCurrentContext());

    expect(store.getActions()).toEqual([
      actions.fetchCurrentContext(),
      actions.fetchCurrentContextFailed(error),
      actions.fetchCurrentContextFailed(error)
    ]);
  });
});
