import PropTypes from 'prop-types';
import React from 'react';
import Dropzone from './Dropzone';

export const errorCodes = {
  ImageWidthTooSmall: 'ImageWidthTooSmall',
  ImageHeightTooSmall: 'ImageHeightTooSmall',
  ImageWidthTooLarge: 'ImageWidthTooLarge',
  ImageHeightTooLarge: 'ImageHeightTooLarge',
  FileSizeTooLarge: 'FileSizeTooLarge',
  FileSizeTooSmall: 'FileSizeTooSmall',
  FileTypeIncorrect: 'FileTypeIncorrect',
};

function getImage(file) {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.onload = () => resolve(image);
    image.onerror = reject;
    image.src = file.preview;
  });
}

const imageTypes = ['image/gif', 'image/jpeg', 'image/png'];

/**
 * Wrapper around [react-dropzone](https://react-dropzone.js.org/). Adds validation for min and max image dimensions, and error codes to allow displaying localized error messages.
 */
export class ImageDropzone extends React.Component {
  constructor(props) {
    super(props);

    this.onDrop = this.onDrop.bind(this);
    this.validateFile = this.validateFile.bind(this);
  }

  onDrop(acceptedFiles, rejectedFiles, event) {
    const { onDrop, onDropAccepted, onDropRejected } = this.props;

    this.validateFiles(acceptedFiles).then(() => {
      const finalAcceptedFiles = acceptedFiles.filter(file => file.errorCodes.length === 0);
      const finalRejectedFiles = rejectedFiles.concat(acceptedFiles.filter(file => file.errorCodes.length > 0));

      if (typeof onDrop === 'function') {
        onDrop(finalAcceptedFiles, finalRejectedFiles, event);
      }

      if (finalRejectedFiles.length > 0 && typeof onDropRejected === 'function') {
        onDropRejected(finalRejectedFiles, event);
      }

      if (finalAcceptedFiles.length > 0 && typeof onDropAccepted === 'function') {
        onDropAccepted(finalAcceptedFiles, event);
      }
    });
  }

  validateFiles(files) {
    return Promise.all(files.map(this.validateFile));
  }

  validateFile(file) {
    const { minWidth, minHeight, maxWidth, maxHeight } = this.props;

    if (!minWidth && !minHeight && !maxWidth && !maxHeight) {
      return Promise.resolve();
    }

    return getImage(file).then(image => {
      if (minWidth && image.width < minWidth) file.errorCodes.push('ImageWidthTooSmall');
      if (minHeight && image.height < minHeight) file.errorCodes.push('ImageHeightTooSmall');
      if (maxWidth && image.width > maxWidth) file.errorCodes.push('ImageWidthTooLarge');
      if (maxHeight && image.height > maxHeight) file.errorCodes.push('ImageHeightTooLarge');

      return true;
    });
  }

  render() {
    const { minWidth, minHeight, maxWidth, maxHeight, onDropAccepted, onDropRejected, ...rest } = this.props;

    return <Dropzone {...rest} activeClassName="drag-over" onDrop={this.onDrop} />;
  }
}

ImageDropzone.propTypes = {
  ...Dropzone.propTypes,
  /** MIME type of the images you wish to accept. */
  accept: (props, propName, componentName) => {
    const customTypesString = props[propName];
    const customTypes = customTypesString.split(',').map(type => type.trim());

    customTypes.forEach(type => {
      if (!imageTypes.includes(type)) {
        return new Error(`Prop ${propName} in ${componentName}: ${type} is not an image MIME type. ${propName}`);
      }

      return null;
    });
  },
  /** Minimum width, in px, for selected images */
  minWidth: PropTypes.number,
  /** Minimum height, in px, for selected images */
  minHeight: PropTypes.number,
  /** Maximum height, in px, for selected images */
  maxWidth: PropTypes.number,
  /** Maximum height, in px, for selected images */
  maxHeight: PropTypes.number,
};

ImageDropzone.defaultProps = {
  accept: 'image/gif, image/jpeg, image/png',
};

export default ImageDropzone;
