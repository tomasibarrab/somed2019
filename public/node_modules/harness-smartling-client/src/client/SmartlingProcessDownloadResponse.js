/* eslint-disable new-cap */

import uuidV4 from 'uuid/v4';
import unzip from 'unzip2';
import mkdirp from 'mkdirp';
import del from 'del';

module.exports = function (SmartlingFileDetailsBuilder, fsPromise, Promise, path, Utils, fs) {
  class SmartlingProcessDownloadResponse {
    constructor(buffer, options, saveTo) {
      this.buffer = buffer;
      this.options = options;
      this.saveTo = saveTo;

      // To be used as the name of the temp directory.
      this.tempId = uuidV4();
    }

    static process(buffer, options, saveTo) {
      return new SmartlingProcessDownloadResponse(buffer, options, saveTo).process();
    }

    process() {
      return Utils.promiseQueue([
        this._checkDirectoryExist.bind(this),
        this._createTempDirectory.bind(this),
        this._saveBufferToFile.bind(this),
        this._extractContents.bind(this),
        this._moveContentsToFinalDestination.bind(this)
      ])
      // Make sure to try and clean up even if there is a failure
      .finally(this._cleanUpTemporaryFiles.bind(this));
    }

    _checkDirectoryExist() {
      return fsPromise.statAsync(this.saveTo)
        .then((stats) => {
          if (!stats.isDirectory()) {
            throw new Error(`'${this.saveTo}' directory does not exist`);
          }

          return stats;
        });
    }

    _createTempDirectory() {
      return new Promise((resolve, reject) => {
        mkdirp(this._getTempDirectoryPath(), (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }

    _saveBufferToFile() {
      if (!this.options.fileUri) {
        return Promise.reject(new Error('fileUri is not defined in the download options.'));
      }

      const archivePath = this._getTempFilePath();

      return Promise.resolve(fsPromise.writeFileSync(archivePath, this.buffer, 'binary'));
    }

    _extractContents() {
      return new Promise((resolve, reject) => {
        const tempFilePath = this._getTempFilePath();

        const unzipExtractor = unzip.Extract({ path: this._getTempDirectoryPath() });

        unzipExtractor.on('error', reject);
        unzipExtractor.on('close', resolve);
        unzipExtractor.on('end', resolve);

        fs.createReadStream(tempFilePath).pipe(unzipExtractor);
      });
    }

    _moveContentsToFinalDestination() {
      return SmartlingFileDetailsBuilder.build(this._getTempDirectoryPath(), this.saveTo, this.options.fileUri)
        .then((result) => {
          const fileDetails = result.fileDetails;

          if (!fileDetails || fileDetails.length < 1) {
            throw new Error('No file details were loaded.');
          }

          return Promise.each(fileDetails, (entry) => fsPromise.renameAsync(entry.sourceFile, entry.destinationFile));
        });
    }

    _cleanUpTemporaryFiles() {
      return new Promise((resolve, reject) => {
        del([
          this._getTempFilePath(),
          this._getTempDirectoryPath()
        ])
        .then(resolve)
        .catch(reject);
      });
    }

    _unlinkPath(assetPath) {
      return fsPromise.unlinkAsync(assetPath);
    }

    _getTempFilePath() {
      return path.join(this.saveTo, `${this._getFileName()}`);
    }

    _getTempDirectoryPath() {
      return path.join(this.saveTo, `temp-${this.tempId}`);
    }

    _getFileName() {
      return `${this.tempId}.zip`;
    }
  }

  return SmartlingProcessDownloadResponse;
};
