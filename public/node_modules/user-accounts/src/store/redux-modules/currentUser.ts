/**
 * Actions, Epics, Selectors and Reducers for CurrentUser editing
 * Created by: Michele Ursino
 * May 21st 2018
 */

import { combineReducers } from 'redux';
import { createSelector } from 'reselect';
import { Observable } from 'rxjs/Observable';
import actionCreatorFactory, { Action, Success } from 'typescript-fsa';

import get from 'lodash/get';

import { flattenUserProfile } from '../../utils/reducer-helpers';
import { AjaxStatuses, Epic, SaveStatus, State, User, UserPayload, UserState } from '../types';

// ========================= Actions =============================

const createAction = actionCreatorFactory();

const fetchCurrentUser = createAction.async<string, User>('FETCH_CURRENT_USER');
const addNewUser = createAction.async<UserPayload, User>('ADD_NEW_USER');
const updateExistingUser = createAction.async<UserPayload, {}>('UPDATE_EXISTING_USER');

const editNewUser = createAction('EDIT_NEW_USER');
const resetCurrentUser =  createAction.async<number, undefined>('RESET_CURRENT_USER');

export const actions = {
  addNewUser,
  editNewUser,
  fetchCurrentUser,
  resetCurrentUser,
  updateExistingUser,
};

// ======================== Selectors ============================

const baseSelector = (state: State) => state.currentUser;

const isLoading = createSelector(baseSelector,
  (state: UserState<User>) => state.status.fetch === 'started');
const isSaving = createSelector(baseSelector,
  (state: UserState<User>) => state.status.save === 'started');
const hasFailed = createSelector(baseSelector,
  (state: UserState<User>) => state.status.save === 'failed');
const createHasCompleted = createSelector(baseSelector,
  (state: UserState<User>) => state.status.save === 'create-done');
const updateHasCompleted = createSelector(baseSelector,
  (state: UserState<User>) => state.status.save === 'update-done');
const isNewUser = createSelector(baseSelector,
  (state: UserState<User>) => (!state.user || !state.user.id));

const saveStatus = createSelector(baseSelector,
    (state: UserState<User>) => {
      return  state.status.save || 'none' as SaveStatus;
    });

const saveUser = (state: State, userData: User): UserPayload => {
  return {
    ...userData,
    countryCode: get(state.currentContext, ['restaurant', 'address', 'countryCode']),
    product: get(state.currentContext, ['restaurant', 'productType'], 'Guest_Center'),
    rid: get(state.currentContext, ['restaurant', 'rid']),
  };
};

export const selectors = {
  createHasCompleted,
  hasFailed,
  isLoading,
  isNewUser,
  isSaving,
  saveStatus,
  saveUser,
  updateHasCompleted,
};

// ======================= Transformers ==========================

function transformUserTrim(data: UserPayload): UserPayload {
  return {
    ...data,
    firstName: data.firstName.trim(),
    lastName:  data.lastName.trim(),
    // on create, trim spaces from start and end of email
    // on update, email is not set
    ...(data.email && { email: data.email.trim() }),
  };
}

// ========================== Epics ==============================

const resetCurrentUserEpic: Epic = (action$) =>
  action$
    .ofType(resetCurrentUser.started.type)
    .switchMap(({ payload }) => Observable.of(true).delay(payload))
    .map(() => resetCurrentUser.done({ params: 0, result: undefined }));

const addNewUserEpic: Epic = (action$, store, { usersApi }) =>
  action$
  .ofType(addNewUser.started.type)
  .map(({payload}) => selectors.saveUser(store.getState(), payload))
  .map((userPayload) => ({
    scope: get(store.getState(), ['scope']),
    user: transformUserTrim(userPayload),
  }))
  .switchMap(({ scope, user }: any) =>
    usersApi(scope).addUser({ user })
      .map(({ response }) => addNewUser.done({ params: user, result: response}))
      .catch(error => [addNewUser.failed({
        error: get(error, ['response', 'message'], error.message || error),
        params: user,
      })]),
  );

const fetchCurrentUserEpic: Epic = (action$, store, { usersApi }) =>
  action$
    .ofType(fetchCurrentUser.started.type)
    .map((action: Action<string>) => ({
      appScope: get(store.getState(), ['appScope']),
      scope: get(store.getState(), ['scope']),
      userid: action.payload,
    }))
    .switchMap(({ userid, scope, appScope }: any) =>
      // always request profile from appScope context, because api will return all associated profiles
      usersApi(appScope).getUser({
        getRelatedProfiles: appScope.type === 'group',
        id: userid,
      })
        .map(result => ({
          ...result,
          // inject current context (from scope), so we can filter the current profile in flattenUserProfile()
          contextUrn: scope.context,
        }))
        .map(result => fetchCurrentUser.done({ params: userid, result }))
        .catch(error => [fetchCurrentUser.failed({ params: userid, error })]),
    )
    .catch(error => [fetchCurrentUser.failed({ params: '', error })]);

const updateExistingUserEpic: Epic = (action$, store, { usersApi }) =>
  action$
    .ofType(updateExistingUser.started.type)
    .map(action => selectors.saveUser(store.getState(), action.payload))
    .map(userPayload => ({
      scope: get(store.getState(), ['scope']),
      user: transformUserTrim(userPayload),
    }))
    .switchMap(({ scope, user }: any) =>
      usersApi(scope).updateUser({ user })
        .map(() => {
          // TODO: it would be better if the API response (res.response) could contain the modified user!!!
          return updateExistingUser.done({ params: user, result: user });
        })
        .catch(error => {
          return [updateExistingUser.failed({
            error: get(error, ['response', 'message'], error.message || error),
            params: user,
          })]
        }),
    );

export const epics = {
  addNewUserEpic,
  fetchCurrentUserEpic,
  resetCurrentUserEpic,
  updateExistingUserEpic,
};

// ========================= Reducers ============================

export const initialState: UserState<User> = {
  id: '',
  status: {},
  user: {},
};

function ajaxStatuses(current: AjaxStatuses = initialState.status, action: Action<void>): AjaxStatuses {
  switch (action.type) {
    case actions.editNewUser.type:
      return {};
    case actions.resetCurrentUser.done.type:
      return {};
    case actions.updateExistingUser.started.type:
    case actions.addNewUser.started.type:
      return {
        ...current,
        save: 'started',
      };
    case actions.updateExistingUser.failed.type:
    case actions.addNewUser.failed.type:
      return {
        ...current,
        save: 'failed',
      };
    case actions.updateExistingUser.done.type:
      return {
        ...current,
        save: 'update-done',
      };
    case actions.addNewUser.done.type:
      return {
        ...current,
        save: 'create-done',
      };
    case actions.fetchCurrentUser.failed.type:
      return {
        ...current,
        fetch: 'failed',
      };
    case actions.fetchCurrentUser.done.type:
      return {
        ...current,
        fetch: 'done',
      };
    case actions.fetchCurrentUser.started.type:
      return {
        ...current,
        fetch: 'started',
      };
    default:
      return current;
  }
}

function currentUser(
  current: Partial<User> = initialState.user,
  action: Action< User | Success<User, User>>): Partial<User> {
  switch (action.type) {
    case actions.editNewUser.type:
      return {};
    case actions.fetchCurrentUser.done.type:
      return flattenUserProfile((action.payload as Success<User, User>).result);
    case actions.updateExistingUser.started.type:
      return { ...current, ...action.payload } as User;
    case actions.addNewUser.started.type:
      return action.payload as User;
    case actions.updateExistingUser.done.type:
      return flattenUserProfile({ ...current, ...(action.payload as Success<User, User>).result });
    case actions.addNewUser.done.type:
      return (action.payload as Success<User, User>).result;
    default:
      return current;
  }
}

function userId(current: string = initialState.id, action: Action<Success<string, User>>): string {
  switch (action.type) {
    case actions.resetCurrentUser.done.type:
    case actions.editNewUser.type:
      return '';
    case actions.fetchCurrentUser.done.type:
    case actions.addNewUser.done.type:
    case actions.updateExistingUser.done.type:
      return action.payload.result.id || action.payload.result.urn;
    default:
      return current;
  }
}

export const reducer = combineReducers<UserState<User>>({
  id: userId,
  status: ajaxStatuses,
  user: currentUser,
});
