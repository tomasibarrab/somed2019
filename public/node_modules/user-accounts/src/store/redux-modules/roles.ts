/**
 * Actions, Epics, Selectors and Reducers for Restaurant Roles and Permissions
 * Created by: Michele Ursino
 * May 1st 2018
 */

import get from 'lodash/get';
import { combineReducers } from 'redux';
import { Observable } from 'rxjs';
import { ObservableInput } from 'rxjs/Observable';
import actionCreatorFactory, { Action, ActionCreator, Success } from 'typescript-fsa';

import {
  filterHiddenRoles,
  isVisible,
  sortPermissionsByRank,
  sortRolesPermissions,
} from '../../utils/metaFilters';
import {
  AsyncNextAction,
  Epic,
  InProgressOps,
  Permission,
  PermissionWithMetadata,
  Role,
  RolesFor,
  RolesState,
} from '../types';

// ========================= Actions =============================

const createAction = actionCreatorFactory();

const fetchRoles =
  createAction.async<AsyncNextAction<any>, Role[]>('FETCH_ROLES');

const fetchPermissions =
  createAction.async<AsyncNextAction<any>, PermissionWithMetadata[]>('FETCH_PERMISSIONS');

const fetchDefaultPermissions =
  createAction.async<{}, Role[]>('FETCH_DEFAULT_PERMISSIONS');

const ensurePermissions = createAction('ENSURE_PERMISSIONS');

const clearPermissions = createAction('CLEAR_PERMISSIONS');

const saveRole =
  createAction.async<{ roleId: string }, {}>('SAVE_ROLE');

const editRole =
  createAction<{ roleId: string, edit: boolean}>('EDIT_ROLE');

const editPermissionInRole =
  createAction<{ roleId: string, permId: string, flag: boolean}>('EDIT_PERMISSION_IN_ROLE');

export const actions = {
  clearPermissions,
  editPermissionInRole,
  editRole,
  ensurePermissions,
  fetchDefaultPermissions,
  fetchPermissions,
  fetchRoles,
  saveRole,
};

// ======================== Selectors ============================

function getRolesOrPermissionsEmpty(state: RolesState): boolean {
  return state.permissions.length === 0 || state.roles.length === 0;
}

function getRolesAndPermissionsLoading(state: RolesState): boolean {
  return state.inProgress.fetchingPermissions === 'inprogress'
    || state.inProgress.fetchingRoles === 'inprogress';
}

function getRolesAndPermissionError(state: RolesState): boolean {
  return state.inProgress.fetchingPermissions === 'error'
    || state.inProgress.fetchingRoles === 'error';
}

function getVisiblePermissions(state: RolesState): Permission[] {
  return state.permissions.filter(isVisible).map(p => p.urn);
}

export const selectors = {
  getRolesAndPermissionError,
  getRolesAndPermissionsLoading,
  getRolesOrPermissionsEmpty,
  getVisiblePermissions,
};

// ========================== Epics ==============================


/**
 * Create a Role request from a current Role from the redux store.
 * @param role Role from the redux store
 */
export function createRoleRequest(role: Role): Role {
  return {
    ...role,
    permissions: [ ...(role.editingPermissions || role.permissions), ...(role.hiddenPermissions || [])],
  };
}

/**
 * Note: this function will not fetch permissions and role if already in the
 * redux store.
 */
const ensurePermissionsEpic: Epic = (action$, store) => {
  return action$.ofType(ensurePermissions.type)
    .switchMap(({ payload = {} }) => {
      const whichRoles: RolesFor = payload.rolesFor || 'appRoles';

      const perms = get(store.getState(), [whichRoles, 'permissions' ]);
      const roles = get(store.getState(), [whichRoles, 'roles' ]);

      if (!perms || !perms.length || !roles || !roles.length || payload.forceReload) {
        return Observable.from([
          actions.fetchPermissions.started({
            nextAction: actions.fetchRoles.started,
            nextPayload: { params: { rolesFor: whichRoles }},
            params: { rolesFor: whichRoles },
          }),
        ]);
      } else {
        return Observable.of();
      }
    });
};

/**
 * Utility function that creates an observable result for a epic with
 * AsyncNextAction data. This utility will put the success done action as first
 * item of the array and the next action (with its parameters) in the second item of the array.
 * Note: if there is no nextAction in the rawReq then the array will have single item.
 * @param result the data result for the async action
 * @param rawReq the raw request data of the action
 * @param actionCreator the creator for the done action to be returned.
 */
function observableResults<T>(
  result: T,
  rawReq: any,
  actionCreator: ActionCreator<{ params: {}, result: T}>,
): ObservableInput<any> {
  return Observable.from([
    actionCreator({ params: (rawReq && rawReq.params) || {}, result }),
    rawReq.nextAction ? rawReq.nextAction(rawReq.nextPayload || {}) : undefined,
  ].filter(a => a !== undefined));
}

const fetchRolesEpic: Epic = (action$, store, { usersApi }) =>
  action$.ofType(fetchRoles.started.type)
    .map(({ payload }) => {
      const rolesFor = get(payload, ['params', 'rolesFor']) || 'appRoles';
      return {
        payload,
        permissions: get(store.getState(), [rolesFor, 'permissions']),
        scope: get(store.getState(), ['scope']),
      };
    })
    .switchMap(({ payload, permissions, scope }: any) =>
      usersApi(scope).getRoles()
        .map(result => filterHiddenRoles(result.roles))
        .map(filteredRoles => sortRolesPermissions(filteredRoles, permissions))
        .switchMap(sortedRoles => observableResults(sortedRoles, payload, fetchRoles.done))
        .catch(error => [fetchRoles.failed(error)]),
    );

const fetchPermissionsEpic: Epic = (action$, store, { usersApi }) =>
  action$.ofType(fetchPermissions.started.type)
    .map(({ payload }) => ({
      payload,
      scope: get(store.getState(), ['scope']),
    }))
    .switchMap(({ scope, payload }) =>
      usersApi(scope).getPermissions()
        .map(({ permissions }) => sortPermissionsByRank(permissions))
        .switchMap(orderedPermissions => observableResults(orderedPermissions, payload, fetchPermissions.done))
        .catch(error => [fetchPermissions.failed(error)]),
    );

const saveRoleEpic: Epic = (action$, store, { usersApi }) =>
  action$.ofType(saveRole.started.type)
    .map(({ payload }) => ({
      payload: {
        ...payload,
        role: createRoleRequest(
          get(store.getState(), ['appRoles', 'roles'])
            .find((r: Role) => r.urn === payload.roleId),
        ),
      },
      scope: get(store.getState(), ['scope']),
    }))
    .switchMap(({ scope, payload }: any) =>
      usersApi(scope).updateRole({ role: payload.role })
        .map(() => saveRole.done({ params: payload.rid, result: payload.role }))
        .catch(error => [saveRole.failed({ params: { roleId: payload.roleId }, error })]),
    );

const saveRoleCompleteEpic: Epic = (action$) =>
    action$.ofType(saveRole.done.type)
      .map(() => actions.fetchRoles.started({}));

export const epics = {
  ensurePermissionsEpic,
  fetchPermissionsEpic,
  fetchRolesEpic,
  saveRoleCompleteEpic,
  saveRoleEpic,
};


// ========================= Reducers ============================
function ignoreRolesAction(action: any, rolesFor: RolesFor) {
  const branch = get(action.payload, ['params', 'rolesFor'], undefined);
  return branch && branch !== rolesFor;
}

const defaultPermissionsReducer = (rolesFor: RolesFor) => (
  defPermissions: Role[] = [],
  action: Action<Success<{}, Role[]>>,
): Role[] => {
  if (ignoreRolesAction(action, rolesFor)) {
    return defPermissions;
  }

  if (action.type === fetchDefaultPermissions.done.type) {
    return action.payload.result;
  } else {
    return defPermissions;
  }
};

const rolesReducer = (rolesFor: RolesFor) => (
  roles: Role[] = [],
  action: Action<any>,
): Role[] => {
  if (ignoreRolesAction(action, rolesFor)) {
    return roles;
  }

  switch (action.type) {
    case fetchRoles.done.type:
      return ((action.payload.result) as Role[])
          .map(role => ({ ...role, status: 'view' } as Role));
    case saveRole.started.type:
      return roles.map(role => action.payload.roleId === role.urn
        ? ({...role, status: 'saving'} as Role)
        : role,
      );
    case saveRole.failed.type:
      return roles.map(role => action.payload.params.roleId === role.urn
        ? ({ ...role, status: 'error' } as Role)
        : role,
      );
    case saveRole.done.type:
      return roles.map(role => action.payload.result.urn === role.urn
        ? ({ ...role, status: 'saved' } as Role )
        : role,
      );
    case editRole.type:
      return roles.map((role: Role) => {
        if (action.payload.roleId === role.urn) {
          return {
            ...role,
            editingPermissions: action.payload.edit ? [...role.permissions] : undefined,
            status: action.payload.edit ? 'editing' : 'view',
          } as Role;
        }
        return role;
      });
    case editPermissionInRole.type:
      return roles.map((role: Role) => {
        if (role.urn === action.payload.roleId && role.editingPermissions ) {
          if (action.payload.flag) {
            role.editingPermissions.push(action.payload.permId);
          } else {
            role.editingPermissions = role.editingPermissions.filter(p => p !== action.payload.permId);
          }
          return { ...role };
        }
        return role;
      });
    case clearPermissions.type:
      return [];
    default:
      return roles;
  }
};

const permissionsReducer = (rolesFor: RolesFor) => (
  currPermissions: PermissionWithMetadata[] = [],
  action: Action<Success<{}, PermissionWithMetadata[]>>,
): PermissionWithMetadata[] => {
  if (ignoreRolesAction(action, rolesFor)) {
    return currPermissions;
  }

  switch (action.type) {
    case fetchPermissions.done.type:
      return action.payload.result;
    case clearPermissions.type:
      return [];
    default:
      return currPermissions;
  }
};

const inProgressReducer = (rolesFor: RolesFor) => (
  currOps: InProgressOps = {},
  action: Action<any>,
): InProgressOps => {
  if (ignoreRolesAction(action, rolesFor)) {
    return currOps;
  }

  switch (action.type) {
    case fetchDefaultPermissions.started.type:
      return {
        ...currOps,
        fetchingDefaultPermissions: 'inprogress',
      };
    case fetchRoles.started.type:
      return {
        ...currOps,
        fetchingRoles: 'inprogress',
      };
    case fetchPermissions.started.type:
      return {
        ...currOps,
        fetchingPermissions: 'inprogress',
      };
    case fetchDefaultPermissions.done.type:
      return {
        ...currOps,
        fetchingDefaultPermissions: undefined,
      };
    case fetchDefaultPermissions.failed.type:
      return {
        ...currOps,
        fetchingDefaultPermissions: 'error',
      };
    case fetchRoles.done.type:
      return {
        ...currOps,
        fetchingRoles: undefined,
      };
    case fetchRoles.failed.type:
      return {
        ...currOps,
        fetchingRoles: 'error',
      };
    case fetchPermissions.done.type:
      return {
        ...currOps,
        fetchingPermissions: undefined,
      };
    case fetchPermissions.failed.type:
      return {
        ...currOps,
        fetchingPermissions: 'error',
      };
    default:
      return currOps;
  }
};

/**
 * These reducers are the same for at least 2 branches of the root reducer:
 *   1. "appRoles" are the ones used for the Users Directory, as well as for managing
 *      the Access Types; these usually don't change once they are loaded;
 *   2. "profileRoles" are used on the create / edit page, and can change on the fly
 *      (by selecting, from a dropdown, another existing profile for the currentUser).
 * @param rolesFor
 */
export const reducer = (rolesFor: RolesFor) => combineReducers<RolesState>({
  defPermissions: defaultPermissionsReducer(rolesFor),
  inProgress: inProgressReducer(rolesFor),
  permissions: permissionsReducer(rolesFor),
  roles: rolesReducer(rolesFor),
});
