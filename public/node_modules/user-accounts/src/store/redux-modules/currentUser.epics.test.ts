import configureMockStore from 'redux-mock-store';
import { ActionsObservable } from 'redux-observable';
import { Observable } from 'rxjs';

import { Action, User } from '../types';
import {
  actions,
  epics,
  initialState,
} from './currentUser';

const mockStore = configureMockStore();

const state = {
  appRoles: {
    roles: [{
      permissions: ['test-1', 'test-2'],
      urn: 'test-role',
    }],
  },
  appScope: {
    rid: '123',
    type: 'restaurant',
  },
  currentContext: {
    restaurant: {
      rid: 123,
    },
  },
  currentUser: { ...initialState },
  scope: {
    rid: '123',
    type: 'restaurant',
  },
};

const mockedUser: User = {
  email: 'foo@foo.com',
  enable2FA: false,
  firstName: 'John',
  gdprNotificationReceiver: false,
  id: '123',
  lastActive: '',
  lastName: 'Smith',
  newUser: false,
  phone: '01234345667',
  role: 'urn:ot.rest.perms:marketing',
  roles: [ 'urn:ot.rest.perms:marketing', 'urn:ot.rest.perms:analytics' ],
  title: 'Guest_Center_Title_Chef',
  urn: 'urn:fake.urn:123',
};

const mockedApi = {
  addUser: ({ user }: { user: any }): Observable<{ response: User}> =>
    Observable.of({ response: mockedUser}),
  getUser: ({ userid }: { userid: string }): Observable<User> =>
    Observable.of(mockedUser),
};

describe('currentUser epics', () => {

  it('should fetch the currentUser', (done) => {
    global.fetch = () => Promise.resolve({
      json: () => ({ enabled: true }),
    });

    const output$ = epics.fetchCurrentUserEpic(
      ActionsObservable.of(actions.fetchCurrentUser.started('123')),
      mockStore(state),
      { usersApi: () => mockedApi },
    );

    // the test needs to be scheduled after the mocked fetch, which is a Promise and runs async
    Promise.resolve()
      .then(() => {
        output$.toArray().subscribe((acts: Action[]) => {
          expect(acts).toHaveLength(1);
          expect(acts[0].type).toBe(actions.fetchCurrentUser.done.type);
        });
      })
      .then(done);
  });

  it('should add a new user', () => {
    const output$ = epics.addNewUserEpic(
      ActionsObservable.of(actions.addNewUser.started(mockedUser)),
      mockStore(state),
      { usersApi: () => mockedApi },
    );
    output$.toArray().subscribe((acts: Action[]) => {
      expect(acts).toHaveLength(1);
      expect(acts[0].type).toBe(actions.addNewUser.done.type);
    });
  });

  it('should fail to add a new user (with structured error response)', () => {
    mockedApi.addUser = () => Observable.throw({
      response: {
        errorCode: 'Unauthorized',
        message: 'custom-error-message',
        statusCode: 401,
      },
      status: 410,
    });

    const output$ = epics.addNewUserEpic(
        ActionsObservable.of(actions.addNewUser.started(mockedUser)),
        mockStore(state),
        { usersApi: () => mockedApi },
    );
    output$.toArray().subscribe((acts: Action[]) => {
      expect(acts).toHaveLength(1);
      expect(acts[0].type).toBe(actions.addNewUser.failed.type);
      expect(acts[0].payload.error).toBe('custom-error-message');
    });
  });

  it('should fail to add a new user (without error response)', () => {
    mockedApi.addUser = () => Observable.throw({
      message: 'Some Server Error',
      response: null,
      status: 500,
    });

    const output$ = epics.addNewUserEpic(
        ActionsObservable.of(actions.addNewUser.started(mockedUser)),
        mockStore(state),
        { usersApi: () => mockedApi },
    );
    output$.toArray().subscribe((acts: Action[]) => {
      expect(acts).toHaveLength(1);
      expect(acts[0].type).toBe(actions.addNewUser.failed.type);
      expect(acts[0].payload.error).toBe('Some Server Error');
    });
  });
});
