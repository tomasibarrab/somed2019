import arrayMutators from 'final-form-arrays';
import get from 'lodash/get';
import React from 'react';
import { Form, FormRenderProps } from 'react-final-form';
import { InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';
import { RouteComponentProps } from 'react-router-dom';

import { AsyncContent } from 'gca-react-components';
import { Account } from 'gca-react-components/src/redux-modules/currentContext';
import * as validate from 'gca-react-components/src/utils/validate';

import { actions as availableUserActions } from '../store/redux-modules/availableUser';
import { actions as currentUserActions, selectors as currentUserSelectors } from '../store/redux-modules/currentUser';
import { actions as rolesActions, selectors as rolesSelectors } from '../store/redux-modules/roles';
import { actions as scopeActions } from '../store/redux-modules/scope';
import { createEditableDataFromUser, createUserFromEditableData } from '../store/redux-modules/users';
import { GuestCenterScope, Role, RoleEdit, SaveStatus, State, User, UserData, UserState } from '../store/types';
import { eventTracker, trackingCategory, trackingEvents } from '../utils/trackingUtils';
import { checkEmailDecorator, checkRoleDecorator } from './decorators';
import UserForm from './UserForm';

import { observe } from '../utils/finalObserver';
import './UserEditor.scss';

interface UserEditorActions {
  addUser: (user: User) => void;
  editNewUser: () => void;
  ensurePermissions: (params: any) => void;
  fetchAvailableUser: (id: string) => void;
  fetchUser: (id: string) => void;
  resetCurrentUser: (ms: number) => void;
  resetPermissions: () => void;
  resetScope: () => void;
  updateExistingUser: (data: Partial<User>) => void;
}

interface UserEditorState {
  account: Account;
  isCreate: boolean;
  roles: Role[];
  rolesAndPermissionLoading: boolean;
  rolesAndPermissionError: boolean;
  saveNewUserDone: boolean;
  saveError: boolean;
  saveStatus: SaveStatus;
  scope: GuestCenterScope,
  updateUserDone: boolean;
  userLoading: boolean;
  userState: UserState<User>;
}

interface UserEditorRouteParams {
  userId?: string;
}

type RoleSetValidator = (value: RoleEdit[]) => validate.ValidationError;

/**
 * Produce an array validator that makes sure at least ONE role is set.
 */
function validateRoles(): RoleSetValidator {
  return (value: RoleEdit[]): validate.ValidationError => {
    if (!value) {
      return undefined;
    }
    if (value.find((role) => role.set)) {
      return undefined;
    } else {
      const err: string[] = [];
      (err as any)['FINAL_FORM/array-error'] = 'validate.needOneSet';
      return err;
    }
  };
}

type UserEditorProps =
  UserEditorState
  & UserEditorActions
  & InjectedIntlProps
  & RouteComponentProps<{}>;


class UserEditorImpl extends React.Component<UserEditorProps> {

  private readonly validateUser: validate.FormValidator;

  constructor(p: UserEditorProps) {
    super(p);

    this.validateUser = validate.create({
      email: validate.compose(
        validate.required(p.intl.formatMessage({ id: 'validate.required' })),
        validate.email(p.intl.formatMessage({ id: 'validate.email' })),
      ),
      firstName: validate.compose(
        validate.required(p.intl.formatMessage({ id: 'validate.required' })),
        validate.maxChars(80, p.intl.formatMessage({ id: 'validate.maxChars' })),
      ),
      lastName: validate.compose(
        validate.required(p.intl.formatMessage({ id: 'validate.required' })),
        validate.maxChars(80, p.intl.formatMessage({ id: 'validate.maxChars' })),
      ),
      phone: validate.compose(
        validate.required(p.intl.formatMessage({ id: 'validate.required' })),
        validate.minChars(5, p.intl.formatMessage({ id: 'validate.minChars.phone' })),
        validate.maxChars(21, p.intl.formatMessage({ id: 'validate.maxChars.phone' })),
      ),
      rolesSet: validateRoles(),
      title: validate.compose(
        validate.required(p.intl.formatMessage({ id: 'validate.required' })),
      ),
    });
  }

  public componentDidMount() {
    const { editNewUser, ensurePermissions, fetchUser, match } = this.props;

    ensurePermissions({ rolesFor: 'profileRoles' });

    const { userId }: UserEditorRouteParams = match.params;

    if (!userId) {
      editNewUser();
    } else {
      fetchUser(userId);
    }
  }

  public componentDidUpdate(previous: UserEditorProps) {
    const { ensurePermissions, fetchUser, saveNewUserDone, scope, history, match, updateUserDone } = this.props;

    const { userId }: UserEditorRouteParams = match.params;
    const { userId: oldUserId }: UserEditorRouteParams = previous.match.params;

    if (saveNewUserDone || updateUserDone) {
      history.push('/directory');
    } else if (
      userId !== oldUserId
      || scope.type !== previous.scope.type
      || scope.id !== previous.scope.id
    ) {
      ensurePermissions({
        forceReload: true,
        rolesFor: 'profileRoles',
      });

      if (userId) {
        fetchUser(userId);
      }
    }
  }

  public componentWillUnmount() {
    const { resetPermissions, resetScope } = this.props;
    resetPermissions();
    resetScope();
  }

  public render() {
    const {
      intl, rolesAndPermissionLoading, rolesAndPermissionError, userLoading, userState,
      account, saveStatus, isCreate, match,
    } = this.props;

    const { userId }: UserEditorRouteParams = match.params;

    const initialValues = this.convertUserToForm(userState.user);
    const decorators = [ observe(initialValues, checkRoleDecorator) ];
    if (isCreate && !userId) {
      decorators.push(observe(initialValues, checkEmailDecorator(this.props.fetchAvailableUser)));
    }

    return (
      <AsyncContent
        isLoading={rolesAndPermissionLoading || userLoading}
        isError={rolesAndPermissionError || userState.status.fetch === 'failed'}
        errorTitle={intl.formatMessage({
          id: (isCreate || !userId) ? 'user.error.create.title' : 'user.error.nouser.title',
        })}
        errorMessage={intl.formatMessage({
          id: (isCreate || !userId) ? 'user.error.create.message' : 'user.error.nouser.message',
        })}
      >
        <Form
          initialValues={initialValues}
          decorators={decorators}
          validateOnBlur={false}
          onSubmit={this.handleUserSubmit}
          mutators={{ ...arrayMutators }}
          validate={this.validateUser}
        >
          {(rprops: FormRenderProps) => (
            <UserForm
              {...rprops}
              isSelf={!isCreate && userState.user && userState.user.email === account.userName}
              isNew={isCreate || !userId}
              saveStatus={saveStatus}
              onCancel={this.handleCancel}
            />
          )}
        </Form>
      </AsyncContent>
    );
  }

  /**
   * Convert a regular User object to an UserData object better suited for the
   * form in renderForm(). Note undefined fields are set as empty strings to
   * help compute the pristine object.
   */
  private convertUserToForm = (user: Partial<User>): UserData => {
    const { roles, isCreate, match } = this.props;
    const { userId }: UserEditorRouteParams = match.params;
    return createEditableDataFromUser(userId, user, roles, isCreate);
  };

  /**
   * Convert a form UserData to a regular User
   */
  private convertFormToUser = (data: UserData): User => {
    const { isCreate, match } = this.props;
    const { userId }: UserEditorRouteParams = match.params;
    return createUserFromEditableData( data, userId, isCreate);
  };

  private handleUserSubmit = (values: any) => {
    const { addUser, isCreate, updateExistingUser } = this.props;
    const { user } = this.props.userState;
    const data = this.convertFormToUser(values);

    eventTracker.sendEvent({
      action: isCreate ? trackingEvents.addUser.action : trackingEvents.editUser.action,
      category: trackingCategory,
      label: isCreate ? trackingEvents.addUser.labels.createButton : trackingEvents.editUser.labels.saveButton,
    });

    if (isCreate) {
      addUser(data);
    } else {
      delete data.email;  // Updating am existing user fails if contains email
      updateExistingUser({ ...data, id: user.id });
    }
  };

  private handleCancel = () => {
    const { history, isCreate } = this.props;

    eventTracker.sendEvent({
      action: isCreate ? trackingEvents.addUser.action : trackingEvents.editUser.action,
      category: trackingCategory,
      label: isCreate ? trackingEvents.addUser.labels.cancelButton : trackingEvents.editUser.labels.cancelButton,
    });

    this.props.resetCurrentUser(0);
    history.push('/directory');
  }
}

export function mapStateToProps(state: State): UserEditorState {
  return {
    account: get(state, ['currentContext', 'user']),
    isCreate: currentUserSelectors.isNewUser(state),
    roles: state.profileRoles.roles,
    rolesAndPermissionError: rolesSelectors.getRolesAndPermissionError(state.profileRoles),
    rolesAndPermissionLoading:
      rolesSelectors.getRolesAndPermissionsLoading(state.profileRoles)
      || rolesSelectors.getRolesOrPermissionsEmpty(state.profileRoles),
    saveError: currentUserSelectors.hasFailed(state),
    saveNewUserDone: currentUserSelectors.createHasCompleted(state),
    saveStatus: currentUserSelectors.saveStatus(state),
    scope: state.scope,
    updateUserDone: currentUserSelectors.updateHasCompleted(state),
    userLoading: currentUserSelectors.isLoading(state),
    userState: state.currentUser,
  }
}

export const mapDispatchToProps = {
  addUser: currentUserActions.addNewUser.started,
  editNewUser: currentUserActions.editNewUser,
  ensurePermissions: rolesActions.ensurePermissions,
  fetchAvailableUser: availableUserActions.fetchAvailableUser.started,
  fetchUser: currentUserActions.fetchCurrentUser.started,
  resetCurrentUser: currentUserActions.resetCurrentUser.started,
  resetPermissions: rolesActions.clearPermissions,
  resetScope: scopeActions.resetOriginalScope,
  updateExistingUser: currentUserActions.updateExistingUser.started,
};

const UserEditorIntl = injectIntl(UserEditorImpl);
const UserEditor = connect<UserEditorState, UserEditorActions, {}>
  (mapStateToProps, mapDispatchToProps)(UserEditorIntl);

export { UserEditorImpl as PureUserEditor };
export default UserEditor;
