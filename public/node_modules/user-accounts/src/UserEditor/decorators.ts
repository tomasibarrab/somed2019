
import { debounceTime, map } from 'rxjs/operators';

import { UserData } from '../store/types';
import { BatchChanges, ChangesObservable, FormObservable } from '../utils/finalObserver';
import {
  isRoleGroupAllAccess,
  isRoleRestaurantAllAccess,
} from '../utils/rolesHelpers';

/**
 * Check if the ALL_ACCESS role is checked return un-check changes for all other roles in the form.
 * Return true when perform changes to any role checkbox.
 * @param existingValues
 * @param newValues
 */
export function rolesCheck(newValues: Partial<UserData>, existingValues: UserData): BatchChanges {
  const changes: BatchChanges = {};

  if (!newValues.rolesSet || !newValues.rolesSet.length) {
    return changes;
  }

  const groupAllAccessRole = newValues.rolesSet.find(isRoleGroupAllAccess);
  const restaurantAllAccessRole = newValues.rolesSet.find(isRoleRestaurantAllAccess);

  existingValues.rolesSet.forEach((roleSet, idx) => {
    // when Group AllAccess is set, unset ALL OTHER roles
    if (groupAllAccessRole && groupAllAccessRole.set) {
      if (roleSet.set && roleSet.urn !== groupAllAccessRole.urn) {
        changes[`rolesSet[${idx}].set`] = false;
      }
    } else if (
      // when Restaurant AllAccess is set, unset ALL OTHER RESTAURANT roles
      restaurantAllAccessRole
      && restaurantAllAccessRole.set
      && (!groupAllAccessRole || roleSet.urn.startsWith('urn:ot.groups.roles'))
    ) {
      if (roleSet.set && roleSet.urn !== restaurantAllAccessRole.urn) {
        changes[`rolesSet[${idx}].set`] = false;
      }
    }
  });

  return changes;
}

/**
 * Monitor changes in the Roles checkbox to ensure All-Access selection will disable
 * other roles.
 */
export const checkRoleDecorator = (action$: FormObservable<UserData>): ChangesObservable =>
  action$.pipe(
    map(data => rolesCheck(data.newValues, data.previousValues)),
  );

/**
 * Monitor changes in the email field to trigger an async call to check if the email is
 * available for a new user in the RID.
 */
export function checkEmailDecorator(fetchUser: (id: string) => void) {
  return (action$: FormObservable<UserData>): ChangesObservable =>
    action$.pipe(
      debounceTime(500),
      map(data => {
        // async check if no errors and email has changed...
        if (data.errors.email === undefined
          && data.newValues.email
          && data.newValues.email !== data.previousValues.email) {
          fetchUser(data.newValues.email);
        }
        // No changes to the form are required
        return {};
      }),
    );
}
