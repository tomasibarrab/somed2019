import { Button } from '@buffet/button';
import { InputWithIcon } from '@buffet/input';
import { Paginator } from '@buffet/paginator';
import { Panel } from '@buffet/panel';

import { AsyncContent } from 'gca-react-components';
import { Account } from 'gca-react-components/src/redux-modules/currentContext';

import queryString from 'query-string';

import { Action as HistoryAction, Location, UnregisterCallback } from 'history';
import debounce from 'lodash/debounce';
import get from 'lodash/get';
import React from 'react';
import { FormattedMessage, InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';
import { RouteComponentProps } from 'react-router-dom';

import { DropdownAlert } from '../common/DropdownAlert/DropdownAlert';
import { DROPDOWN_RESET_TIME, modalTypes } from '../constants';
import { actions as currentUserActions } from '../store/redux-modules/currentUser';
import { openModal } from '../store/redux-modules/modals';
import { actions as scopeActions } from '../store/redux-modules/scope';
import { actions as usersActions, selectors as usersSelectors } from '../store/redux-modules/users';
import { GuestCenterScope, SortOrder, SortParameters, State, User, UserState } from '../store/types';
import { getUserId, getUserTitle } from '../utils/appUtils';
import {
  userHasGroupAccess,
  userHasGroupProfile,
  userHasHigherLevelProfile,
} from '../utils/contextHelpers';
import { propsToQuerystring, sortedToProps } from '../utils/querystring-helpers';
import { eventTracker, trackingCategory, trackingEvents } from '../utils/trackingUtils';
import { HeaderCell, ItemCell } from './ItemCell';
import { ItemList, ItemListProps } from './ItemList';
import { SortControl } from './SortControl';
import UserRoles from './UserRoles';

import { headerButtonsContainer } from '../utils/styleUtils';
import './Directory.scss';


function UserList(p: ItemListProps<User>) {
  return <ItemList {...p} />
}

interface SearchQueryParams {
  q?: string;
  sort: string;
  order: SortOrder
  page: string;
}

interface DirectoryActions {
  confirmDelete: (payload: any) => void;
  ensureUsers: () => void;
  resetUser: (ms: number) => void;
  sortUsers: (s: SortParameters) => void;
  setSearchQuery: (sq: string) => void;
  selectPage: (page: number) => void;
  setScope: (context: string) => void;
}

interface DirectoryState {
  account: Account;
  appScope: GuestCenterScope;
  profileScope: GuestCenterScope;
  isGroupApp: boolean;
  users: User[];
  sorted?: any;
  currentUser: UserState<User>;
  usersFetchStatus: 'failed' | 'done' | 'started' | undefined;
  searchQuery: string;
  currentPage: number;
  totalPages: number;
}

interface DirectoryOwnState {
  searchValue: string;
}

type DirectoryProps =
  DirectoryState
  & DirectoryActions
  & InjectedIntlProps
  & RouteComponentProps<{}>;

class DirectoryImpl extends React.Component<DirectoryProps, DirectoryOwnState> {

  private unlisten: UnregisterCallback;

  constructor(p: DirectoryProps) {
    super(p);
    this.state = {
      searchValue: p.searchQuery,
    };

    this.setSearchFilter = debounce(this.setSearchFilter, 300);
  }

  public componentDidMount() {
    const {
      history, usersFetchStatus, ensureUsers, currentUser, resetUser, users,
      searchQuery, sorted, currentPage, // state from redux store
    } = this.props;

    const { q, sort, order, page } = this.getQueryParams();

    if (!q && !sort && !order && !page && (searchQuery || sorted || currentPage)) {
      const sortPar = sortedToProps(sorted);
      this.pushHistory(searchQuery, sortPar.sort, sortPar.order, currentPage);
    }

    if (q) {
      this.setState(state => ({ ...state, searchValue: q }));
      this.props.setSearchQuery(q);
    }

    if (sort) {
      this.props.sortUsers({ sort: sort || 'firstName', order: order || 'asc' });
    }

    if (page || page === '0') {
      this.props.selectPage(parseInt(page, 10));
    }

    this.unlisten = history.listen(this.onHistoryChanged);

    if (currentUser.status.save === 'create-done' || currentUser.status.save === 'update-done') {
      ensureUsers();
      resetUser(DROPDOWN_RESET_TIME);
    } else if ((!users || users.length === 0) && usersFetchStatus !== 'done') {
      ensureUsers();
    }
  }

  public componentWillUnmount() {
    this.unlisten();
  }

  public render() {
    const {
      account, appScope, isGroupApp, currentUser, usersFetchStatus, intl, users, currentPage, totalPages, resetUser,
    } = this.props;
    const { searchValue } = this.state;

    const dropMsgVisible = currentUser.status.save === 'create-done' || currentUser.status.save === 'update-done';
    const isLoading = usersFetchStatus === 'started';

    const disableClicks = isLoading || dropMsgVisible;

    return (
      <>
        <DropdownAlert
          type="success"
          drop={dropMsgVisible}
          onClose={() => resetUser(0)}
          msg={intl.formatMessage(
              {
                id: currentUser.status.save === 'create-done'
                  ? 'directory.list.createok'
                  : 'directory.list.updateok',
              },
            { firstName: currentUser.user.firstName, lastName: currentUser.user.lastName },
          )}
        />
        <Panel
          title={intl.formatMessage({ id: `directory.title.${appScope.type}` })}
          headerContent={
            <Button
              type="button"
              data-testid="adduser-button"
              className="adduser-button"
              theme="primary"
              size="large"
              onClick={this.handleAddUser}
            >
              <FormattedMessage id="directory.addUser" />
            </Button>
          }
          customHeaderStyle={headerButtonsContainer}
        >
          <div key="1" className="gca-header-search" >
            <InputWithIcon
              id="search-box"
              placeholder={intl.formatMessage({ id: 'directory.search.placeholder' })}
              type="text"
              value={searchValue || ''}
              onChange={this.handleSearchChange}
              autoFocus={true}
              valid={true}
            />
          </div>
          <AsyncContent
            isLoading={isLoading}
            isError={usersFetchStatus === 'failed'}
            errorTitle={intl.formatMessage({ id: 'userAccounts.errorTitle' })}
            errorMessage={intl.formatMessage({ id: 'userAccounts.errorMessage' })}
          >
            <>
            <UserList
              items={users}
              renderHeader={this.renderListHeader}
              activeId={currentUser.id}
              onItemClick={this.handleEditClick}
              clickableItem={(user) => {
                if (disableClicks) {
                  return false;
                }
                return !userHasHigherLevelProfile(user);
              }}
            >
            {(user, idx) => {
              const isLoggedInUser = account.userName.toLowerCase() === user.email.toLowerCase();
              const isGroupUser = userHasGroupProfile(user);
              const isHigherLevelUser = userHasHigherLevelProfile(user);

              return (
                <>
                  <ItemCell key={`${idx}.1`} title={`${user.firstName} ${user.lastName}`} testid={`name_${user.email}`}>
                    {user.firstName} {user.lastName}
                  </ItemCell>
                  <ItemCell key={`${idx}.2`} testid={`title_${user.email}`}>
                    <FormattedMessage id={`userAccounts.title.${getUserTitle(user.title)}`} />
                  </ItemCell>
                  <ItemCell key={`${idx}.3`} title={user.email}  testid={`email_${user.email}`}>
                    {user.email}
                  </ItemCell>
                  <ItemCell key={`${idx}.4`} testid={`phone_${user.email}`}>
                    {user.phone}
                  </ItemCell>
                  <ItemCell key={`${idx}.5`} testid={`roles_${user.email}`}>
                    { (isGroupApp || isGroupUser)
                      ? (
                          <FormattedMessage
                            id={userHasGroupAccess(user) ? 'userAccounts.group' : 'userAccounts.rest'}
                          />
                      )
                      : <UserRoles user={user} />
                    }
                  </ItemCell>
                  <ItemCell key={`${idx}.6`} testid={`actions_${user.email}`}>
                    { !isHigherLevelUser
                      ? (
                        <div className="buttons-col">
                          <Button
                            type="button"
                            key="edit"
                            data-testid={`edit-button-${user.id}`}
                            className={`edit-button-${getUserId(user.id)}`}
                            theme="link"
                            onClick={(e: any) => this.handleEditClick(user, e)}
                            disabled={disableClicks}
                          >
                            <FormattedMessage id="directory.list.editaction" />
                          </Button>
                          {!isLoggedInUser
                            ? <Button
                                type="button"
                                key="remove"
                                data-testid={`remove-button-${user.id}`}
                                className={`remove-button-${getUserId(user.id)}`}
                                theme="link"
                                onClick={(e: any) => this.handleDeleteClick(user, e)}
                                disabled={disableClicks}
                              >
                                <FormattedMessage id="directory.list.deleteaction" />
                              </Button>
                            : <div className="no-button-fill" />
                          }
                        </div>
                      )
                      : null
                    }
                  </ItemCell>
                </>
              );
            }}
            </UserList>
            <Paginator page={currentPage} totalPages={totalPages} selectPage={this.handlePagination} />
            </>
          </AsyncContent>
        </Panel>
      </>
    );
  }

  private getQueryParams = (): SearchQueryParams => {
    const { location } = this.props;
    return queryString.parse(location.search);
  };

  private getSortOrder = () => {
    const { sorted } = this.props;

    const sortBy = sorted ? Object.keys(sorted).pop() : undefined;
    if (sortBy) {
      return { sortBy, order: sorted[sortBy] };
    }

    return {};
  };

  private getArrowDirectionFor = (fieldName: string) => {
    const { sortBy, order } = this.getSortOrder();
    if (sortBy === fieldName) {
      return order === 'asc' ? 'up' : 'down';
    }

    return undefined;
  };

  private renderListHeader = (): React.ReactNode => {
    const { sortBy } = this.getSortOrder();
    const { isGroupApp } = this.props;

    return (
      <>
        <HeaderCell key="header.1">
          <span
            data-testid="sort-firstName-toggle"
            className={`sortable ${sortBy === 'firstName' ? 'active' : ''}`}
            onClick={this.handleKeySort('firstName')}
          >
            <FormattedMessage id="directory.list.name" />
          </span>
          <SortControl
            name="sort-firstName"
            onUp={this.handleKeySort('firstName', 'asc')}
            onDown={this.handleKeySort('firstName', 'desc')}
            active={this.getArrowDirectionFor('firstName')}
          />
        </HeaderCell>
        <HeaderCell key="header.2">
          <span
            data-testid="sort-title-toggle"
            className={`sortable ${sortBy === 'title' ? 'active' : ''}`}
            onClick={this.handleKeySort('title')}
          >
            <FormattedMessage id="directory.list.title" />
          </span>
          <SortControl
            name="sort-title"
            onUp={this.handleKeySort('title', 'asc')}
            onDown={this.handleKeySort('title', 'desc')}
            active={this.getArrowDirectionFor('title')}
          />
        </HeaderCell>
        <HeaderCell key="header.3">
          <span
            data-testid="sort-email-toggle"
            className={`sortable ${sortBy === 'email' ? 'active' : ''}`}
            onClick={this.handleKeySort('email')}
          >
            <FormattedMessage id="directory.list.email" />
          </span>
          <SortControl
            name="sort-email"
            onUp={this.handleKeySort('email', 'asc')}
            onDown={this.handleKeySort('email', 'desc')}
            active={this.getArrowDirectionFor('email')}
          />
        </HeaderCell>
        <HeaderCell key="header.4">
          <FormattedMessage id="directory.list.phone" />
        </HeaderCell>
        <HeaderCell key="header.5">
          <FormattedMessage id={isGroupApp ? 'directory.list.levelofaccess' : 'directory.list.roles'} />
        </HeaderCell>
        <HeaderCell key="header.6" />
      </>
    );
  };

  private onHistoryChanged = (location: Location, action: HistoryAction) => {
    if (action === 'POP') {
      const { q, sort, order, page } = this.getQueryParams();

      if (q) {
        this.setState(state => ({ ...state, searchValue: q }));
        this.props.setSearchQuery(q);
      }
      if (sort || order) {
        this.props.sortUsers({ sort: sort || 'firstName', order: order || 'asc' });
      }
      if (page || page === '0') {
        this.props.selectPage(parseInt(page, 10));
      }
    }
  };

  private handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    this.setState(state => ({ ...state, searchValue: value }));
    this.setSearchFilter();
  };

  /**
   * Debounced function triggering the actual search filtering the users in directory
   */
  private readonly setSearchFilter = () => {
    eventTracker.sendEvent({
      action: trackingEvents.searchUsers.action,
      category: trackingCategory,
      label: trackingEvents.searchUsers.labels.searchQuery,
    });

    this.props.setSearchQuery(this.state.searchValue);
    // get sorting props
    const sortPar = sortedToProps(this.props.sorted);
    // put params in url
    this.pushHistory(this.state.searchValue, sortPar.sort, sortPar.order, 0);
  };

  private handleKeySort = (key: string, order?: SortOrder) => () => {
    eventTracker.sendEvent({
      action: trackingEvents.searchUsers.action,
      category: trackingCategory,
      label: `${trackingEvents.searchUsers.labels.sortField} - ${key} - ${order || 'toggle'}`,
    });

    // get order from param or toggle existing order
    const sortOrder = order || (this.props.sorted[key] === 'asc' ? 'desc' : 'asc');
    // call sorting callback
    this.props.sortUsers({ sort: key, order: sortOrder });
    // put params in url
    this.pushHistory(this.props.searchQuery, key, sortOrder, 0);
  };

  private handlePagination = ({ selected }: { selected: number }) => {
    eventTracker.sendEvent({
      action: trackingEvents.searchUsers.action,
      category: trackingCategory,
      label: trackingEvents.searchUsers.labels.gotoPage,
      value: selected + 1,
    });

    this.props.selectPage(selected);
    // get sorting props
    const sortPar = sortedToProps(this.props.sorted);
    // put params in url
    this.pushHistory(this.state.searchValue, sortPar.sort, sortPar.order, selected);
  };

  private handleEditClick = (user: User, e?: React.SyntheticEvent<HTMLElement>) => {
    const { history, location, profileScope, setScope } = this.props;
    if (e) {
      e.stopPropagation();
    }

    eventTracker.sendEvent({
      action: trackingEvents.editUser.action,
      category: trackingCategory,
      label: trackingEvents.editUser.labels.editButton,
    });

    // if the user doesn't have a profile for the current context
    if (profileScope.context !== user.context) {
      // set that context before going to the edit page
      setScope(user.context!);
    }

    history.push(location.pathname + `/user/${user.urn || user.id}`);
  };

  private handleDeleteClick = (user: User, e?: React.SyntheticEvent<HTMLElement>) => {
    if (e) {
      e.stopPropagation();
    }

    eventTracker.sendEvent({
      action: trackingEvents.removeUser.action,
      category: trackingCategory,
      label: trackingEvents.removeUser.labels.removeDialog,
    });

    this.props.confirmDelete({
      modal: modalTypes.DELETE_USER,
      modalPayload: {
        firstName: user.firstName,
        id: user.id,
        lastName: user.lastName,
        type: this.props.appScope.type,
      },
    });
  };

  private handleAddUser = () => {
    const { history, location } = this.props;

    eventTracker.sendEvent({
      action: trackingEvents.addUser.action,
      category: trackingCategory,
      label: trackingEvents.addUser.labels.addButton,
    });

    history.push(location.pathname + '/user/new');
  };

  private pushHistory(q: string, sort: string, order: string, page: number) {
    this.props.history.push({
      pathname: this.props.location.pathname,
      search: propsToQuerystring({ order, q, sort, page }),
    });
  }
}

export function mapStateToProps(state: State): DirectoryState {
  return {
    account: get(state, ['currentContext', 'user'], {}),
    appScope: state.appScope,
    currentPage: state.users.currentPage,
    currentUser: state.currentUser,
    isGroupApp: state.appScope.type === 'group',
    profileScope: state.scope,
    searchQuery: state.users.searchQuery || '',
    sorted: state.users.currentSort,
    totalPages: Math.ceil(state.users.totalUsers / state.users.pageSize),
    users: state.users.users,
    usersFetchStatus: usersSelectors.fetchStatus(state),
  }
}

export const mapDispatchToProps = {
  confirmDelete: openModal,
  ensureUsers: usersActions.ensureUsers,
  resetUser: currentUserActions.resetCurrentUser.started,
  selectPage: usersActions.navigateUsers,
  setScope: scopeActions.setScopeFromContextUrn,
  setSearchQuery: usersActions.searchUsers,
  sortUsers: usersActions.sortUsers,
};

const DirectoryIntl = injectIntl(DirectoryImpl);
const Directory = connect<DirectoryState, DirectoryActions, {}>
  (mapStateToProps, mapDispatchToProps)(DirectoryIntl);

export default Directory;
export { DirectoryImpl as PureDirectory };
