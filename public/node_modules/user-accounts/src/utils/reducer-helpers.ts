import {
  GuestCenterScope,
  Role,
  User,
  UserProfile,
} from '../store/types';
import { isVisible } from './metaFilters';


export const transformArrayToObject =
  (arr: any[], key = 'id') => arr.reduce((obj, curr) => ({ [curr[key]]: curr, ...obj }), {});


/**
 * Add searchableText to each user producing an array of SearchableUsers
 */
export const indexUsers = (list: User[], scope: GuestCenterScope, roles: Role[]): User[] => {
  return list.map(indexUser(scope, roles));
};

/**
 * Make a single user searchable by adding the searchableText to it.
 */
const indexUser = (scope: GuestCenterScope, roles: Role[]) => (user: User): User => {
  return ({
    ...sortUsersRoles(flattenUserProfile(user, scope), roles),
    id: user.id || user.urn,
  });
};

/**
 * Extract the profile that matches the current context, OR get the first profile (if available),
 * then merges its content into the user data.
 * @param user input user to transform
 * @param scope main context the user was requested in
 */
export const flattenUserProfile = (user: User, scope?: GuestCenterScope): User => {
  if (!user.profiles || user.profiles.length === 0) {
    return user;
  } else {
    // contextUrn is injected in fetchCurrentUserEpic() from scope
    const context = scope ? scope.context : user.contextUrn;

    // TODO: always get the first profile (expected data should be sorted according to group hierarchy)
    const defaultProfile: any =
      // try to get exact context (for user details)
      (!scope && user.contextUrn && user.profiles.find(p => p.context === user.contextUrn))
      // try to get the group profile
      || user.profiles.find(p => p.context.startsWith('urn:ot.groups'))
      // fallback to matching-context profile
      || user.profiles.find(p => p.context === context)
      // default to first profile
      || user.profiles[0];

    // clean `null` values
    const defaultProfileValues: Partial<UserProfile> = Object.keys(defaultProfile)
      .filter((key: string) => defaultProfile[key] !== null)
      .map(key => ({ [key]: defaultProfile[key] }))
      .reduce((profileValues, value) => ({ ...profileValues, ...value }), {});

    // merge profile values with user values
    return { ...user, ...defaultProfileValues };
  }
};

/**
 * Sort and filter user roles according to the metadata available for each role in roles.
 * @param user User User containing Roles to sort and filter
 * @param sortedRoles Role[] Array of sorted Roles with metadata
 */
function sortUsersRoles(user: User, sortedRoles: Role[]) {
  const filteredRoles = user.roles
    ? sortedRoles
      .filter(fullRole => (user.roles!.includes(fullRole.urn) && isVisible(fullRole)))
      .map(fullRole => fullRole.urn)
    : [];

  const roles = filteredRoles.length ? filteredRoles : (user.roles || []);

  return {
    ...user,
    role: roles.length ? roles[0] : '',
    roles,
  };
}
