import isEqual from 'lodash/isEqual';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { InjectedIntl } from 'react-intl';

import { DROPDOWN_RESET_TIME, titleIds } from '../constants';
import { UserFormProps } from '../UserEditor/UserForm';

/**
 * Compute the pristine value for each field in the form.
 * Pristine means the value matches the initial value.
 */
export function computePristines(currentValues: any, initialValues: any): any {
  const pristines: any = {};
  Object.keys(currentValues).forEach(key => {
    pristines[key] = isEqual(currentValues[key], initialValues[key])
  });
  return pristines;
}

// Checks if all required properties of an object are truthy
export function allProps(object: any, properties?: string[]): boolean {
  const keysToCheck = properties || Object.keys(object);
  return !keysToCheck.some(p => !object[p]);
}

// Checks if at least one required property of an object is truthy
export function someProps(object: any, properties?: string[]): boolean {
  const keysToCheck = properties || Object.keys(object);
  return keysToCheck.some(p => object[p]);
}

// set roles titles as state, initialize it only once
export function useTitles(intl: InjectedIntl) {
  const [titles] = useState(() => {
    return titleIds.map((id: string) => ({
      label: intl.formatMessage({ id: `userAccounts.title.${id}` }),
      value: id,
    }));
  });

  return titles;
}

interface DisabledSections {
  disableEmail: boolean;
  disableRoles: boolean;
  disableUserInfo: boolean;
}

  // logic to enable/disable UserInfo and Roles sections
export function useDisabledSections({
  availableHasRidOrProfile,
  availableIsLoaded,
  availableIsLoading,
  errors,
  initialValues,
  isSelf,
  saveStatus,
  values,
}: Partial<UserFormProps>): DisabledSections {
  // logic to enable/disable email field
  const disableEmail = saveStatus === 'started';

  // marks a loading state or an existing user profile
  const isLoadingOrExisting = (
    saveStatus === 'started'
    || availableIsLoading
    || (availableIsLoaded && availableHasRidOrProfile)
  );
  // errors & pristine fields
  const emailError = allProps(errors, ['email']);
  const userInfoErrors = someProps(errors, ['email', 'firstName', 'lastName', 'phone', 'title']);
  const pristines = computePristines(values, initialValues);
  const pristineUserInfo = allProps(pristines, ['firstName', 'lastName', 'phone', 'title']);
  const pristineRoles = allProps(pristines, ['rolesSet']);

  // logic to enable/disable userInfo and roles sections
  const disableUserInfo = isLoadingOrExisting || (emailError && pristineUserInfo);
  const disableRoles = isLoadingOrExisting || isSelf || (userInfoErrors && pristineRoles);

  return {
    disableEmail,
    disableRoles,
    disableUserInfo,
  };
}

type SubmitHandler = (event?: React.SyntheticEvent<HTMLFormElement>) => void;
interface SubmitHandlerProps {
  canShowDropdownError: boolean;
  hideDropdownError: () => void;
  getSubmitHandler: (originalHandler: SubmitHandler) => SubmitHandler;
  submitAttempted: boolean;
}

// altered form submit handler & submit states
export function useSubmitHandler({
  errors,
  saveStatus,
}: Partial<UserFormProps>): SubmitHandlerProps {
  const failedOrErrors = saveStatus === 'failed' || someProps(errors);

  // show an error dropdown when submit failures are present
  const [canShowDropdownError, setCanShowDropdownError] = useState(false);
  const timerId = useRef<number>();
  useEffect(() => {
    if (!timerId.current && canShowDropdownError && failedOrErrors) {
      // set a timeout to hide the error
      timerId.current = window.setTimeout(() => {
        timerId.current = undefined;
        setCanShowDropdownError(false);
      }, DROPDOWN_RESET_TIME);
    }
  }, [canShowDropdownError, failedOrErrors]);

  // ensure timeout is cleared on component unmount
  useEffect(() => () => clearTimeout(timerId.current), []);

  function hideDropdownError() {
    clearTimeout(timerId.current);
    timerId.current = undefined;
    setCanShowDropdownError(false);
  }

  // keep the status of form submission
  const [submitAttempted, setSubmitAttempted] = useState(false);

  // overwrite the passed submit handler
  const getSubmitHandler = useCallback((originalHandler: SubmitHandler): SubmitHandler => {
    return (event) => {
      // update local state when form is submitted
      setSubmitAttempted(true);
      setCanShowDropdownError(true);
      // call the original submit handler
      originalHandler(event);
    }
  }, []);

  return {
    canShowDropdownError: canShowDropdownError && failedOrErrors,
    getSubmitHandler,
    hideDropdownError,
    submitAttempted,
  };
}
