# asyncStateReducer

This is a reducer generator for async fetched data.

The function takes as arguments two parameters:
- an `asyncAction` created with `actionCreatorFactory().async<...>(...)` from `typescript-fsa`
- a function which maps the response from the async call to the data you want to store

The result is a generated reducer that will take care of setting the state in the store.

By default, the produced state is an object with 3 properties:
- `status` - the status of the request
- `data`* - the data retrieved from the response and mapped with the passed function (as second argument)
- `error`* - if the request failed, the error details will be here

\* `data` is only set if the `status` is `done`

\* `error` is only set if the `status` is `failed`

The reducer generator also takes an optional 3rd string argument, if you want to override the property where the final data is stored
(i.e. use your own naming instead of `data`).

All types ar inferred automatically.

## Basic use

```tsx
import { actionCreatorFactory } from 'typescript-fsa';

import { asyncStateReducer, AsyncState } from 'shared-react-utils/asyncStateReducer';

// create the async action with your own types
const createAction = actionCreatorFactory();
const asyncAction = createAction.async<PayloadType, ResponseType, ErrorType>('ACTION_NAME');

// define your async state type
type StoreAsyncState = AsyncState<SomeDataType>;

// generate the reducer
export const reducer = asyncStateReducer(
    asyncAction,
    payload => payload.result.someData,
);

```

...where:
- `PayloadType`, `ResponseType`, `ErrorType` and `SomeDataType` are your own
- `SomeDataType` is the final type of the data you will store (can be a primitive or anything you want)
- second argument (the mapping function) is a map from `ResponseType` to `SomeDataType`


Because you passed `asyncAction`, you'll get full autocomplete in the mapping function's payload, based on the `ResponseType`
(`payload` is automatically inferred as `Success<PayloadType, ResponseType>`, so `payload.result` is of type `ResponseType`).

##### !!! NOTE

This is just a reducer generator. You're still fully responsible for creating the epics of your async action:

```tsx
const asyncActionEpic: Epic = (action$, store, { api }) =>
  action$
    .filter(asyncAction.started.match)
    .switchMap(({ payload }) =>
      api.fetchSomeAsyncStuff(payload)
        .flatMap(result => [
          asyncAction.done({ params: payload, result }),
        ])
        .catch(error => [
          asyncAction.failed({ params: payload, error }),
        ])
    );
     
```

## Using selectors

Using selectors works as expected, with full type completion: 

```tsx
import { createSelector } from 'reselect';

//...

const baseSelector = (state: GlobalState) => state.myAsyncState; // GlobalState => StoreAsyncState

const isLoading = createSelector(
  baseSelector,
  state => state.status === 'started', // StoreAsyncState => boolean
);

const asyncData = createSelector(
  baseSelector,
  state => state.data, // StoreAsyncState => SomeDataType | undefined
);

```

## Custom data property name

As mentioned, you can pass a third argument to customize the name of the property holding your data.

Just make sure you use the same name when defining the type of your async state.

```tsx
// define your async state type
type StoreAsyncState = AsyncState<SomeDataType, 'myOwnProp'>;

// generate the reducer
export const reducer = asyncStateReducer(
    asyncAction,
    payload => payload.result.someData,
    'myOwnProp',
);

```

Now everything works as expected, but your async data is under the `myOwnProp` property:

```tsx
const asyncData = createSelector(
  baseSelector,
  state => state.myOwnProp, // full autocomplete here; SomeDataType | undefined
);
```
