import {
  cleanup,
  fireEvent,
  queryByText,
  render,
  wait,
} from '@testing-library/react';
import React from 'react';
import { IntlProvider } from 'react-intl';
import { MemoryRouter } from 'react-router';
import Login from './Login';

jest.mock('../common/api');
import * as messages from '../translations/json/en-us.json';

export default function getIntl() {
  // Create the IntlProvider to retrieve context for wrapping around.
  const intlProvider = new IntlProvider({ locale: 'en-us', messages }, {});
  return intlProvider.getChildContext().intl;
}

afterEach(cleanup)

// tslint:disable-next-line
const consoleError = console.error;
beforeAll(() => {
  jest.spyOn(console, 'error').mockImplementation((...args) => {
    if (!args[0].includes('Warning: An update to %s inside a test was not wrapped in act')) {
      consoleError(...args);
    }
  });
});

describe('Login component', () => {
  const onSubmit = jest.fn();
  const handleSubmit = jest.fn();

  const props = {
    handleSubmit,
    intl: getIntl(),
    isSubmitting: false,
    messages,
    onSubmit,
  };

  const renderTree = (node) => {
    return <IntlProvider locale="en" messages={messages}>
      <MemoryRouter initialEntries={['/']} >
        {node}
      </MemoryRouter>
    </IntlProvider>
  };

  const rendererWithIntl = node => render(renderTree(node));

  const history: any = jest.fn();
  history.location = jest.fn();

  const location: any = jest.fn();
  const match: any = jest.fn();

  const commonProps = { history, location, match }

  it('Login and Password input fields are displayed when the page is loaded', () => {

    const { getByTestId } = rendererWithIntl(<Login {...commonProps} {...props} />);
    expect(getByTestId('user-name-text-input')).toBeDefined();
    expect(getByTestId('password-text-input')).toBeDefined();
    expect(getByTestId('submit-button')).toBeDefined();
  });

  it('Both error message appear if login and password input fields are empty', () => {
    const { getByTestId } = rendererWithIntl(<Login  {...commonProps} {...props} />);
    fireEvent.click(getByTestId('submit-button'));
    const emailErrorPanel: any = getByTestId('user-name-text-input').nextElementSibling;
    expect(emailErrorPanel).toBeDefined();
    expect(queryByText(emailErrorPanel, 'Please enter a valid email address.')).not.toBeNull();
    const passwordErrorPanel: any = getByTestId('password-text-input').nextElementSibling;
    expect(passwordErrorPanel).toBeDefined();
    expect(queryByText(passwordErrorPanel, 'Please complete all fields.')).not.toBeNull();
  });

  it('Error message appears  password input field is empty', () => {
    const { getByTestId } = rendererWithIntl(<Login  {...commonProps} {...props} />);
    fireEvent.click(getByTestId('submit-button'));
    const passwordErrorPanel: any = getByTestId('password-text-input').nextElementSibling;
    expect(passwordErrorPanel).toBeDefined();
    expect(queryByText(passwordErrorPanel, 'Please complete all fields.')).not.toBeNull();
  });


  it('Client side validation error appears if username is incorrect email', () => {
    const { getByTestId } = rendererWithIntl(<Login  {...commonProps} {...props} />);
    fireEvent.click(getByTestId('submit-button'));
    const emailErrorPanel: any = getByTestId('user-name-text-input').nextElementSibling;
    expect(emailErrorPanel).toBeDefined();
    expect(queryByText(emailErrorPanel, 'Please enter a valid email address.')).not.toBeNull();
  });

  test('Error message appears if server response with error', async () => {
    const { getByTestId } = rendererWithIntl(<Login  {...commonProps} {...props} />);
    const usernameElm = getByTestId('user-name-text-input');
    fireEvent.change(usernameElm, { target: { value: 'erroruser@opentable.com' } });
    const passwordElm = getByTestId('password-text-input');
    fireEvent.change(passwordElm, { target: { value: 'secret' } });
    fireEvent.click(getByTestId('submit-button'));
    await wait(() => getByTestId('errorMessage'));
    const errorPanel = getByTestId('errorMessage');
    // the mocked api call located at /common/__mocks__/api is invoked with the fake error message
    expect(queryByText(errorPanel, 'ERROR MESSAGE HERE')).not.toBeNull();
  });

  test('Succeseful login user with recaptcha', async () => {

    let redirectUrl;

    const grecaptcha: any = (window as any).grecaptcha = {};
    document.location.assign = (param) => { redirectUrl = param };
    grecaptcha.refreshRecaptchaTokens = () => {
      setTimeout(() => {
        grecaptcha.tokensReadyCallback('tokenV2-valid', 'tokenV3-valid');
      }, 100);
    }
    const { getByTestId } = rendererWithIntl(<Login  {...commonProps} {...props} />);
    const usernameElm = getByTestId('user-name-text-input');
    fireEvent.change(usernameElm, { target: { value: 'user@needrecaptcha.net' } });
    const passwordElm = getByTestId('password-text-input');
    fireEvent.change(passwordElm, { target: { value: 'secret' } });
    fireEvent.click(getByTestId('submit-button'))
    await wait(() => expect(redirectUrl).toBeDefined());
    expect(redirectUrl === '/postlogin').toBeTruthy();
  });
});
