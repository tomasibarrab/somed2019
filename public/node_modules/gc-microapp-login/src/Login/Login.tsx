// tslint:disable:object-literal-sort-keys
import React, { useContext, useEffect, useState } from 'react';
import { InjectedIntlProps, injectIntl } from 'react-intl';
import { Route, RouteComponentProps, Switch } from 'react-router-dom';
import { AsyncProgress, useAsync } from 'shared-react-utils/useAsync';

import * as api from '../common/api';
import { ConnectionLostCtx } from '../common/App/App';
import { Routes } from '../common/App/routes';
import { ErrorCode, LoginRequest, LoginResponse, Message, MessageType, RegisterPhoneRequest } from '../common/types';
import { ResultStatus } from '../common/types';
import { RegisterPhone } from '../RegisterPhone/RegisterPhone';
import { VerifyCode } from '../VerifyCode/VerifyCode';
import { EnterCredentials } from './EnterCredentials';

type LoginProps = InjectedIntlProps & RouteComponentProps<any>;

const loginSuccess = (loginResp: LoginResponse): boolean => !!loginResp.redirectUrl;

export function Login({ intl, history }: LoginProps) {
  const [loginCredentials, setLoginCredentials] = useState({ username: '', password: '' });
  const [cellphone, setCellphone] = useState('');
  const [loginStatus, loginApi] = useAsync(api.login);
  const [waitForRecapture, setWaitForRecapture] = useState(false);
  const showConnectionLostModal = useContext(ConnectionLostCtx);
  const [message, setMessage] = React.useState<Message>();

  // temporary solution for fixing the problem with /#/change-password that is
  // actual duting the A/B testing EXPERIMENT. Remove when it is done
  useEffect(() => {
    const prefix = '#/change-password/';
    if (window.location.hash) {
      const hash = window.location.hash;
      if (hash.startsWith(prefix)) {
        history.replace(hash.split('#')[1]);
      }
    }
  }, []);

  useEffect(() => {
    const infoMessage = history.location.state
      ? history.location.state.message
      : undefined;
    if (infoMessage !== message) {
      setMessage(infoMessage);
    }
  }, [history.location.state && history.location.state.message]);

  const displayError = React.useCallback((errorMessage: string): void => setMessage({
    text: errorMessage,
    type: MessageType.error,
  }), []);

  const proceedWithRecaptcha = React.useCallback((values: LoginRequest, errorMessage: string) => {
    const grecaptcha = (window as any).grecaptcha;
    if (grecaptcha) {
      // register the callback to receive the recaptacha tokens
      grecaptcha.tokensReadyCallback = ((recaptchaTokenV2: string, recaptchaTokenV3: string) => {
        setWaitForRecapture(false);
        handleLogin({ ...values, recaptchaTokenV2, recaptchaTokenV3 });
      });
      // initialize the recaptcha tokens generation
      setWaitForRecapture(true);
      grecaptcha.refreshRecaptchaTokens();
    } else {
      displayError(errorMessage);
    }
  }, []);

  const handleError = React.useCallback((loginResp: LoginResponse, values: LoginRequest) => {
    const errorMessage: string = loginResp.errorMessages ? loginResp.errorMessages[0]
      : intl.formatMessage({ id: 'ErrorProcessingRequest' });
    if (loginResp.resultStatus === ResultStatus.credentialsLockedOut) {
      history.push(Routes.ResetPassword, { email: values.username, errorMessage });
    } else if (loginResp.errorCode === ErrorCode.needsRegistration) {
      setLoginCredentials(values);
      history.push(Routes.RegisterPhone);
    } else if (loginResp.errorCode === ErrorCode.codeNeeded) {
      setCellphone(loginResp.cellphone);
      setLoginCredentials(values);
      history.push(Routes.VerifyCode);
    } else if (loginResp.errorCode === ErrorCode.recaptchaRequired) {
      proceedWithRecaptcha(values, errorMessage);
    } else {
      displayError(errorMessage);
    }
  }, [displayError, proceedWithRecaptcha]);

  const handleConnectionFail = React.useCallback(() => {
    showConnectionLostModal();
  }, []);

  const handleLoginResponse = React.useCallback((
    loginResp: LoginResponse,
    values: LoginRequest | RegisterPhoneRequest,
  ): void => {
    if (loginSuccess(loginResp)) {
      location.assign(loginResp.redirectUrl);
    } else {
      handleError(loginResp, values);
    }
  }, [handleError]);

  // this a function to resolve the cycle dependency
  function handleLogin(values: LoginRequest) {
    setMessage(undefined);
    loginApi(values)
      .then((loginResp: LoginResponse) => {
        handleLoginResponse(loginResp, values)
      })
      .catch(err => {
        // tslint:disable-next-line
        console.error(err);
        handleConnectionFail();
      });
  };

  const inProgress = loginStatus.progress === AsyncProgress.Started || waitForRecapture;

  const enterCredentialsParams = {
    intl,
    message,
    handleLogin,
    inProgress,
  }
  const registerPhoneParams = {
    intl,
    message,
    handleLoginResponse,
    loginCredentials,
    handleConnectionFail,
  }
  const verifyCodeParams = {
    intl,
    message,
    cellphone,
    handleLogin,
    handleLoginResponse,
    inProgress,
    loginCredentials,
    setMessage,
    handleConnectionFail,
  }

  return (
    <Switch>
      <Route
        exact
        path={Routes.RegisterPhone}
        render={() => <RegisterPhone {...registerPhoneParams} />}
      />
      <Route
        exact
        path={Routes.VerifyCode}
        render={() => <VerifyCode {...verifyCodeParams} />}
      />
      <Route
        exact
        path={Routes.Login}
        render={() => (<EnterCredentials {...enterCredentialsParams} />)}
      />
    </Switch>
  );
}
export default injectIntl(Login);
