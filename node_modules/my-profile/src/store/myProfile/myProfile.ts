import {
  CurrentContextAsyncStatus,
  FETCH_CURRENT_CONTEXT_SUCCESS,
  selectors as currentContextSelectors,
} from 'gca-react-components/src/redux-modules/currentContext';
import { CurrentContext } from 'gca-react-components/src/redux-modules/currentContext.d';
import merge from 'gca-react-components/src/utils/merge';
import { combineEpics } from 'redux-observable';
import { Action, actionCreatorFactory, Success } from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';
import AsyncStatus from '../../AsyncStatus';
import '../commonRxjs';
import {
  Epic,
  State,
  Store,
} from '../types';


// ---------------------------------------------------------------------------------------------------------------------
// types
// ---------------------------------------------------------------------------------------------------------------------

interface Indexable {
  [index: string]: any
}

export interface BasicUser {
  email: string,
  rid: number;
}

export interface FormData extends Indexable {
  email?: string;
  firstName?: string;
  lastName?: string;
  title?: string;
  phone?: string;
}

export interface UserDTO extends FormData, Indexable {
  countryCode?: string;
  id?: string;
  product?: string;
  roles?: string[];
  userType?: string;
  status?: string;
  rid?: number;
}

export interface MyProfileState {
  fetchUserStatus: AsyncStatus;
  updateUserStatus: AsyncStatus;
  previousUser: UserDTO | null;
  user: UserDTO | null;
}


// ---------------------------------------------------------------------------------------------------------------------
// actions
// ---------------------------------------------------------------------------------------------------------------------

const actionCreator = actionCreatorFactory();

export const fetchUser = actionCreator.async<BasicUser, UserDTO, {}>('FETCH_USER');
export const updateUser = actionCreator.async<FormData, {}, {}>('UPDATE_USER');
export const resetUpdateUser = actionCreator('RESET_UPDATE_USER');

export const actions = {
  fetchUser,
  updateUser,
  // tslint:disable-next-line:object-literal-sort-keys
  resetUpdateUser,
};


// ---------------------------------------------------------------------------------------------------------------------
// selectors
// ---------------------------------------------------------------------------------------------------------------------

function getFetchUserStatus(state: State): AsyncStatus {
  return state.myProfile.fetchUserStatus;
}

function getUpdateUserStatus(state: State): AsyncStatus {
  return state.myProfile.updateUserStatus;
}

/**
 * Internal guard selector for updateUserEpic
 */
function getUser(state: State): UserDTO {
  if (!state.myProfile.user) {
    throw new Error('User not defined');
  }

  return state.myProfile.user;
}

export const selectors = {
  getFetchUserStatus,
  getUpdateUserStatus,
};


// ---------------------------------------------------------------------------------------------------------------------
// epics
// ---------------------------------------------------------------------------------------------------------------------

export const triggerFetchUserEpic: Epic = (action$, store) =>
  action$.ofType(FETCH_CURRENT_CONTEXT_SUCCESS)
    .map(() => (
      {
        email: currentContextSelectors.user(store.getState()).userName,
        rid: currentContextSelectors.user(store.getState()).rid,
      }
    ))
    .map((basicUser: BasicUser) => fetchUser.started(basicUser));

export const fetchUserEpic: Epic = (action$, store, { api }) =>
  action$.filter(fetchUser.started.match)
    .mergeMap(({ payload }: Action<BasicUser>) => api
      .fetchUser(payload.email, payload.rid)
      .map((user: UserDTO) => fetchUser.done(
        {
          params: payload,
          result: { ...user, product: currentContextSelectors.currentContext(store.getState()).productType },
        },
      ))
      .catch(err => [fetchUser.failed({ params: payload, error: err })]),
  );

export const updateUserEpic: Epic = (action$, store, { api }) =>
  action$.filter(updateUser.started.match)
    .mergeMap(({ payload }: Action<FormData>) => api
      .updateUser({ ...getUser(store.getState()), ...payload })
      .map(() => updateUser.done({ params: payload, result: {} }))
      .catch(err => [updateUser.failed({ params: payload, error: err })]),
  );

/**
 * If the user has changed the email they will no longer be properly logged-in, so re-direct them to the login screen
 */
export const updateUserDoneEpic: Epic = (action$, store) =>
  action$.filter(updateUser.done.match)
    .filter(({ payload }) => {
      const previousUser = store.getState().myProfile.previousUser;
      const previousEmail = previousUser && previousUser.email;

      if (previousEmail !== payload.params.email) {
        window.location.assign('/login');
      }

      // :TRICKY: return false to prevent infinitely re-dispatching the done action
      return false;
    });

export const myProfileEpic = combineEpics(
  fetchUserEpic,
  triggerFetchUserEpic,
  updateUserEpic,
  updateUserDoneEpic,
);


// ---------------------------------------------------------------------------------------------------------------------
// reducer
// ---------------------------------------------------------------------------------------------------------------------

export const initialState: MyProfileState = {
  fetchUserStatus: AsyncStatus.Initial,
  updateUserStatus: AsyncStatus.Initial,
  // tslint:disable-next-line:object-literal-sort-keys
  previousUser: null,
  user: null,
}

export const myProfileReducer = reducerWithInitialState(initialState)
  .case(fetchUser.started, state => ({ ...state, fetchUserStatus: AsyncStatus.Started }))
  .case(fetchUser.done, (state: MyProfileState, { params, result }: Success<BasicUser, UserDTO>) => (
    { ...state, fetchUserStatus: AsyncStatus.Done, user: { ...result } }
  ))
  .case(fetchUser.failed, state => ({ ...state, fetchUserStatus: AsyncStatus.Failed }))
  .case(updateUser.started, state => (
    { ...state, updateUserStatus: AsyncStatus.Started, previousUser: { ...state.user } }
  ))
  .case(updateUser.done, (state: MyProfileState, { params, result }: Success<FormData, {}>) => (
    { ...state, updateUserStatus: AsyncStatus.Done, user: { ...state.user, ...params } }
  ))
  .case(updateUser.failed, state => ({ ...state, updateUserStatus: AsyncStatus.Failed }))
  .case(resetUpdateUser, state => ({ ...state, updateUserStatus: AsyncStatus.Initial }))
