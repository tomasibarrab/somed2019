import { fromJS } from 'immutable';
import { safeGet } from './safeGet';

describe('SafeGet Util', () => {
  const regularObject = {
    shallow: 'shallow-string',
    deeplyNested: {
      nest: {
        it: {
          deep: 'deeply-nested-string',
        },
      },
    },
  };

  const immutableObject = fromJS(regularObject);

  const mixedObject = immutableObject.setIn(['deeplyNested', 'nest'], {
    it: {
      deep: 'deeply-nested-string',
    }
  });

  describe('Regular Objects', () => {
    it('Returns undefined when the path does not exist for regular Objects', () => {
      expect(safeGet(regularObject, ['not-a-real-path'])).toEqual(undefined);
      expect(safeGet(regularObject, ['not', 'a', 'real', 'path'])).toEqual(undefined);
    });

    it('Handles shallow access for regular Objects', () => {
      expect(safeGet(regularObject, ['shallow'])).toEqual('shallow-string');
    });

    it('Handles deep access for regular Objects', () => {
      const path = ['deeplyNested', 'nest', 'it', 'deep'];
      expect(safeGet(regularObject, path)).toEqual('deeply-nested-string');
    });
  });

  describe('Immutable Objects', () => {
    it('Returns undefined when the path does not exist for immutable Objects', () => {
      expect(safeGet(immutableObject, ['not-a-real-path'])).toEqual(undefined);
      expect(safeGet(immutableObject, ['not', 'a', 'real', 'path'])).toEqual(undefined);
    });

    it('Handles shallow access for immutable Objects', () => {
      expect(safeGet(immutableObject, ['shallow'])).toEqual('shallow-string');
    });

    it('Handles deep access for immutable Objects', () => {
      const path = ['deeplyNested', 'nest', 'it', 'deep'];
      expect(safeGet(immutableObject, path)).toEqual('deeply-nested-string');
    });
  });

  describe.skip('Mixed Objects', () => {
    it('Returns undefined when the path does not exist for mixed Objects', () => {
      expect(safeGet(mixedObject, ['not-a-real-path'])).toEqual(undefined);
      expect(safeGet(mixedObject, ['not', 'a', 'real', 'path'])).toEqual(undefined);
    });

    it('Handles shallow access for mixed Objects', () => {
      expect(safeGet(mixedObject, ['shallow'])).toEqual('shallow-string');
    });

    it('Handles deep object access for mixed Objects', () => {
      const path = ['deeplyNested', 'nest'];
      expect(safeGet(mixedObject, path)).toEqual({
        it: {
          deep: 'deeply-nested-string',
        }
      });
    });

    it('Handles deep access for mixed Objects', () => {
      const path = ['deeplyNested', 'nest', 'it', 'deep'];
      expect(safeGet(mixedObject, path)).toEqual('deeply-nested-string');
    });
  });
});
