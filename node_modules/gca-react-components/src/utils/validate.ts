/**
 * Validator functions and related utilities. Also includes a factory to create a form validator.
 *
 * General form of a validator is a function which consumes a form value and returns `undefined` for valid values, and a
 * string in the form of a localized value key if there is an error.
 *
 * Usage: recommend this module be imported as `import * as validate from 'gca-react-components/src/utils/validate'`.
 * Then individual validators, functions can be referenced as `validate.compose()`, `validate.create()`, etc.
 */

// Errors are reported as string values or array of string values. If there is no error, an error will be `undefined`
export type ValidationError = string | string[] | undefined;
export type Validator<T> = (value: T) => ValidationError;
export type StringValidator =  Validator<string | undefined>;
export interface ErrorMap { [id: string]: ValidationError };
export interface ValueMap { [id: string]: any };
export interface ValidatorsMap { [id: string]: Validator<any> };
export type FormValidator = (values: ValueMap) => ErrorMap; // returns a map of errors

/**
 * Create a composed validator which will execute all passed in validators for a provided value. Will return the first
 * error encountered, or `undefined` if none of the validators evaluate to invalid.
 */
export const compose = (...validators: Validator<any>[]): Validator<any> => (value: any): ValidationError =>
  validators.reduce((error: ValidationError, validator: Validator<any>) => error || validator(value), undefined);

/**
 * Required field validation. Value must not be `undefined` or empty string to pass.
 */
export const required = (err?: string): Validator<any> =>
  (value: any): ValidationError =>
    value !== undefined && value !== '' ? undefined : err || 'validate.required';

/**
 * RegEx validator factory function
 *
 * @param {regex} a regular expression to test a string against
 * @param {string} errorMessage an error message key
 */
export function regEx(regex: RegExp, errorMessage: string): StringValidator {
  return (value: string | undefined): ValidationError => (!value || !regex.test(value))
    ? errorMessage
    : undefined;
}

//
// regex source: http://emailregex.com/
// based on: RFC 5322
//
// tslint:disable-next-line:max-line-length
const emailRegEx = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

/**
 * Email validation factory function.
 * Must not be falsy, and must pass RegEx pattern for email.
 *
 * @param {string} errorMessage (optional) an error message key
 * @return {StringValidator} a validator which will check for a syntactically correct email
 */
export const email = (err: string | undefined): StringValidator => regEx(emailRegEx, err || 'validate.email');

/**
 * Min chars validator factory function
 *
 * @param {number} min string passed to validator will be valid if greater than or equal to this value
 * @param {string} errorMessage (optional) an error message key
 * @return {StringValidator} a validator which will check for the specified min number of characters
 */
export const minChars = (min: number, err?: string): StringValidator => {
  return (value: string | undefined): ValidationError => (!value || value.length < min)
    ? err || 'validate.minChars'
    : undefined;
}

/**
 * Max chars validator factory function
 *
 * @param {number} max string passed to validator will be valid if less than or equal to this value
 * @param {string} errorMessage (optional) an error message key
 * @return {StringValidator} a validator which will check for the specified max number of characters
 */
export const maxChars = (max: number, err?: string): StringValidator => {
  return (value: string | undefined): ValidationError => (value !== '' && (!value || value.length > max))
    ? err || 'validate.maxChars'
    : undefined;
}

/**
 * Form validator factory function.
 *
 * @param {ValidatorsMap} validators a map of `Validator`s whose keys should correspond to named form fields
 * @return {FormValidator} a function called with a map of field values which returns a corresponding map of errors if
 *  there are any, or any empty object if there are no errors
 */
export function create(validators: ValidatorsMap): FormValidator {
  return (values: ValueMap): ErrorMap => Object.keys(validators)
    .reduce((errors: ErrorMap, valueKey: string) => {
        const error: ValidationError = validators[valueKey](values[valueKey]);
        if (error) {
          errors[valueKey] = error;
        }
        return errors;
      },
      { },
    );
}
