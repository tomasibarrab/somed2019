import React from 'react';
import request from 'superagent';
import { AsyncState } from './types/AsyncState';
import { getScope, Scope } from '@buffet/scope-service';
import { enforceGlobalSingleton } from '@buffet/utils';

export interface Restaurant {
  address: Address;
  availabilitySettingsSectionEnabled: boolean;
  billingPhoneNumber: null;
  bookingInterval: number;
  createdBy: null;
  creationDate: string;
  errorCodes: any[];
  firstModifiedDateSinceLastPublish: string;
  hasRestaurantGoneLive: boolean;
  hasUnpublishedChanges: boolean;
  id: string;
  isAnalyticsEnabled: boolean;
  isClaimedListing: boolean;
  isConnectRestaurant: boolean;
  isERB: boolean;
  isGuestBridge: boolean;
  isGuestCenterRestaurant: boolean;
  isOffline: boolean;
  isRestaurantApi: boolean;
  isTestRestaurant: boolean;
  isUncreated: boolean;
  largePartyMinSize: number;
  lastPublishDate: string;
  lastPublishStatus: null;
  lastUpdatedBy: null;
  lastUpdatedDate: string;
  locale: string;
  lockoutEnabled: boolean;
  name: string;
  partySizeAvailabilityControlsEnabled: boolean;
  passcodeEnabled: boolean;
  passcodeSettings: null;
  pendingProductType: null;
  productType: string;
  restaurantSetupId: null;
  restaurantStatus: null;
  rid: number;
  setupWizard: SetupWizard;
  timeElapsedSinceLastPublishMinutes: null;
  timeZone: string;
  timestamp: number;
}
interface Address {
  city: string;
  country: string;
  countryCode: string;
  postalCode: null;
  province: null;
  provinceCode: string;
  street1: null;
  street2: null;
}
interface SetupWizard {
  wizardSteps: WizardSteps;
}
interface WizardSteps {
  calendar: Calendar;
  combinations: Combinations;
  floorPlan: FloorPlan;
  publish: Publish;
  shift: Shift;
}
interface Calendar {
  errorCodes: ErrorCodes;
  stepHasErrors: boolean;
  stepName: string;
  topLevelErrorCodes: any[];
}
interface ErrorCodes {}
interface Combinations {
  errorCodes: ErrorCodes;
  stepHasErrors: boolean;
  stepName: string;
  topLevelErrorCodes: any[];
}
interface FloorPlan {
  errorCodes: ErrorCodes;
  stepHasErrors: boolean;
  stepName: string;
  topLevelErrorCodes: any[];
}
interface Publish {
  errorCodes: ErrorCodes;
  stepHasErrors: boolean;
  stepName: string;
  topLevelErrorCodes: any[];
}
interface Shift {
  errorCodes: ErrorCodes;
  stepHasErrors: boolean;
  stepName: string;
  topLevelErrorCodes: any[];
}

export type State = AsyncState<Restaurant>;

const initialState: State = {
  status: 'init',
  data: undefined
};

export const RESTAURANT_CONTEXT_URL = '/gateway/proxies/gcrestaurant/api/restaurants/';

const { Provider, Consumer } = enforceGlobalSingleton('CurrentRestaurantContext', () =>
  React.createContext<State>(initialState)
);

export class CurrentRestaurantProvider extends React.Component<{}, State> {
  state = initialState;

  componentDidMount() {
    const scope = getScope();

    if (scope.type === 'restaurant') {
      this.setState({
        status: 'started'
      });

      request
        .get(`${RESTAURANT_CONTEXT_URL}${scope.id}`)
        .then(res => {
          this.setState({
            status: 'done',
            data: res.body
          });
          this.setSessionStorage(res.body, scope);
        })
        .catch(res => {
          this.setState({
            status: 'failed'
          });
        });
    } else {
      this.setState({
        status: 'failed'
      });
    }
  }

  render() {
    return <Provider value={this.state}>{this.props.children}</Provider>;
  }

  private setSessionStorage(contextData: Restaurant, scope: Scope) {
    const gcContext = {
      id: scope.id,
      type: scope.type,
      data: contextData
    };
    try {
      // Write restaurant data to session storage under key 'gcContext'
      const sessionDataValue = JSON.stringify(gcContext);
      sessionStorage.setItem('gcContext', sessionDataValue);

      // Announce to anyone listening that the data has been stored successfully
      /* istanbul ignore else */
      if (typeof Event === 'function') {
        // ES6 Setup
        const globalEvent = new Event('updateSessionStorage.gcContext', {
          bubbles: true,
          cancelable: false
        });
        document.dispatchEvent(globalEvent);
      } else if (typeof Event === 'object') {
        // ES5 Setup
        const globalEvent = document.createEvent('Event');
        globalEvent.initEvent('updateSessionStorage.gcContext', true, false);
        document.dispatchEvent(globalEvent);
      }
    } catch (err) {
      /* istanbul ignore next */
      console.log('CurrentRestaurantContext: Error while writing gcContext to SessionStorage', err);
    }
  }
}

export { Consumer as CurrentRestaurantConsumer, Provider as TestCurrentRestaurantProvider };
