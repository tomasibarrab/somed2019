import React from 'react';
import { render, fireEvent } from 'react-testing-library';
import { CheckboxFilterWithState } from './CheckboxFilterWithState';

const options = [
  {
    id: 'test',
    label: 'Test',
    state: 'unchecked'
  },
  {
    id: 'test-partial',
    label: 'Test Partial',
    state: 'partial'
  },
  {
    id: 'test-without-state',
    label: 'Test Without State'
  },
  {
    id: 'test-nested-partial',
    label: 'Test Nested Partial',
    state: 'partial',
    options: [
      {
        id: 'nested-01',
        label: 'Nested 01',
        state: 'unchecked'
      },
      {
        id: 'nested-02',
        label: 'Nested 02',
        state: 'checked'
      }
    ]
  }
];

const toggleAll = {
  isVisible: true,
  label: 'Global Label',
  toggleCount: 'selectedOfAll',
  state: 'unchecked',
  showGlobalExpansionToggle: true
};

async function renderScenario(scenarioProps: any = {}) {
  const defaultProps = {
    applyLabel: 'Apply',
    onChange: () => {},
    onApply: () => {},
    options,
    toggleAll
  };

  const props = {
    ...defaultProps,
    ...scenarioProps
  };

  const result = render(<CheckboxFilterWithState {...props} />);

  return result;
}

test('Should render a nested checkbox list', async () => {
  const result = await renderScenario();
  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should broadcast changes', async () => {
  const spyOnChange = jest.fn();
  const { getByText } = await renderScenario({ onChange: spyOnChange });
  const NestedButton = getByText('Nested 01');

  fireEvent.click(NestedButton);

  const action = 'toggle';
  const actionId = 'nested-01';
  const checkedIds = ['test-partial', 'nested-01', 'nested-02'];
  const currentState = [
    { id: 'test', label: 'Test', state: 'unchecked' },
    { id: 'test-partial', label: 'Test Partial', state: 'checked' },
    { id: 'test-without-state', label: 'Test Without State' },
    {
      id: 'test-nested-partial',
      label: 'Test Nested Partial',
      options: [
        { id: 'nested-01', label: 'Nested 01', state: 'checked' },
        { id: 'nested-02', label: 'Nested 02', state: 'checked' }
      ],
      state: 'checked'
    }
  ];

  expect(spyOnChange).toHaveBeenCalledTimes(1);
  expect(spyOnChange).toHaveBeenCalledWith(action, actionId, checkedIds, currentState);
});

test('Should tick all boxes', async () => {
  const result = await renderScenario();
  const NestedButton = result.getByTestId('checkbox-global');

  fireEvent.click(NestedButton);

  expect(result.container.firstChild).toMatchSnapshot();
  expect(NestedButton.textContent).toEqual('Global Label (5/5)');
});

test('Should untick all boxes', async () => {
  // Check all states for renderScenario
  const optionProps = options.map(option => {
    const newOption = option;

    if (newOption.options) {
      newOption.options = newOption.options.map(nestedOption => ({
        ...nestedOption,
        state: 'checked'
      }));
    }

    return {
      ...newOption,
      state: 'checked'
    };
  });

  const result = await renderScenario({ options: optionProps });
  const NestedButton = result.getByTestId('checkbox-global');

  fireEvent.click(NestedButton);

  expect(result.container.firstChild).toMatchSnapshot();
  expect(NestedButton.textContent).toEqual('Global Label (0/5)');
});

test('Should render without a global header/toggle', async () => {
  const result = await renderScenario({ toggleAll: undefined });
  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should determine parent checkbox state based on children', async () => {
  // Check all states for renderScenario
  const optionProps = options.map(option => {
    const newOption = option;

    if (newOption.options) {
      newOption.options = newOption.options.map(nestedOption => ({
        ...nestedOption,
        state: 'checked'
      }));
    }

    return {
      ...newOption,
      state: 'checked'
    };
  });

  const result = await renderScenario({ options: optionProps });
  const NestedCheckbox = result.getByText('Nested 01');

  // Sets parent from `checked` to `partial`
  fireEvent.click(NestedCheckbox);
  expect(result.container.firstChild).toMatchSnapshot();

  // Sets parent from `partial` to `checked`
  fireEvent.click(NestedCheckbox);
  expect(result.container.firstChild).toMatchSnapshot();

  // Sets parent from `checked` to `unchecked`
  fireEvent.click(NestedCheckbox);
  fireEvent.click(result.getByText('Nested 02'));

  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should allow global toggling', async () => {
  const result = await renderScenario();
  const GlobalToggleExpansion = result.getByTestId('checkbox-global--expansion-toggle');

  // Toggle all checkboxes open
  fireEvent.click(GlobalToggleExpansion);
  expect(result.container.firstChild).toMatchSnapshot();

  // Toggle all checkboxes closed
  fireEvent.click(GlobalToggleExpansion);
  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should allow parent checkbox toggling', async () => {
  const result = await renderScenario();
  const ToggleExpansion = result.getByTestId('checkbox--expansion-toggle--id--test-nested-partial');

  // Toggle checkbox open
  fireEvent.click(ToggleExpansion);
  expect(result.container.firstChild).toMatchSnapshot();

  // Toggle checkbox closed
  fireEvent.click(ToggleExpansion);
  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should select a nested checkbox and set parents to partial', async () => {
  // uncheck all states for renderScenario
  const optionProps = options.map(option => {
    const newOption = option;

    if (newOption.options) {
      newOption.options = newOption.options.map(nestedOption => ({
        ...nestedOption,
        state: 'unchecked'
      }));
    }

    return {
      ...newOption,
      state: 'unchecked'
    };
  });

  const result = await renderScenario({ options: optionProps });
  const NestedCheckbox = result.getByTestId('checkbox-child--id--nested-01');

  // Check nested option
  fireEvent.click(NestedCheckbox);
  expect(result.container.firstChild).toMatchSnapshot();

  // Uncheck nested option
  fireEvent.click(NestedCheckbox);
  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should select a parent checkbox and set its children to checked', async () => {
  const result = await renderScenario();
  const ParentCheckbox = result.getByTestId('checkbox--id--test-nested-partial');

  // Check all child options
  fireEvent.click(ParentCheckbox);
  expect(result.container.firstChild).toMatchSnapshot();

  // Uncheck all child options
  fireEvent.click(ParentCheckbox);
  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should toggle a non-parent and non-child option', async () => {
  const result = await renderScenario();
  const Checkbox = result.getByTestId('checkbox--id--test-partial');

  // Check option
  fireEvent.click(Checkbox);
  expect(result.container.firstChild).toMatchSnapshot();

  // Uncheck option
  fireEvent.click(Checkbox);
  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should render displaying the total count of available options', async () => {
  const ToggleAllOptions = {
    ...toggleAll,
    toggleCount: 'all'
  };

  const result = await renderScenario({ toggleAll: ToggleAllOptions });

  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should render displaying the selected count of available options', async () => {
  const ToggleAllOptions = {
    ...toggleAll,
    toggleCount: 'selected'
  };

  const result = await renderScenario({ toggleAll: ToggleAllOptions });

  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should render with an unmanipulated global label', async () => {
  const ToggleAllOptions = {
    ...toggleAll,
    toggleCount: undefined
  };

  const result = await renderScenario({ toggleAll: ToggleAllOptions });

  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should render a nested checkbox list with search', async () => {
  const result = await renderScenario({ searchable: true });
  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should filter options with search text change', async () => {
  const result = await renderScenario({ searchable: true, searchPlaceholderText: 'Search' });
  const SearchBox = result.getByPlaceholderText('Search') as HTMLInputElement;

  fireEvent.change(SearchBox, {
    target: { value: 'State' }
  });

  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should filter nested options with search text change', async () => {
  const result = await renderScenario({ searchable: true, searchPlaceholderText: 'Search' });
  const SearchBox = result.getByPlaceholderText('Search') as HTMLInputElement;

  fireEvent.change(SearchBox, {
    target: { value: '01' }
  });

  expect(result.container.firstChild).toMatchSnapshot();
});

test('Should filter options with search text change and use provided filter', async () => {
  const result = await renderScenario({
    searchable: true,
    searchPlaceholderText: 'Search',
    searchFilter: (option: any, query: any) => {
      if (option.label === 'Test') return true;
      return false;
    }
  });
  const SearchBox = result.getByPlaceholderText('Search') as HTMLInputElement;

  fireEvent.change(SearchBox, {
    target: { value: 'State' }
  });

  expect(result.container.firstChild).toMatchSnapshot();
});
