import EventTracker from './EventTracker';

describe('EventTracker', () => {
  let instance: EventTracker;

  beforeEach(() => {
    instance = new EventTracker();
  });

  it('should be disabled by default', () => {
    expect(instance.isEnabled).toBe(false);
  });

  describe('static getTime()', () => {
    it('should return performance.now when performance exists', () => {
      jest.spyOn(window.performance, 'now').mockImplementation(() => 90210);

      const result = EventTracker.getTime();
      expect(result).toBe(90210);
    });

    it('should default to Date.now() when performance is missing', () => {
      jest.spyOn(Date, 'now').mockImplementation(() => 1999);
      const windowClone = { ...window };
      delete (window as any).performance;

      const result = EventTracker.getTime();
      expect(result).toBe(1999);

      window = windowClone;
    });
  });

  describe('setDimensions()', () => {
    it('should not throw when scope is not defined', () => {
      expect(() => {
        instance.setDimensions();
      }).not.toThrow();
    });

    it('should match types case-insensitively', () => {
      const gcScope = {
        type: 'GrOuP',
        id: 9876
      } as any;

      jest.spyOn(instance, 'queue');
      instance.setDimensions(gcScope);
      expect(instance.queue).toHaveBeenCalledWith('set', 'dimension1', 9876);
    });

    it('should set "dimension2" equal to the rid when gcScope.type is "Restaurant"', () => {
      const gcScope = {
        type: 'Restaurant',
        id: 1234
      } as any;

      jest.spyOn(instance, 'queue');
      instance.setDimensions(gcScope);
      expect(instance.queue).toHaveBeenCalledWith('set', 'dimension2', 1234);
    });

    it('should set "dimension1" equal to the groupId when gcScope.type is "Group"', () => {
      const gcScope = {
        type: 'Group',
        id: 9876
      } as any;

      jest.spyOn(instance, 'queue');
      instance.setDimensions(gcScope);
      expect(instance.queue).toHaveBeenCalledWith('set', 'dimension1', 9876);
    });
  });

  describe('isGoogleAnalyticsLoaded()', () => {
    it('should return false when window.ga is missing', () => {
      const result = instance.isGoogleAnalyticsLoaded();
      expect(result).toEqual(false);
    });

    it('should return false when window.ga.getAll is not a function', () => {
      (window as any).ga = {};

      const result = instance.isGoogleAnalyticsLoaded();
      expect(result).toEqual(false);
    });

    it('should return true when window.ga.getAll is a function', () => {
      const getAll = jest.fn();
      (window as any).ga = { getAll };

      const result = instance.isGoogleAnalyticsLoaded();
      expect(result).toEqual(true);
    });
  });

  describe('static track()', () => {
    it('should call the method and curry the arguments to the google analytics tracker', () => {
      const send = jest.fn();
      const mockTracker = { send };

      const getAll = jest.fn().mockImplementation(() => [mockTracker]);
      (window as any).ga = { getAll };

      instance.track('send', 'test', 123);
      expect(mockTracker.send).toHaveBeenCalledWith('test', 123);
    });

    it('should not call the method if GA is not defined yet', () => {
      (window as any).ga = {};
      spyOn(console, 'error');

      instance.track('send', 'test', 123);

      expect(console.error).toHaveBeenCalledWith(
        'Unable to track. GA tracker not defined for method: ',
        'send',
        ', and tracking arguments: ',
        'test',
        123
      );
    });
  });

  describe('enable()', () => {
    it('should always set isEnabled to true', () => {
      expect(instance.isEnabled).toBe(false);
      instance.enable();
      expect(instance.isEnabled).toBe(true);
    });

    it('should always try to replay queued events', () => {
      jest.spyOn(instance, 'replayQueuedEvents');
      expect(instance.replayQueuedEvents).not.toHaveBeenCalled();
      instance.enable();
      expect(instance.replayQueuedEvents).toHaveBeenCalled();
    });
  });

  describe('disable()', () => {
    it('should always set isEnabled to false', () => {
      instance.isEnabled = true;
      instance.disable();
      expect(instance.isEnabled).toBe(false);
    });
  });

  describe('isReady()', () => {
    it('should return false when disabled', () => {
      const result = instance.isReady();
      expect(result).toBe(false);
    });

    it('should return false when google analytics is not loaded', () => {
      jest.spyOn(instance, 'isGoogleAnalyticsLoaded').mockImplementation(() => false);

      instance.isEnabled = false;

      const result = instance.isReady();
      expect(result).toBe(false);
    });

    it('should return true when enabled and google analytics is loaded', () => {
      jest.spyOn(instance, 'isGoogleAnalyticsLoaded').mockImplementation(() => true);

      instance.isEnabled = true;

      const result = instance.isReady();
      expect(result).toBe(true);
    });
  });

  describe('queue()', () => {
    beforeEach(() => {
      jest.spyOn(instance, 'replayQueuedEvents').mockImplementation();
    });

    it('should push the args into the eventQueue', () => {
      instance.queue('send', 'test', 123);
      expect(instance.eventQueue.length).toBe(1);
    });

    it('should always call replayQueuedEvents()', () => {
      instance.queue('set', 'test', 123);
      expect(instance.replayQueuedEvents).toHaveBeenCalled();
    });

    it('should call console.info if url param debug is true', () => {
      spyOn(console, 'info');
      const { location } = window;
      delete window.location;
      window.location = { ...location, search: 'debug=true' };

      instance.queue('send', 'test', 123);
      expect(console.info).toHaveBeenCalledWith('QUEUED EventTracker', 'send', 'test', 123);

      // clean up and reset location
      window.location = location;
    });
  });

  describe('replayQueuedEvents()', () => {
    beforeEach(() => {
      jest.spyOn(instance, 'track').mockImplementation(() => {});
    });

    it('should not call track when not ready', () => {
      jest.spyOn(instance, 'isReady').mockImplementation(() => false);

      instance.replayQueuedEvents();

      expect(instance.track).not.toHaveBeenCalled();
    });

    it('should empty the queue after every run', () => {
      jest.spyOn(instance, 'isReady').mockImplementation(() => true);

      instance.eventQueue = [['send', 'one'], ['set', 'two']];

      instance.replayQueuedEvents();
      expect(instance.track).toBeCalledWith('send', 'one');
      expect(instance.track).toBeCalledWith('set', 'two');
    });
  });

  describe('sendPageView()', () => {
    it('should set the url to the page and send a pageview to the queue', () => {
      jest.spyOn(instance, 'queue');

      instance.sendPageView('test.com');

      expect(instance.queue).toBeCalledTimes(2);
      expect(instance.queue).toBeCalledWith('set', 'page', 'test.com');
      expect(instance.queue).toHaveBeenCalledWith('send', 'pageview');
    });
  });

  describe('sendException', () => {
    it('should add an exception to the queue', () => {
      const description =
        "Sir, I don't know where your ship learned to communicate, but it has the most peculiar dialect.";
      const fatal = false;

      jest.spyOn(instance, 'queue');

      instance.sendException({ description, fatal });

      expect(instance.queue).toHaveBeenCalledWith('send', 'exception', {
        exDescription: description,
        exFatal: fatal
      });
    });
  });

  describe('sendEvent()', () => {
    it('should add an event to the queue', () => {
      const category = 'Battle Station';
      const action = 'Fully Armored and Operational';
      const label = 'Witnessing';
      const value = 1;
      const type = 'firepower';
      const when = 'Now';

      jest.spyOn(instance, 'queue');

      instance.sendEvent({ category, action, label, value }, { when, type });

      expect(instance.queue).toHaveBeenCalledWith('send', 'event', {
        eventCategory: category,
        eventAction: action,
        eventLabel: label,
        eventValue: value,
        when,
        type
      });
    });

    it('does not require customMetrics', () => {
      const category = 'Super Power';
      const action = 'Punch';
      const label = 'One Punch Man';
      const value = Infinity;

      jest.spyOn(instance, 'queue');

      instance.sendEvent({ category, action, label, value });

      expect(instance.queue).toHaveBeenCalledWith('send', 'event', {
        eventCategory: category,
        eventAction: action,
        eventLabel: label,
        eventValue: value
      });
    });
  });

  describe('createTimer()', () => {
    it('should take a category and start tracking time, then take a variable and label and pass the time difference to sendTiming', () => {
      jest.spyOn(instance, 'sendTiming');
      jest.spyOn(EventTracker, 'getTime').mockImplementationOnce(() => 2001);

      const category = 'Federation Starships';
      const variable = 'Star Trek';
      const label = 'USS Enterprise';

      const timer = instance.createTimer(category);

      jest.spyOn(EventTracker, 'getTime').mockImplementationOnce(() => 3702);

      timer(variable, label);

      expect(instance.sendTiming).toHaveBeenCalledWith({
        category,
        variable,
        value: 1701,
        label
      });
    });
  });

  describe('sendTiming()', () => {
    it('should log an error in the console if value is not a number', () => {
      jest.spyOn(console, 'error').mockImplementation(() => {});
      instance.sendTiming({ category: 'cat', variable: 'var', value: NaN });

      expect(console.error).toHaveBeenCalledWith('EventTracker.sendTiming() requires a numeric "value" property');
    });

    it('should add a send timing action to the queue', () => {
      const timeOptions = {
        category: 'cat',
        variable: 'var',
        value: 1701,
        label: 'lab'
      };
      jest.spyOn(instance, 'queue');

      instance.sendTiming(timeOptions);

      expect(instance.queue).toHaveBeenCalledWith('send', 'timing', {
        timingCategory: 'cat',
        timingVar: 'var',
        timingValue: 1701,
        timingLabel: 'lab'
      });
    });
  });
});
