import React, { useState, useEffect, useRef } from 'react';
import classnames from 'classnames/bind';
import styles from './LabeledInput.css';

const cx = classnames.bind(styles);

export interface LabeledInputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  statusText?: React.ReactNode;
  id?: string;
  label: string;
  state?: 'default' | 'error' | 'success' | 'disabled';

  // This is optional on the extended type, but we are overriding to make it required
  onChange(e: React.ChangeEvent<HTMLInputElement>): void;
}

/**
 * Custom React Hook to handle the status text animations.
 * @param statusText
 */
function useAnimatedStatusText(statusText?: React.ReactNode) {
  const [inputStatusText, setInputStatusText] = useState(() => statusText);
  const [statusIn, setStatusIn] = useState(() => !statusText);
  const [statusOut, setStatusOut] = useState(false);

  const timer = useRef<any>(null);

  useEffect(() => {
    if (statusText) {
      // set newly received status text, will be animated "in" if the previous was empty
      setInputStatusText(statusText);
      // stop any previous "out" animation
      clearTimeout(timer.current);
      setStatusOut(false);
    } else {
      // start "out" animation
      setStatusOut(true);
      // set timeout to remove the status text once the animation is finished
      timer.current = setTimeout(() => {
        // set empty status text
        setInputStatusText(undefined);
        // mark "out" animation as complete
        setStatusOut(false);
        // set "in" animation flag for future updates
        setStatusIn(true);
      }, 300); // TODO: parameterize this, or better yet use onAnimationEnd() instead of setTimeout()
    }
  }, [statusText]);

  // clear any remaining timeout on un-mount
  useEffect(() => {
    return () => {
      clearTimeout(timer.current);
    };
  }, []);

  return { inputStatusText, statusIn, statusOut };
}

export const LabeledInput = React.forwardRef<HTMLInputElement, LabeledInputProps>((props, ref) => {
  const { className, value, statusText, label, state, disabled, ...rest } = props;
  const inputId = props.id || `buffet__phone-input--${Date.now()}`;

  // TODO: remove the "disabled state" approach and just use the "disabled" HTML attribute
  const isDisabled = disabled || state === 'disabled';

  const { inputStatusText, statusIn, statusOut } = useAnimatedStatusText(statusText);

  return (
    <div className={cx('inputWrapper')}>
      <label className={cx('label', !value && 'hiddenLabel', isDisabled && 'disabled')} htmlFor={inputId}>
        {label}
      </label>

      <input
        {...rest}
        className={cx(value ? styles.floatingLabel : styles.noLabel, disabled ? 'disabled' : state, className)}
        disabled={isDisabled}
        id={inputId}
        name={inputId}
        placeholder={label}
        ref={ref}
        value={value}
      />

      {inputStatusText && (
        <div
          data-testid="status-code"
          className={cx({
            statusAnimateIn: statusIn,
            statusAnimateOut: statusOut,
            statusInfo: state !== 'error' && state !== 'success',
            statusSuccess: state === 'success',
            statusError: state === 'error',
            disabled: isDisabled
          })}
        >
          {inputStatusText}
        </div>
      )}
    </div>
  );
});

LabeledInput.defaultProps = {
  state: 'default',
  type: 'text'
};
