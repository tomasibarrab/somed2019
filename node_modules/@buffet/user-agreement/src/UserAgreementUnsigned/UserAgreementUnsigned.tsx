import React, { MouseEvent, ReactElement } from 'react';
import styles from '../UserAgreement.css';
import { AlertMessage } from '@buffet/alert-message';
import { Button } from '@buffet/button';
import { Notify } from '@buffet/notify';
import { UserAgreementPanel } from '../UserAgreementPanel/UserAgreementPanel';
import { GATEWAY_BASE_PATH, UAS_BASE_PATH } from '../UserAgreement';
import { LabeledCheckbox } from '@buffet/checkbox';
import request from 'superagent';
import { injectIntl, InjectedIntlProps, FormattedMessage } from 'react-intl';
import { SubmitAgreementAsyncState, AgreementDetails, UASAgreementDTO } from '../UserAgreement.types';

export interface UserAgreementUnsignedProps {
  agreementType: string;
  context: string;
  agreementDetails: AgreementDetails;
  updateAgreementDetails: (payload: AgreementDetails) => void;
}

export interface UserAgreementInteractionProps {
  onAgreeIntent?: (isChecked?: boolean) => void;
  onAgreeConfirm?: () => void;
  onViewAgreement?: () => void;
  onHideAgreement?: () => void;
}

export interface UserAgreementUnsignedState {
  hasIntentToAgree: boolean;
  submitAgreementState: SubmitAgreementAsyncState;
  isShowAgreement: boolean;
}

interface Props extends UserAgreementUnsignedProps, UserAgreementInteractionProps, InjectedIntlProps {}

class UserAgreementUnsignedView extends React.Component<Props, UserAgreementUnsignedState> {
  state: UserAgreementUnsignedState = {
    hasIntentToAgree: false,
    submitAgreementState: { status: 'init', data: undefined },
    isShowAgreement: false
  };

  render() {
    const {
      agreementDetails: {
        type: { agreeTextId, intentTextId }
      }
    } = this.props;

    return (
      <>
        <div className={styles.userAgreement}>
          <LabeledCheckbox
            id={`agreement-checkbox-${this.props.agreementType}`}
            checked={this.state.hasIntentToAgree}
            onClick={this.handleAgreeIntent}
            testId="agreement-label"
            checkboxTestId="agreement-checkbox"
            label={
              <FormattedMessage
                id={`userAgreement.checkbox.haveReadTerms.${intentTextId}`}
                values={{
                  clickableShortTitle: (
                    <a
                      onClick={this.handleViewAgreement}
                      data-testid="agreement-termslink"
                      className={styles.viewAgreement}
                    >
                      {this.props.agreementDetails.termsAndConditions[0].title}
                    </a>
                  )
                }}
              />
            }
          />
          <Button
            type="button"
            onClick={this.handleAgreeConfirm}
            theme="primary"
            disabled={!this.state.hasIntentToAgree}
            busy={this.state.submitAgreementState.status === 'started'}
            testId="agreement-button"
            className={styles.agreeConfirmButton}
          >
            <FormattedMessage id={`userAgreement.button.agree.${agreeTextId}`} />
          </Button>
        </div>
        <UserAgreementPanel
          agreementDetails={this.props.agreementDetails}
          handleHideAgreement={this.handleHideAgreement}
          handleAgreeConfirm={this.handleAgreeConfirm}
          submitAgreementState={this.state.submitAgreementState}
          show={this.state.isShowAgreement}
        />
        {this.renderAlert()}
      </>
    );
  }

  /**
   * Render a banner type alert if necessary. If the `error.status` is `401` this an auth or permission issue (assuming
   * permission if the user has gotten this far). This could happen if a user with signing permission caused the
   * agreement to be created but did not sign the agreement, and then a user without signing permission attempts to
   * sign.
   * Otherwise if not a `401` display a general error message.
   */
  private renderAlert(): ReactElement | null {
    if (this.state.submitAgreementState.status === 'failed') {
      const messageId =
        this.state.submitAgreementState.error.status === 401
          ? 'userAgreement.submitError.permission.message'
          : 'userAgreement.submitError.async.message';
      return (
        <Notify show={this.state.submitAgreementState.status === 'failed'} autohide={false} delay={0}>
          <AlertMessage
            id="submit-error-alert"
            iconId="negative"
            type="error"
            message={this.props.intl.formatMessage({ id: messageId })}
          />
        </Notify>
      );
    } else {
      return null;
    }
  }

  private handleAgreeIntent = (event: MouseEvent): void => {
    if (this.props.onAgreeIntent) {
      this.props.onAgreeIntent(!this.state.hasIntentToAgree);
    }

    this.setState({ hasIntentToAgree: !this.state.hasIntentToAgree });
  };

  private handleAgreeConfirm = (): void => {
    if (this.props.onAgreeConfirm) {
      this.props.onAgreeConfirm();
    }

    this.setState({ submitAgreementState: { status: 'started', data: undefined } });

    request
      .post(`${GATEWAY_BASE_PATH}${UAS_BASE_PATH}/${this.props.agreementDetails.id}/sign`)
      .send({
        termsId: [this.props.agreementDetails.termsAndConditions[0].termsId]
      })
      .then(res => {
        this.setState({
          submitAgreementState: { status: 'done', data: res.body as UASAgreementDTO },
          isShowAgreement: false
        });
        this.props.updateAgreementDetails(res.body);
      })
      // commenting out the catch for now because api handling should really be handled in the top level component
      .catch(
        /* istanbul ignore next */ err => {
          // TODO: top level component needs to handle error also â€” should pull up async handling
          /* istanbul ignore next */
          this.setState({ submitAgreementState: { status: 'failed', data: undefined, error: err } });
        }
      );
  };

  private handleViewAgreement = (event: MouseEvent): void => {
    // Prevent click from also triggering Checkbox Label click handlers
    event.preventDefault();
    event.stopPropagation();
    event.nativeEvent.stopImmediatePropagation();

    this.setState({ isShowAgreement: true });

    if (this.props.onViewAgreement) {
      this.props.onViewAgreement();
    }
  };

  private handleHideAgreement = (): void => {
    this.setState({ isShowAgreement: false });

    if (this.props.onHideAgreement) {
      this.props.onHideAgreement();
    }
  };
}

export const UserAgreementUnsigned = injectIntl<UserAgreementUnsignedProps & UserAgreementInteractionProps>(
  UserAgreementUnsignedView
);
