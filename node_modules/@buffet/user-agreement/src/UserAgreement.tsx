import React from 'react';
import styles from './UserAgreement.css';
import { Button } from '@buffet/button';
import { UserAgreementInteractionProps, UserAgreementUnsigned } from './UserAgreementUnsigned/UserAgreementUnsigned';
import { UserAgreementErrorPanel } from './UserAgreementErrorPanel/UserAgreementErrorPanel';
import { registerMessages } from '@buffet/intl';
import request from 'superagent';
import {
  FetchAgreementAsyncState,
  AgreementDetails,
  AgreementSource,
  BaseAgreementDTO,
  OTResponseError,
  Pricing
} from './UserAgreement.types';

export const locales = [
  'ca-ES',
  'de-CH',
  'de-DE',
  'en-AU',
  'en-GB',
  'en-IE',
  'en-US',
  'es-ES',
  'es-MX',
  'fr-CA',
  'fr-FR',
  'it-IT',
  'ja-JP',
  'nl-NL',
  'pt-BR',
  'zh-CN'
];

const messages = locales.reduce((acc: any, locale: any) => {
  acc[locale] = require(`../translations/${locale}/user-agreement.json`);
  return acc;
}, {});

registerMessages(messages);

export interface UserAgreementProps {
  agreementType: string;
  context: string;
  contextName: string;
  onAgreeSuccess?: (agreement: BaseAgreementDTO) => void;
  onInitialized?: (agreement: BaseAgreementDTO) => void;
  pricing?: Pricing[];
}

export interface UserAgreementState {
  hasIntentToAgree: boolean;
  fetchAgreementState: FetchAgreementAsyncState;
  agreementDetails: AgreementDetails | undefined;
  isSigned: boolean;
}

interface Props extends UserAgreementProps, UserAgreementInteractionProps {}

export const GATEWAY_BASE_PATH = '/gateway/proxies/userAgreementService';
export const UAS_BASE_PATH = '/v1/user-agreement/agreements';

export class UserAgreement extends React.Component<Props, UserAgreementState> {
  state: UserAgreementState = {
    hasIntentToAgree: false,
    fetchAgreementState: { status: 'init', data: undefined },
    agreementDetails: undefined,
    isSigned: false
  };

  agreementSource: AgreementSource | undefined;

  componentDidMount() {
    this.fetchAgreement();
  }

  render() {
    switch (this.state.fetchAgreementState.status) {
      case 'done':
        return (
          <UserAgreementUnsigned
            agreementDetails={this.state.agreementDetails as AgreementDetails}
            agreementType={this.props.agreementType}
            context={this.props.context}
            updateAgreementDetails={this.updateAgreementDetails}
            onAgreeIntent={this.props.onAgreeIntent}
            onAgreeConfirm={this.props.onAgreeConfirm}
            onViewAgreement={this.props.onViewAgreement}
            onHideAgreement={this.props.onHideAgreement}
          />
        );
      case 'failed':
        return <UserAgreementErrorPanel error={this.state.fetchAgreementState.error} />;
      default:
        return (
          <Button
            type="button"
            theme="bare"
            onClick={/* istanbul ignore next */ () => {}}
            disabled
            busy
            className={styles.agreeConfirmButton}
            data-testid="loading-spinner"
          />
        );
    }
  }

  /**
   * Callback provided to `UserAgreementUnsigned` to provide the resulting agreement DTO after successfully agreeing to
   * an agreement. This top level component then calls the external callback `onAgreeSuccess()` if provided.
   */
  private updateAgreementDetails = (agreementDetails: AgreementDetails) => {
    this.setState({
      agreementDetails
    });

    /* istanbul ignore next */
    if (this.props.onAgreeSuccess) {
      this.props.onAgreeSuccess({
        source: 'UAS',
        isSigned: true,
        agreementDetails
      });
    }
  };

  private fetchAgreement = () => {
    this.setState({ fetchAgreementState: { status: 'started', data: undefined } });
    request
      .get(`${GATEWAY_BASE_PATH}${UAS_BASE_PATH}/${this.props.agreementType}/${this.props.context}`)
      .then(res => {
        const agreement: BaseAgreementDTO = res.body;
        this.setState({
          fetchAgreementState: { status: 'done', data: null },
          agreementDetails: agreement.agreementDetails,
          isSigned: agreement.isSigned
        });
        this.agreementSource = agreement.source as AgreementSource;

        /* istanbul ignore next */
        if (this.props.onInitialized) {
          this.props.onInitialized(agreement);
        }
      })
      .catch((err: OTResponseError) => {
        if (err.status == 404) {
          this.createAgreement();
        } else {
          this.setState({ fetchAgreementState: { status: 'failed', data: undefined, error: err } });
        }
      });
  };

  private createAgreement = () => {
    let body: { type: string; context: string; contextName: string; pricing?: Pricing[] } = {
      type: this.props.agreementType,
      context: this.props.context,
      contextName: this.props.contextName
    };

    /* istanbul ignore next */
    if (this.props.pricing) {
      body = {
        ...body,
        pricing: this.props.pricing
      };
    }
    request
      .post(`${GATEWAY_BASE_PATH}${UAS_BASE_PATH}`)
      .send(body)
      .then(res => {
        const agreementDetails: AgreementDetails = res.body;
        this.setState({
          fetchAgreementState: { status: 'done', data: null },
          agreementDetails,
          isSigned: false
        });
        this.agreementSource = 'UAS';

        /* istanbul ignore next */
        if (this.props.onInitialized) {
          this.props.onInitialized({
            source: 'UAS',
            isSigned: false,
            agreementDetails
          });
        }
      })
      .catch((err: OTResponseError) => {
        /* istanbul ignore next */
        this.setState({ fetchAgreementState: { status: 'failed', data: undefined, error: err } });
      });
  };
}
