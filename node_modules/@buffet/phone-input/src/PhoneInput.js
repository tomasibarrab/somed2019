/* eslint-disable no-use-before-define */
/* eslint-disable consistent-return */
import React from 'react';
import { parseIncompletePhoneNumber, parsePhoneNumberFromString } from 'libphonenumber-js';
import PhoneNumberInput from 'react-phone-number-input/react-responsive-ui';
import PropTypes from 'prop-types';
import { Icon } from '@buffet/icon';
import { LabeledInput } from '@buffet/input';
import styles from './PhoneInput.css';
import './imports.vanilla.css';

const isStandardNumber = value => /^[\s+\-()\d]*$/g.test(value);

/**
 * An OTKit styled wrapper around `react-phone-number-input` that attempts to
 * preserve as much of the original  functionality as possible while adding the
 * ability to enter and edit "non-standard" numbers such as "1-800-OPENTABLE" or
 * "916-123-456 ext. 789".
 */
export default class PhoneInput extends React.Component {
  constructor(props) {
    super(props);

    this.state = this.getInitialState();

    this.phoneInputId = `phone-input--${Date.now()}`;

    this.onFocus = this.onFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    this.onPhoneNumberInputChange = this.onPhoneNumberInputChange.bind(this);
    this.update = this.update.bind(this);

    /**
     * TRICKY: This function returns a higher order component class that is
     * bound to this specific instance of `PhoneInput`. This class is injected
     * into `react-phone-number-input` via its `inputComponent` prop. This
     * "sandwich" approach allows us to utilize the full behavior of
     * `react-phone-number-input` when the user enters values that it supports,
     * but skip it entirely when unsupported characters are entered.
     *
     * NOTE: Because we are creating this HOC on mount and per-instance, it's
     * possible there could be a performance impact when rendering many
     * instances of `PhoneInput`.
     */
    this.inputComponent = createInputComponent(this);
  }

  getInitialState() {
    const { defaultCountry, allowNonStandardCharacters } = this.props;
    const value = this.props.value || '';
    const phoneNumber = parsePhoneNumberFromString(value, defaultCountry);
    const isValid = Boolean(phoneNumber && phoneNumber.isValid());
    const formattedValue = allowNonStandardCharacters ? value : parseIncompletePhoneNumber(value);

    return { focused: false, rawValue: value, formattedValue, isValid };
  }

  render() {
    const { defaultCountry, placeholder } = this.props;
    const { formattedValue, isValid } = this.state;

    const classes = [styles.gcPhoneInput].filter(Boolean).join(' ');

    return (
      <div className={classes}>
        <PhoneNumberInput
          countryOptions={['JP', 'AU', 'CA', 'DE', 'MX', 'GB', 'US', '|', '...']}
          country={defaultCountry}
          placeholder={placeholder}
          value={formattedValue}
          onChange={this.onPhoneNumberInputChange}
          onFocus={this.onFocus}
          onBlur={this.onBlur}
          id={this.phoneInputId}
          maxlength="30"
          inputComponent={this.inputComponent}
        />

        {isValid && (
          <span data-testid="buffet__phone-input__checkmark" className={styles.checkmark}>
            <Icon iconId="checkmark" />
          </span>
        )}
      </div>
    );
  }

  onPhoneNumberInputChange(formattedValue) {
    this.setState({ formattedValue }, this.update);
  }

  onInputComponentChange(rawValue) {
    this.setState({ rawValue }, this.update);
  }

  update() {
    const data = this.getData();
    this.setState({ isValid: data.isValid });

    /* istanbul ignore else */
    if (typeof this.props.onChange === 'function') {
      this.props.onChange(data);
    }
  }

  getData() {
    const { formattedValue, rawValue } = this.state;
    const phoneNumber = formattedValue && parsePhoneNumberFromString(formattedValue, this.props.defaultCountry);

    const data = {
      isValid: this.state.isValid,
      value: ''
    };

    if (!isStandardNumber(rawValue)) {
      data.isValid = false;
      data.value = rawValue;
    } else if (phoneNumber) {
      data.country = phoneNumber.country;     // 2 character country code: 'US', 'DE', etc.
      data.isValid = phoneNumber.isValid();
      data.value = phoneNumber.number;        // Country prefix + phone number: '+14151234567'
      data.shortValue = phoneNumber.nationalNumber; // '4151234567'
      data.valuePrefix = phoneNumber.countryCallingCode; // '1', '49'
    }

    return data;
  }

  onFocus() {
    this.setState({
      focused: true
    });
  }

  onBlur() {
    this.setState({
      focused: false
    });
  }
}

PhoneInput.propTypes = {
  allowNonStandardCharacters: PropTypes.bool,
  defaultCountry: PropTypes.string,
  inputClassName: PropTypes.string,
  label: PropTypes.string.isRequired,
  value: PropTypes.string,
  placeholder: PropTypes.string,
  id: PropTypes.string,
  onChange: PropTypes.func
};

PhoneInput.defaultProps = {
  allowNonStandardCharacters: false,
  value: ''
};

/**
 * HOC Factory for `PhoneInput`. Not intended to be used on its own.
 */
function createInputComponent(wrapperComponent) {
  return class InputComponent extends React.Component {
    constructor(props) {
      super(props);

      this.state = { country: props.country, rawValue: props.value };
      this.inputRef = React.createRef();
      this.onChange = this.onChange.bind(this);
      this.focus = this.focus.bind(this);
    }

    static getDerivedStateFromProps(props, state) {
      /**
       * In general this component should respect user input exactly as entered.
       * One exception to this is when the user manually selects a country. In
       * that case we want to update our raw value to the new value from
       * `react-phone-number-input`, which implements the logic of stripping the
       * old country prefix and prepending the new one. However, there is no way
       * for our interior component to listen directly for a country change, so
       * we are detecting changes to the matched country here.
       */
      if (props.country && props.country !== state.country && isStandardNumber(state.rawValue)) {
        return {
          country: props.country,
          rawValue: props.value
        };
      }

      return state;
    }

    render() {
      const { id, inputClassName, label, error } = wrapperComponent.props;
      const { onBlur, onFocus } = this.props;
      const inputValue = this.getInputValue();

      /**
       * We're explicitely avoiding passing the className from
       * `react-phone-number-input` so that we don't have to override all its
       * styling. Instead, we're passing down the `inputClassName` prop from the
       * top level.
       */
      return (
        <LabeledInput
          label={label}
          ref={this.inputRef}
          value={inputValue}
          onChange={this.onChange}
          onFocus={onFocus}
          onBlur={onBlur}
          type="tel"
          autoComplete="tel"
          id={id}
          className={inputClassName}
          state={error ? 'error' : 'default'}
          statusText={error || ''}
        />
      );
    }

    getInputValue() {
      const { defaultCountry } = wrapperComponent.props;
      const { focused } = wrapperComponent.state;
      const { rawValue } = this.state;
      const { country, value } = this.props;

      /**
       * If the user is currently focused on the input or has entered
       * non-formattable characters we want to show them exactly what they have
       * entered.
       */
      if (focused || !isStandardNumber(rawValue)) {
        return rawValue;
      }

      const phoneNumber = parsePhoneNumberFromString(value, country);

      /**
       * If we were able to parse a phone number we want to format it
       * - Using local ("NATIONAL") formatting for local numbers
       * - Using international format for all others
       */
      if (phoneNumber) {
        const isLocalNumber = country === defaultCountry;
        const numberFormat = isLocalNumber ? 'NATIONAL' : 'INTERNATIONAL';

        return phoneNumber.format(numberFormat);
      }

      return value;
    }

    onChange(event) {
      const { allowNonStandardCharacters } = wrapperComponent.props;
      const { value } = event.target;

      const rawValue = allowNonStandardCharacters ? value : parseIncompletePhoneNumber(value);

      this.setState({ rawValue });

      /** Always send our updated value up to the wrapper component */
      wrapperComponent.onInputComponentChange(rawValue);

      if (isStandardNumber(rawValue)) {
        this.props.onChange(rawValue);
      } else {
        /**
         * TRICKY: We're using `react-phone-number-input` as both a transformer
         * for the values we emit to the parent and as UI component. In order to
         * avoid strange behavior of the UI part, we emit a dummy value to force
         * it to display as international and invalid. As long as the wrapper
         * component's rawValue is non-standard it will ignore any resulting
         * output from `react-phone-number-input`.
         */
        this.props.onChange('+999');
      }
    }

    /* istanbul ignore next */
    focus() {
      this.inputRef.current.focus();
    }
  };
}
