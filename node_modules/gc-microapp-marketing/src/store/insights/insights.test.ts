import { cloneDeep } from 'lodash';
import { ActionCreator } from 'redux';
import configureMockStore from 'redux-mock-store';
import { createEpicMiddleware } from 'redux-observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import { Observable } from 'rxjs/Observable';
import { AsyncActionCreators } from 'typescript-fsa';
import {
  fetchActions,
  fetchCampaigns,
  fetchCoverTypes,
  fetchEachCampaignDetailsEpic,
  filterActions,
  insightsEpic,
  reducer,
  refetchDataWhenFiltersChangeEpic,
  triggerFetchEachCampaignDetailsEpic,
} from './insights';
import { ComparativePeriod, Days } from './insights.types';

describe('Insights store', () => {
  const fetchActionAndReducerScenarios: Array<{
    action: AsyncActionCreators<any, any, any>;
    apiFunctionName: string;
    payload: any;
    stateKey: string;
  }> = [
    {
      action: fetchActions.fetchCoverTrends,
      apiFunctionName: 'fetchCoverTrends',
      payload: {
        apiParameter: 'a',
      },
      stateKey: 'coverTrends',
    },
    {
      action: fetchActions.fetchSummaryCurrent,
      apiFunctionName: 'fetchReservationSummary',
      payload: {
        apiParameter: 'b',
      },
      stateKey: 'summaryCurrent',
    },
    {
      action: fetchActions.fetchSummaryPrevious,
      apiFunctionName: 'fetchReservationSummary',
      payload: {
        apiParameter: 'c',
      },
      stateKey: 'summaryPrevious',
    },
  ];

  const initialState = {
    coverTrends: {
      loading: false,
    },
    filters: {
      compareTo: ComparativePeriod.PreviousPeriod,
      dateRange: {
        endDate: '2019-01-20',
        startDate: '2019-01-14',
      },
      daysOfWeek: { [Days.Friday]: true },
      timeRange: {
        endTime: '20:00:00',
        startTime: '04:00:00',
      },
    },
    summaryCurrent: {
      loading: false,
    },
    summaryPrevious: {
      loading: false,
    },
  } as any;

  describe('actions & reducers', () => {
    /*
      Create actions, pass them through reducers.

      Only may need two actual "tests" here though because all the
      filter actions are the same simple "set in" sort of reducer,

      and all the fetch actions are of the Async type.
    */

    const filterActionAndReducerScenarios: Array<{
      action: ActionCreator<any>;
      payload: any;
      stateKey: string;
    }> = [
      {
        action: filterActions.setCompareTo,
        payload: ComparativePeriod.LastYear,
        stateKey: 'compareTo',
      },
      {
        action: filterActions.setDaysOfWeek,
        payload: { [Days.Monday]: true },
        stateKey: 'daysOfWeek',
      },
      {
        action: filterActions.setTimeRange,
        payload: {
          endTime: '23:59:59',
          startTime: '00:00:00',
        },
        stateKey: 'timeRange',
      },
      {
        action: filterActions.setDateRange,
        payload: {
          endDate: '2019-02-01',
          startDate: '2019-01-01',
        },
        stateKey: 'dateRange',
      },
    ];

    filterActionAndReducerScenarios.forEach(({ action, payload, stateKey }) => {
      it(`set ${stateKey}`, () => {
        const stateToChange = cloneDeep(initialState);

        const actual = reducer(stateToChange, action(payload));
        expect(actual.filters[stateKey]).toEqual(payload);
      });
    });

    fetchActionAndReducerScenarios.forEach(({ action, payload, stateKey }) => {
      it(`sets ${stateKey}.loading for started, loading and data for done, and loading, error for failed`, () => {
        const stateToChange = cloneDeep(initialState);

        const actualStarted = reducer(stateToChange, action.started(payload));
        expect(actualStarted[stateKey].loading).toEqual(true);

        const actualDone = reducer(actualStarted, action.done({ result: '1', params: payload }));
        expect(actualDone[stateKey].loading).toEqual(false);
        expect(actualDone[stateKey].data).toEqual('1');

        const actualFailed = reducer(actualStarted, action.failed({ error: true, params: payload }));
        expect(actualFailed[stateKey].error).toEqual(true);
      });
    });
  });

  describe('epics', () => {
    fetchActionAndReducerScenarios.forEach(({ action, payload, stateKey, apiFunctionName: afn }) => {
      const apiResponse = `${stateKey} - response`;

      it(`listens for action.started for ${stateKey}, sends action.done with API response from ${afn}`, () => {
        const dependencies = { api: { [afn]: () => Observable.of({ data: apiResponse }) } };

        const rootEpic = (action$, store) => insightsEpic(action$, store, dependencies as any);
        const epicMiddleware = createEpicMiddleware(rootEpic);
        const mockStore = configureMockStore([epicMiddleware]);

        const state = cloneDeep(initialState);
        const testStore = mockStore(state);

        testStore.dispatch(action.started(payload));
        const actions = testStore.getActions();

        expect(actions.length).toEqual(2);
        expect(actions[1].type).toEqual(action.done.type);
        expect(actions[1].payload).toEqual({
          params: payload,
          result: apiResponse,
        });
      });

      it(`sends action.failed for ${stateKey} if API request fails`, () => {
        const dependencies = { api: { [afn]: () => Observable.throw('error of some kind') } };

        const rootEpic = (action$, store) => insightsEpic(action$, store, dependencies as any);
        const epicMiddleware = createEpicMiddleware(rootEpic);
        const mockStore = configureMockStore([epicMiddleware]);

        const state = cloneDeep(initialState);
        const testStore = mockStore(state);

        testStore.dispatch(action.started(payload));
        const actions = testStore.getActions();

        expect(actions.length).toEqual(2);
        expect(actions[1].type).toEqual(action.failed.type);
        expect(actions[1].payload).toEqual({
          error: true,
          params: payload,
        });
      });
    });

    describe('refetchDataWhenFiltersChangeEpic', () => {
      it('synthesizes API request parameters and sends fetch start action for ea. endpoint when setFilter axn', () => {
        const epicMiddleware = createEpicMiddleware(refetchDataWhenFiltersChangeEpic);
        const mockStore = configureMockStore([epicMiddleware]);

        const state = cloneDeep(initialState);
        /*
          This epic uses the entire state directly, so the store's state structure must
          match that of the app. The reducers above operate on the insights sub-state area
          and so don't need to have this { insights: ... } structure.
        */
        const testStore = mockStore({
          insights: state,
        });

        testStore.dispatch(filterActions.setCompareTo(ComparativePeriod.PreviousPeriod));
        const actions = testStore.getActions();

        expect(actions).toMatchSnapshot();
      });
    });

    describe('triggerFetchEachCampaignDetailsEpic', () => {
      it('causes fetch of campaigns coming out of campaignTotals selector when fetchCoverTypes done', () => {
        const epicMiddleware = createEpicMiddleware(triggerFetchEachCampaignDetailsEpic);
        const mockStore = configureMockStore([epicMiddleware]);

        const state = cloneDeep(initialState);

        state.coverTypes = {
          data: {
            domain: ['PAID250-12345', 'PAID150-54321'],
            range: {
              'PAID150-54321': {
                domain: ['2019-01-03'],
                range: {
                  '2019-01-03': {
                    campaign_id: 54321,
                    covers: 5,
                  },
                },
              },
              'PAID250-12345': {
                domain: ['2019-01-01'],
                range: {
                  '2019-01-01': {
                    campaign_id: 12345,
                    covers: 2,
                  },
                },
              },
            },
          },
        };
        const testStore = mockStore({ insights: state });

        // payload for that action is unused in this epic
        testStore.dispatch(fetchCoverTypes.done({ params: {} as any, result: {} as any }));

        const actions = testStore.getActions();

        expect(actions).toMatchSnapshot();
      });
    });

    describe('fetchEachCampaignDetailsEpic', () => {
      it('upon fetchCampaignsStarted, it calls api.fetchCampaign(rid, cid) for each campaign ' +
      'then dispatches fetchCampaigns.done with array of campaign information', () => {
        const epicMiddleware = createEpicMiddleware(fetchEachCampaignDetailsEpic, {
          dependencies: {
            api: {
              fetchCampaign: jest.fn((rid, intCampaignId) => Observable.of({
                campaignId: intCampaignId,
                rid,
                schedule: [{
                  dayOfWeek: 'FRIDAY',
                  endTime: '09:45',
                  startTime: '00:00',
                }],
              })),
            } as any,
          },
        });
        const mockStore = configureMockStore([epicMiddleware]);

        const state = cloneDeep(initialState);

        const testStore = mockStore({
          currentContext: {
            restaurant: {
              rid: 1004158,
            },
          },
          insights: state,
        });

        testStore.dispatch(fetchCampaigns.started([12345, 54321]));

        const actions = testStore.getActions();

        expect(actions).toMatchSnapshot();
      });
    });
  });
});
