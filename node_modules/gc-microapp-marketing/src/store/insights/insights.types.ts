import { CampaignType } from '../../store/campaigns/campaigns.types';
import { AsyncData } from '../types';

/////////////////////////
// MAIN INSIGHTS STATE //
/////////////////////////

type AsyncDataWithParams<DT, PT> = AsyncData<DT> & {
  params?: PT;
};

export interface InsightsState {
  coverTrends: AsyncDataWithParams<CoverTrends, FetchCoverTrendsOptions>;
  coverTypes: AsyncData<CoverTypes>;
  filters: Filters; // TODO: shouldn't be optional; make initial state for this
  summaryCurrent: AsyncData<CoverSummary>;
  summaryPrevious: AsyncData<CoverSummary>;
  campaigns: AsyncData<CampaignType[]>;
}

/////////////////////////////
// PARTS OF MAIN APP STATE //
/////////////////////////////
type Without<T, K> = Pick<T, Exclude<keyof T, K>>;

export interface CampaignTotal {
  covers: number;
  firstTimeGuests?: number;
  outOfTownGuests?: number;
  campaignId: number;
}

interface AdditionalCampaignInformation {
  uuidCampaignId: string;
  totalSpend: number;
}

export type AugmentedCampaignType = Without<CampaignType, 'campaignId'> & CampaignTotal & AdditionalCampaignInformation;

interface CoverTypeSeriesDataPoint {
  campaign_id: number;
  cover_type: string;
  date_actual: string;
  covers: number;
}

interface CoverTypeSeriesRange {
  [date: string]: CoverTypeSeriesDataPoint;
}

export type ISODateKey = string; // e.g. '2019-01-01'

interface CoverTypeSeries {
  domain: ISODateKey[];
  range: CoverTypeSeriesRange;
}

interface CoverTypesRange {
  [coverType: string]: CoverTypeSeries; // Indexed with one of the domain values in the below comment
}

// looks like "TPROMOTED600-217697" - e.g. "COVERTYPESCORE-CAMPAIGNID"
export type CoverTypeCampaignIdKey = string;

export interface CoverTypes {
  domain: CoverTypeCampaignIdKey[];
  range: CoverTypesRange;
}

export type CoverSummary = CoverSummaryDataPoint[];

export interface CoverSummaryDataPoint {
  bonus_points_covers: number;
  channel_direct_covers: number;
  channel_discovery_covers: number;
  channel_restref_covers: number;
  custom_promotions_covers: number;
  is_flex_reso: true;
  low_exposure_covers: number;
  offer_covers: number;
  online_pending_covers: number;
  opentable_covers: number;
  opentable_network_covers: number;
  opentable_partner_covers: number;
  phone_covers: number;
  promoted_results_covers: number;
  promoted_results_with_targeting_covers: number;
  standard_exposure_covers: number;
  total_seated_covers: number;
  walkin_covers: number;
  your_network_covers: number;
}

export interface CoverTrends {
  covers_over_time: CoversOverTimeDataPoint[];
  covers_by_source: CoversBySourceDataPoint[];
  // Other things included here are reservation lead times and avg. party sizes
}

interface CommonDataPointProps {
  date_actual: string;
  date_previous: string;
}

type CoversOverTimeDataPoint = CommonDataPointProps & {
  covers_actual: number;
  covers_previous: number;
  change_percent: number;
  bonus_points_actual: number;
  promoted_results_actual: number;
  promoted_results_with_targeting_actual: number;
  custom_promotions_actual: number;
  offer_actual: number;
  bonus_points_previous: number;
  promoted_results_previous: number;
  promoted_results_with_targeting_previous: number;
  custom_promotions_previous: number;
  offer_previous: number;
};

type CoversBySourceDataPoint = CommonDataPointProps & {
  walkin_actual: number;
  walkin_previous: number;
  walkin_change_percent: number;
  phone_actual: number;
  phone_previous: number;
  phone_change_percent: number;
  your_network_actual: number;
  your_network_previous: number;
  your_network_change_percent: number;
  opentable_network_actual: number;
  opentable_network_previous: number;
  opentable_network_change_percent: number;
};

/////////////
// FILTERS //
/////////////

export interface Filters {
  dateRange: DateRange;
  daysOfWeek: DaysOfWeek;
  timeRange: TimeRange;
  compareTo: ComparativePeriod;
}

export interface DateRange {
  startDate: string;
  endDate: string;
}

export enum DateRangeName {
  Start = 'startDate',
  End = 'endDate',
}

export type DaysOfWeek = { [dayOfWeek in Days]: boolean };

export interface TimeRange {
  startTime?: string;
  endTime?: string;
}

export enum Days {
  Sunday = 'SUNDAY',
  Monday = 'MONDAY',
  Tuesday = 'TUESDAY',
  Wednesday = 'WEDNESDAY',
  Thursday = 'THURSDAY',
  Friday = 'FRIDAY',
  Saturday = 'SATURDAY',
}

export enum ComparativePeriod {
  PreviousYear = 'last-year',
  PreviousPeriod = 'previous-period',
}

////////////////////
// API PARAMETERS //
////////////////////

export enum Granularity {
  Year = 'YEAR',
  Month = 'MONTH',
  Week = 'WEEK',
  Day = 'DAY',
  Hour = 'HOUR',
}

export enum CoverStates {
  Booked = 'booked',
  Seated = 'seated',
  Finished = 'finished',
  NoShow = 'noShow',
  Cancelled = 'cancelled',
}

export interface BasicFetchOptions {
  startDate: string;
  endDate: string;
}

type CommonFetchOptions = BasicFetchOptions & {
  startTime?: string;
  endTime?: string;
  daysOfWeek?: Days[];
};

export type FetchCoverTypesOptions = BasicFetchOptions;

export type FetchCoverTrendsOptions = CommonFetchOptions & {
  comparativePeriod?: ComparativePeriod;
  comparativeStartDate: string;
  comparativeEndDate: string;
  granularity: string;
};

export type FetchSummaryOptions = CommonFetchOptions & {
  stateCategories?: CoverStates[];
  // default true; meaning: track covers by date visited, instead of date booked
  isVisitDate?: boolean;
  samplePct?: number;
};
