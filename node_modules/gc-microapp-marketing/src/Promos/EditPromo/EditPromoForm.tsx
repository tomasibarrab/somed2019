import classNames from 'classnames';
import { AlertMessage, Button, ConfirmContent, TextAreaField } from 'gca-react-components';
import { cleanString } from 'gca-react-components/src/utils/string';
import * as React from 'react';
import { FormattedMessage, InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';
import { formValueSelector, InjectedFormProps, reduxForm } from 'redux-form';
import { initialValuesSelector } from '../../store/promos/promoForm';
import { PromoForm, promoFormDefaults } from '../../store/promos/promoForm';
import { currentPromoSelector, Status, updatePromo } from '../../store/promos/promos';
import { RestaurantPromo } from '../../store/promos/promos.types';
import { Dispatch, State } from '../../store/types';
import { CreditCardForm } from './CreditCardForm';

import './EditPromoForm.scss';

export const PROMO_FORM_NAME = 'promos';
export const enum Fields {
  Message = 'message',
  RequireCreditCard = 'requireCreditCard',
  Inform = 'inform',
  Amount = 'amount',
  Days = 'days',
  StartTime = 'startTime',
  EndTime = 'endTime',
  AllShifts = 'allShifts',
}

interface SP {
  currentPromo: RestaurantPromo;
  creditCardEnabled: boolean;
  allShifts: boolean;
  inform: boolean;
  initialValues: PromoForm;
  productType: string;
  requireCreditCard: boolean;
  rid: number;
  status: Status;
}

interface DP {
  leavePromo: () => void;
}

export type BaseProps = SP & DP & InjectedIntlProps;
export type Props = BaseProps & InjectedFormProps<PromoForm, BaseProps>;

class EditPromoForm extends React.Component<Props, {}> {
  public render() {
    const {
      currentPromo,
      handleSubmit,
      intl: { formatMessage },
      invalid,
      leavePromo,
      pristine,
      productType,
      status,
    } = this.props;

    const isEditMode = !!currentPromo.promoRestaurant;
    const placeholder =
      currentPromo.promo.selfServeDetails.placeHolder ||
      formatMessage({
        id: 'promos.form.placeholder',
      });

    // Seasonal and Featured promos have different description lengths. ¯\_(ツ)_/¯
    const maxDescriptionLength = currentPromo.promo.type === 'Seasonal' ? 300 : 100;

    const showCCForm = productType === 'Guest_Center' && currentPromo.promo.type === 'Seasonal';

    return (
      <form onSubmit={handleSubmit} className="edit-promo-form">
        <AlertMessage display="block" type="warn" active={status === 'failure'}>
          <FormattedMessage id="promos.form.error" />
        </AlertMessage>

        <p className="subtitle">
          <FormattedMessage id="promos.form.description" />
        </p>
        <TextAreaField
          name={Fields.Message}
          min={50}
          max={maxDescriptionLength}
          placeholder={placeholder}
          rows={3}
          parse={cleanString}
        />

        {showCCForm && <CreditCardForm {...this.props} />}

        <footer>
          <Button
            htmlType="submit"
            disabled={invalid || pristine}
            theme={isEditMode ? 'primary' : 'publish'}
            busy={status === 'open'}
          >
            <FormattedMessage id={`promos.form.${isEditMode ? 'save' : 'publish'}`} />
          </Button>

          {isEditMode && (
            <ConfirmContent onConfirm={leavePromo}>
              {({ showConfirm, onInitial, onConfirm }) =>
                showConfirm ? (
                  <Button theme="link" onClick={onConfirm}>
                    <FormattedMessage id="promos.form.leave.confirm" />
                  </Button>
                ) : (
                  <Button theme="link" onClick={onInitial}>
                    <FormattedMessage id="promos.form.leave" />
                  </Button>
                )
              }
            </ConfirmContent>
          )}
        </footer>
      </form>
    );
  }

  public componentWillUpdate(nextProps: Props) {
    if (nextProps.requireCreditCard === false && nextProps.inform === true) {
      if (this.props.change) {
        this.props.change(Fields.Inform, false);
        this.props.change(Fields.AllShifts, true);
      }
    }
  }
}

const ReduxEditPromoForm = reduxForm<PromoForm, BaseProps>({
  form: PROMO_FORM_NAME,
  onSubmit: (values, dispatch) => {
    dispatch(updatePromo.started(promoFormDefaults(values)));
  },
})(EditPromoForm);

const mapState = (state: State) => {
  const formValues = formValueSelector(PROMO_FORM_NAME)(
    state,
    Fields.Inform,
    Fields.RequireCreditCard,
    Fields.AllShifts,
  );
  return {
    allShifts: formValues.allShifts,
    creditCardEnabled: state.promos.creditCardEnabled,
    currentPromo: currentPromoSelector(state),
    inform: formValues.inform,
    initialValues: initialValuesSelector(state),
    productType: state.currentContext.restaurant.productType,
    requireCreditCard: formValues.requireCreditCard,
    rid: state.currentContext.restaurant.rid,
    status: state.promos.saveStatus,
  };
};

const mapDispatch = (dispatch: Dispatch) => ({
  leavePromo(e: any) {
    e.preventDefault();
    dispatch(updatePromo.started(null));
  },
});

export default connect(mapState, mapDispatch)(injectIntl(ReduxEditPromoForm));
