import MonthlyBudget from './MonthlyBudget';

import { mount } from 'enzyme';
import React from 'react';
import { IntlProvider } from 'react-intl';
import { Provider } from 'react-redux';
import configureMockStore from 'redux-mock-store';
import { createEmptyFormSettings } from '../../../store/flexiblepricing/createEmptyFormSettings';
import { VisibilityType } from '../../../store/flexiblepricing/flexiblepricing.types';
import makeMockState, { mockDiscoveryPrices } from '../../../store/flexiblepricing/makeMockState';
import { keys } from '../../../translations/bundles/marketing.json';

const renderComponent = (state: any) => {
  const store = configureMockStore([])(state);

  return {
    store,
    wrapper: mount(
      <Provider store={store}>
        <IntlProvider messages={keys} locale="en-US">
          <MonthlyBudget />
        </IntlProvider>
      </Provider>,
    ),
  };
};

const updateAndAssertInputText = (wrapper: any, inputText: string) => {
  wrapper.update();
  const inputBox = wrapper.find('input[name="budget"]');
  expect(inputBox.prop('value')).toEqual(inputText);
};

const typeIntoInput = (wrapper: any, inputText: any) => {
  const inputBox = wrapper.find('input[name="budget"]');
  inputBox.simulate('change', { target: { value: inputText } });
};

const expectActionCount = (store: any, count: number) => {
  expect(store.getActions().length).toEqual(count);
};

const expectActionCountAndLastWithPayloadAmount = (store: any, count: number, amount: number) => {
  const actions = store.getActions();
  expect(actions.length).toEqual(count);
  expect(actions[actions.length - 1].payload).toEqual(amount);
};

describe('MonthlyBudget', () => {
  it('matches snapshot', () => {
    const mockSettings = createEmptyFormSettings(mockDiscoveryPrices);

    mockSettings.increase.monthlyBudget.amount = 500;
    mockSettings.enable.monthlyBudget = true;

    const state = makeMockState({
      formVisibilitySettings: mockSettings,
    });
    const { wrapper } = renderComponent(state);

    expect(wrapper.debug()).toMatchSnapshot();
  });

  it('clicking checkbox to disable monthly budget sends action to do so', () => {
    const mockSettings = createEmptyFormSettings(mockDiscoveryPrices);

    mockSettings.increase.monthlyBudget.amount = 500;
    mockSettings.enable.monthlyBudget = true;

    const state = makeMockState({
      formVisibilitySettings: mockSettings,
    });
    const { wrapper, store } = renderComponent(state);

    expect(store.getActions().length).toEqual(0);
    wrapper.find('Checkbox').prop('onClick')();

    expect(store.getActions()).toMatchSnapshot();
  });

  it('typing in the monthly budget box does not do anything if !enabled.monthlyBudget', () => {
    const mockSettings = createEmptyFormSettings(mockDiscoveryPrices);

    const state = makeMockState({
      formVisibilitySettings: mockSettings,
    });
    const { wrapper, store } = renderComponent(state);

    expectActionCount(store, 0);

    typeIntoInput(wrapper, '');
    /* Default text loaded into budget box is budget.toFixed(2), make sure it didn't change */
    updateAndAssertInputText(wrapper, '0.00');

    expectActionCount(store, 0);

    typeIntoInput(wrapper, '9');
    updateAndAssertInputText(wrapper, '0.00');
  });

  describe('text entry', () => {
    const mockSettings = createEmptyFormSettings(mockDiscoveryPrices);

    mockSettings.increase.monthlyBudget.amount = 0;
    mockSettings.enable.monthlyBudget = true;

    const state = makeMockState({
      formVisibilitySettings: mockSettings,
    });
    const { wrapper, store } = renderComponent(state);

    /* `text` is what the user attempted to enter in the box,
        if `newValue` is present, it reflects that an action should have been dispatched
          to update the monthly budget to that value, as well as that the string in the box should
          have updated as well.
        if `newValue` is not present, it reflects that the input was not accepted, should not change
          the string in the input box, and should not update the monthly budget in the state.
    */
    const entries = [
      {
        description: 'Typing in the empty string sets budget to 0',
        newValue: 0,
        text: '',
      },
      {
        description: 'letters not accepted',
        text: 'a',
      },
      {
        description: 'minus signs not accepted',
        text: '-',
      },
      {
        description: '. accepted, sets budget to 0 since it parses as NaN',
        newValue: 0,
        text: '.',
      },
      {
        description: 'decimals with no leading zeros accepted',
        newValue: 0.9,
        text: '.9',
      },
      {
        description: 'decimals with no leading zeros accepted',
        newValue: 0.99,
        text: '.99',
      },
      {
        description: 'adding a third decimal place is not allowed',
        text: '.999',
      },
      {
        description: 'numbers close to limit accepted',
        newValue: 99999999,
        text: '99999999',
      },
      {
        description: 'adding any character that would put number over limit not accepted',
        text: '199999999',
      },
      {
        description: 'adding a negative sign not accepted',
        text: '-99999999',
      },
      {
        description: 'adding . accepted since it does not put number over limit',
        newValue: 99999999,
        text: '99999999.',
      },
      {
        description: 'go even closer to the limit',
        newValue: 99999999.9,
        text: '99999999.9',
      },
      {
        description: 'go even closer-er to the limit',
        newValue: 99999999.99,
        text: '99999999.99',
      },
      {
        description: 'not that close',
        text: '99999999.999',
      },
    ];

    let actionCount = 0;
    let expectedInputText = '';
    entries.forEach(({ description, text, newValue }: any) => {
      it(description, () => {
        typeIntoInput(wrapper, text);

        expectedInputText = newValue !== undefined ? text : expectedInputText;

        updateAndAssertInputText(wrapper, expectedInputText);

        if (newValue !== undefined) {
          actionCount += 1;
          expectActionCountAndLastWithPayloadAmount(store, actionCount, newValue);
        } else {
          expectActionCount(store, actionCount);
        }
      });
    });
  });
});
