import { AsyncContent } from 'gca-react-components';
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { Redirect, Route, RouteComponentProps, Switch } from 'react-router-dom';
import { FlexiblePricingState } from '../../store/flexiblepricing/flexiblepricing.types';
import { State } from '../../store/types';
import LandingPage from './LandingPage/LandingPage';

import {
  fetchActiveContractPrices,
  fetchPricingInfo,
} from '../../store/flexiblepricing/flexiblepricing';
import { hasVisibilitySettings as hasVisibilitySettingsSelector } from '../../store/flexiblepricing/selectors';
import FlexiblePricingErrorBoundary from './FlexiblePricingErrorBoundary';
import FlexiblePricingMain from './FlexiblePricingMain';

type RP = RouteComponentProps<any>;

interface SP {
  activeContractPrices: FlexiblePricingState['activeContract'];
  appInitialized: boolean;
  hasVisibilitySettings: boolean;
  pricingInfo: FlexiblePricingState['pricingInfo'];
  visibilitySettings: FlexiblePricingState['visibilitySettings'];
}

interface DP {
  fetchPricingInfoStarted: typeof fetchPricingInfo.started;
  fetchActiveContractPricesStarted: typeof fetchActiveContractPrices.started;
}

type Props = SP & DP & RP;

export const enum Routes {
  LandingPage = 'landing-page',
  Settings = 'settings',
}

class FlexiblePricing extends Component<Props> {
  public componentDidMount() {
    const { fetchPricingInfoStarted, fetchActiveContractPricesStarted } = this.props;
    fetchPricingInfoStarted({ firstFetch: true });
    fetchActiveContractPricesStarted({});
    /* Needs a parameter now that we are using `typeof` above and not just lying
    // about what the types of these are. Might use this first parameter in the future as an
    // indicator to "actually refetch the resource" or if false, just ensure it's there -
    // this would accomplish lazy fetching when `false` and allow true re-fetching when true
    // since there will be situations where child components here could want to force a re-fetch
    // such as when completing a POST or DELETE to make sure everything went as planned (though an Epic
    // could alternatively trigger this instead ) */
  }

  public render() {
    const {
      match,
      hasVisibilitySettings,
      pricingInfo,
      visibilitySettings,
      appInitialized,
      activeContractPrices,
    } = this.props;
    const error = visibilitySettings.error || pricingInfo.error || activeContractPrices.error;
    const redirectLocation = hasVisibilitySettings ? Routes.Settings : Routes.LandingPage;
    return (
      <FlexiblePricingErrorBoundary hasError={error}>
        <AsyncContent isLoading={!appInitialized || activeContractPrices.loading}>
          <Switch>
            <Route component={LandingPage} path={`${match.url}/${Routes.LandingPage}`} />
            <Route path={`${match.url}/${Routes.Settings}`} component={FlexiblePricingMain} />
            <Redirect to={`${match.url}/${redirectLocation}`} />
          </Switch>
        </AsyncContent>
      </FlexiblePricingErrorBoundary>
    );
  }
}

const mapState = (state: State) => ({
  activeContractPrices: state.flexiblePricing.activeContract,
  appInitialized: state.flexiblePricing.appInitialized,
  hasVisibilitySettings: hasVisibilitySettingsSelector(state),
  pricingInfo: state.flexiblePricing.pricingInfo,
  visibilitySettings: state.flexiblePricing.visibilitySettings,
});

const mapDispatch = {
  fetchActiveContractPricesStarted: fetchActiveContractPrices.started,
  fetchPricingInfoStarted: fetchPricingInfo.started,
};

export default connect<SP, DP, RP>(
  mapState,
  mapDispatch,
)(FlexiblePricing);
