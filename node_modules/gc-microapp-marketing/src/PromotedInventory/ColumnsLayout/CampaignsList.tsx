import './CampaignsList.scss';

import ArrowIcon from '-!svg-react-loader!./arrow.svg';
import { AsyncContent, Button, FeatureToggle, Panel } from 'gca-react-components';
import { selectors } from 'gca-react-components/src/redux-modules/currentContext';
import {
    selectors as featureToggleSelectors,
} from 'gca-react-components/src/redux-modules/featureToggles';
import _ from 'lodash';
import React, { Component } from 'react';
import { FormattedMessage, InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';
import { Link } from 'react-router-dom';

import { AlertMessage } from '@buffet/alert-message';
import { Notify } from '@buffet/notify';

import GuestCampaignsLeadGen from '../../GuestCampaigns/GuestCampaignsLeadGen';
import { actions, clearCreate, closeModal } from '../../store/campaigns/campaigns';
import {
    CampaignGroup, CampaignState, CampaignType, FetchCampaignsOptions, ModalState, OpenModalPayload,
    Pages, PatchActionPayload, PatchBudgetPayload, PutSuppressionDatesPayload,
} from '../../store/campaigns/campaigns.types';
import { State } from '../../store/types';
import { getId } from '../CampaignsList/Modals/EditBudgetModal';
import ModalPicker from '../CampaignsList/Modals/ModalPicker';
import { APPROVE_CUSTOM_PROMOTION_FEATURE_NAME } from '../constants';
import CustomPromotionsLandingPage from '../CustomPromotions/CustomPromotionsLandingPage';
import { Routes } from '../Specials';
import SpecialsLandingPage from '../Specials/SpecialsLandingPage';
import Campaign from './Campaign';
import CustomPromotionsIntroduction from './CustomPromotionsIntroduction';

// TODO: should these be moved to other files?
const getCreateButton = (
  type: Pages,
  rid: number,
  clickCallToAction: (data: any) => void,
): React.ReactElement<{}> | undefined => {
  switch (type) {
    case Pages.Specials:
      return (
        /* Would love to not have this div here but don't want our styling to mess up
       other parts of the microapp that may have header content. */
        <div className="create-campaign-btn-container">
          <Link to={Routes.Campaign}>
            <Button
              data-testid="btnCreateSpecial"
              onClick={() => clickCallToAction({ name: 'Create Special', page: 'Specials List' })}
              type="button"
              theme="primary"
            >
              <FormattedMessage id="guestcampaigns.list.specials.create" />
            </Button>
          </Link>
        </div>
      );
    case Pages.CustomPromotions:
      return (
        <FeatureToggle featureId="featureGcaPiCreateCustomPromotion">
          <div className="create-campaign-btn-container">
            <a href={`/admin/marketing/${rid}/custom-promotions/create`}>
              <Button
                data-testid="btnCreateCustomPromotion"
                onClick={() => {
                  clickCallToAction({
                    feature: 'Start new campaign',
                    name: 'Create campaign',
                    page: 'CP campaigns list',
                  })
                }}
                type="button"
                theme="primary"
              >
                <FormattedMessage id="guestcampaigns.list.custom_promotions.create" />
              </Button>
            </a>
          </div>
        </FeatureToggle>
      );
    default:
      return undefined;
  }
};

const getTitleMessageId = (type: Pages): string => {
  if (type === Pages.CustomPromotions) {
    return 'guestcampaigns.list.custom_promotions';
  }
  if (type === Pages.Specials) {
    return 'guestcampaigns.list.specials';
  }
  if (type === Pages.FlexiblePricing) {
    return 'guestcampaigns.list.flexible_pricing';
  }
  return 'guestcampaigns.list.promoted_results';
};

const decorated = (WrappedComponent: any, clickCallToAction: (data: any) => void, rid: any) => {
  return class extends Component {
    public render() {
      return <WrappedComponent clickCallToAction={clickCallToAction} rid={rid} {...this.props} />;
    }
  };
};

const getEmptyComponent = (clickCallToAction: (data: any) => void, pageType: Pages, rid: any): any => {
  if (pageType === Pages.Specials) {
    return decorated(SpecialsLandingPage, clickCallToAction, rid);
  }
  if (pageType === Pages.CustomPromotions) {
    return decorated(CustomPromotionsLandingPage, clickCallToAction, rid);
  }
  if (pageType === Pages.FlexiblePricing) {
    return () => <div>{/* intentionally empty */}</div>;
  }
  return GuestCampaignsLeadGen;
};

interface SP {
  /* State props - given by redux */
  approveCustomPromotionFeature: boolean;
  campaigns: any;
  currentUserEmail: string;
  done: boolean;
  failed: boolean;
  loading: boolean;
  modal?: ModalState;
  notify: boolean;
  pageType: Pages;
  rid: number;
}

interface DP {
  /* Dispatch props - action creators */
  clearCreate: () => void;
  clickCallToAction: typeof actions.clickCallToAction;
  closeModal: () => void;
  fetchCampaignsRequest: (payload: FetchCampaignsOptions) => void;
  getCredits: (payload: any) => void;
  hideNotifyPopup: () => void;
  openModal: (payload: OpenModalPayload) => void;
  patchBudgetRequest: (payload: PatchBudgetPayload) => void;
  patchCampaignRequest: (payload: PatchActionPayload) => void;
  putSuppressionDates: (payload: PutSuppressionDatesPayload) => void;
}

interface OP {
  type: Pages;
}

type Props = SP & DP & OP & InjectedIntlProps;

/* React.Component<P, S> ------ P is type/interface of props, S is type/interface of state */
// tslint:disable-next-line:max-classes-per-file
class CampaignsList extends React.Component<Props, {}> {
  constructor(props) {
    super(props);

    this.state = {
      notify: false,
    };
  }

  public componentDidMount() {
    const { type, done, fetchCampaignsRequest, pageType } = this.props;
    if (!done || pageType !== type) {
      fetchCampaignsRequest({
        pageType: type,
      });
    }
    this.props.clearCreate();
  }

  public render() {
    const {
      approveCustomPromotionFeature,
      campaigns,
      clickCallToAction,
      currentUserEmail,
      failed,
      getCredits,
      hideNotifyPopup,
      intl,
      loading,
      modal,
      notify,
      openModal,
      pageType,
      rid,
    } = this.props;
    const groups = this.makeGroups(campaigns);

    const notificationIcon = failed ? 'negative' : 'success';
    const notificationType = failed ? 'error' : 'success';
    const notificationMessageId = failed ? 'edit_budget_error' : 'budget_saved';
    const content = (
      <>
        <Notify autohide={true} show={notify} delay={5} onTransitioned={this.onNotifyTransition}>
          <AlertMessage
            id="notification"
            iconId={notificationIcon}
            type={notificationType}
            message={this.props.intl.formatMessage({ id: getId(notificationMessageId) })}
            onClose={() => hideNotifyPopup()}
          />
        </Notify>
        {pageType === Pages.Specials && (
          <p className="description">
            <FormattedMessage id="guestcampaigns.list.specials.description" />
          </p>
        )}
        {pageType === Pages.PromotedResults && (
          <p className="description">
            <FormattedMessage id="guestcampaigns.list.promoted_results.description" />
          </p>
        )}
        {this.onlyInactive(groups) && pageType === Pages.PromotedResults && (
          <p className="inactive-message">
            <FormattedMessage id="guestcampaigns.list.inactive_message" />
            <a href="https://restaurant.opentable.com/products/extras/promoted-results" target="_blank">
              <FormattedMessage id="guestcampaigns.custompromotions.landingpage.cta_button" />
            </a>
            .
          </p>
        )}
        {pageType === Pages.PromotedResults && (
          <p>
            <FormattedMessage id="guestcampaigns.list.infobox.1" />
            <br />
            <FormattedMessage
              id="guestcampaigns.list.infobox.2"
              values={{
                'phone-number': <FormattedMessage id="guestcampaigns.support.phone" tagName="strong" />,
              }}
            />
          </p>
        )}
        {modal && (
          <ModalPicker
            campaign={modal.campaign}
            closeModal={this.props.closeModal}
            currentUserEmail={currentUserEmail}
            fetchCampaignsRequest={this.props.fetchCampaignsRequest}
            modalType={modal.type}
            pageType={pageType}
            patchBudgetRequest={this.props.patchBudgetRequest}
            patchCampaignRequest={this.props.patchCampaignRequest}
            putSuppressionDates={this.props.putSuppressionDates}
          />
        )}
        {pageType === Pages.CustomPromotions && <CustomPromotionsIntroduction />}
        {Object.keys(groups)
          .sort((a, b) => groups[a].order - groups[b].order)
          .filter(
            key =>
              key !== CampaignGroup.Pending || (pageType === Pages.CustomPromotions && approveCustomPromotionFeature),
          )
          .map(key => {
            return {
              group: groups[key].data.filter((campaign: CampaignType) => {
                return campaign.state === CampaignState.Draft ? campaign.needsDecisionMakerApproval : true;
              }),
              key,
            };
          })
          .filter(({ group }) => group.length > 0)
          .map(({ key, group }) => (
            <section key={key} className={key}>
              <header>
                <h2>
                  <ArrowIcon className={_.kebabCase(pageType)} />
                  <FormattedMessage id={`guestcampaigns.list.group_header.${key}`} />
                </h2>
                {key !== CampaignGroup.Recommended && this.makeStateDescription(pageType, key)}
              </header>
              {group.map((campaign: CampaignType) => (
                <Campaign
                  key={campaign.campaignId}
                  actions={actions}
                  campaign={campaign}
                  defaultApprovalMessage={{
                    messageToRestaurant: intl.formatMessage({
                      id: 'guestcampaigns.list.state_description_pending',
                    }),
                    recommendedBy: intl.formatMessage({
                      id: 'guestcampaigns.list.state_description_pending.attribution',
                    }),
                  }}
                  group={key}
                  openModal={openModal}
                  getCredits={getCredits}
                  patchCampaignRequest={this.props.patchCampaignRequest}
                  titleId={getTitleMessageId(pageType)}
                  currentUserEmail={currentUserEmail}
                  pageType={pageType}
                  clickCallToAction={clickCallToAction}
                />
              ))}
            </section>
          ))}
      </>
    );
    const contentWithPanel = (
      <Panel
        title={intl.formatMessage({ id: getTitleMessageId(pageType) })}
        headerContent={getCreateButton(pageType, rid, clickCallToAction)}
      >
        {content}
      </Panel>
    );
    return (
      <AsyncContent
        isLoading={loading}
        isError={failed}
        isEmpty={campaigns.length === 0 || (pageType === Pages.CustomPromotions && this.onlyInactive(groups))}
        emptyComponent={getEmptyComponent(clickCallToAction, pageType, rid)}
      >
        <>{pageType === Pages.FlexiblePricing ? content : contentWithPanel}</>
      </AsyncContent>
    );
  }

  private onNotifyTransition = (visibility: boolean) => {
    if (!visibility) {
      this.props.hideNotifyPopup();
    }
  };

  private onlyInactive = (groups: any) => {
    const numActive = parseInt(
      Object.keys(groups)
        .filter(key => key !== CampaignGroup.Inactive)
        .reduce((a, c) => a + groups[c].data.length, 0),
      10,
    );
    return numActive === 0;
  };

  private getDraftGroupName(campaign: CampaignType) {
    const { needsDecisionMakerApproval } = campaign;
    if (needsDecisionMakerApproval) {
      return CampaignGroup.Recommended;
    }
    return CampaignGroup.Pending;
  }

  private makeGroups = (campaigns: any) => {
    return campaigns.reduce(
      (accumulator: any, current: any) => {
        switch (current.state) {
          case CampaignState.Draft:
            accumulator[this.getDraftGroupName(current)].data.push(current);
            break;
          case CampaignState.Paused:
            accumulator[CampaignGroup.Paused].data.push(current);
            break;
          case CampaignState.Live:
            accumulator[CampaignGroup.Active].data.push(current);
            break;
          case CampaignState.Discarded:
          case CampaignState.Ended:
            accumulator[CampaignGroup.Inactive].data.push(current);
            break;
        }
        return accumulator;
      },
      {
        [CampaignGroup.Active]: { order: 4, data: [] },
        [CampaignGroup.Inactive]: { order: 5, data: [] },
        [CampaignGroup.Paused]: { order: 3, data: [] },
        [CampaignGroup.Pending]: { order: 2, data: [] },
        [CampaignGroup.Recommended]: { order: 1, data: [] },
      },
    );
  };

  private makeStateDescription = (type: Pages, state: string) => {
    let id;
    switch (type) {
      case Pages.CustomPromotions:
        id = `guestcampaigns.list.custom_promotions.state_description_${state}`;
        break;
      case Pages.PromotedResults:
        id = `guestcampaigns.list.promoted_results.state_description_${state}`;
        break;
      case Pages.Specials:
        id = `guestcampaigns.list.specials.state_description_${state}`;
        break;
      default:
        id = `guestcampaigns.list.state_description_${state}`;
    }
    return (
      <FormattedMessage
        id={id}
        tagName="p"
        values={{ 'phone-number': <FormattedMessage id="guestcampaigns.support.phone" tagName="strong" /> }}
      />
    );
  };
}

const mapState = (state: State) => ({
  approveCustomPromotionFeature: featureToggleSelectors.featureToggle(state, APPROVE_CUSTOM_PROMOTION_FEATURE_NAME),
  campaigns: state.campaigns.list,
  currentUserEmail: selectors.user(state).userName,
  done: state.campaigns.success || state.campaigns.error,
  failed: state.campaigns.error,
  loading: state.campaigns.loading,
  modal: state.campaigns.modal,
  notify: state.campaigns.showNotifyPopup,
  pageType: state.campaigns.pageType,
  rid: selectors.rid(state),
});

const mapDispatch = () => {
  const {
    clickCallToAction,
    getCredits,
    fetchCampaigns,
    hideNotifyPopup,
    openModal,
    patchBudget,
    patchCampaign,
    putSuppressionDates,
  } = actions;
  return {
    clearCreate,
    clickCallToAction,
    closeModal,
    fetchCampaignsRequest: fetchCampaigns.started,
    getCredits: getCredits.started,
    hideNotifyPopup,
    openModal,
    patchBudgetRequest: patchBudget.started,
    patchCampaignRequest: patchCampaign.started,
    putSuppressionDates: putSuppressionDates.started,
  };
};

export default connect<SP, DP, OP>(
  mapState,
  mapDispatch(),
)(injectIntl(CampaignsList));

export { CampaignsList };
