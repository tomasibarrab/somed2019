import moment, { Moment } from 'moment';
import {
  CustomSuppressionDate,
  DefaultSuppressionDateDescription,
  SuppressionDates,
} from '../../../../store/campaigns/campaigns.types';
import { dateFormat } from '../../../constants';
import defaultSuppressionDatesDescriptions from '../../../default-suppression-dates.json';
import { DateAttributes } from './BlockedDatesPicker';

export const toISODate = (m: Moment): string => m.format(dateFormat.MOMENT);

export const convertSuppressionDatesToMap = (
  suppressionDates: SuppressionDates | undefined,
): Map<string, DateAttributes> => {
  let blocked: Map<string, DateAttributes> = defaultSuppressionDatesDescriptions.reduce(
    (datesMap: Map<string, DateAttributes>, defaultDate: DefaultSuppressionDateDescription) => {
      const isBlocked =
        suppressionDates &&
        Array.isArray(suppressionDates.default) &&
        suppressionDates.default.find((id: string) => defaultDate.id === id)
          ? true
          : false;

      datesMap.set(defaultDate.startDate, { isBlocked, isDefault: true, isNew: !isBlocked, id: defaultDate.id });
      return datesMap;
    },
    new Map(),
  );

  blocked =
    suppressionDates && Array.isArray(suppressionDates.custom)
      ? suppressionDates.custom.reduce((datesMap: Map<string, DateAttributes>, date: CustomSuppressionDate) => {
          if (date.startDate === date.endDate) {
            datesMap.set(date.startDate, {
              isBlocked: true,
              isDefault: false,
              isNew: false,
              label: date.label,
            });
          } else {
            // Iterate over all the days in the range adding them individually
            const cursor = moment(date.startDate);
            const end = moment(date.endDate);
            while (!cursor.isAfter(end, 'day')) {
              datesMap.set(toISODate(moment(cursor)), {
                isBlocked: true,
                isDefault: false,
                isNew: false,
                label: date.label,
              });
              cursor.add(1, 'day');
            }
          }
          return datesMap;
        }, blocked)
      : blocked;

  return blocked;
};

const makeCustomSuppressionDate = (date: string, label?: string): CustomSuppressionDate => ({
  endDate: date,
  label,
  startDate: date,
});

const getDefaultSuppressionDateId = (date: string): string[] => {
  return defaultSuppressionDatesDescriptions
    .filter((defaultSuppressionDate: DefaultSuppressionDateDescription) =>
      moment(defaultSuppressionDate.startDate).isSame(moment(date), 'day'),
    )
    .map((defaultSuppressionDate: DefaultSuppressionDateDescription) => defaultSuppressionDate.id);
};

// Can compare dates as strings since ISO Dates lexicographic order === chronological order
const customSuppressionDateCompare = (a: CustomSuppressionDate, b: CustomSuppressionDate): number => {
  if (a.startDate > b.startDate) {
    return 1;
  }
  return -1;
};

export const translateMap = (datesMap: Map<string, DateAttributes>): SuppressionDates => {
  const custom: CustomSuppressionDate[] = [];
  let def: string[] = [];

  datesMap.forEach(({ isDefault, isBlocked, label }, key) => {
    if (isBlocked) {
      if (isDefault) {
        def = def.concat(getDefaultSuppressionDateId(key));
      } else {
        custom.push(makeCustomSuppressionDate(key, label));
      }
    }
  });
  return {
    custom: custom.sort(customSuppressionDateCompare),
    default: def,
  };
};
