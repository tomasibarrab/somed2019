import './CampaignsList.scss';

import { AsyncContent, Button, FeatureToggle, Panel } from 'gca-react-components';
import { selectors } from 'gca-react-components/src/redux-modules/currentContext';
import {
    selectors as featureToggleSelectors,
} from 'gca-react-components/src/redux-modules/featureToggles';
import React, { Component } from 'react';
import { FormattedMessage, InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';
import { Link } from 'react-router-dom';

import GuestCampaignsLeadGen from '../../GuestCampaigns/GuestCampaignsLeadGen';
import { actions, clearCreate, closeModal } from '../../store/campaigns/campaigns';
import {
    CampaignGroup, CampaignState, CampaignType, CampaignTypes, FetchCampaignsOptions, ModalState,
    OpenModalPayload, Pages, PatchActionPayload, PatchBudgetPayload, PutSuppressionDatesPayload,
} from '../../store/campaigns/campaigns.types';
import { State } from '../../store/types';
import { APPROVE_CUSTOM_PROMOTION_FEATURE_NAME } from '../constants';
import CustomPromotionsLandingPage from '../CustomPromotions/CustomPromotionsLandingPage';
import { Routes } from '../Specials';
import SpecialsLandingPage from '../Specials/SpecialsLandingPage';
import Campaign from './Campaign';
import DraftCampaign from './DraftCampaign';
import ModalPicker from './Modals/ModalPicker';

const getCreateButton = (
  type: Pages,
  rid: number,
  clickCallToAction: (data: any) => void,
): React.ReactElement<{}> | undefined => {
  switch (type) {
    case Pages.Specials:
      return (
        /* Would love to not have this div here but don't want our styling to mess up
       other parts of the microapp that may have header content. */
        <div className="create-campaign-btn-container">
          <Link to={Routes.Campaign}>
            <Button
              data-testid="btnCreateSpecial"
              onClick={() => clickCallToAction({ name: 'Create Special', page: 'Specials List' })}
              type="button"
              theme="primary"
            >
              <FormattedMessage id="guestcampaigns.list.specials.create" />
            </Button>
          </Link>
        </div>
      );
    case Pages.CustomPromotions:
      return (
        <FeatureToggle featureId="featureGcaPiCreateCustomPromotion">
          <div className="create-campaign-btn-container">
            <a href={`/admin/marketing/${rid}/custom-promotions/create`}>
              <Button
                data-testid="btnCreateCustomPromotion"
                onClick={() => clickCallToAction({ name: 'Create Custom Promotion', page: 'Campaigns List' })}
                type="button"
                theme="primary"
              >
                <FormattedMessage id="guestcampaigns.list.custom_promotions.create" />
              </Button>
            </a>
          </div>
        </FeatureToggle>
      );
    default:
      return undefined;
  }
};

const getTitleMessageId = (type: Pages): string => {
  if (type === Pages.CustomPromotions) {
    return 'guestcampaigns.list.custom_promotions';
  }
  if (type === Pages.Specials) {
    return 'guestcampaigns.list.specials';
  }
  return 'guestcampaigns.list.promoted_results';
};

interface SP {
  /* State props - given by redux */
  campaigns: any;
  done: boolean;
  failed: boolean;
  loading: boolean;
  modal?: ModalState;
  pageType: Pages;
  rid: number;
  approveCustomPromotionFeature: boolean;
}

interface DP {
  /* Dispatch props - action creators */
  clearCreate: () => void;
  clickCallToAction: (data: any) => void;
  closeModal: () => void;
  fetchCampaignsRequest: (payload: FetchCampaignsOptions) => void;
  openModal: (payload: OpenModalPayload) => void;
  patchBudgetRequest: (payload: PatchBudgetPayload) => void;
  patchCampaignRequest: (payload: PatchActionPayload) => void;
  putSuppressionDates: (payload: PutSuppressionDatesPayload) => void;
}

interface OP {
  type: Pages;
}

type Props = SP & DP & OP & InjectedIntlProps;

const decorated = (WrappedComponent: any, clickCallToAction: (data: any) => void, rid: any) => {
  return class extends Component {
    public render() {
      return <WrappedComponent clickCallToAction={clickCallToAction} rid={rid} {...this.props} />;
    }
  };
};

const getEmptyComponent = (clickCallToAction: (data: any) => void, pageType: Pages, rid: any): any => {
  if (pageType === Pages.Specials) {
    return decorated(SpecialsLandingPage, clickCallToAction, rid);
  }
  if (pageType === Pages.CustomPromotions) {
    return decorated(CustomPromotionsLandingPage, clickCallToAction, rid);
  }
  return GuestCampaignsLeadGen;
};

/* React.Component<P, S> ------ P is type/interface of props, S is type/interface of state */
// tslint:disable-next-line:max-classes-per-file
class CampaignsList extends React.Component<Props, {}> {
  public componentDidMount() {
    const { type, done, fetchCampaignsRequest, pageType } = this.props;
    if (!done || pageType !== type) {
      fetchCampaignsRequest({ pageType: type });
    }
    this.props.clearCreate();
  }

  public render() {
    const {
      loading,
      failed,
      campaigns,
      pageType,
      intl,
      modal,
      rid,
      clickCallToAction,
      approveCustomPromotionFeature,
    } = this.props;
    const groups = this.makeGroups(campaigns);
    return (
      <AsyncContent
        isLoading={loading}
        isError={failed}
        isEmpty={campaigns.length === 0 || (pageType === Pages.CustomPromotions && this.onlyInactive(groups))}
        emptyComponent={getEmptyComponent(clickCallToAction, pageType, rid)}
      >
        <Panel
          title={intl.formatMessage({ id: getTitleMessageId(pageType) })}
          headerContent={getCreateButton(pageType, rid, clickCallToAction)}
        >
          {this.onlyInactive(groups) && pageType === Pages.PromotedResults && (
            <p className="inactive-message">
              <FormattedMessage id="guestcampaigns.list.inactive_message" />
              <a href="https://restaurant.opentable.com/products/extras/promoted-results" target="_blank">
                Learn More
              </a>
              .
            </p>
          )}
          {pageType === Pages.PromotedResults && (
            <p>
              <FormattedMessage id="guestcampaigns.list.infobox.1" />
              <br />
              <FormattedMessage
                id="guestcampaigns.list.infobox.2"
                values={{
                  'phone-number': <FormattedMessage id="guestcampaigns.support.phone" tagName="strong" />,
                }}
              />
            </p>
          )}
          {modal && (
            <ModalPicker
              campaign={modal.campaign}
              modalType={modal.type}
              patchBudgetRequest={this.props.patchBudgetRequest}
              patchCampaignRequest={this.props.patchCampaignRequest}
              fetchCampaignsRequest={this.props.fetchCampaignsRequest}
              putSuppressionDates={this.props.putSuppressionDates}
              closeModal={this.props.closeModal}
              pageType={pageType}
            />
          )}
          <div className="campaigns-list">
            {Object.keys(groups)
              .sort((a, b) => groups[a].order - groups[b].order)
              .filter(
                key =>
                  key !== CampaignGroup.Pending ||
                  (pageType === Pages.CustomPromotions && approveCustomPromotionFeature),
              )
              .map(key => {
                return {
                  group: groups[key].data.filter((campaign: CampaignType) => {
                    return campaign.state === CampaignState.Draft ? campaign.needsDecisionMakerApproval : true;
                  }),
                  key,
                };
              })
              .filter(({ group }) => group.length > 0)
              .map(({ key, group }) => {
                const campaignComponents = group.map((campaign: CampaignType) =>
                  key === CampaignGroup.Pending ? (
                    <DraftCampaign campaign={campaign} key={campaign.campaignId} openModal={this.props.openModal} />
                  ) : (
                    <Campaign campaign={campaign} key={campaign.campaignId} />
                  ),
                );
                return (
                  <section key={key}>
                    <div>
                      <h2>{key}</h2>
                      {this.makeStateDescription(pageType, key)}
                    </div>
                    <table>
                      {key !== CampaignGroup.Pending && (
                        <thead>
                          <tr>
                            <FormattedMessage tagName="th" id="guestcampaigns.list.type" />
                            <FormattedMessage tagName="th" id="guestcampaigns.list.campaigndates" />
                            <th>&nbsp;</th>
                          </tr>
                        </thead>
                      )}
                      {campaignComponents}
                    </table>
                  </section>
                );
              })}
          </div>
        </Panel>
      </AsyncContent>
    );
  }

  private groupDoesNotHaveOnlyDraftDecisionMakerCustomPromotions = (
    // PI-2774
    data: any,
  ) =>
    data.filter((campaign: CampaignType) => {
      const { type: campaignType, state, needsDecisionMakerApproval } = campaign;
      return !(
        campaignType === CampaignTypes.CustomPromotions &&
        state === CampaignState.Draft &&
        !needsDecisionMakerApproval
      );
    }).length > 0;

  private onlyInactive = (groups: any) => {
    const numActive = parseInt(
      Object.keys(groups)
        .filter(key => key !== CampaignGroup.Inactive)
        .filter(key => this.groupDoesNotHaveOnlyDraftDecisionMakerCustomPromotions(groups[key].data))
        .reduce((a, c) => a + groups[c].data.length, 0),
      10,
    );
    return numActive === 0;
  };

  private makeGroups = (campaigns: any) => {
    return campaigns.reduce(
      (accumulator: any, current: any) => {
        switch (current.state) {
          case CampaignState.Draft:
            accumulator[CampaignGroup.Pending].data.push(current);
            break;
          case CampaignState.Paused:
            accumulator[CampaignGroup.Paused].data.push(current);
            break;
          case CampaignState.Live:
            accumulator[CampaignGroup.Active].data.push(current);
            break;
          case CampaignState.Discarded:
          case CampaignState.Ended:
            accumulator[CampaignGroup.Inactive].data.push(current);
            break;
        }
        return accumulator;
      },
      {
        [CampaignGroup.Active]: { order: 3, data: [] },
        [CampaignGroup.Inactive]: { order: 4, data: [] },
        [CampaignGroup.Paused]: { order: 2, data: [] },
        [CampaignGroup.Pending]: { order: 1, data: [] },
      },
    );
  };

  private makeStateDescription = (type: Pages, state: string) => {
    let id;
    switch (type) {
      case Pages.CustomPromotions:
        id = `guestcampaigns.list.custom_promotions.state_description_${state}`;
        break;
      case Pages.Specials:
        id = `guestcampaigns.list.specials.state_description_${state}`;
        break;
      default:
        id = `guestcampaigns.list.state_description_${state}`;
    }
    return (
      <FormattedMessage
        id={id}
        tagName="p"
        values={{ 'phone-number': <FormattedMessage id="guestcampaigns.support.phone" tagName="strong" /> }}
      />
    );
  };
}

const mapState = (state: State) => ({
  approveCustomPromotionFeature: featureToggleSelectors.featureToggle(state, APPROVE_CUSTOM_PROMOTION_FEATURE_NAME),
  campaigns: state.campaigns.list,
  done: state.campaigns.success || state.campaigns.error,
  failed: state.campaigns.error,
  loading: state.campaigns.loading,
  modal: state.campaigns.modal,
  pageType: state.campaigns.pageType,
  rid: selectors.rid(state),
});

const mapDispatch = () => {
  const { clickCallToAction, fetchCampaigns, openModal, patchCampaign, putSuppressionDates } = actions;
  return {
    clearCreate,
    clickCallToAction,
    closeModal,
    fetchCampaignsRequest: fetchCampaigns.started,
    openModal,
    patchCampaignRequest: patchCampaign.started,
    putSuppressionDates: putSuppressionDates.started,
  };
};

export default connect<SP, DP, OP>(
  mapState,
  mapDispatch(),
)(injectIntl(CampaignsList));

export { CampaignsList };
