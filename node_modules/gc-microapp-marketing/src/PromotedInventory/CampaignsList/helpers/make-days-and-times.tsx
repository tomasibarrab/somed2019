import moment from 'moment';
import React from 'react';
import { FormattedMessage, FormattedTime } from 'react-intl';
import { CampaignTypes, ShiftAndDay, ShiftAndDays } from '../../../store/campaigns/campaigns.types';

const weekdaysSortValue: { [index: string]: number } = {
  /* Keys must be sorted alphabetically. */
  FRIDAY: 4,
  MONDAY: 0,
  SATURDAY: 5,
  SUNDAY: 6,
  THURSDAY: 3,
  TUESDAY: 1,
  WEDNESDAY: 2,
};

const getShiftTimeDescription = (
  { startTime, endTime }: { startTime: string; endTime: string },
  type: CampaignTypes,
): JSX.Element[] => {
  const startTimeDate: Date = moment(startTime, 'HH:mm:ss').toDate();
  const endTimeDate: Date = moment(endTime, 'HH:mm:ss').toDate();

  return [
    <FormattedTime value={startTimeDate} key="start" />,
    <span key="dash"> - </span>,
    <FormattedTime value={endTimeDate} key="end" />,
  ];
};

const byWeekdayAsc = (a: any, b: any) => weekdaysSortValue[a] - weekdaysSortValue[b];

const formatWeekday = (weekday: string): string =>
  moment()
    .day(weekday)
    .format('ddd');

const makeDaysAndTimes = (
  schedule: any,
  type: CampaignTypes,
  isShortTerm?: boolean,
  startDate?: string,
  endDate?: string,
): JSX.Element => {
  /* Show the more compact version of the campaign if it is shortTerm, for a single day and shift. */
  if (
    (type === CampaignTypes.PromotedResults || type === CampaignTypes.CustomPromotions) &&
    isShortTerm &&
    startDate === endDate &&
    schedule.length === 1
  ) {
    return (
      <li>
        {getShiftTimeDescription(schedule[0], type)}
        <span className="parenthesize">{moment(startDate).format('ddd, MMM D')}</span>
      </li>
    );
  }

  const rows = makeRows(schedule);
  const listItems: JSX.Element[] = Object.keys(rows)
    .sort()
    .map((key: string): JSX.Element => {
      const row = rows[key];

      const sortedWeekdays = row.daysOfWeek.sort(byWeekdayAsc);

      let isConsecutive: boolean = false;
      const numWeekdays = sortedWeekdays.length;
      if (numWeekdays >= 3) {
        /* Check if consecutive, in that case, make the pretty string a
           "Mon - Wed" or something instead of "Mon, Tue, Wed".
        */
        const first: any = sortedWeekdays[0];
        const last: any = sortedWeekdays[numWeekdays - 1];
        if (weekdaysSortValue[last] - weekdaysSortValue[first] === numWeekdays - 1) {
          /* Consecutive if so. E.g.
             Tues, Wed, Thurs, Fri => 1, 2, 3, 4 => 4 - 1 == 3
          */
          isConsecutive = true;
        }
      }

      const formattedWeekdays = sortedWeekdays.map(formatWeekday);

      let weekdaysDescription: string;
      if (isConsecutive) {
        weekdaysDescription = `${formattedWeekdays[0]} - ${formattedWeekdays[numWeekdays - 1]}`;
      } else {
        weekdaysDescription = formattedWeekdays.join(', ');
      }

      const shiftTimeDescription = getShiftTimeDescription(row, type);

      /* Yes the li is repeated here but w/o it you need
         extra spans in the markup to hold array keys */
      return (
        <li key={key}>
          {weekdaysDescription}
          <span className="parenthesize">{shiftTimeDescription}</span>
        </li>
      );
    });
  return <>{listItems}</>;
};

const makeRows = (schedule: ShiftAndDay[]): { [index: string]: ShiftAndDays } => {
  /*
  input:
  [{ startTime: '12:00:00', endTime: '21:00:00', dayOfWeek: 'SUNDAY' }, ...]

  output:
  {
    '12:00:00-15:00:00': {
      startDate: Date() // the start Time as a Date obj, for FormattedDate
      endDate: Date() // same as above
      daysOfWeek: ['MONDAY', ...]
    }
  }
  */

  return schedule.reduce((accumulator: any, current: any) => {
    const key = `${current.startTime}-${current.endTime}`;

    if (!accumulator[key]) {
      accumulator[key] = {
        daysOfWeek: [current.dayOfWeek],
        endTime: current.endTime,
        startTime: current.startTime,
      };
    } else {
      accumulator[key].daysOfWeek.push(current.dayOfWeek);
    }

    return accumulator;
  }, {});
};

export default makeDaysAndTimes;
