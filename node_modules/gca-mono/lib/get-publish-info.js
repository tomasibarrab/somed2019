
const fs = require('fs');
const { diffFiles } = require('./git');

const monoConfig = require('./config').getMonoPackageConfig();
const lockData = require('./lock').getLockData();
const { isRegistryApp, getRawPackageVersion, getRawDeployVersion } = require('./package-utils');
const { compileFullMicroappList } = require('./get-microapps');
const { formatVersionHyphenated } = require('./load-local-package');

/*
*  This library is for processing the package.json of all apps at once
*  to determine which apps should build/upload/promote.
*/

function isHigherSemver(a, b) {
  const [aMajor, aMinor, aPatch] = a.split('.').map(num => parseInt(num, 10));
  const [bMajor, bMinor, bPatch] = b.split('.').map(num => parseInt(num, 10));

  return aMajor > bMajor || aMinor > bMinor || aPatch > bPatch;
}

function getChangedPaths() {
  const workspaces = monoConfig.workspaces;
  console.log("WORKSPACES", workspaces)

  const changedFiles = diffFiles(lockData.lastPublishCommit)
    .map(file => file.split('/'))
    .filter(([workspace]) => workspaces.includes(workspace));

  console.log("CHANGED ALL:", changedFiles);
  return [...new Set(changedFiles.map(([workspace, package]) => `${workspace}/${package}`))];
}

function getSubDirs(workspace) {
  return fs.readdirSync(`./${workspace}`).map(file => ({
    workspace,
    path: `${process.cwd()}/${workspace}/${file}`,
  }));
}

function flatten(result, list) {
  return result.concat(list)
}

function hasPackageJson(pkg) {
  try {
    fs.accessSync(`${pkg.path}/package.json`);
    return true;
  } catch (e) {
    return false;
  }
}

function getPackageJsonFields(pkg) {
  const packageJson = require(`${pkg.path}/package.json`);

  const deployTestingVersionSemver = getRawDeployVersion(packageJson, 'testing');
  const deployProductionVersionSemver = getRawDeployVersion(packageJson, 'production');

  return {
    ...pkg,
    packageFile: packageJson,
    isRegistryApp: isRegistryApp(packageJson),
    name: packageJson.name,
    localVersion: getRawPackageVersion(packageJson), // Package.json package ver.si.on (source)
    testingVersionSemver: deployTestingVersionSemver, // Package.json Testing ver.si.on (source)
    testingVersion: deployTestingVersionSemver ? formatVersionHyphenated(deployTestingVersionSemver) : undefined, // Testing ver-si-on
    productionVersionSemver: deployProductionVersionSemver ? deployProductionVersionSemver : undefined,
    productionVersion: deployProductionVersionSemver ? formatVersionHyphenated(deployProductionVersionSemver) : undefined,
    private: packageJson.private || false,
    commands: Object.keys(packageJson.scripts)
  };
}

function getPublishStatus(pkg) {
  const publishedVersion = lockData.packages[pkg.name] || '0.0.0';
  const pending = publishedVersion === '0.0.0' || isHigherSemver(pkg.localVersion, publishedVersion);


  return {
    ...pkg,
    publishedVersion,
    pending,
  };
}

function getChangedStatus(pkg) {
  const changed = getChangedPaths();

  return {
    ...pkg,
    changed: changed.some(changePath => pkg.path.includes(changePath)),
  }
}

// File changes have been detected in a directory, but its package.json version has not been bumped
function getUnsafeStatus(pkg) {
  return {
    ...pkg,
    unsafe: pkg.changed && !pkg.shouldUpload,
  };
}

function checkNeedsTests(pkg) {
  // Ideal:
  // If there are any changes outside of apps folder (global changes), all apps run [Test]
  // Otherwise, only apps with changes run [Test]

  // Current:
  // All apps run tests every time
  return {
    ...pkg,
    shouldTest: pkg.commands,
  }
}

function checkNeedsUpload(pkg) {
  // Only Build & Upload if the packageVersion number has changed
  const publishedVersion = lockData.packages[pkg.name] || '0.0.0';

  return {
    ...pkg,
    shouldUpload: isHigherSemver(pkg.localVersion, publishedVersion),
  }
}

const checkNeedsPromote = (deployedVersions) => (pkg) => {
  const { isRegistryApp } = pkg;
  // Non-Registry apps don't need promotion
  // Show registry-related fields anyways, just in case the app is being migrated to Registry
  if (!isRegistryApp) {
    return pkg;
  }

  const existsInPP = !!deployedVersions.testing[pkg.name];
  const existsInProd = !!deployedVersions.production[pkg.name];

  // Only Build & Upload if the packageVersion number has changed
  const registryTestingVersion = deployedVersions.testing[pkg.name];
  const registryProductionVersion = deployedVersions.production[pkg.name];

  const shouldPromoteTesting = pkg.testingVersion !== registryTestingVersion;
  const shouldPromoteProduction = pkg.productionVersion !== registryProductionVersion;

  // Registry app
  return {
    ...pkg,
    existsInPP,
    existsInProd,
    shouldPromoteTesting,
    shouldPromoteProduction,
    registryTestingVersion,
    registryProductionVersion,
  }
}

async function getAllPackages() {
  const deployedVersions = await compileFullMicroappList();

  return monoConfig.workspaces
    .map(getSubDirs)
    .reduce(flatten, [])
    .filter(hasPackageJson)
    .map(getPackageJsonFields)
    .map(getPublishStatus)
    // .map(getChangedStatus)
    .map(getUnsafeStatus)
    .map(checkNeedsTests)
    .map(checkNeedsUpload)
    .map(checkNeedsPromote(deployedVersions));
}

let cachedPackages;
module.exports = async function info(filters = {}) {
  if (!cachedPackages) {
    cachedPackages = await getAllPackages();
  }

  // Return only packages that have a specific key+value
  const finalPackages = Object.keys(filters).reduce((filteredPackages, filterKey) => (
    filteredPackages.filter(pkg => pkg[filterKey] === filters[filterKey])
  ), cachedPackages);

  return finalPackages || cachedPackages;
}
