import { ModalWrapper } from 'gca-react-components';
import React, { ComponentType } from 'react';
import { FormattedMessage, InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';

import Confirm from '../Confirm/Confirm';
import PricingDetails from '../PricingDetails/PricingDetails';
import Print from '../Print/Print';
import Scheduling from '../Scheduling/Scheduling';
import { State } from '../store/types';
import {
  actions,
  selectors,
} from '../store/userAgreements/userAgreements';

import AgreementInvalid from '../AgreementInvalid/AgreementInvalid';
import { AgreementStepName } from '../store/userAgreements/userAgreements.types';
import TermsAndConditions from '../TermsAndConditions/TermsAndConditions';
import './UserAgreements.scss';

interface SP {
  currentPageName: AgreementStepName;
  isAnyAsyncFailed: boolean;
  isPageScrolledToBottom: boolean;
}

interface DP {
  dismissError: () => void;
  setPageScrolledToBottom: () => void;
}

interface PageMap {
  [key: string]: ComponentType
}

type Props = SP & DP & InjectedIntlProps;

class UserAgreements extends React.Component<Props, {}> {

  private appContentDiv: HTMLDivElement | null;

  private pages: PageMap = {
    AgreementInvalid,
    Confirm,
    PricingDetails,
    Print,
    Scheduling,
    TermsAndConditions,
  }

  private previousPageName: AgreementStepName | null;

  public componentWillUnmount() {
    // this might not be necessary, but I feel better cleaning up the ref
    if (this.appContentDiv) {
      this.appContentDiv.removeEventListener('scroll', this.handleAppContentDivScrolled);
    }
  }

  public render() {
    const { currentPageName, dismissError, isAnyAsyncFailed, intl } = this.props;
    let appClasses;

    if (currentPageName === AgreementStepName.PricingDetails
      || currentPageName === AgreementStepName.TermsAndConditions) {
        appClasses = 'app-content with-footer';
      } else {
        appClasses = 'app-content';
      }

    const errorModal = !isAnyAsyncFailed
      ? null
      : (
          <ModalWrapper
            title={intl.formatMessage({ id: 'app.errorTitle' })}
            confirmButtonText={intl.formatMessage({ id: 'modals.error.confirm' })}
            onConfirm={() => dismissError()}
            onCancel={() => null}
          >
            <FormattedMessage tagName="p" id="modals.error.body" />
          </ModalWrapper>
        );

    const PageComponent: any = this.pages[currentPageName];

    // ensure the content is scrolled to the top if this is a new page
    if (!this.previousPageName || this.previousPageName !== currentPageName) {
      // ts wants me to check this by itself
      if (this.appContentDiv) {
        this.appContentDiv.scrollTop = 0;
      }
    }

    this.previousPageName = currentPageName;

    return (
      <section className={appClasses} ref={this.registerAppContentDiv}>
        <div className="page">
          <PageComponent />
          {errorModal}
        </div>
      </section>
    );
  };

  private handleAppContentDivScrolled = () => {
    const { isPageScrolledToBottom, setPageScrolledToBottom } = this.props;

    if (!isPageScrolledToBottom && this.appContentDiv) {
      const appContentDiv: HTMLDivElement = this.appContentDiv;
      const isScrolled = appContentDiv.scrollHeight - appContentDiv.scrollTop === appContentDiv.clientHeight;

      if (isScrolled) {
        setPageScrolledToBottom();
      }
    }
  }

  private registerAppContentDiv = (appContentDiv: HTMLDivElement) => {
    this.appContentDiv = appContentDiv;

    if (this.appContentDiv) {
      this.appContentDiv.addEventListener('scroll', this.handleAppContentDivScrolled);
    }
  }
}

const mapState = (state: State): SP => ({
  currentPageName: selectors.getCurrentPage(state),
  isAnyAsyncFailed: selectors.getAnyAsyncFailed(state),
  isPageScrolledToBottom: state.userAgreements.isPageScrolledToBottom,
});

const mapDispatch = {
  dismissError: actions.resetUserAgreements,
  setPageScrolledToBottom: actions.pageScrolledToBottom,
}

export default connect<SP, DP, {}>(mapState, mapDispatch)(injectIntl<SP & DP>(UserAgreements));
export { UserAgreements as PureUserAgreements };
