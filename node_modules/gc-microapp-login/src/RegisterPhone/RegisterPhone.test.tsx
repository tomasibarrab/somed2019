import {
  cleanup,
  fireEvent,
  render,
  wait,
} from '@testing-library/react';
import React from 'react';
import { IntlProvider } from 'react-intl';
import { MemoryRouter } from 'react-router';

import * as messages from '../translations/json/en-us.json';

jest.mock('../common/api');
import { ErrorCode, LoginResponse, RegisterPhoneRequest } from '../common/types';

import RegisterPhone from './RegisterPhone';

export default function getIntl() {
  // Create the IntlProvider to retrieve context for wrapping around.
  const intlProvider = new IntlProvider({ locale: 'en-us', messages }, {});
  return intlProvider.getChildContext().intl;
}

afterEach(cleanup);

// tslint:disable-next-line
const consoleError = console.error;
beforeAll(() => {
  jest.spyOn(console, 'error').mockImplementation((...args) => {
    if (!args[0].includes('Warning: An update to %s inside a test was not wrapped in act')) {
      consoleError(...args);
    }
  });
});

const locationMock: any = jest.fn();
locationMock.state = jest.fn();
const historyMock: any = jest.fn();

describe('RegisterPhone component', () => {
  const onSubmit = jest.fn();
  const handleSubmit = jest.fn();

  const props = {
    handleSubmit,
    intl: getIntl(),
    isSubmitting: false,
    messages,
    onSubmit,
  };

  const renderTree = (node) => {
    return <IntlProvider locale="en" messages={messages}>
      <MemoryRouter initialEntries={['/register-phone']} >
        {node}
      </MemoryRouter>
    </IntlProvider>
  };

  const rendererWithIntl = node => render(renderTree(node));

  const defaultParams = {
    handleConnectionFail: jest.fn(),
    handleLoginResponse: jest.fn(),
    loginCredentials: { username: 'user@ail.com', password: 'secret' },
    message: undefined,
  }

  test('UI elements are displayed when the page is loaded', () => {
    const { getByTestId, getByPlaceholderText } = rendererWithIntl(
      <RegisterPhone {...defaultParams} {...props} />,
    );
    expect(getByPlaceholderText('Phone Number')).toBeDefined();
    expect(getByTestId('submit-button')).toBeDefined();
  });

  test('Display an client-side validation error message if the phone input field is empty', () => {
    const { getByTestId } = rendererWithIntl(<RegisterPhone {...defaultParams} {...props} />);

    fireEvent.click(getByTestId('submit-button'));
    const errorPanel = getByTestId('status-code');
    expect(errorPanel).toBeDefined();
  });

  test('Display an client-side validation error message if the phone input field is invalid', () => {
    const { getByTestId, getByPlaceholderText } = rendererWithIntl(
      <RegisterPhone {...defaultParams} {...props} />,
    );
    const phoneInputElm = getByPlaceholderText('Phone Number');
    fireEvent.change(phoneInputElm, { target: { value: '1925408' } });
    fireEvent.click(getByTestId('submit-button'));

    const errorPanel = getByTestId('status-code');
    expect(errorPanel).toBeDefined();
  });

  test('Redirected to the Routes.VerifyCode page if the phone input field is valid', async () => {

    let responseContext: LoginResponse;

    const handleLoginResponse: (loginResp: LoginResponse, values: RegisterPhoneRequest) => void =
      (loginResp: LoginResponse, values: RegisterPhoneRequest) => {
        responseContext = { ...loginResp };
      };

    const { getByTestId, getByPlaceholderText, queryByTestId, debug } = rendererWithIntl(
      <RegisterPhone  {...defaultParams} {...props} handleLoginResponse={handleLoginResponse} />,
    );
    const phoneInputElm = getByPlaceholderText('Phone Number');
    fireEvent.change(phoneInputElm, { target: { value: '19254085222' } });
    fireEvent.click(getByTestId('submit-button'))
    await wait(() => responseContext.resultStatus === 3)
    expect(responseContext.errorCode === ErrorCode.codeNeeded).toBeTruthy();
  });
});
