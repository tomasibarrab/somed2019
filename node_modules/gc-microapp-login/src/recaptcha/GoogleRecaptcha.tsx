/*
Google Recaptcha has two versions of the human/bot verification check.
Document: https://developers.google.com/recaptcha/intro
GC Login uses both v2 and v3 versions. The approach of how to integrate both versions described
here: https://developers.google.com/recaptcha/docs/faq

Google Recaptcha creates a 'Recaptcha' property of window global object. After the
'Recaptcha' is created we use it as a container for store tokens during the session.

Google Recaptcha asks own server to apply for the tokens (tokenV2 and tokenV3). Then, those tokens
are sent to the gc-login-service for the verification. Right now, the gc-login-service uses
tokenV2 to make a decision, tokenV3 is used for statistic purpose only.

Once validated by the gc-login-service, both tokens become invalid. So, they need to be refreshed
before the next interaction with the server.

Applying for the tokenV3 does not require an interaction with the user. So, we can apply for the
tokenV3 anytime in background.

Applying for the token2 might cause the interaction with the user (solving Recaptcha challenge).
Therefore, we can apply for it only after the user clicks 'Sign In' button.

Google Recaptcha V3 execute() method returns Promise.
Google Recaptcha V2 execute() returns void and required the callback function defined upfront during the
'Recaptcha' initialization.

For the optimization purpose, we apply for the tokenV3 just after the 'Recaptcha' is created. it helps
to avoid an extra round of the interaction during the first login attempt when Recaptcha is required.
For all other attempts, both tokenV3 and tokenV3 are refreshed.

Login.tsx registers the tokensReadyCallback that is invoked when both tokenV2 and tokenV3 are fresh and ready.
*/

// tslint:disable:object-literal-sort-keys
import React, { useCallback, useEffect } from 'react';
import useScript from 'react-script-hook';

export interface RecaptchaProps {
  apiUrl: string,
  sitekeyV2: string;
  sitekeyV3: string;
  action: string
}

const tokenV2key = 'tokenV2';
const tokenV3key = 'tokenV3';

const recaptchaHost = () => (window as any).grecaptcha || {};

const encodeErrorToken = (key: string, msg: string, data?: string) => {
  recaptchaHost()[key] = '#' + msg + (data || '') + (recaptchaHost()[key] || '');
}

export function RecaptchaProvider({ apiUrl, sitekeyV2, sitekeyV3, action }: RecaptchaProps) {

  useEffect(() => {
    // initialize the object with callback on case of exceptional script loading
    // it will be overritten if recaptcha is initialized succesefully
    (window as any).grecaptcha = { refreshRecaptchaTokens };
  }, []);

  const refreshV3Token: () => Promise<void> = useCallback(async () => {
    encodeErrorToken(tokenV3key, 'unable to retrive v3token'); // pessimistic approch.
    recaptchaHost().tokenV3 = await recaptchaHost().execute(sitekeyV3, { action });
  }, [recaptchaHost() && recaptchaHost().tokenV3]);

  const handleTokenReadyCallback = useCallback(() => {
    recaptchaHost().tokensReadyCallback(recaptchaHost().tokenV2, recaptchaHost().tokenV3);
  }, [
      recaptchaHost() && recaptchaHost().tokenV2,
      recaptchaHost() && recaptchaHost().tokenV3,
    ]);

  const refreshRecaptchaTokens = useCallback(async () => {

    // if recaptcha is not loaded, report the problem to the server
    if (!recaptchaHost().ready) {
      handleTokenReadyCallback();
      return;
    }

    // already invoked? need to refresh v3 before asking for v2
    try {
      if (recaptchaHost().tokenV2 || !recaptchaHost().tokenV3) {
        recaptchaHost().tokenV3 = undefined;
        recaptchaHost().reset();
        await refreshV3Token();
      }
      // apply for tokenV2.
      recaptchaHost().execute();

    } catch (ex) {
      encodeErrorToken(tokenV2key, 'unable to refresh the token. ', ex);
      // something wrong happens. report to the server
      handleTokenReadyCallback();
    }
  }, [
      refreshV3Token,
      handleTokenReadyCallback,
      recaptchaHost() && recaptchaHost().tokenV2,
      recaptchaHost() && recaptchaHost().tokenV3,
    ]);

  // onRecaptchaV2Callback is used as a callback for tokenV2
  const onRecaptchaV2Callback = useCallback((tokenV2: string) => {
    recaptchaHost().tokenV2 = tokenV2;
    handleTokenReadyCallback();
  }, [handleTokenReadyCallback]);

  // v2token call returned err. report it
  const onRecaptchaV2Error = useCallback((err: string) => {
    encodeErrorToken(
      tokenV2key,
      'encounters an error (usually network connectivity). ',
      err,
    );
    handleTokenReadyCallback();
  }, [handleTokenReadyCallback]);

  // v2token call return expiration status. report it.
  const onRecaptchaV2Expired = useCallback((exp: string) => {
    encodeErrorToken(
      tokenV2key,
      'recaptcha response expired. ',
      exp,
    );
    handleTokenReadyCallback();
  }, [handleTokenReadyCallback]);

  useScript({
    src: `${apiUrl}?render=${sitekeyV3}`,
    onload: () => {
      recaptchaHost().ready(
        () => {
          recaptchaHost().refreshRecaptchaTokens = refreshRecaptchaTokens;
          refreshV3Token(); // optimized for the first login call
          recaptchaHost().render(
            document.getElementById('recaptcha'),
            {
              'callback': onRecaptchaV2Callback,
              'error-callback': onRecaptchaV2Error,
              'expired-callback': onRecaptchaV2Expired,
            },
          );
        },
      )
    },
    onerror: (ex: any) => {
      // the recaptcha script cannot be loaded. report it
      encodeErrorToken(tokenV2key, 'unable to load the recaptcha script');
      // tslint:disable-next-line
      console.error('Unable to load the recaptcha script!')
    },
  });

  return (
    <div
      id="recaptcha"
      className="g-recaptcha"
      data-sitekey={sitekeyV2}
      data-size="invisible"
    />);
}

export default RecaptchaProvider;
