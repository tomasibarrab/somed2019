module.exports = (Processor, Promise, Utils, HTTPService, Logger, JPParsingOutputHandler, _) ->

  class JPParsingProcessor extends Processor

    defaultOptions: {
      url: "http://linguistics.ci-uswest2.otenv.com/batch/ja/words"
      requestTimeout: 5000
      allowedLocales: ['ja-jp']
      doNotParse: []
      failOnError: false
    }

    allowedLocale: (locale) ->
      @options.allowedLocales is 'all' or _.contains @options.allowedLocales, locale

    run: ->
      @toParse = Utils.deepClone(@context.result)
      @options = _.extend {}, @defaultOptions, @config
      if not @allowedLocale(@context.locale)
        Promise.resolve()
      else
        @buildParsingCollection()
        @parse()

    buildParsingCollection: =>
      @dontParse = {}
      for key in @options.doNotParse
        @dontParse[key] = @toParse[key]
        delete  @toParse[key]

    parse: =>
      HTTPService.post(@options.url)
        .send(@toParse)
        .promiseBody()
        .then(@processParsedOutput)
        .catch(@handleParserError)

    handleParserError: (error) =>
      if @options.failOnError
        Logger.error "JP Parsing API Error: #{error.statusCode}. Translation processing failed. To ignore this error next time, set failOnError to false."
        Promise.reject(error)
      else
        Logger.error "JP Parsing API Error: #{error.statusCode}. JP word wrap not applied. Translation processing continuing."
        Promise.resolve(@context.result)

    processParsedOutput: (promiseBody) =>
      if _.isEmpty promiseBody then @handleParserError()
      output = {}
      for key, sentenceObj of promiseBody
        output[key] = JPParsingOutputHandler.buildString(sentenceObj)
      Promise.resolve(@context.result = _.extend output, @dontParse)
