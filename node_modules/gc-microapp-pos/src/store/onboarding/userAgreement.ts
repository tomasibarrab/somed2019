import { AgreementDetails } from '@buffet/user-agreement';
import actionCreatorFactory from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';
import { getAgreementTypeForPos } from '../../constants';
import { AsyncState } from '../../store/AsyncState';

import {
  AgreementType,
  CreateUserAgreementApiParams,
  Epic,
  FetchAgreementDetailsParams,
  OnboardingDisplayStateName,
  State,
  UserAgreementData,
} from '../types';

import { cancelPosActivation, fetchPosRideData } from './posStatus';

import { Observable } from 'rxjs/Observable';
import '../commonRxjs';


// ---------------------------------------------------------------------------------------------------------------------
// actions
// ---------------------------------------------------------------------------------------------------------------------

const actionCreator = actionCreatorFactory();
export const fetchUserAgreement = actionCreator
  .async<FetchAgreementDetailsParams, UserAgreementData, any>('FETCH_USER_AGREEMENT');

export const createUserAgreement = actionCreator
  .async<CreateUserAgreementApiParams, AgreementDetails>('CREATE_USER_AGREEMENT');


// ---------------------------------------------------------------------------------------------------------------------
// epics
// ---------------------------------------------------------------------------------------------------------------------

const getDisplayState = (state: State, isSigned: boolean): OnboardingDisplayStateName => {
  if (isSigned) {
    return state.onBoarding.selectedPos.Id ? 'nextSteps' : 'posSelect';
  }
  return 'landing';
};

export const triggerFetchUserAgreementEpic: Epic = (action$, store) =>
  action$
    .filter(fetchPosRideData.done.match)
    .map(({ payload }) => {
      const {
        params: rid,
        result: { isPosActive, ride },
      } = payload;

      let agreementTypes: AgreementType[];
      const posId = ride.posBrandId;

      if (posId) {
        agreementTypes = [getAgreementTypeForPos(posId)];
      } else {
        agreementTypes = [AgreementType.generic, AgreementType.omnivore];
      }

      return !isPosActive
        ? fetchUserAgreement.started({ rid, agreementTypes })
        : // assume Terms are signed if POS is active
          fetchUserAgreement.done({
            params: { rid, agreementTypes: [] },
            result: { isSigned: true, displayState: 'active' },
          });
    });

export const fetchUserAgreementEpic: Epic = (action$, store, { api }) =>
  action$
    .filter(fetchUserAgreement.started.match)
    .mergeMap(({ payload: { rid, agreementTypes } }) =>
      Observable.forkJoin(agreementTypes.map(agreementType => api
        .getUserAgreement({ rid, agreementType })
        .catch(err => Observable.of({ isSigned: false }))))
      .map(apiResponses => {
        const isSigned = apiResponses.some(res => res.isSigned);
        return fetchUserAgreement.done({
          params: { rid, agreementTypes },
          result: {
            displayState: getDisplayState(store.getState(), isSigned),
            isSigned,
          },
        });
      }),
  );

/**
 * If the POS activation has been successfully cancelled, then want to create a fresh unsigned User Agreement for the
 * corresponding agreement type.
 */
export const triggerCreateUserAgreementEpic: Epic = (action$, store) =>
  action$
    .filter(cancelPosActivation.done.match)
    .map(() => {
      const state = store.getState();

      return createUserAgreement.started({
        agreementType: getAgreementTypeForPos(state.onBoarding.selectedPos.Id),
        restaurantName: state.currentContext.restaurant.name,
        rid: state.currentContext.restaurant.rid,
      });
    });

export const createUserAgreementEpic: Epic = (action$, store, { api }) =>
  action$
    .filter(createUserAgreement.started.match)
    .mergeMap(({ payload }) => api
      .createUserAgreement(payload)
      .flatMap(response => [
        createUserAgreement.done({ params: payload, result: response.response }),

        //
        // synthetically fire done on fetch agreements, since the success of creating a new agreement for the pos
        // agreement type means it is no longer signed, and the user should be directed to the posSelect page
        //
        fetchUserAgreement.done({
          params: { rid: payload.rid, agreementTypes: [payload.agreementType] },
          result: { isSigned: false, displayState: 'posSelect' },
        }),
      ])
      .catch(error => [createUserAgreement.failed({ error, params: payload })]),
    );


// ---------------------------------------------------------------------------------------------------------------------
// reducer
// ---------------------------------------------------------------------------------------------------------------------

export const initialState: AsyncState<boolean> = {
  data: undefined,
  status: 'init',
};

export const fetchUserAgreementReducer = reducerWithInitialState(initialState as AsyncState<boolean>)
  .case(fetchUserAgreement.started, state => ({
    data: undefined,
    status: 'started',
  }))
  .case(fetchUserAgreement.done, (state, { result }) => ({
    data: result.isSigned,
    status: 'done',
  }))
  .case(fetchUserAgreement.failed, (state, { error }) => ({
    data: error,
    status: 'failed',
  }));

export const createUserAgreementReducer = reducerWithInitialState(initialState as AsyncState<AgreementDetails>)
  .case(createUserAgreement.started, state => ({
    data: undefined,
    status: 'started',
  }))
  .case(createUserAgreement.done, (state, { result }) => ({
    data: result,
    status: 'done',
  }))
  .case(createUserAgreement.failed, (state, { error }) => ({
    data: error,
    status: 'failed',
  }));
