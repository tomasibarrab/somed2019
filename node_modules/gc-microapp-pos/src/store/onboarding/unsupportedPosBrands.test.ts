import { Observable } from 'rxjs/Observable';
import { addNotification, removeNotificationById } from 'shared-react-smart-ui/NotificationCenter';
import { createAsyncMockStore, leadGenFormMock } from './onboarding.mocks';
import {
  clearErrorNotificationsEpic,
  initialState,
  leadGenNotificationSymbol,
  submitLeadGen,
  submitLeadGenEpic,
  submitLeadGenReducer,
} from './unsupportedPosbrands';

import { updateDisplayState } from '../onboarding/onboarding';

describe('submit unsupported pos lead gen Actions', () => {
  it('should take a lead gen form object', () => {
    const actual = submitLeadGen.started(leadGenFormMock);
    const expected = { payload: leadGenFormMock, type: submitLeadGen.started.type };

    expect(actual).toEqual(expected);
  });

  it('should not really need anything to be done', () => {
    const actual = submitLeadGen.done({ params: leadGenFormMock, result: undefined });
    const expected = { payload: { params: leadGenFormMock, result: undefined }, type: submitLeadGen.done.type };

    expect(actual).toEqual(expected);
  });
});

describe('submit lead gen epic', () => {
  it('should pass the lead gen form to the api and fire done', () => {
    const mockResponse: Observable<null> = Observable.of(null);

    const mockApi = { submitLeadGen: jest.fn(() => mockResponse) };

    const store = createAsyncMockStore(mockApi, submitLeadGenEpic);

    store.dispatch(submitLeadGen.started(leadGenFormMock));
    expect(store.getActions()).toEqual([
      submitLeadGen.started(leadGenFormMock),
      submitLeadGen.done({ params: leadGenFormMock, result: null }),
      updateDisplayState('submittedLeadGen'),
    ]);

    expect(mockApi.submitLeadGen).toHaveBeenCalledWith(leadGenFormMock);
  });

  it('should pass the lead gen form to the api and fire failed if api throws', () => {
    const mockResponse: Observable<null> = Observable.throw('some error');

    const mockApi = { submitLeadGen: jest.fn(() => mockResponse) };

    const store = createAsyncMockStore(mockApi, submitLeadGenEpic);

    store.dispatch(submitLeadGen.started(leadGenFormMock));
    expect(store.getActions()).toEqual([
      submitLeadGen.started(leadGenFormMock),
      submitLeadGen.failed({ params: leadGenFormMock, error: 'some error' }),
      addNotification({
        iconId: 'negative',
        id: leadGenNotificationSymbol,
        messageId: 'app.error.general',
        type: 'error',
      }),
    ]);

    expect(mockApi.submitLeadGen).toHaveBeenCalledWith(leadGenFormMock);
  });
});

describe('clear error notifications epic', () => {
  it('should remove any error notifications when lead gen submitted', () => {
    const mockResponse: Observable<null> = Observable.of(null);

    const store = createAsyncMockStore({}, clearErrorNotificationsEpic);

    store.dispatch(submitLeadGen.started(leadGenFormMock));
    expect(store.getActions()).toEqual([
      submitLeadGen.started(leadGenFormMock),
      removeNotificationById(leadGenNotificationSymbol),
    ]);
  });
});

describe('submit lead gen reducer', () => {
  it('should set status to start when start action is fired', () => {
    const action = {
      payload: leadGenFormMock,
      type: submitLeadGen.started.type,
    };

    const expected = {
      data: undefined,
      status: 'started',
    };

    const actual = submitLeadGenReducer(initialState, action);

    expect(actual).toEqual(expected);
  });

  it('should set status to done when the done action is fired', () => {
    const action = {
      payload: { params: leadGenFormMock, result: undefined },
      type: submitLeadGen.done.type,
    };

    const expected = {
      data: undefined,
      status: 'done',
    };

    const actual = submitLeadGenReducer(initialState, action);

    expect(actual).toEqual(expected);
  });

  it('should set status to failed when the failed action is fired', () => {
    const action = {
      type: submitLeadGen.failed.type,
    };

    const expected = {
      data: undefined,
      status: 'failed',
    };

    const actual = submitLeadGenReducer(initialState, action);

    expect(actual).toEqual(expected);
  });
});
