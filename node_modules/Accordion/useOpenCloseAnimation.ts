import { useCallback, useLayoutEffect, useRef, useState } from 'react';

import { isIE } from 'shared-utils/dom';
import { AccordionHookProps, AccordionProps } from './AccordionTypes';


export const useOpenCloseAnimation = ({ isOpen, onOpen, onClose }: Partial<AccordionProps>): AccordionHookProps => {
  const wrapperRef = useRef<HTMLDivElement>(null);
  const contentRef = useRef<HTMLDivElement>(null);

  const [height, setHeight] = useState(() => (isOpen ? null : 0)); // null means height is auto (children are visible)
  const [isAnimating, setAnimating] = useState(false);
  const [firstRender, setFirstRender] = useState(true);

  // when isOpen changes...
  useLayoutEffect(() => {
    // no animations on first render
    if (firstRender) {
      setFirstRender(false);
      return () => null;
    } else {
      // prepare for animation
      setAnimating(true);

      // prepare height for "close" animation (from "auto" to fixed size in px) => needs a render
      if (height === null && !isOpen && contentRef.current) {
        setHeight(contentRef.current.offsetHeight);
      }

      // start the open/close animation after a small delay (give time for above case to render)
      const t = setTimeout(() => {
        if (!isOpen) {
          setHeight(0);
        } else if (contentRef.current) {
          setHeight(contentRef.current.offsetHeight);
        }
      }, 0);

      return () => clearTimeout(t);
    }
  }, [isOpen]);

  // function to run when animation is complete
  // this will be different every time "animating" and "height" change
  const animationCleanUp = useCallback(({ target, propertyName }: TransitionEvent) => {
    if (target === wrapperRef.current && propertyName === 'height' && isAnimating) {
      setAnimating(false);

      if (height) {
        setHeight(null);
        if (typeof onOpen === 'function') {
          onOpen();
        }
      } else if (height === 0 && typeof onClose === 'function') {
        onClose();
      }
    }
  }, [isAnimating, height]);

  // re-attach the event listener for animation end every time this changes
  // todo: performance check for doing this too often
  useLayoutEffect(() => {
    if (wrapperRef.current !== null) {
      wrapperRef.current.addEventListener('transitionend', animationCleanUp);
    }
    return () => {
      if (wrapperRef.current !== null) {
        wrapperRef.current.removeEventListener('transitionend', animationCleanUp)
      }
    }
  }, [animationCleanUp]);

  // - improve performance by not mounting children when they are not supposed to be rendered;
  // - always render children for IE, due to performance issues when mounting/un-mounting.
  const renderChildren = isAnimating || (height !== 0) || isIE();

  return {
    contentRef,
    height,
    isAnimating,
    renderChildren,
    wrapperRef,
  };
};
