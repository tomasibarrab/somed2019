/**
 * Actions, Epics, Selectors and Reducers for AvailableUser
 * Created by: Michele Ursino
 * May 21st 2018
 */

import { combineReducers } from 'redux';
import { createSelector } from 'reselect';
import { Observable } from 'rxjs/Observable';
import actionCreatorFactory, { Action, Success } from 'typescript-fsa';

import get from 'lodash/get';

import { AjaxStatuses, AnyUser, Epic, State, User, UserState } from '../types';
import { actions as currentUserActions } from './currentUser';

// ========================= Actions =============================

const createAction = actionCreatorFactory();

const fetchAvailableUser = createAction.async<string, User>('FETCH_AVAILABLE_USER');
const resetAvailableUser = createAction.async<number, undefined>('RESET_AVAILABLE_USER');

export const actions = {
  fetchAvailableUser,
  resetAvailableUser,
};

// ======================== Selectors ============================

const baseSelector = (state: State) => state.availableUser;

const isLoading = createSelector(baseSelector,
  (state: UserState<AnyUser>) => state.status.fetch === 'started');

const isLoaded = createSelector(baseSelector,
    (state: UserState<AnyUser>) => state.status.fetch === 'done');

const isFailed = createSelector(baseSelector,
    (state: UserState<AnyUser>) => state.status.fetch === 'failed');

const hasRidOrProfile = createSelector(baseSelector,
    (state: UserState<AnyUser>) =>
      (get(state, [ 'user', 'rid']) ||
      get(state, [ 'user', 'profiles', 'length']) > 0 ) );

export const selectors = {
  hasRidOrProfile,
  isFailed,
  isLoaded,
  isLoading,
};

// ======================= Transformers ==========================

// ========================== Epics ==============================

const fetchAvailableUserEpic: Epic = (action$, store, { usersApi }) =>
  action$
    .ofType(fetchAvailableUser.started.type)
    .map((action: Action<string>) => ({
      email: action.payload,
      scope: get(store.getState(), ['scope']),
    }))
    .switchMap(({ scope, email }) =>
      usersApi(scope).getAnyUserByEmail({ email })
        .map(result =>
          fetchAvailableUser.done({ params: email, result }))
        .catch(error => [fetchAvailableUser.failed({ params: email, error })]),
    );

const resetAvailableUserEpic: Epic = (action$) =>
  action$
    .ofType(resetAvailableUser.started.type)
    .mergeMap(({payload}) => Observable.of(payload).delay(payload))
    .map(p => resetAvailableUser.done({ params: p, result: undefined }));

export const epics = {
  fetchAvailableUserEpic,
  resetAvailableUserEpic,
};

// ========================= Reducers ============================

export const initialState: UserState<AnyUser> = {
  id: '',
  status: {},
  user: {},
};

function ajaxStatuses(current: AjaxStatuses = initialState.status, action: Action<void>): AjaxStatuses {
  switch (action.type) {
    case currentUserActions.resetCurrentUser.done.type:
    case actions.resetAvailableUser.done.type:
      return {};
    case actions.fetchAvailableUser.done.type:
      return {
        ...current,
        fetch: 'done',
      };
    case actions.fetchAvailableUser.started.type:
      return {
        ...current,
        fetch: 'started',
      };
    case actions.fetchAvailableUser.failed.type:
      return {
        ...current,
        fetch: 'failed',
      };
    default:
      return current;
  }
}

function userId(current: string = initialState.id, action: Action<Success<string, AnyUser>>): string {
  switch (action.type) {
    case currentUserActions.resetCurrentUser.done.type:
    case actions.resetAvailableUser.done.type:
    case actions.fetchAvailableUser.started.type:
      return '';
    case actions.fetchAvailableUser.done.type:
      return action.payload.result.id || action.payload.result.urn;
    default:
      return current;
  }
}

function availableUser(
  current: Partial<AnyUser> = initialState.user,
  action: Action< AnyUser | Success<AnyUser, AnyUser>>): Partial<AnyUser> {
  switch (action.type) {
    case currentUserActions.resetCurrentUser.done.type:
    case actions.resetAvailableUser.done.type:
    case actions.fetchAvailableUser.started.type:
      return {};
    case actions.fetchAvailableUser.done.type:
      return (action.payload as Success<AnyUser, AnyUser>).result;
    default:
      return current;
  }
}

export const reducer = combineReducers<UserState<AnyUser>>({
  id: userId,
  status: ajaxStatuses,
  user: availableUser,
});
