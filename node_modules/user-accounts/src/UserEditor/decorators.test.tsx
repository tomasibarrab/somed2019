import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/map';

import { Observable } from 'rxjs/Observable';
import { FormChange } from '../utils/finalObserver';
import { GROUPROLE_ALL_ACCESS, GROUPROLE_REST_ALL_ACCESS, RIDROLE_ALL_ACCESS } from '../utils/rolesHelpers';
import { checkEmailDecorator, rolesCheck } from './decorators';


describe('Final-Form Decorators', () => {

  it('rolesCheck: if the ALL_ACCESS role is checked, un-check any other role', () => {
    const existingValues = {
      rolesSet: [
        {
          set: false,
          urn: RIDROLE_ALL_ACCESS,
        },
        {
          set: true,
          urn: 'urn:ot.rest.perms:marketing',
        },
      ],
    };
    const newValues = {
      rolesSet: [
        {
          set: true, // <-- this changed
          urn: RIDROLE_ALL_ACCESS,
        },
        {
          set: true,
          urn: 'urn:ot.rest.perms:marketing',
        },
      ],
    };

    const batchChanges = rolesCheck(newValues, existingValues);

    expect(batchChanges).toEqual({
      'rolesSet[1].set': false,
    });
  });

  it('rolesCheck: if the ALL_ACCESS role is checked, don\'t un-check other unchecked roles', () => {
    const existingValues = {
      rolesSet: [
        {
          set: false,
          urn: RIDROLE_ALL_ACCESS,
        },
        {
          set: false,
          urn: 'urn:ot.rest.perms:marketing',
        },
      ],
    };
    const newValues = {
      rolesSet: [
        {
          set: true, // <-- this changed
          urn: RIDROLE_ALL_ACCESS,
        },
        {
          set: false,
          urn: 'urn:ot.rest.perms:marketing',
        },
      ],
    };
    const batchChanges = rolesCheck(newValues, existingValues);
    expect(batchChanges).toEqual({});
  });

  it('rolesCheck: if the GROUP_ALL_ACCESS role is checked, un-check any other role', () => {
    const existingValues = {
      rolesSet: [
        {
          set: false,
          urn: GROUPROLE_ALL_ACCESS,
        },
        {
          set: true,
          urn: 'urn:ot.group.roles:accounts',
        },
        {
          set: true,
          urn: GROUPROLE_REST_ALL_ACCESS,
        },
        {
          set: false,
          urn: 'urn:ot.groups.roles:foh',
        },
      ],
    };
    const newValues = {
      rolesSet: [
        {
          set: true, // <-- this changed
          urn: GROUPROLE_ALL_ACCESS,
        },
        {
          set: true,
          urn: 'urn:ot.group.roles:accounts',
        },
        {
          set: true,
          urn: GROUPROLE_REST_ALL_ACCESS,
        },
        {
          set: false,
          urn: 'urn:ot.groups.roles:foh',
        },
      ],
    };
    const batchChanges = rolesCheck(newValues, existingValues);
    expect(batchChanges).toEqual({
      'rolesSet[1].set': false,
      'rolesSet[2].set': false,
    });
  });

  it('rolesCheck: if the GROUPROLE_REST_ALL_ACCESS role is checked, un-check all other restaurant roles', () => {
    const existingValues = {
      rolesSet: [
        {
          set: false,
          urn: GROUPROLE_ALL_ACCESS,
        },
        {
          set: true,
          urn: 'urn:ot.group.roles:accounts',
        },
        {
          set: false,
          urn: GROUPROLE_REST_ALL_ACCESS,
        },
        {
          set: true,
          urn: 'urn:ot.groups.roles:foh',
        },
      ],
    };
    const newValues = {
      rolesSet: [
        {
          set: false,
          urn: GROUPROLE_ALL_ACCESS,
        },
        {
          set: true,
          urn: 'urn:ot.group.roles:accounts',
        },
        {
          set: true, // <-- this changed
          urn: GROUPROLE_REST_ALL_ACCESS,
        },
        {
          set: true,
          urn: 'urn:ot.groups.roles:foh',
        },
      ],
    };
    const batchChanges = rolesCheck(newValues, existingValues);
    expect(batchChanges).toEqual({
      'rolesSet[3].set': false,
    });
  });

  it('should call the fetchUser given function when a new email is in the data and there are no errors', () => {
    const previousValues = {};
    const newValues = {
      email: 'example@test.com',
    };
    const fetchUser = jest.fn();
    const source$ = new Observable<FormChange<any>>( subscriber => {
      subscriber.next({ newValues, previousValues, errors: {} })
    });
    checkEmailDecorator(fetchUser)(source$).subscribe({
      next: () => {
        expect(fetchUser).toBeCalled();
      },
    })
  });

  it('checkEmailDecorator: should NOT call fetchUser when a new email is in the data and there are errors', () => {
    const previousValues = {};
    const newValues = {
      email: 'example@test.com',
    };
    const fetchUser = jest.fn();
    const source$ = new Observable<FormChange<any>>( subscriber => {
      subscriber.next({ newValues, previousValues, errors: { email: 'invalid' } })
    });
    checkEmailDecorator(fetchUser)(source$).subscribe({
      next: () => {
        expect(fetchUser).not.toBeCalled();
      },
    })
  });

  it('checkEmailDecorator: should NOT call fetchUser when a new email is in the data and there are no errors', () => {
    const previousValues = {
      email: 'example@test.com',
    };
    const newValues = {
      email: 'example@test.com',
    };
    const fetchUser = jest.fn();
    const source$ = new Observable<FormChange<any>>( subscriber => {
      subscriber.next({ newValues, previousValues, errors: {} })
    });
    checkEmailDecorator(fetchUser)(source$).subscribe({
      next: () => {
        expect(fetchUser).not.toBeCalled();
      },
    })
  });
});
