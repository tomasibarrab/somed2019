// tslint:disable: object-literal-sort-keys

import moment from 'moment';
import { curry, head, pathOr, reduce, tail } from 'ramda';

// tslint:disable-next-line: ordered-imports
import { Config, Group, Restaurant, RidData, RidEntitiesSummary, SearchDTO, User, GCEventStatus } from './types';
import { buildDataRequest, buildDataRequests, toJson, toQueryString } from './utils';

const jsonHeader = { 'Content-Type': 'application/json' };

const csrfheader = {
  'X-CSRF-TOKEN': pathOr('', ['hydronator', 'microapp', 'csrfToken'], window),
}

const baseBistroApiPath = '/admin/api/bistro';

const baseGateway = '/gateway/proxies';

export interface SearchParameters {
  query: string;
  [option: string]: string | string[] | undefined;
}

export const noResult = <T>(): SearchDTO<T> => ({
  items: [],
  pageIndex: 0,
  pageSize: 0,
  totalPages: 0,
  totalResults: 0,
});

// ======= local utilities =======================================

const toRender = curry((config: Config, data: any) => ({
  data,
  keys: config.dataItems,
  title: config.dataSource,
}));

// ======= exported APIs ========================================

export function fetchRequest(request: Config): Promise<RidData> {
  return fetch(request.url)
    .then(toJson)
    .then(toRender(request));
}

export function getAllRidData(rid: string, typeName = 'rid'): Promise<RidData[]> {
  // Array of async requests accumulating data on given data array...
  const requests = buildDataRequests(typeName, rid).map( dataRequest => {
    return (pd: RidData[]) =>
    fetchRequest(dataRequest)
      .then(d => [...pd, d])
      .catch(err => pd);
  });
  // return the last requests promise carrying the accumulated result array
  return reduce(
    (prevPromise, currPromise) => prevPromise.then(currPromise),
    head(requests)!([]),   // initial array of RidData is empty
    tail(requests),
  );
}

export function getDataFetch(id: string, source: string): () => Promise<RidData> {
  const request = buildDataRequest(source, id);
  if (request) {
    return () => fetchRequest(request);
  } else {
    return () => Promise.reject(new Error(`Source: ${source} is not supported`))
  }
}

export function makeRestaurantOperational(rid: string): Promise<any> {
  const url = `${baseBistroApiPath}/venue/${rid}`;
  return fetch(
    url,
    {
      headers: { ...jsonHeader, ...csrfheader },
      method: 'PUT',
    })
    .then(toJson);
}

export function getRidPermissions( rid: string ): Promise<any> {
  const url = `${baseBistroApiPath}/permissions/${rid}`;
  return fetch(url)
    .then(toJson);
}

export function searchAgreementByRid(rid: string): Promise<any> {
  const url = `${baseBistroApiPath}/user-agreements/agreements/search/${rid}`;
  return fetch(url)
    .then(toJson);
}

export function searchAgreementByEmail(email: string): Promise<any> {
  const url = `${baseBistroApiPath}/user-agreements/agreements/search?email=${email}`;
  return fetch(url)
    .then(toJson);
}

export function searchRestaurants(options: SearchParameters): Promise<SearchDTO<Restaurant>> {
  if (options.query && options.query.length >= 3) {
    const encodedQuery = toQueryString(options, ['withDiscrepancies']);
    if (options.withDiscrepancies === 'true') {
      const url = `${baseBistroApiPath}/restaurants/search/discrepancies${encodedQuery}`;
      return fetch(url)
        .then(toJson);
    } else {
      const url = `${baseGateway}/rgsearch/api/v2/restaurants${encodedQuery}&pageSize=999`;
      return fetch(url)
        .then(toJson);
    }
  } else {
   return Promise.resolve(noResult());
  }
}

export function syncRestaurantAssetsFromSFDC(rid: string): Promise<any> {
  const url = `${baseBistroApiPath}/restaurants/${rid}/sync/assets`;
  return fetch(
    url,
    {
      headers: { ...jsonHeader, ...csrfheader },
      method: 'POST',
    })
    .then(toJson);
}

export function searchGroups(options: SearchParameters): Promise<SearchDTO<Group>> {
  if ( options.query.length >= 3 ) {
    const encodedQuery = toQueryString(options);
    const url = `${baseGateway}/rgsearch/api/v2/groups${encodedQuery}&pageSize=999`;
    return fetch(url)
      .then(toJson);
  } else {
    return Promise.resolve(noResult());
  }
}

export function searchUser(options: SearchParameters): Promise<SearchDTO<User>> {
  if ( options.query.length >= 3 ) {
    const encodedQuery = toQueryString(options);
    const url = `${baseBistroApiPath}/users/search${encodedQuery}`;
    return fetch(url)
      .then(toJson);
  } else {
    return Promise.resolve(noResult());
  }
}

export function setUserState(urn: string, active: boolean): Promise<boolean> {
  const url = `${baseBistroApiPath}/users/${urn}/status?active=${active}`;
  return fetch(
    url,
    {
      headers: { ...jsonHeader, ...csrfheader },
      method: 'PUT',
    })
    .then(toJson);
}

export function saveNewUser(user: Partial<User>): Promise<boolean> {
  const url = `${baseBistroApiPath}/users/new`;
  return fetch(
    url,
    {
      body: JSON.stringify(user),
      headers: { ...jsonHeader, ...csrfheader },
      method: 'POST',
    })
    .then(toJson);
}

export function resetPassword(email: string): Promise<boolean> {
  const url = `${baseBistroApiPath}/users/${email}/reset_password`;
  return fetch(
    url,
    {
      headers: { ...jsonHeader, ...csrfheader },
      method: 'POST',
    })
    .then(toJson);
}

export function getUserPermissionsForContext(userUrn: string, contextId: string): Promise<any> {
  const url = `${baseGateway}/gcPermissionsAggregator/api/v2/contexts/${contextId}/principals/${userUrn}/permissions`;
  return fetch(url)
    .then(toJson);
}

export function getUserInfo(userUrn: string): Promise<User> {
  const url = `${baseBistroApiPath}/users/${userUrn}`;
  return fetch(url)
    .then(toJson);
}

export function getRidEntitiesSummary(rid: string): Promise<RidEntitiesSummary> {
  const url = `/admin/api/restaurant/${rid}/system-change/import-status`;
  return fetch(url)
    .then(toJson);
}

export function getRestaurantInfo(rid: string | number): Promise<Restaurant> {
  const url = `${baseGateway}/gcrestaurant/api/restaurants/${rid}`;
  return fetch(url)
    .then(toJson);
}

export function getRidBulkDeleteWhitelist(rid: string | number): Promise<boolean> {
  const url = `${baseBistroApiPath}/restaurants/${rid}/bulkdelete/onwhitelist`;
  return fetch(url)
    .then(toJson);
}

export function bulkDeleteStart(rid: string | number): Promise<GCEventStatus> {
  const url = `${baseBistroApiPath}/restaurants/${rid}/bulkdelete/start`;
  return fetch(
    url,
    {
      headers: { ...jsonHeader, ...csrfheader },
      method: 'POST',
    })
    .then(toJson);
}

export function bulkDeleteStatus(rid: string, reqId: string | number): Promise<GCEventStatus> {
  const url = `${baseBistroApiPath}/restaurants/${rid}/bulkdelete/${reqId}/status`;
  return fetch(url)
    .then(toJson);
}

export function searchPartners(from: string, to: string): Promise<any> {
  const pdpDashboardUrl = '/partnerDataPlatform/writeback/v2/dashboard/partnerrestaurants'
  const now = moment().format('YYYY-MM-DD');
  const weekBefore = moment().subtract(7, 'days').format('YYYY-MM-DD');

  if (from != null && to != null) {
    const url =
      `${baseGateway}${pdpDashboardUrl}?from=${from + 'T00:00:01.818Z'}&to=${to + 'T23:59:59.818Z'}`;
    return fetch(url)
      .then(toJson);
  } else {
    const url =
      `${baseGateway}${pdpDashboardUrl}?from=${weekBefore + 'T00:00:01.818Z'}&to=${now + 'T23:59:59.818Z'}`;
    return fetch(url)
      .then(toJson);
  }
}
