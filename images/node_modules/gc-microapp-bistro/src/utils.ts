import {
  compose,
  curry,
  equals,
  filter,
  find,
  head,
  ifElse,
  is,
  isEmpty,
  isNil,
  keys,
  propEq,
  reduce,
  tail,
 } from 'ramda';

import { AsyncError } from 'shared-react-utils/useAsync';

import dataConfig from './config';
import { Config, QSParameters, RidInputState } from './types';

/** replace all occurrences of "{str}" with the given id value  */
export const parseUrl = (str: string, id: string) => str.replace(/{.*}/, id);

/**
 * Build an array of Config object for a given type and customized
 * with the given id
 * @param idType Type of data to fetch
 * @param id Value of the ID to inject in the URLs of all found requests
 */
export const buildDataRequests = (idType: string, id: string): Config[] =>
  dataConfig
    .filter(config => config.url != null)
    .filter(config => config.idType === idType)
    .map((config: Config) => ({ ...config, url: parseUrl(config.url, id) }));

/**
 * Build a Config object for a given DataSource
 * @param source Name of the data source to select
 * @param id Value of the ID to inject in the request URL
 */
export const buildDataRequest = (source: string, id: string): Config | undefined =>
 ifElse(
  is(Object),
  (config: Config) => ({ ...config, url: parseUrl(config.url, id) }),
  () => undefined,
 )(find(propEq('dataSource', source), dataConfig));

export const toJson = (data: Response) => data.json();

export const initSearchState = (q: string) => ({
  id: null,
  input: q,
  touched: false,
});

export const initialRidInputState = (): RidInputState => ({
  id: null,
  input: '',
  touched: false,
});

export const validateRidInput = (st: RidInputState) =>
  !st.touched || !isNaN(parseInt(st.input, 10));

/**
 * Builds a querystring selecting the "key" option from the given options.
 * @param options Object key value containing the parameters.
 * @param key the key to extract into the result string.
 * @param prepend Char to prepend to the result. Default is "&"
 */
const toSingleQuery = (options: QSParameters, key: string, prepend = '&') => {
  const option = options[key];
  if ( !isNil(option) && !isEmpty(option)) {
    return `${prepend}${key}=${encodeURIComponent(option.toString())}`;
  } else {
    return '';
  }
}

/** Returns true if s is not in slist (array of T) */
const isNotIn = curry( <T>(slist: T[], s: T) =>
 compose<T[], T | undefined, boolean>(
   isNil,
   find(equals<T>(s)))(slist),
  );

/**
 * Converts an array of options to a well defined querystring.
 * Note the function filters any option mentioned in the ignoreList
 * also the properties with a falsy value will be omitted from the querystring:
 * 0, -0, null, false, NaN, undefined.
 */
export const toQueryString = (options: QSParameters, ignoreList: string[] = []) => {
  const valKeys = compose<QSParameters, string[], string[], string[]>(
    filter<string>(s => Boolean(options[s])),
    filter<string>(isNotIn(ignoreList)),
    keys,
  )(options);
  return reduce(
    (qs: string, opt: string) => qs + toSingleQuery(options, opt, '&'),
    toSingleQuery(options, valKeys[0], '?'),
    tail(valKeys),
  );
};

/** extracts the id from a urn of a principal */
export const idFromUrn = (urn: string) => {
  return head(urn.split(':').reverse());
}

export type AsyncTask = () => Promise<any>;

/**
 * Simple utility used to execute multiple async call in sequence.
 * This simple implementation return a promise with the result of the
 * last call in the sequence array.
 * @param asyncArr an array of function returning promises and accepting no parameters.
 */
export function simpleAsyncSequence( asyncArr: AsyncTask[]): Promise<any> {
  return asyncArr.reduce(
    (prevPromise, asyncCall) =>
      prevPromise.then(() => asyncCall()),
      Promise.resolve(),
  );
}
