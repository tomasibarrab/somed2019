import React from 'react';
import { render, cleanup } from 'react-testing-library';
import { clearMessages, IntlProvider, getLocaleData, registerMessages } from './intl';
import { addLocaleData, FormattedMessage } from 'react-intl';

import enLocaleData from 'react-intl/locale-data/en';
import itLocaleData from 'react-intl/locale-data/it';

addLocaleData(enLocaleData);
addLocaleData(itLocaleData);

function reset() {
  delete window.hydronator;
  delete window.opentable;
  clearMessages();
  cleanup();
}

function setLanguage(lang = 'en-US') {
  window.hydronator = {
    microapp: {
      lang
    }
  };
}

function renderScenario() {
  return render(
    <IntlProvider>
      <FormattedMessage id="helloWorld" />
    </IntlProvider>
  );
}

// Note, all of these tests are testing that the messages are being provided correctly. The other half of the equation
// is that the locale for other `Intl` features like `FormattedDate` and `FormattedNumber` is set correctly. I don't
// think there's a reliable way to test for this because `jsdom` does not polyfill Intl (see:
// https://github.com/jsdom/jsdom/issues/1626). `react-intl` does throw warnings that it is falling back to en-US due to
// lack of locale support, so that will have to be sufficient for now.
describe('Intl', async () => {
  beforeEach(reset);

  it('Should use language from fallback data island when one is provided', async () => {
    window.opentable = {
      locale: 'it-IT'
    };

    registerMessages({
      'en-US': {
        helloWorld: 'Hello World'
      },
      'it-IT': {
        helloWorld: 'Ciao mondo'
      }
    });

    expect(renderScenario().getByText('Ciao mondo')).toBeDefined();
  });

  it('Should use language from fallback data island when one is provided', async () => {
    window.opentable = {
      restaurant: {
        locale: 'it-IT'
      }
    };

    registerMessages({
      'en-US': {
        helloWorld: 'Hello World'
      },
      'it-IT': {
        helloWorld: 'Ciao mondo'
      }
    });

    expect(renderScenario().getByText('Ciao mondo')).toBeDefined();
  });

  it('Should fall back to en-US if window.opentable.restaurant is present, but has no locale', async () => {
    window.opentable = {
      restaurant: {}
    };

    registerMessages({
      'en-US': {
        helloWorld: 'Hello World'
      },
      'it-IT': {
        helloWorld: 'Ciao mondo'
      }
    });

    expect(renderScenario().getByText('Hello World')).toBeDefined();
  });

  it('Should fall back to en-US when no language is available', async () => {
    registerMessages({
      'en-US': {
        helloWorld: 'Hello World'
      }
    });

    setLanguage('it-IT');

    expect(renderScenario().getByText('Hello World')).toBeDefined();
  });

  it('Should handle lowercase message map and mixed-case locale', async () => {
    registerMessages({
      'en-us': {
        helloWorld: 'Hello World'
      }
    });

    setLanguage('en-US');

    expect(renderScenario().getByText('Hello World')).toBeDefined();
  });

  it('Should handle mixed-case message map and lower-case locale', async () => {
    registerMessages({
      'en-US': {
        helloWorld: 'Hello World'
      }
    });

    setLanguage('en-us');

    expect(renderScenario().getByText('Hello World')).toBeDefined();
  });

  it('Should use the last registered message if the same id is registered multiple times', async () => {
    registerMessages({
      'en-US': {
        helloWorld: 'Hello World'
      }
    });

    registerMessages({
      'en-US': {
        helloWorld: 'Hello Earth'
      }
    });
  });

  it('Should use the last registered message if the same id is registered under multiple cases', async () => {
    registerMessages({
      'en-US': {
        helloWorld: 'Hello World'
      }
    });

    registerMessages({
      'en-us': {
        helloWorld: 'Hello Earth'
      }
    });

    expect(renderScenario().getByText('Hello Earth')).toBeDefined();
  });
});

describe('getLocaleData', async () => {
  beforeEach(reset);
  it('Should fall back to en-US when no language is available', async () => {
    const expectedResult = {
      locale: 'en-US',
      language: 'en',
      country: 'us'
    };
    expect(getLocaleData()).toEqual(expectedResult);
  });

  it('Should return correct locale from hydronator', async () => {
    setLanguage('ja-jp');
    const expectedResult = {
      locale: 'ja-JP',
      language: 'ja',
      country: 'jp'
    };
    expect(getLocaleData()).toEqual(expectedResult);
  });

  it('Should return correct locale from opentable if hydronator unavailable', async () => {
    window.opentable = {
      locale: 'fr-CA'
    };
    const expectedResult = {
      locale: 'fr-CA',
      language: 'fr',
      country: 'ca'
    };
    expect(getLocaleData()).toEqual(expectedResult);
  });

  it('Should return correct locale from restaurant if hydronator or opentable are unavailable', async () => {
    window.opentable = {
      restaurant: {
        locale: 'es-MX'
      }
    };
    const expectedResult = {
      locale: 'es-MX',
      language: 'es',
      country: 'mx'
    };
    expect(getLocaleData()).toEqual(expectedResult);
  });
});
