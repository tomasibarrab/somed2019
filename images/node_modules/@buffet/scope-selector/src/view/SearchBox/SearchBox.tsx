import React from 'react';
import { Icon } from '@buffet/icon';
import styles from './SearchBox.css';
import { injectIntl, InjectedIntlProps } from 'react-intl';

export interface ViewProps {
  onChange(query: string): void;
  value: string;
}

interface State {
  searchQuery: string;
}

export interface Props extends ViewProps, InjectedIntlProps {}

class SearchBoxView extends React.Component<Props, State> {
  state = { searchQuery: '' };

  /**
   * It isn't an expected use case that the SearchBox (and hence ScopeSelector) would be intialized with some arbitrary
   * value, but it is allowed for for completeness (and the sake of unit tests ;-) )
   */
  componentDidMount() {
    this.setState({ searchQuery: this.props.value });
  }

  componentDidUpdate(prevProps: Props) {
    if (this.props.value !== prevProps.value && this.props.value !== this.state.searchQuery) {
      this.setState({ searchQuery: this.props.value });
    }
  }

  render() {
    const placeholderText = this.props.intl.formatMessage({ id: 'scopeSelector.searchPlaceholder' });
    const cancelText = this.props.intl.formatMessage({ id: 'scopeSelector.cancel' });

    return (
      <div className={styles.searchBox}>
        <div className={styles.inputWrapper}>
          <Icon className={styles.searchIcon} iconId="magnifyingGlass" />
          <input
            className={styles.input}
            type="text"
            onChange={this.onChange}
            value={this.state.searchQuery}
            placeholder={placeholderText}
            aria-label={placeholderText}
          />
        </div>
        {this.state.searchQuery.length > 0 && (
          <button className={styles.cancelButton} onClick={this.cancel}>
            {cancelText}
          </button>
        )}
      </div>
    );
  }

  private onChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    this.setSearchQuery(event.target.value);
  };

  private cancel = () => {
    this.setSearchQuery('');
  };

  private setSearchQuery(searchQuery: string) {
    this.setState({ searchQuery });
    this.debouncedHandleChange(searchQuery);
  }

  private handleChange = (value: string) => {
    this.props.onChange(value);
  };

  /**
   * handleChange debounced 300ms
   */
  private debouncedHandleChange = debounce(this.handleChange, 300);
}

/**
 * Utility function to wrap a provided function in a debounce
 *
 * @param func
 * @param wait
 */
function debounce(func: (value: string) => void, wait: number) {
  let timeoutId: number;

  return (value: string) => {
    clearTimeout(timeoutId);
    timeoutId = window.setTimeout(() => func(value), wait);
  };
}

export const SearchBox = injectIntl<ViewProps>(SearchBoxView);
