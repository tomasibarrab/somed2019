import React from 'react';
import request from 'superagent';
import {
  Restaurant,
  SearchDTO,
  RestaurantDTO,
  GroupSearchItemDTO,
  RestaurantSearchState,
  GroupSearchState,
  InitState,
  StartedState,
  FailedState,
  DoneState,
  RestaurantSearchItemDTO
} from './ScopeSelector.types';
import { mapRestaurants, normalizeRestaurant } from './RestaurantMapper';
import { ScopeSelectorInnerProvider } from './ScopeSelectorService';
import { getScope } from '@buffet/scope-service';
import { FeatureToggleChildProps } from '@buffet/feature-toggle-context';

const RESTAURANT_SEARCH_PATH_DEPRECATED = '/restaurant-search/v1/restaurants';
const RESTAURANT_SEARCH_PATH = '/gateway/proxies/rgsearch/api/v2/restaurants';
const GROUP_SEARCH_PATH = '/gateway/proxies/rgsearch/api/v2/groups';
const SWITCH_RID_PATH = '/gateway/api/account/switch/rid';
const INIT_STATE: InitState = { status: 'init', data: undefined };
const STARTED_STATE: StartedState = { status: 'started', data: undefined };
const FAILED_STATE: FailedState = { status: 'failed', data: undefined };
const emptyGroupResults: GroupSearchItemDTO[] = [];
const GROUP_MOCK_DONE_STATE: DoneState<GroupSearchItemDTO[]> = {
  status: 'done',
  data: emptyGroupResults
};
const SMALL_RID_RESULTS_MAX = 5;

interface SwitchRidResponse {
  body: {
    restaurant: RestaurantDTO;
    redirectUrl: string;
  };
}

export interface State {
  currentSearch: string;
  ridCount: number;
  groupCount: number;
  restaurantSearchState: RestaurantSearchState;
  groupSearchState: GroupSearchState;
  userHasManyRids: boolean;
  currentRid?: number;
  currentGroupId?: number;
  initialized: boolean;
}

export interface ScopeSelectorInterface extends State {
  recentRestaurants: Restaurant[];
  reset(): void;
  selectRid(id: number): void;
  selectGroup(id: number): void;
  setSearch(query: string): void;
}

export interface Props {
  addRecentRestaurant(restaurant: Restaurant): void;
  recentRestaurants: Restaurant[];
  featureToggleState: FeatureToggleChildProps;
}

export class ScopeSelectorInner extends React.Component<Props, State> {
  state: State = {
    restaurantSearchState: INIT_STATE,
    groupSearchState: INIT_STATE,
    currentSearch: '',
    ridCount: 0,
    groupCount: 0,
    userHasManyRids: false,
    currentRid: getScope().type === 'restaurant' ? getScope().id : undefined,
    currentGroupId: getScope().type === 'group' ? getScope().id : undefined,
    initialized: false
  };

  initialGroupResults: GroupSearchItemDTO[] = [];
  initialRestaurantResults: Restaurant[] = [];

  public componentDidMount() {
    this.initialize();
  }

  public componentDidUpdate(prevProps: Props) {
    /* istanbul ignore next */
    this.initialize();
  }

  public render() {
    return (
      <ScopeSelectorInnerProvider
        value={{
          ...this.state,
          recentRestaurants: mapRestaurants(this.props.recentRestaurants),
          reset: this.reset,
          selectRid: this.selectRid,
          selectGroup: this.selectGroup,
          setSearch: this.setSearch
        }}
      >
        {this.props.children}
      </ScopeSelectorInnerProvider>
    );
  }

  /**
   * Reset the scope-selector back to the proper post-initialization state, depending on number of RIDs the user has.
   * The idea here is to favor showing recent restaurants when showing/re-showing the scope-selector if there's more
   * results than can be shown reasonably at once. The `SearchBox` is only shown above this limit.
   */
  public reset = () => {
    if (this.state.userHasManyRids) {
      this.clearSearch();
    }
  };

  /**
   * Updates the `currentSearch` state property, and initiates async search if necessary
   */
  public setSearch = (query: string) => {
    this.setState({
      currentSearch: query
    });

    //
    // if the search term is empty string don't perform a new search, but rather call `clearSearch()`. This will result
    // in no restaurant results being displayed (except possibly for the local storage recent restaurants), and initial
    // group results being displayed if any (from the initial group search with an empty query â€” if it was performed)
    //
    if (query === '') {
      this.clearSearch();
    }
    // non-empty search query, so try to initiate restaurant and group searches
    else {
      // important to encode since there could be characters such as '&' in the query
      const encodedSearch = encodeURIComponent(query);

      // only do a restaurant search if the intial restaurant search returned with non-zero total possible results
      if (this.state.ridCount > 0) {
        this.setState({
          restaurantSearchState: STARTED_STATE
        });

        // use the new restaurant search endpoint if searching groups is toggled on
        if (this.shouldSearchGroups()) {
          request
            .get(RESTAURANT_SEARCH_PATH)
            .query(`query=${encodedSearch}`)
            .then(this.handleRestaurantSearchSuccess)
            .catch(this.handleRestaurantFailure);
        }
        // otherwise use the legacy restaurant search endpoint
        else {
          request
            .post(RESTAURANT_SEARCH_PATH_DEPRECATED)
            .send({
              query: this.state.currentSearch
            })
            .then(this.handleRestaurantSearchSuccess)
            .catch(this.handleRestaurantFailure);
        }
      }

      // only do a group search if the initial group search returned with non-zero total possible results
      if (this.state.groupCount > 0) {
        this.setState({
          groupSearchState: STARTED_STATE
        });

        request
          .get(GROUP_SEARCH_PATH)
          .query('pageSize=5')
          .query(`query=${encodedSearch}`)
          .then(this.handleGroupSearchSuccess)
          .catch(this.handleGroupFailure);
      }
    }
  };

  /**
   * Called when user has selected a restaurant they wish to navigate to. This first calls the switch rid endpoint,
   * which returns a redirect url to actually navigate to.
   */
  public selectRid = (id: number) => {
    this.setState({ currentRid: id });

    request
      .post(SWITCH_RID_PATH)
      .send({
        id,
        rid: id
      })
      .then((res: SwitchRidResponse) => {
        if (res.body) {
          if (res.body.restaurant) {
            this.props.addRecentRestaurant(normalizeRestaurant(res.body.restaurant));
          }
          if (res.body.redirectUrl) {
            window.location.assign(res.body.redirectUrl);
          } else {
            this.handleRestaurantFailure();
          }
        } else {
          this.handleRestaurantFailure();
        }
      })
      .catch(this.handleRestaurantFailure);
  };

  /**
   * Called when user has selected a group they wish to navigate to. Unlike `selectRid()` there is no endpoint to
   * ask for a redirect location, so the navigation is performed directly.
   */
  public selectGroup = /* istanbul ignore next */ (id: number) => {
    window.location.assign(`/group/${id}/home`);
  };

  /**
   * Called out of either `componentDidMount()` or `componentDidUpdate()`. The method is gated with the `initialized`
   * property on state so it is only executed once. It waits for feature toggle context to succeed or fail in order to
   * provide for toggling group search on or not. Kicks off initially restaurant search, and potentially initial group
   * search.
   */
  private initialize = () => {
    const { featureToggleState } = this.props;
    const { initialized } = this.state;

    if (initialized || !(featureToggleState.status === 'done' || featureToggleState.status === 'failed')) {
      return;
    }

    this.setState({
      restaurantSearchState: STARTED_STATE,
      groupSearchState: this.shouldSearchGroups() ? STARTED_STATE : GROUP_MOCK_DONE_STATE,
      initialized: true
    });

    // use the new restaurant search endpoint if searching groups is toggled on
    if (this.shouldSearchGroups()) {
      request
        .get(RESTAURANT_SEARCH_PATH)
        .then(this.handleRestaurantInitializeSuccess)
        .catch(this.handleRestaurantFailure);
    }
    // otherwise use the legacy restaurant search endpoint
    else {
      request
        .post(RESTAURANT_SEARCH_PATH_DEPRECATED)
        .send({
          query: ''
        })
        .then(this.handleRestaurantInitializeSuccess)
        .catch(this.handleRestaurantFailure);
    }

    if (this.shouldSearchGroups()) {
      request
        .get(GROUP_SEARCH_PATH)
        .query('pageSize=5')
        .then(this.handleGroupInitializeSuccess)
        .catch(this.handleGroupFailure);
    }
  };

  /**
   * Reset to empty query search state. Reset restaurant and group results to 'done' with their initial empty query
   * result set. But if the intial result for either was an error, retain that result.
   */
  private clearSearch = () => {
    let groupSearchState: GroupSearchState = this.state.groupSearchState;
    let restaurantSearchState: RestaurantSearchState = this.state.restaurantSearchState;

    // if there are non-zero total possible group results, reset group search to the initial empty query result
    if (this.state.groupCount > 0) {
      groupSearchState = {
        status: 'done',
        data: this.initialGroupResults
      };
    }

    //
    // if there are non-zero total possible restaurant results, reset restaurant search to the initial empty query
    // result
    //
    if (this.state.ridCount > 0) {
      restaurantSearchState = {
        status: 'done',
        data: this.initialRestaurantResults
      };
    }

    this.setState({
      currentSearch: '',
      restaurantSearchState,
      groupSearchState
    });
  };

  /**
   * Check global feature toggle for whether group searching should be performed or not
   */
  private shouldSearchGroups(): boolean {
    const { featureToggleState } = this.props;

    if (featureToggleState.status === 'done') {
      return featureToggleState.showFeature;
    }

    return false;
  }

  /**
   * First time only successful restaurant results. Cache count total restaurants, and determine whether to show
   * recent restaurants or not.
   */
  private handleRestaurantInitializeSuccess = (res: { body: SearchDTO<RestaurantSearchItemDTO> }) => {
    const ridCount = res.body.totalResults;
    this.initialRestaurantResults = mapRestaurants(res.body.items);

    this.setState({
      ridCount,
      restaurantSearchState: {
        status: 'done',
        data: this.initialRestaurantResults
      },
      userHasManyRids: ridCount > SMALL_RID_RESULTS_MAX
    });
  };

  /**
   * First time only successful group results. Cache count total groups and initial result set.
   */
  private handleGroupInitializeSuccess = (res: { body: SearchDTO<GroupSearchItemDTO> }) => {
    this.initialGroupResults = res.body.items;

    this.setState({
      groupCount: res.body.totalResults,
      groupSearchState: {
        status: 'done',
        data: res.body.items
      }
    });
  };

  /**
   * Handle any non-initial successful restaurant search result
   */
  private handleRestaurantSearchSuccess = (res: { body: SearchDTO<RestaurantSearchItemDTO> }) => {
    this.setState({
      restaurantSearchState: {
        status: 'done',
        data: mapRestaurants(res.body.items)
      }
    });
  };

  /**
   * Handle any non-initial successful group search result
   */
  private handleGroupSearchSuccess = (res: { body: SearchDTO<GroupSearchItemDTO> }) => {
    this.setState({
      groupSearchState: {
        status: 'done',
        data: res.body.items
      }
    });
  };

  private handleGroupFailure = /* istanbul ignore next */ () => {
    this.setState({
      groupSearchState: FAILED_STATE
    });
  };

  private handleRestaurantFailure = () => {
    this.setState({
      restaurantSearchState: FAILED_STATE
    });
  };
}
