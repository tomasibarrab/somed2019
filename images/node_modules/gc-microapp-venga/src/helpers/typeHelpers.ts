import {
  AddOn,
  AGREEMENT_TYPE_ROOT,
  AgreementType,
  BundleDetails,
  PricedAddOn,
  Pricing,
  ShortAgreementType,
} from '../store/types';


export const bundleDetailsToPricing = (bundle: BundleDetails, currencyCode: string): Pricing => ({
  billingRecurrence: bundle.billingRecurrence,
  currencyCode,
  feeType: bundle.feeType,
  listPrice: bundle.listPrice,
  productCode: bundle.sku,
  productName: bundle.name,
  termLength: bundle.termLength,
});

export const addOnToPriced = (addOn: AddOn | undefined, currencyCode: string): PricedAddOn | undefined => {
  if (!addOn) {
    return undefined;
  }

  return {
    bundleCategory: addOn.bundleCategory,
    bundleDetails: addOn.bundleDetails.map(bundle => bundleDetailsToPricing(bundle, currencyCode)),
    bundleDisplayName: addOn.bundleDisplayName,
    bundleName: addOn.bundleName,
    status: addOn.status,
  };
};

export const pricingToBundle = (price: Pricing): BundleDetails => ({
  billingRecurrence: price.billingRecurrence,
  description: '',
  feeType: price.feeType,
  listPrice: price.listPrice,
  name: price.productName,
  sku: price.productCode,
  termLength: price.termLength,
});

// filtering function of add-ons by bundle name
export const addOnByName = (product: AgreementType) => (addOn: AddOn) => (addOn.bundleName === product);

// strips the root of the agreement type
export const shortAgreementType = (agreementType: AgreementType) => (
  agreementType.replace(AGREEMENT_TYPE_ROOT, '') as ShortAgreementType
);

// appends the root of the agreement type
export const longAgreementType = (agreementType: ShortAgreementType) => (
  `${AGREEMENT_TYPE_ROOT}${agreementType}` as AgreementType
);

// checks whether a short string is a valid long agrement type
export const validShortAgreementType = (agreementType?: ShortAgreementType) => (
  agreementType !== undefined && [ShortAgreementType.host, ShortAgreementType.review_manager].includes(agreementType)
);
