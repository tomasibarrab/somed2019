/**
 * This is a factory for creating specific Product AsyncActions, Epics and Reducer.
 */
import { BaseAgreementDTO } from '@buffet/user-agreement';
import get from 'lodash/get';
import { combineReducers } from 'redux';
import { createSelector } from 'reselect';
import { AsyncState, asyncStateReducer } from 'shared-react-utils/asyncStateReducer';
import { actionCreatorFactory } from 'typescript-fsa';

import 'rxjs/add/observable/of';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/takeUntil';

import {
  addOnByName,
  addOnToPriced,
} from '../../helpers/typeHelpers';

import {
  AgreementType,
  Epic,
  PricedAddOn,
  Pricing,
  PricingResponse,
} from '../types';

import { ProductsState } from './products';


export interface SingleProductState {
  price: AsyncState<PricedAddOn>,
  userAgreement: AsyncState<BaseAgreementDTO>;
}

// generic actions
const createAction = actionCreatorFactory();
export const fetchAllProductPrices = createAction.async<number, PricingResponse, any>('PRODUCT_PRICES');


export function generateReducerActionsEpics(product: AgreementType) {
  const createGeneratedAction = actionCreatorFactory(product.toUpperCase());


  // -------------------------------------------------------------------------------------------------------------------
  // actions
  // -------------------------------------------------------------------------------------------------------------------

  const fetchUserAgreement = createGeneratedAction.async<number, BaseAgreementDTO, any>(
    'PRODUCT_USER_AGREEMENT',
  );

  // -------------------------------------------------------------------------------------------------------------------
  // epics
  // -------------------------------------------------------------------------------------------------------------------

  const fetchProductUserAgreementEpic: Epic = (action$, store, { api }) =>
    action$
      .filter(fetchUserAgreement.started.match)
      .switchMap(({ payload: rid }) =>
        api.getUserAgreement({ rid, agreementType: product }) // (1) & (2)
          .map(result => fetchUserAgreement.done({ params: rid, result })) // (4) & (5)
          .catch(error => [
            fetchUserAgreement.failed({ params: rid, error }),
          ]),
      );


  // -------------------------------------------------------------------------------------------------------------------
  // reducers
  // -------------------------------------------------------------------------------------------------------------------

  const reducer = combineReducers<SingleProductState>({
      price: asyncStateReducer(
        fetchAllProductPrices,
        payload => addOnToPriced(
          payload.result.addons && payload.result.addons.find(addOnByName(product)),
          payload.result.currency,
        ),
      ),
      userAgreement: asyncStateReducer(
        fetchUserAgreement,
        payload => payload.result,
      ),
    });


  // -------------------------------------------------------------------------------------------------------------------
  // selectors
  // -------------------------------------------------------------------------------------------------------------------

  const baseSelector = (state: ProductsState): SingleProductState => state[product];

  // We need to load both UserAgreement and Price before doing anything.
  const loadingSelector = createSelector(
    baseSelector,
    productState => (
      productState.price.status === 'started'
      || productState.userAgreement.status === 'started'
    ),
  );

  // UserAgreement may not exist, that's an expected case, so we don't care about it here.
  // We only consider an error if the Price fails.
  const errorSelector = createSelector(
    baseSelector,
    productState => productState.price.status === 'failed',
  );

  const priceSelector = createSelector(
    baseSelector,
    productState => productState.price.data,
  );

  const userAgreementSelector = createSelector(
    baseSelector,
    productState => productState.userAgreement.data,
  );

  const pricingSelector = createSelector(
    userAgreementSelector,
    priceSelector,

    (agreementData, priceData) => {
      const agreementPricing: Pricing[] = get(agreementData, ['agreementDetails', 'pricing'], []);

      if (agreementPricing.length) {
        return agreementPricing;
      } else {
        return priceData ? priceData.bundleDetails : undefined;
      }
    },
  );

  const pricingBundleSelector = createSelector(
    userAgreementSelector,
    priceSelector,

    (agreementData, priceData): PricedAddOn | undefined => {
      const agreementPricing: Pricing[] = get(agreementData, ['agreementDetails', 'pricing'], []);

      if (agreementPricing && agreementPricing.length && priceData) {
        return {
          ...priceData,
          bundleDetails: agreementPricing,
        };
      } else if (priceData) {
        return priceData;
      } else {
        return undefined;
      }
    },
  );

  const activeSelector = createSelector(
    priceSelector,
    priceData =>
      priceData ? priceData.status === 'Active' : false,
  );

  // TODO: inferring pricing details is dangerous, although this assumption holds for now
  const basePriceSelector = createSelector(
    pricingSelector,
    priceData => priceData && priceData.find(pricing => pricing.termLength > 0),
  );


  // export all
  return {
    actions: {
      fetchUserAgreement,
    },
    epics: {
      fetchProductUserAgreementEpic,
    },
    reducer,
    selectors: {
      basePrice: basePriceSelector,
      isActive: activeSelector,
      isError: errorSelector,
      isLoading: loadingSelector,
      pricing: pricingSelector,
      pricingBundle: pricingBundleSelector,
      userAgreement: userAgreementSelector,
    },
  };
}

export default generateReducerActionsEpics;
