import DateRangePicker from 'gca-react-components/src/components/DateRangePicker/DateRangePicker';
import moment, { Moment } from 'moment';
import React from 'react';
import { InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';

import { dateRange } from '../../../store/reviewFilters/reviewFilters';
import { State } from '../../../store/types';
import { getMomentLocale, Locale } from '../../../utils/moment-locale-mappings';

import './DateRangePickerOverrides.scss';

function isOutsideRange(date: Moment) {
  return date.isAfter(moment());
}

interface Dates {
  startDate: null | Moment;
  endDate: null | Moment;
}

interface Props extends InjectedIntlProps {
  locale: Locale;
  set(payload: any, applyOnSet?: boolean): void;
}

type FocusType = 'startDate' | 'endDate' | null;

interface CustomState {
  dates: Dates;
  focused: FocusType;
}

class Custom extends React.Component<Props, CustomState> {
  public state: CustomState = {
    dates: {
      endDate: null,
      startDate: null,
    },
    focused: 'startDate',
  };

  constructor(props: Props) {
    super(props);

    const momentLocale = getMomentLocale(props.locale);
    moment.locale(momentLocale);
  }

  public render() {
    const { intl } = this.props;

    return (
      <DateRangePicker
        startDate={this.state.dates.startDate}
        startDatePlaceholderText={intl.formatMessage({ id: 'reviews.filters.dateRange.startDatePlaceholder' })}
        endDatePlaceholderText={intl.formatMessage({ id: 'reviews.filters.dateRange.endDatePlaceholder' })}
        endDate={this.state.dates.endDate}
        focusedInput={this.state.focused}
        onDatesChange={this.onDatesChange}
        onFocusChange={this.onFocusChange}
        isOutsideRange={isOutsideRange}
        numberOfMonths={1}
        initialVisibleMonth={moment}
        hideKeyboardShortcutsPanel
      />
    );
  }

  private onFocusChange = (focused: FocusType) => {
    // Prevent calendar frome closing
    if (focused !== null) {
      this.setState({ focused });
    }
  };

  // onFocusChange always fires before onDatesChange
  private onDatesChange = ({ startDate, endDate }: Dates) => {
    this.setState({ dates: { startDate, endDate } });

    if (startDate && endDate) {
      this.props.set(
        {
          end: endDate.toISOString(),
          start: startDate.toISOString(),
        },
        true,
      );
    }
  };
}

function mapStateToProps(state: State) {
  return {
    locale: state.language.locale,
    ...dateRange.selector(state),
  };
}

export default connect(mapStateToProps, dateRange.actions)(injectIntl(Custom));
export { Custom as PureCustom };
