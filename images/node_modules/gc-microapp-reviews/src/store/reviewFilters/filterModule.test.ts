import { create } from './filterModule';

const FOCUS_FILTER = 'reviewFilters/FOCUS_FILTER';
const APPLY_FILTERS = 'reviewFilters/APPLY_FILTERS';
const SET_FILTER = 'reviewFilters/SET_FILTER';
const CANCEL_FILTER = 'reviewFilters/CANCEL_FILTER';
const QUERY_SUCCESS = 'reviewFilters/QUERY_SUCCESS';

const defaults = {
  APPLY: APPLY_FILTERS,
  CANCEL: CANCEL_FILTER,
  FOCUS: FOCUS_FILTER,
  SET: SET_FILTER,
  SUCCESS: QUERY_SUCCESS,
  applyOnSet: false,
  initialValue: 50,
  integrityCheck: () => true,
  path: ['test'],
  validate: () => true,
};

function createTestModule(options = {}) {
  return create(Object.assign({}, defaults, options));
}

// REDUCER
// =======================================================

describe('filterModule', () => {
  it('should throw if initialValue fails integrityCheck()', () => {
    const instantiateBadModule = () => createTestModule({ integrityCheck: () => false });

    expect(instantiateBadModule).toThrow();
  });

  it('should default current and pending to initialValue', () => {
    const module = createTestModule();
    const result = module.reducer(undefined, { type: 'NO_MATCH' });

    expect(result.current).toEqual(defaults.initialValue);
    expect(result.pending).toEqual(defaults.initialValue);
  });

  describe('actions', () => {
    it('should have an apply() function that properly formats redux actions', () => {
      expect(createTestModule().actions.apply()).toEqual({ type: APPLY_FILTERS, target: 'test' });
    });

    it('should have an cancel() function that properly formats redux actions', () => {
      expect(createTestModule().actions.cancel()).toEqual({ type: CANCEL_FILTER, target: 'test' });
    });

    it('should have an focus() function that properly formats redux actions', () => {
      expect(createTestModule().actions.focus()).toEqual({ type: FOCUS_FILTER, target: 'test' });
    });

    it('should have an set() function that properly formats redux actions', () => {
      expect(createTestModule().actions.set(50)).toEqual({
        applyOnSet: false,
        payload: 50,
        target: 'test',
        type: SET_FILTER,
      });
    });

    it('should have an set() function that properly formats redux actions', () => {
      expect(createTestModule().actions.set(50)).toEqual({
        applyOnSet: false,
        payload: 50,
        target: 'test',
        type: SET_FILTER,
      });
    });
  });

  describe('selector', () => {
    it('should return the contents of the filter as an object', () => {
      const module = createTestModule();
      const store = { test: module.initialState };

      expect(module.selector(store)).toBeInstanceOf(Object);
    });

    it('should return the current and pending values, and the focus state', () => {
      const module = createTestModule();
      const store = { test: module.initialState };

      expect(module.selector(store).current).toEqual(defaults.initialValue);
      expect(module.selector(store).pending).toEqual(defaults.initialValue);
      expect(module.selector(store).focused).toEqual(false);
    });

    it('should return with { ..., valid: true } if validate() passes', () => {
      const module = createTestModule();
      const store = { test: module.initialState };

      expect(module.selector(store).valid).toEqual(true);
    });

    it('should return with { ..., valid: false } if validate() fails', () => {
      const module = createTestModule({ validate: () => false });
      const store = { test: module.initialState };

      expect(module.selector(store).valid).toEqual(false);
    });

    it('should return with { ..., changed: false } if current === pending', () => {
      const module = createTestModule();
      const store = { test: module.initialState };

      expect(module.selector(store).changed).toEqual(false);
    });

    it('should return with { ..., changed: true } if current !== pending', () => {
      const module = createTestModule();
      const store = { test: { ...module.initialState, pending: 100 } };

      expect(module.selector(store).changed).toEqual(true);
    });
  });

  describe('reducer', () => {
    it('should return default state if action is not matched', () => {
      const module = createTestModule();
      const action = { type: 'NO_MATCH' };
      const result = module.reducer(module.initialState, action);

      expect(result).toEqual(module.initialState);
    });

    describe('APPLY', () => {
      it('should be ignored if this module is not the target', () => {
        const module = createTestModule();
        const action = { type: APPLY_FILTERS, target: 'not me' };
        const result = module.reducer(module.initialState, action);

        expect(result).toEqual(module.initialState);
      });

      it('should clear focused if validate() passes', () => {
        const module = createTestModule();
        const action = module.actions.apply();
        const result = module.reducer({ ...module.initialState, focused: true }, action);

        expect(result.focused).toEqual(false);
      });

      it('should leave focused untouched if validate() fails', () => {
        const module = createTestModule({ validate: () => false });
        const action = module.actions.apply();
        const result = module.reducer({ ...module.initialState, focused: true }, action);

        expect(result.focused).toEqual(true);
      });
    });

    describe('CANCEL', () => {
      it('should reset pending value to current value', () => {
        const module = createTestModule({ validate: () => false });
        const action = module.actions.cancel();
        const result = module.reducer({ ...module.initialState, pending: 100 }, action);

        expect(result.pending).toEqual(result.current);
      });

      it('should clear focus regardless of whether validate() passes or not', () => {
        const module = createTestModule({ validate: () => false });
        const action = module.actions.cancel();
        const result = module.reducer({ ...module.initialState, focused: true }, action);

        expect(result.focused).toEqual(false);
      });
    });

    describe('FOCUS', () => {
      it('should be ignored if this module is not the target', () => {
        const module = createTestModule();
        const action = { type: FOCUS_FILTER, target: 'not me' };
        const result = module.reducer(module.initialState, action);

        expect(result).toEqual(module.initialState);
      });

      it('should set focus', () => {
        const module = createTestModule();
        const action = module.actions.focus();
        const result = module.reducer(module.initialState, action);

        expect(result.focused).toEqual(true);
      });
    });

    describe('SET', () => {
      it('should be ignored if this module is not the target', () => {
        const module = createTestModule();
        const action = { type: SET_FILTER, target: 'not me', payload: 100 };
        const result = module.reducer(module.initialState, action);

        expect(result).toEqual(module.initialState);
      });

      it('should set the pending value', () => {
        const module = createTestModule();
        const action = module.actions.set(100);
        const result = module.reducer(module.initialState, action);

        expect(result.pending).toEqual(100);
      });

      it('should clear focus if applyOnSet is true', () => {
        const module = createTestModule();
        const action = module.actions.set(100, true);
        const result = module.reducer({ ...module.initialState, focused: true }, action);

        expect(result.focused).toEqual(false);
      });

      it('should leave focused untouched if new value is invalid, even if applyOnSet is true', () => {
        const module = createTestModule({ validate: () => false });
        const action = module.actions.set(100, true);
        const result = module.reducer({ ...module.initialState, focused: true }, action);

        expect(result.focused).toEqual(true);
      });
    });
  });
});
