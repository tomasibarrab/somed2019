import configureMockStore from 'redux-mock-store';
import { createEpicMiddleware } from 'redux-observable';
import { Observable } from 'rxjs';

import { Dependencies } from '../store';
import { User, UserSearchResponse, UsersState } from '../types';
import {
  actions,
  epics,
  initialState as INITIAL_STATE,
  reducer as usersReducer,
  transformers,
  } from './users';

/**
 * REDUCER TESTS
 */

const fakeUser: User = {
  email: `john@fake.com`,
  enable2FA: false,
  firstName: 'John',
  gdprNotificationReceiver: false,
  id: '1',
  lastActive: '',
  lastName: 'Smith',
  newUser: false,
  phone: '1234567890',
  role: `FakeAccessType`,
  roles: [`FakeAccessType`],
  title: 'FakeTitle',
  urn: 'urn:fake.urn:1',
};

describe('users reducer', () => {

  it('should return initialState', () => {
    const actual = usersReducer(undefined, { type: ''});
    expect(actual).toEqual(INITIAL_STATE);
  });

  it('FETCH_USERS should set loading to true', () => {
    const initialState: UsersState = {
      currentSort: '',
      fetchStatus: null,
      isCreating: false,
      users: [],
    };
    const action = actions.fetchSearchUsers.started({});
    const expected = { ...initialState, fetchStatus: 'started' };
    const actual = usersReducer(initialState, action);

    expect(actual).toEqual(expected);
  });

  it('FETCH_USERS_FAILURE should set loading to false and users to payload', () => {
    const initialState: UsersState = {
      currentSort: '',
      fetchStatus: 'started',
      isCreating: false,
      users: [],
    };
    const action = actions.fetchSearchUsers.failed({ params: {}, error: {} });
    const expected = { ...initialState, fetchStatus: 'failed' };
    const actual = usersReducer(initialState, action);

    expect(actual).toEqual(expected);
  });

  it('FETCH_USERS_DONE should set loading to false and error to false along with payload', () => {
    const usersData: User[] = [fakeUser];
    const initialState: UsersState = {
      currentSort: '',
      fetchStatus: 'started',
      isCreating: false,
      users: [],
    };
    const action = actions.fetchSearchUsers.done({ params: {
        appRoles: ['urn:fake.urn:1'],
        appScope: { context: 'urn:fake.urn:1' },
      }, result: { totalCount: 1, users: usersData }});
    const expected = {
      ...initialState,
      fetchStatus: 'done',
      totalUsers: usersData.length,
      users: usersData,
    };
    const actual = usersReducer(initialState, action);

    expect(actual).toEqual(expected);
  });

  it('SORT_USERS should set the new user as first in the list', () => {
    const users: User[] = [
      { ...fakeUser, id: '1', firstName: 'A' },
      { ...fakeUser, id: '2', firstName: 'B' },
      { ...fakeUser, id: '3', firstName: 'C' },
    ];
    const currentSort = { firstName: 'asc' };
    const initialState: UsersState = {
      currentSort,
      currentUserId: 'test1',
      isCreating: false,
      updateStatus: 'started',
      users,
    };

    const action = actions.sortUsers({ sort: 'firstName', order: 'desc' });
    const expected = {
      ...initialState,
      currentSort: {
        firstName: 'desc',
      },
      users,
    };
    const actual = usersReducer(initialState, action);

    expect(actual).toEqual(expected);
  });

  it('should handle the default cause', () => {
    const initialState: UsersState = {
      currentSort: '',
      currentUserId: 'test1',
      isCreating: false,
      updateStatus: 'started',
      users: [],
    };

    const action = { type: 'NO_MATCH_ACTION' };
    const expected = { ...initialState };
    const actual = usersReducer(initialState, action);

    expect(actual).toEqual(expected);
  });
});


/**
 * EPIC TESTS
 */

describe('fetchSearchUsersEpic', () => {
  const state = {
    appRoles: {
      roles : [ { urn: `FakeAccessType`}],
    },
    appScope: {
      context: 'urn:fake.urn:1',
    },
    currentContext: {
      restaurant: {
        rid: 123,
      },
    },
  };

  const users: User[] = [
    { ...fakeUser, id: '123', title: 'Guest_Center_Title_Other' },
    { ...fakeUser, id: '456', title: 'Guest_Center_Title_Other' },
  ];
  const searchResult: UserSearchResponse = { totalCount: 2, users };
  const searchUsers = () => Observable.of({ response: searchResult });
  const dependencies: Dependencies = { usersApi: () => ({ searchUsers }) };
  const rootEpic = (action$, thestore) => epics.fetchSearchUsersEpic(action$, thestore, dependencies);
  const epicMiddleware = createEpicMiddleware(rootEpic);
  const mockStore = configureMockStore([epicMiddleware]);

  let store;
  beforeEach(() => {
    store = mockStore(state);
  });

  afterEach(() => {
    epicMiddleware.replaceEpic(rootEpic);
  });

  it('should fetch users', (done) => {
    global.fetch = () => Promise.resolve({
      json: () => ({ enabled: true }),
    });

    store.dispatch(actions.fetchSearchUsers.started({}));

    // the test needs to be scheduled after the mocked fetch, which is a Promise and runs async
    setTimeout(() => {
      expect(store.getActions()).toEqual([
        actions.fetchSearchUsers.started({}),
        actions.fetchSearchUsers.done({
          params: {
            appRoles: state.appRoles.roles,
            appScope: state.appScope,
          },
          result: searchResult,
        }),
      ]);
      done();
    }, 0);
  });
});

describe('fetchSearchUsersEpic', () => {
  const state = {
    currentContext: {
      restaurant: {
        rid: 123,
      },
    },
  };

  const searchUsers = () => Observable.throw('bad request');
  const dependencies = { usersApi: () => ({ searchUsers }) };
  const rootEpic = (action$, thestore) => epics.fetchSearchUsersEpic(action$, thestore, dependencies);
  const epicMiddleware = createEpicMiddleware(rootEpic);
  const mockStore = configureMockStore([epicMiddleware]);

  let store;
  beforeEach(() => {
    global.fetch = () => Promise.resolve({
      json: () => ({ enabled: true }),
    });
    store = mockStore(state);
  });

  afterEach(() => {
    epicMiddleware.replaceEpic(rootEpic);
  });

  it('should fails to fetch users', (done) => {
    store.dispatch(actions.fetchSearchUsers.started({}));

    // the test needs to be scheduled after the mocked fetch, which is a Promise and runs async
    setTimeout(() => {
      expect(store.getActions())
        .toEqual([
          actions.fetchSearchUsers.started({}),
          actions.fetchSearchUsers.failed({ error: 'bad request', params: {} }),
        ]);
      done();
    }, 0);
  });
});

describe('transformers', () => {
  it('sanitizePhone should strip non-digit characters', () => {
    const user1 = transformers.sanitizePhone({ ...fakeUser, phone: '123.456.7890' });
    const user2 = transformers.sanitizePhone({ ...fakeUser, phone: '123-456-7890' });
    expect(user1.phone).toEqual('1234567890');
    expect(user2.phone).toEqual('1234567890');
  });

  it('sanitizePhone should', () => {
    const user1 = transformers.sanitizePhone({ ...fakeUser, phone: '123.456.7890x12345678' });
    expect(user1.phone).toEqual('1234567890');
  });

  it('should handle non-string values', () => {
    expect(transformers.sanitizePhone({ ...fakeUser, phone: ''}).phone).toEqual('');
    expect(transformers.sanitizePhone({ ...fakeUser, phone: null }).phone).toEqual('');
    // no need to test this since we use type static checking and phone must be a string
    // expect(transformers.sanitizePhone({ ...fakeUser, phone: { phone: '123', ext: '1' } }).phone).toEqual('');
  });

  it('should copy a role in roles if roles is empty', () => {
    const user = {
      ...fakeUser,
      role: 'test-role',
      roles: [],
    };
    const transdormedUser = transformers.transformRoleToRoleList(user);
    expect(transdormedUser.roles).toHaveLength(1);
    expect(transdormedUser.roles[0]).toBe('test-role');
  });

  it('should copy a role in roles if roles is undefined', () => {
    const user = {
      ...fakeUser,
      role: 'test-role',
      roles: undefined,
    };
    const transdormedUser = transformers.transformRoleToRoleList(user);
    expect(transdormedUser.roles).toHaveLength(1);
    expect(transdormedUser.roles[0]).toBe('test-role');
  });

  it('should not copy a role in roles if roles is set with at least one element', () => {
    const user = {
      ...fakeUser,
      role: 'test-role',
      roles: ['existing-role'],
    };
    const transdormedUser = transformers.transformRoleToRoleList(user);
    expect(transdormedUser.roles).toHaveLength(1);
    expect(transdormedUser.roles[0]).toBe('existing-role');
  })

});
