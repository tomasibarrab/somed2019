import { createSelector } from 'reselect';
import { actionCreatorFactory } from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';

import get from 'lodash/get';
import { Observable } from 'rxjs';

import 'rxjs/add/observable/of';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/takeUntil';

import { modalTypes, titleIds } from '../../constants';
import { indexUsers } from '../../utils/reducer-helpers';
import {
  Epic,
  GuestCenterScope,
  Role,
  SortParameters,
  State,
  User,
  UserData,
  UserSearchResponse,
  UsersState,
} from '../types';
import { CLOSE_MODAL, CONFIRM_CLOSE_MODAL, OPEN_MODAL, openModal } from './modals';
import { actions as roleActions } from './roles';


const createAction = actionCreatorFactory();

const fetchSearchUsers = createAction.async<any, UserSearchResponse>('FETCH_SEARCH_USERS');

const ensureUsers = createAction('ENSURE_USERS');

const deleteUser = createAction.async<{}, string>('DELETE_USER');

const sortUsers = createAction<SortParameters>('SORT_USERS');

const searchUsers = createAction('SEARCH_USERS');

const navigateUsers = createAction<number>('NAVIGATE_USERS');

export const actions = {
  deleteUser,
  ensureUsers,
  fetchSearchUsers,
  navigateUsers,
  searchUsers,
  sortUsers,
};

/**
 * SELECTORS
 */

const baseSelector = (state: State) => get(state, 'users');
const fetchStatusSelector = createSelector(baseSelector, (state) => get(state, 'fetchStatus'));

export const selectors = {
  fetchStatus: fetchStatusSelector,
};


/**
 * TRANSFORMERS
 */
// payload transformations when fetch from server for client consumption
function transformTitle(user: Partial<User> ): Partial<User> {
  if (user.title && titleIds.indexOf(user.title) >= 0) {
    return user;
  }

  if (titleIds.indexOf(`Guest_Center_Title_${user.title}`) >= 0) {
    return { ...user, title: `Guest_Center_Title_${user.title}` };
  }

  return { ...user, title: 'Guest_Center_Title_Other' };
}

/**
 * Create a UserData object from a User. This function compute rolesSet and rolesNotEditable.
 * These are needed in the UserEditor.
 */
export function createEditableDataFromUser(
  userId: string | undefined, originalUser: Partial<User>, editableRoles: Role[], isCreate: boolean ): UserData {
    const user = transformTitle(originalUser);

    return ({
      email: user.email || '',
      enable2FA: Boolean(user.enable2FA),
      firstName: user.firstName || '',
      gdprNotificationReceiver: Boolean(user.gdprNotificationReceiver),
      id: userId || '',
      lastActive: user.lastActive || '',
      lastName: user.lastName || '',
      newUser: isCreate,
      phone: user.phone || '',
      role: user.role || '',
      rolesNotEditable: user.roles
        ? user.roles.filter(roleUrn => !editableRoles.some(availableRole => availableRole.urn === roleUrn))
        : [],
      rolesSet: editableRoles.map(availableRole => ({
        permissions: availableRole.permissions,
        set: user.roles !== undefined && user.roles.find(roleUrn => roleUrn === availableRole.urn) !== undefined,
        urn: availableRole.urn,
      })),
      title: user.title || '',
      urn: user.urn || '',
    });
}

/**
 * Create a User from edited data modified by the UserEditor
 */
export function createUserFromEditableData(data: UserData, userId: string | undefined, isCreate: boolean): User {
  return {
    email: data.email || '',
    enable2FA: Boolean(data.enable2FA),
    firstName: data.firstName || '',
    gdprNotificationReceiver: Boolean(data.gdprNotificationReceiver),
    id: userId && !isCreate ? userId : '',
    lastActive: data.lastActive || '',
    lastName: data.lastName || '',
    newUser: isCreate,
    phone: data.phone || '',
    role: data.role || '',
    roles: [
      ...data.rolesNotEditable,
      ...data.rolesSet.filter(roleSet => roleSet.set).map(roleSet => roleSet.urn),
    ],
    title: data.title || '',
    urn: data.urn || '',
  };
}

function sanitizePhone(user: User) {
  const phone = user.phone && user.phone.replace(/\D/g, '').slice(0, 10) || '';
  return { ...user, phone };
}

function transformUsersForClient(users: User[]): User[] {
  return users
    .map(transformTitle)
    .map(sanitizePhone);
}

function transformRoleToRoleList(user: User) {
  // Legacy user creation needs to create the roles array
  const transformedUser = user.roles && user.roles.length > 0  ? { ...user } : { ...user, roles: [user.role] };
  delete transformedUser.role;
  return transformedUser;
}

export const transformers = {
  sanitizePhone,
  transformRoleToRoleList,
};

/**
 * EPICS
 */

 /**
  * This epic takes care of calling all the required async actions
  * needed to render the list of users.
  * Note: the actions are called in sequence using the AsyncNextAction
  * param in roleActions.fetchPermissions and roleActions.fetchRoles
  * Note: this function will not fetch permissions and role if already in the
  * redux store.
  */
const ensureUsersEpic: Epic = (action$, store) => {
  return action$.ofType(ensureUsers.type)
    .debounceTime(100)
    .switchMap(() => {
      const perms = get(store.getState(), ['appRoles', 'permissions' ]);

      if (!perms || perms.length === 0) {
        return Observable.from([
          roleActions.fetchPermissions.started({
            nextAction: roleActions.fetchRoles.started,
            nextPayload: {
              nextAction: fetchSearchUsers.started,
              nextPayload: {},
              params: { rolesFor: 'appRoles' },
            },
            params: { rolesFor: 'appRoles' },
          }),
        ]);
      } else {
        return Observable.from([
          fetchSearchUsers.started({}),
        ]);
      }
    });
};

const navigateUsersEpic: Epic = (action$) =>
  action$.ofType(navigateUsers.type)
    .switchMap(() => Observable.of(ensureUsers()));

const searchUsersEpic: Epic = (action$) =>
  action$
    .ofType(
      searchUsers.type,
      sortUsers.type,
    )
    .switchMap(() => Observable.of(navigateUsers(0)));

const fetchSearchUsersEpic: Epic = (action$, store, { usersApi }) =>
  action$
    .ofType(fetchSearchUsers.started.type)
    .map(() => {
      const storeState = store.getState();
      return {
        appRoles: get(storeState, ['appRoles', 'roles']),
        appScope: get(storeState, ['appScope']),
        count: get(storeState, ['users', 'pageSize']),
        currentPage: get(storeState, ['users', 'currentPage']),
        query: get(storeState, ['users', 'searchQuery']),
        sortBy: Object.keys(get(storeState, ['users', 'currentSort'], {})).pop(),
        sortOrder: Object.values(get(storeState, ['users', 'currentSort'], {})).pop(),
      };
    })
    .switchMap(({ query, sortBy, sortOrder, count, currentPage, appRoles, appScope }: any) =>
      usersApi(appScope).searchUsers({
        count,
        includeRelatedContexts: true,
        order: sortOrder === 'asc' ? 'asc' : 'desc',
        query,
        skip: currentPage * count,
        sort: sortBy,
      })
        .map(({ response }: { response: UserSearchResponse }) => ({
          ...response,
          users: transformUsersForClient(response.users),
        }))
        .map(response => fetchSearchUsers.done({ params: { appRoles, appScope }, result: response })),
    )
    .catch(error => [fetchSearchUsers.failed({ params: {}, error })]);

/**
 * This epic listens on a stream of open-modal actions,
 * and then filters based on the type of modal opened.
 * In this case, we only want "delete user" modals.
 * Then, we switch on a a new stream of actions and listen
 * for a confirmation close. This inner stream is cancelled on
 * a modal close. Once we have a confirm close, we can make our
 * api call and finally dispatch our success/error actions depending
 * on the result.
 */
const confirmDeleteReportEpic: Epic = (action$, store, { usersApi }) =>
  action$.ofType(OPEN_MODAL)
    .filter((action) => action.payload.modal === modalTypes.DELETE_USER)
    .switchMap(() =>
      action$
        .takeUntil(action$.ofType(CLOSE_MODAL))
        .filter((action) => action.type === CONFIRM_CLOSE_MODAL)
        .map(() => ({
          appScope: get(store.getState(), ['appScope']),
          userId: get(store.getState(), ['modals', 'modalPayload', 'id']),
        }))
        .switchMap(({ appScope, userId }) =>
          usersApi(appScope)
            .deleteUser({
              id: userId,
              recursively: appScope.type === 'group',
            })
            .map(() => deleteUser.done({ params: {}, result: userId })),
        )
        .catch(error => [
          deleteUser.failed({ params: {}, error}),
          openModal({ modal: modalTypes.ERROR }),
        ]),
    );

export const epics = {
  confirmDeleteReportEpic,
  ensureUsersEpic,
  fetchSearchUsersEpic,
  navigateUsersEpic,
  searchUsersEpic,
};

/**
 * INITIAL STATE & REDUCER
 */

export const initialState: UsersState = {
  currentPage: 0,
  currentSort: {
    firstName: 'asc',
  },
  isCreating: false,
  pageSize: 10, // TODO: make this editable
  totalUsers: 0,
  users: [],
};

export const reducer = reducerWithInitialState<UsersState>(initialState)
  .case(actions.ensureUsers, (state) => ({
    ...state,
    fetchStatus: 'started',
  }))
  .case(fetchSearchUsers.started, (state) => ({
    ...state,
    fetchStatus: 'started',
  }))
  .case(roleActions.fetchPermissions.failed, (state) => ({
    ...state,
    fetchStatus: 'failed',
  }))
  .case(roleActions.fetchRoles.failed, (state) => ({
    ...state,
    fetchStatus: 'failed',
  }))
  .case(fetchSearchUsers.done, (state: UsersState, { params, result }) => {
    const { appRoles, appScope }: { appScope: GuestCenterScope, appRoles: Role[] } = params;
    return ({
      ...state,
      fetchStatus: 'done',
      totalUsers: result.totalCount,
      users: indexUsers(result.users, appScope, appRoles),
    });
  })
  .case(fetchSearchUsers.failed, (state: UsersState) => ({
    ...state,
    fetchStatus: 'failed',
  }))
  .case(deleteUser.started, (state: UsersState) => ({
    ...state,
    updateStatus: 'started',
  }))
  .case(deleteUser.done, (state: UsersState, { result }) => ({
    ...state,
    updateStatus: 'done',
    users: state.users.filter(user => user.id !== result),
  }))
  .case(deleteUser.failed, (state: UsersState) => ({
    ...state,
    updateStatus: 'failed',
  }))
  .case(searchUsers, (state: UsersState, searchQuery: string) => ({
    ...state,
    searchQuery,
  }))
  .case(sortUsers, (state: UsersState, sorting: SortParameters) => ({
    ...state,
    currentSort: {
      [sorting.sort]: sorting.order,
    },
  }))
  .case(navigateUsers, (state: UsersState, currentPage: number) => ({
    ...state,
    currentPage,
  }));
