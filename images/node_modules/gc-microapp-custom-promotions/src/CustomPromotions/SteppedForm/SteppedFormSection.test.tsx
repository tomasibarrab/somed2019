import classnames from 'classnames';
import { mount } from 'enzyme';
import React from 'react';
import { IntlProvider } from 'react-intl';
import { Provider } from 'react-redux';
import { reduxForm } from 'redux-form';
import configureMockStore from 'redux-mock-store';
import messages from '../../i18n/custom-promotions';
import { CUSTOM_PROMOTIONS_FORM_NAME } from '../constants';
import SteppedFormSection from './SteppedFormSection';

describe('SteppedFormSection', () => {
  const mockComponent = (props: any) => (
    <span className={classnames({ 'mock-component': true, ...props })}>{JSON.stringify(props)}</span>
  );
  const makeComponent = (props: any, formStateContents?: any) => {
    const fullStateWithFormValues = {
      form: {
        [CUSTOM_PROMOTIONS_FORM_NAME]: formStateContents || {},
      },
    };
    const store = configureMockStore([])(fullStateWithFormValues);
    const Decorated = reduxForm({ form: CUSTOM_PROMOTIONS_FORM_NAME })(SteppedFormSection as any);
    return {
      component: mount(
        <IntlProvider messages={messages} locale="en-US">
          <Provider store={store}>
            <Decorated form={CUSTOM_PROMOTIONS_FORM_NAME} component={mockComponent} name="mockSectionName" {...props} />
          </Provider>
        </IntlProvider>,
      ),
      store,
    };
  };

  it('should set done and visited states to true and show edit button if defaultDone is true', () => {
    const { component: wrapper } = makeComponent(
      {
        defaultDone: true,
      },
      {},
    );

    expect(wrapper.find('.edit-button').length).toEqual(1);
  });

  it('should set done and visited states to false and hide edit button if defaultDone is false or undefined', () => {
    let { component: wrapper } = makeComponent(
      {
        defaultDone: false,
      },
      {},
    );

    expect(wrapper.find('.edit-button').length).toEqual(0);

    wrapper = makeComponent({}, { syncErrors: { mockSectionName: {} } }).component;
    expect(wrapper.find('.edit-button').length).toEqual(0);
  });

  it('should show next button if onClickNext exists and defaultDone is false', () => {
    const { component: wrapper } = makeComponent(
      {
        defaultDone: false,
        onClickNext: () => true,
      },
      {},
    );

    expect(wrapper.find('.gca-button.bottom.next').length).toEqual(1);
  });

  it('should call props.onDone when click next button w/ no syncErrors', () => {
    const onDone = jest.fn();
    const { component: wrapper } = makeComponent(
      {
        onClickNext: () => true,
        onDone,
      },
      {},
    );

    expect(onDone).not.toHaveBeenCalled();
    expect(wrapper.find('.gca-button.bottom.next').length).toEqual(1);

    const nextButton = wrapper.find('button.next');
    nextButton.simulate('click');

    expect(onDone).toHaveBeenCalledTimes(1);
  });

  it('should display done button and NOT call props.onDone when click edit button w/ no syncErrors', () => {
    const onDone = jest.fn();
    const { component: wrapper } = makeComponent(
      {
        defaultDone: true,
        onDone,
      },
      {},
    );

    /* Open the section */
    const editButton = wrapper.find('.edit-button');
    editButton.simulate('click');
    expect(wrapper.find('.done-button').length).toEqual(1);
    expect(onDone).not.toHaveBeenCalled();
  });

  it('should display edit button and call props.onDone when click done button w/ no syncErrors', () => {
    const onDone = jest.fn();
    const { component: wrapper } = makeComponent(
      {
        defaultDone: true,
        onDone,
      },
      {},
    );

    /* Open the section */
    const editButton = wrapper.find('.edit-button');
    editButton.simulate('click');

    /* Close the section with the upper corner button */
    const cornerDoneButton = wrapper.find('.done-button');
    cornerDoneButton.simulate('click');
    expect(wrapper.find('.edit-button').length).toEqual(1);
  });

  it('should not collapse section when click done button if syncErrors exist', () => {
    const onDone = jest.fn();
    const { component: wrapper } = makeComponent(
      {
        defaultDone: true,
        onDone,
      },
      { syncErrors: { mockSectionName: 'failed' } },
    );

    let renderedMockComponent = wrapper.find('.mock-component');
    expect(renderedMockComponent.length).toEqual(1);

    /* Open the section */
    const editButton = wrapper.find('.edit-button');
    editButton.simulate('click');

    /* Attempt to close the section */
    const cornerDoneButton = wrapper.find('.done-button');
    cornerDoneButton.simulate('click');

    /* It didn't close */
    renderedMockComponent = wrapper.find('.mock-component');
    expect(renderedMockComponent.length).toEqual(1);
  });

  it('should have change function given to child call parent change function w/ form name, sectionName.fieldName, and value', () => {
    const change = jest.fn();
    const { component: wrapper, store } = makeComponent(
      {
        change,
        component: (props: any) => (
          <span
            className="mockChildCallsItsChangeProp"
            onClick={() => {
              props.change('mockFieldName', 'mockValue');
            }}
          >
            Click to fire
          </span>
        ),
      },
      {},
    );

    const renderedMockComponent = wrapper.find('.mockChildCallsItsChangeProp');
    expect(renderedMockComponent.length).toEqual(1);
    expect(store.getActions().length).toEqual(0);

    renderedMockComponent.simulate('click');

    const actions = store.getActions();
    expect(actions.length).toEqual(1);
    expect(actions).toMatchSnapshot();
  });
});
