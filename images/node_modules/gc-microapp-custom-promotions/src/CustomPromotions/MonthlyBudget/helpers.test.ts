import { makeCreditsResponse } from '../../../internals/testing/helpers/creditsHelpers';
import makeCreditsModel from '../../store/customPromotions/makeCreditsModel';
import * as helpers from './helpers';

/* tslint:disable:prefer-const */

describe('budget and credits helpers', () => {
  function* rangeGen(start: number, end: number, increment?: number) {
    for (let i = start; i < end; i += increment || 1) {
      yield i;
    }
    return;
  }

  const mockCoverPrice350 = 3.5;

  it('gets monthly budget from covers, simple multiplication', () => {
    const cm = makeCreditsModel(makeCreditsResponse(false, 0, mockCoverPrice350));
    for (let k of rangeGen(0, 20)) {
      expect(helpers.getMonthlyBudgetFromCovers(k, cm)).toBeCloseTo(mockCoverPrice350 * k);
    }
  });

  it('gets covers from monthly budget, rounding', () => {
    const cm = makeCreditsModel(makeCreditsResponse(false, 0, 4));

    /* tslint:disable:object-literal-sort-keys */
    const scenarios = [
      {
        monthlyBudget: 40,
        expectedCovers: 10,
      },
      {
        monthlyBudget: 4,
        expectedCovers: 1,
      },
      {
        monthlyBudget: 7,
        expectedCovers: 2,
      },
      {
        monthlyBudget: 6,
        expectedCovers: 2,
      },
      {
        monthlyBudget: 5,
        expectedCovers: 1,
      },
    ];
    scenarios.forEach(({ monthlyBudget, expectedCovers }) => {
      expect(helpers.getCoversFromMonthlyBudget(monthlyBudget, cm)).toBeCloseTo(expectedCovers);
    });
  });

  it('gets applied credits', () => {
    const cm = makeCreditsModel(makeCreditsResponse(false, 100, mockCoverPrice350));

    /* Linear region up to max credits, by multiples of coverPrice */
    for (let budget of rangeGen(0, 140, mockCoverPrice350)) {
      expect(helpers.getCreditsApplied(budget, cm)).toBeCloseTo(budget / mockCoverPrice350 * 2.5);
    }

    /* Linear region, rounding test*/
    for (let budget of rangeGen(mockCoverPrice350, mockCoverPrice350 * 2, 0.25)) {
      const expected = (budget % mockCoverPrice350) / mockCoverPrice350 < 0.5 ? 2.5 : 5;
      expect(helpers.getCreditsApplied(budget, cm)).toBeCloseTo(expected);
    }

    /* Saturation/maxed out region */
    expect(helpers.getCreditsApplied(140, cm)).toBeCloseTo(100);
    expect(helpers.getCreditsApplied(500, cm)).toBeCloseTo(100);
  });

  it('gets restaurant total cost', () => {
    const cm = makeCreditsModel(makeCreditsResponse(false, 100, mockCoverPrice350));

    /* Linear region up to max credits, by multiples of coverPrice */
    for (let budget of rangeGen(0, 140, mockCoverPrice350)) {
      expect(helpers.getRestaurantTotalCost(budget, cm)).toBeCloseTo(budget / mockCoverPrice350);
    }

    /* Linear region, rounding test */
    for (let budget of rangeGen(mockCoverPrice350, mockCoverPrice350 * 2, 0.25)) {
      const expected = (budget % mockCoverPrice350) / mockCoverPrice350 < 0.5 ? budget - 2.5 : budget - 5;
      expect(helpers.getRestaurantTotalCost(budget, cm)).toBeCloseTo(expected);
    }

    /* Saturation/maxed out region */
    for (let budget of rangeGen(140, 155, 0.5)) {
      expect(helpers.getRestaurantTotalCost(budget, cm)).toBeCloseTo(budget - 100);
    }
  });

  it('gets cost per cover w/o credits (constant from credits model)', () => {
    const cm = makeCreditsModel(makeCreditsResponse(false, 0, mockCoverPrice350));

    expect(helpers.getCostPerCover(0, cm)).toBeCloseTo(mockCoverPrice350);
    expect(helpers.getCostPerCover(120, cm)).toBeCloseTo(mockCoverPrice350);
    expect(helpers.getCostPerCover(9000, cm)).toBeCloseTo(mockCoverPrice350);
  });

  it('gets cost per cover w/ credits', () => {
    const cm = makeCreditsModel(makeCreditsResponse(false, 100, mockCoverPrice350));

    /* constant $1 region up to max credits, using multiples of coverPrice */
    for (let budget of rangeGen(mockCoverPrice350, 140, mockCoverPrice350)) {
      expect(helpers.getCostPerCover(budget, cm)).toBeCloseTo(1);
    }

    /* Rounding test, budgets that are nonmultiples of coverPrice may deviate from 1 ... */
    for (let budget of rangeGen(mockCoverPrice350, mockCoverPrice350 * 2, 0.25)) {
      const expected = (budget % mockCoverPrice350) / mockCoverPrice350 < 0.5 ? budget - 2.5 : (budget - 5) / 2;
      expect(helpers.getCostPerCover(budget, cm)).toBeCloseTo(expected);
    }

    /* Saturation/maxed out region */
    for (let budget of rangeGen(140, 160, 0.5)) {
      expect(helpers.getCostPerCover(budget, cm)).toBeCloseTo((budget - 100) / Math.round(budget / mockCoverPrice350));
    }
  });

  it('gets unused credits', () => {
    const cm = makeCreditsModel(makeCreditsResponse(false, 100, mockCoverPrice350));

    /* linear decreasing region up to max credits, using multiples of coverPrice */
    for (let budget of rangeGen(mockCoverPrice350, 140, mockCoverPrice350)) {
      expect(helpers.getUnusedCredits(budget, cm)).toBeCloseTo(100 - budget / mockCoverPrice350 * 2.5);
    }

    /* Saturation/maxed out region, no unused credits */
    for (let budget of rangeGen(140, 160, 0.5)) {
      expect(helpers.getUnusedCredits(budget, cm)).toBeCloseTo(0);
    }
  });

  it('formats a currency amount correctly, two decimal places if non integer, no decimal places for int', () => {
    /* tslint:disable:object-literal-sort-keys */
    const scenarios = [
      {
        input: 3.0,
        expected: '3',
      },
      {
        input: 3.01,
        expected: '3.01',
      },
      {
        input: 3.004,
        expected: '3',
      },
      {
        input: 99.41,
        expected: '99.41',
      },
      {
        input: 99.995,
        expected: '100',
      },
      {
        input: 99.994,
        expected: '99.99',
      },
    ];

    scenarios.forEach(({ input, expected }) => {
      expect(helpers.formatCurrencyAmount(input)).toEqual(expected);
    });
  });
});
