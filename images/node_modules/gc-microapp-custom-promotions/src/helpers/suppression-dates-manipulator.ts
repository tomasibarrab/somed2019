import moment, { Moment } from 'moment';
import { DateAttributes } from '../CustomPromotions/BlockedDays/BlockedDatesPickerModal/BlockedDatesPicker';
import { defaultSuppressionDates } from '../CustomPromotions/constants';
import { dateFormat } from '../CustomPromotions/constants';
import {
  CustomSuppressionDate,
  DefaultSuppressionDateDescription,
  SuppressionDates,
} from '../store/customPromotions/customPromotions.types';

export const toISODate = (m: Moment): string => m.format(dateFormat.MOMENT);

export const convertSuppressionDatesToMap = (
  suppressionDates: SuppressionDates | undefined,
): Map<string, DateAttributes> => {
  let blocked: Map<string, DateAttributes> = Object.keys(defaultSuppressionDates).reduce(
    (datesMap: Map<string, DateAttributes>, defaultDateKey: string) => {
      const defaultDate = defaultSuppressionDates[defaultDateKey];
      const isBlocked =
        suppressionDates &&
        Array.isArray(suppressionDates.default) &&
        suppressionDates.default.find((id: string) => defaultDateKey === id)
          ? true
          : false;

      datesMap.set(defaultDate.startDate, { isBlocked, isDefault: true, isNew: !isBlocked, id: defaultDateKey });
      return datesMap;
    },
    new Map(),
  );

  blocked =
    suppressionDates && Array.isArray(suppressionDates.custom)
      ? suppressionDates.custom.reduce((datesMap: Map<string, DateAttributes>, date: CustomSuppressionDate) => {
          if (date.startDate === date.endDate) {
            datesMap.set(date.startDate, {
              isBlocked: true,
              isDefault: false,
              isNew: false,
              label: date.label,
            });
          } else {
            // Iterate over all the days in the range adding them individually
            const cursor = moment(date.startDate);
            const end = moment(date.endDate);
            while (!cursor.isAfter(end, 'day')) {
              datesMap.set(toISODate(moment(cursor)), {
                isBlocked: true,
                isDefault: false,
                isNew: false,
                label: date.label,
              });
              cursor.add(1, 'day');
            }
          }
          return datesMap;
        }, blocked)
      : blocked;

  return blocked;
};

const makeCustomSuppressionDate = (date: string, label?: string): CustomSuppressionDate => ({
  endDate: date,
  label,
  startDate: date,
});

const getDefaultSuppressionDateId = (date: string): string[] => {
  return Object.keys(defaultSuppressionDates)
    .map(defaultDateKey => ({ id: defaultDateKey, ...defaultSuppressionDates[defaultDateKey] }))
    .filter((defaultSuppressionDate: DefaultSuppressionDateDescription & { id: string }) =>
      moment(defaultSuppressionDate.startDate).isSame(moment(date), 'day'),
    )
    .map((defaultSuppressionDate: DefaultSuppressionDateDescription & { id: string }) => defaultSuppressionDate.id);
};

// Can compare dates as strings since ISO Dates lexicographic order === chronological order
const customSuppressionDateCompare = (a: CustomSuppressionDate, b: CustomSuppressionDate): number => {
  if (a.startDate > b.startDate) {
    return 1;
  }
  return -1;
};

export const translateMap = (datesMap: Map<string, DateAttributes>): SuppressionDates => {
  const custom: CustomSuppressionDate[] = [];
  let def: string[] = [];

  datesMap.forEach(({ isDefault, isBlocked, label }, key) => {
    if (isBlocked) {
      if (isDefault) {
        def = def.concat(getDefaultSuppressionDateId(key));
      } else {
        custom.push(makeCustomSuppressionDate(key, label));
      }
    }
  });
  return {
    custom: custom.sort(customSuppressionDateCompare),
    default: def,
  };
};

export const translateToForm = (suppressionDates: SuppressionDates) => {
  const { custom: customDays, default: defaultDays } = suppressionDates;

  return {
    custom: customDays.reduce((accumulator: any, customDay: CustomSuppressionDate) => {
      accumulator[customDay.startDate] = true;
      return accumulator;
    }, {}),
    default: Object.keys(defaultSuppressionDates).reduce((accumulator: any, defaultDateId: string) => {
      accumulator[defaultDateId] = defaultDays.includes(defaultDateId);
      return accumulator;
    }, {}),
  };
};

export const translateFromForm = (formSuppressionDates: any) => {
  const { default: defaultDays, custom } = formSuppressionDates;
  return {
    custom: Object.keys(custom)
      .filter(key => custom[key]) // Only the enabled dates
      .map(dayString => ({ startDate: dayString, endDate: dayString })),
    default: Object.keys(defaultDays).filter(key => defaultDays[key]), // Only the enabled dates
  };
};
