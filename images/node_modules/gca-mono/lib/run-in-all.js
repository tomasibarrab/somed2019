const { curry, propOr, compose, find, equals, filter } = require('ramda');
const execa = require('execa');
const chalk = require('chalk');
const columnify = require('columnify');
const { header } = require('gca-logging-helpers');

function detectErrors(output) {
  return output.match(/FAIL|ERROR|errors/g) != null;
}

function logResult(result) {
  for (const key of ['stdout', 'stderr', 'error']) {
    if (result[key]) {
      console.log(result[key]);
    }
  }
}

const gatherCommandResult = curry((package, completed, total, result) => {
  const failed = (result.code !== 0 && result.code !== undefined) || result.failed || result.killed ||
    (result.stderr.length > 0 && detectErrors(result.stderr));
  console.log(`##teamcity[blockOpened name='${package.name}']`);
  console.log(header(`${package.name} (#${completed} of ${total}):  ${failed ? 'failed' : 'succeeded'}`, { top: 1 }));
  logResult(result);
  console.log(`##teamcity[blockClosed name='${package.name}']`);
  return {
    ...package,
    ...result,
    failed,
  };
});

// Returns a function that filter an array of packages returning the one that support a given command
const selectPackagesWithCommand = (cmd) => filter(compose(find(equals(cmd)), propOr([], 'commands')));

const packageHasCommand = (pkg, commandToFind) => {
  return pkg.commands.find(it => it === commandToFind) !== undefined;
}

module.exports = async function runInAll({
  packages,
  command,
  isDryRun = false
}) {
  console.log(header(`Attempting to run "${command}" task in the following packages:`));
  const pkgSummary = packages.map(pkg => ({
    package: pkg.name,
    will_run: packageHasCommand(pkg, command)
  }));
  console.log(columnify(pkgSummary, { columnSplitter: '     ' }), '\n');

  // const packageWithCommand = packages.filter(compose(find(equals(command)), propOr([], 'commands')));
  const packagesWithCommand = selectPackagesWithCommand(command)(packages);
  const total = packagesWithCommand.length;
  let completed = 0;
  const dryFlag = isDryRun ? ' --dry' : '';
  const cmd = `yarn ${command}${dryFlag}`;

  const asyncTasks = packagesWithCommand.map(pkg => () => {
    console.log(`Executing "${cmd}" on "${pkg.path}" ...`);
    const subprocess = execa.command(cmd, { cwd: pkg.path, env: { FORCE_COLOR: 1 } });
    // subprocess.stdout.pipe(process.stdout);
    return subprocess
      .then(gatherCommandResult(pkg, ++completed, total))
      .catch(gatherCommandResult(pkg, completed, total))
  });

  // Runs the asyncTasks in sequence and collect the results
  return asyncTasks.reduce(
    (prevPromise, task) => {
      return prevPromise
        .then(preRes => task()
          .then(res => ([...preRes, res]))
        );
    },
    Promise.resolve([])
  )
    .then(results => {
      const anyFailed = results.some(result => result.failed);
      const resultData = results.map(result => ({
        name: result.name,
        pkgVersion: result.localVersion,
        status: result.failed ? chalk.red('FAIL') : chalk.green('PASS'),
      }));

      console.log(header(`Summary of "${command}" task`, { top: 1, bottom: 1 }));
      console.log(columnify(resultData, { columnSplitter: '     ' }));

      if (anyFailed) {
        // TODO: Get all tests to a passing state, then revert to the commented code.
        // console.log(chalk.red(`\nTask "${command}" failed in one or more packages. Exiting.\n`));
        // process.exit(1);

        console.log(chalk.red(`\nTask "${command}" failed in one or more packages.\n`));
      } else {
        console.log(chalk.green(`\nTask "${command}" succeeded in all packages.\n`));
        return [];
      }
      return packages.filter(package =>
        results.some(result =>
          result.failed && package.name === result.name)
      );
    });
};

