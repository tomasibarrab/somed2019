import get from 'lodash/get';
import { createSelector } from 'reselect';
import { forkJoin } from 'rxjs/observable/forkJoin';
import { actionCreatorFactory } from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';
import { CategoryStatusOption, Epic } from './../../store/types';
import {
  CategoriesDTO,
  Category,
  CategoryStatus,
  CategoryStatusesDTO,
  RestaurantInfoDTO,
  State,
  TableStatus,
} from './../types';

import 'rxjs/add/observable/of';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/takeUntil';

const createAction = actionCreatorFactory();

const fetchCategories = createAction.async<{}, CategoriesDTO>('FETCH_CATEGORIES');
const checkCategory = createAction.async<string, string>('CHECK_CATEGORY');
const fetchStatuses = createAction.async<{}, CategoryStatusesDTO>('FETCH_STATUSES');
const selectStatus = createAction<number>('SELECT_STATUS');
const publishStatus = createAction.async<{}, {}>('PUBLISH_STATUS');
const selectStatusBucket = createAction<string>('SELECT_STATUS_BUCKET');
const clearCategorySelection = createAction.async<{}, {}>('CLEAR_CATEGORY_SELECTION');
const toggleTableStatusChangeEnabled = createAction.async<{}, {}>('TOGGLE_TABLE_STATUS_CHANGE_ENABLED');
const fetchRestaurantInfo = createAction.async<{}, RestaurantInfoDTO>('FETCH_RESTAURANT_INFO');
const fetchData = createAction('FETCH_DATA');

export const actions = {
  checkCategory,
  clearCategorySelection,
  fetchCategories,
  fetchData,
  fetchRestaurantInfo,
  fetchStatuses,
  publishStatus,
  selectStatus,
  selectStatusBucket,
  toggleTableStatusChangeEnabled,
};

export const initialState: TableStatus = {
  categories: [],
  isFetchingRestaurantInfo: true,
  isFlatCategory: true,
  posType: '',
  publishSuccess: false,
  readyToPublish: false,
  rid: -1,
  selectedStatusBucket: 'unassigned',
  status: 'empty',
  statusList: [],
  tableStatusChangeEnabled: false,
};

// Epics
export const fetchDataEpic: Epic = (action$, store, { api }) =>
  action$
    .ofType(fetchData.type)
    .map(() => get(store.getState(), ['currentContext', 'restaurant', 'rid']))
    .mergeMap((rid: number) =>
      forkJoin([api.fetchCategories({ rid }), api.getRestaurantInfo(rid), api.fetchStatuses()])
        .flatMap(([categories, restaurantInfo, statuses]) => [
          fetchCategories.done({ params: rid, result: categories }),
          fetchRestaurantInfo.done({ params: {}, result: restaurantInfo }),
          fetchStatuses.done({ params: {}, result: statuses }),
        ])
        .catch((error: Error) => [
          fetchCategories.failed({ params: rid, error }),
          fetchStatuses.failed({ params: {}, error }),
          fetchRestaurantInfo.failed({ params: {}, error }),
        ]),
    );
export const publishStatusEpic: Epic = (action$, store, { api }) =>
  action$
    .ofType(publishStatus.started.type)
    .map(() => {
      return {
        categories: get(store.getState(), ['tableStatus', 'categories']),
        rid: get(store.getState(), ['currentContext', 'restaurant', 'rid']),
      };
    })
    .switchMap((params: any) => {
      const categories = store.getState().tableStatus.isFlatCategory
        ? params.categories
        : params.categories.filter((el: Category) => el.level === 1);
      return api
        .publishStatus(params.rid, categories)
        .map(() => publishStatus.done({ params: {}, result: {} }))
        .catch((error: Error) => [publishStatus.failed({ params: {}, error })]);
    });

export const toggleTableStatusChangeEnabledEpic: Epic = (action$, store, { api }) =>
  action$
    .ofType(toggleTableStatusChangeEnabled.started.type)
    .map(() => {
      return {
        enabled: get(store.getState(), ['tableStatus', 'tableStatusChangeEnabled']),
        rid: get(store.getState(), ['currentContext', 'restaurant', 'rid']),
      };
    })
    .switchMap((params: any) => {
      return api
        .updateRetaurantTableStatusChangeEnabled(params.rid, !params.enabled)
        .map(() => toggleTableStatusChangeEnabled.done({ params: {}, result: {} }))
        .catch((error: Error) => [toggleTableStatusChangeEnabled.failed({ params: {}, error: {} })]);
    });

// utility functions

const arrayToMap = (arr: CategoryStatus[]): { [id: number]: CategoryStatus } => {
  return arr.reduce((obj: { [id: number]: CategoryStatus }, el: CategoryStatus): any => {
    obj[el.id] = el;
    return obj;
  }, {});
};

const sortCategories = (categories: Category[]): Category[] => {
  return categories.sort(
    (a: Category, b: Category): number => {
      if (a.status_id === b.status_id) {
        return a.name > b.name ? 1 : -1;
      }
      if (a.status_id === null) {
        return -1;
      } else if (b.status_id === null) {
        return 1;
      } else if (a.status_id < b.status_id) {
        return -1;
      } else {
        return 1;
      }
    },
  );
};
export const getVisibleCategories = (
  categories: Category[],
  bucket: string,
  statusDictionary: { [id: number]: CategoryStatus },
  isFlatCategory = true,
): Category[] => {
  let visibleCategories: Category[] = categories;
  if (bucket === 'all' && isFlatCategory) {
    visibleCategories = sortCategories(visibleCategories);
  }
  const showLevel: number = isFlatCategory ? 0 : 1;

  return visibleCategories
    .filter((val: Category) => {
      return val.level === showLevel;
    })
    .filter((val: Category) => {
      if (bucket === 'all') {
        return true;
      }
      if (bucket === 'unassigned') {
        return val.status_id === null;
      }
      if (val.status_id && statusDictionary[val.status_id].status.toLowerCase() === bucket.toLowerCase()) {
        return true;
      }
      return false;
    });
};

export const getCategoriesCheckedCount = createSelector(
  (state: State) => state.tableStatus.categories,
  (state: State) => state.tableStatus.isFlatCategory,
  (categories: Category[], isFlatCategory: boolean) => {
    return categories.reduce((count: number, cat: Category) => {
      if (isFlatCategory && cat.checked) {
        return (count += 1);
      } else if (!isFlatCategory && cat.level === 1 && cat.checked) {
        return (count += 1);
      }
      return count;
    }, 0);
  },
);

export const isSelectMode = createSelector(
  (state: State) => state.tableStatus.categories,
  (categories: Category[]) => {
    let selectMode: boolean = false;
    categories.forEach((el: Category) => {
      if (el.checked) {
        selectMode = true;
      }
    });
    return selectMode;
  },
);

export const getCountsPerFilter = createSelector(
  (state: State) => state.tableStatus.categories,
  (state: State) => state.tableStatus.isFlatCategory,
  (categories: Category[], isFlatCategory: boolean) => {
    let visibleLevel: number = 0;
    if (!isFlatCategory) {
      visibleLevel = 1;
    }
    const allCount: number = categories.filter((el: Category) => {
      return el.level === visibleLevel;
    }).length;
    const counts: { [id: string]: number } = {
      all: allCount,
      unassigned: 0,
    };
    categories.forEach((el: Category) => {
      if (el.status_id === null && el.level === visibleLevel) {
        counts.unassigned = counts.unassigned + 1;
      } else if (el.status_id != null && el.level === visibleLevel) {
        counts[String(el.status_id)] = counts[String(el.status_id)] ? counts[String(el.status_id)] + 1 : 1;
      }
    });
    return counts;
  },
);

export const getParentCategoriesDictionary = createSelector(
  (tableStatus: TableStatus) => tableStatus.categories,
  (categories: Category[]) => {
    const parentCategoriesDictionary: { [id: string]: Category } = {};
    categories.forEach((val: Category) => {
      if (val.level === 0) {
        parentCategoriesDictionary[val.category_id] = val;
      }
    });
    return parentCategoriesDictionary;
  },
);

export const getStatusList = createSelector(
  (tableStatus: TableStatus) => tableStatus.statusList,
  (statusList: CategoryStatusOption[]) =>
    statusList.map((status: CategoryStatusOption) => {
      return {
        ...status,
        label: status.status,
        value: status.status,
      };
    }),
);

export const getStatusDictionary = createSelector(
  (tableStatus: TableStatus) => tableStatus.statusList,
  (statusList: CategoryStatusOption[]) => arrayToMap(statusList),
);

export const uncheckAllCategories = (categories: Category[]): Category[] => {
  return categories.map((cat: Category) => ({
    ...cat,
    checked: false,
  }));
};

const checkFlatCategoryById = (categories: Category[], categoryId: string): Category[] => {
  return categories.map((cat: Category) => {
    if (cat.category_id === categoryId) {
      return {
        ...cat,
        checked: !cat.checked,
      };
    } else {
      return cat;
    }
  });
};

const checkCascadeChildren = (categories: Category[], categoryId: string, parentChecked: boolean): Category[] => {
  return categories.map((cat: Category) => {
    if (cat.category_id === categoryId || cat.parent_category_id === categoryId) {
      return {
        ...cat,
        checked: parentChecked,
      };
    } else {
      return cat;
    }
  });
};

const checkCategoryById = (tableStatus: TableStatus, categoryId: string): Category[] => {
  const parentCategoriesDictionary = getParentCategoriesDictionary(tableStatus);
  if (parentCategoriesDictionary[categoryId]) {
    const parentChecked: boolean = !parentCategoriesDictionary[categoryId].checked;
    return checkCascadeChildren(tableStatus.categories, categoryId, parentChecked);
  }

  return checkFlatCategoryById(tableStatus.categories, categoryId);
};

const transferCategoryToNewCategoryStatus = (categories: Category[], categoryStatusId: number): Category[] => {
  return categories.map((cat: Category) => {
    if (cat.checked) {
      return {
        ...cat,
        checked: false,
        status_id: categoryStatusId,
      };
    } else {
      return cat;
    }
  });
};

// reducer

export const tableStatusReducer = reducerWithInitialState(initialState)
  .case(toggleTableStatusChangeEnabled.done, state => ({
    ...state,
    tableStatusChangeEnabled: !state.tableStatusChangeEnabled,
  }))
  .case(fetchRestaurantInfo.done, (state, results) => ({
    ...state,
    isFetchingRestaurantInfo: false,
    posType: results.result.pos_type,
    tableStatusChangeEnabled: !!results.result.table_status_change_enabled,
  }))
  .case(fetchRestaurantInfo.failed, (state, results) => ({
    ...state,
    isFetchingRestaurantInfo: false,
  }))
  .case(fetchStatuses.started, state => ({ ...state, fetchStatus: 'started' }))
  .case(fetchStatuses.done, (state, results) => {
    return {
      ...state,
      statusList: results.result.statuses,
    };
  })
  .case(selectStatus, (state, optionId) => {
    return {
      ...state,
      categories: transferCategoryToNewCategoryStatus(state.categories, optionId),
      publishSuccess: false,
      readyToPublish: true,
    };
  })
  .case(selectStatusBucket, (state, bucket) => ({
    ...state,
    selectedStatusBucket: bucket,
  }))
  .case(publishStatus.started, state => ({
    ...state,
    readyToPublish: false,
  }))
  .case(publishStatus.done, state => ({
    ...state,
    publishSuccess: true,
    readyToPublish: false,
  }))
  .case(fetchCategories.done, (state, results) => {
    const isFlatCategory: boolean = !results.result.categories.find((el: Category) => {
      return el.level !== 0;
    });
    return {
      ...state,
      categories: results.result.categories,
      isFlatCategory,
      status: 'done',
    };
  })
  .case(clearCategorySelection.started, state => {
    return {
      ...state,
      categories: uncheckAllCategories(state.categories),
    };
  })

  .case(checkCategory.started, (state, categoryId) => {
    return {
      ...state,
      categories: checkCategoryById(state, categoryId),
    };
  });

export const epics = {
  fetchDataEpic,
  publishStatusEpic,
  toggleTableStatusChangeEnabledEpic,
};
