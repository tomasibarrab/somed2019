import { Observable } from 'rxjs/Observable';
import { Success } from 'typescript-fsa';
import {
  AgreementType,
  FetchAgreementDetailsParams,
  PrimaryProductsResponse,
  SupportedPosBrandsIds,
  UserAgreementData,
} from '../types';
import { createAsyncMockStore, mockUserAgreementResponse, rideResponseMock } from './onboarding.mocks';
import { fetchPosRideData } from './posStatus';
import {
  fetchUserAgreement,
  fetchUserAgreementEpic,
  fetchUserAgreementReducer,
  initialState,
  triggerFetchUserAgreementEpic,
} from './userAgreement';

import '../commonRxjs';

describe('fetch user agreement', () => {
  it('start should take a rid as payload', () => {
    const payload: FetchAgreementDetailsParams = { rid: 2001, agreementTypes: [AgreementType.omnivore] };
    const actual = fetchUserAgreement.started(payload);
    const expected = { payload, type: fetchUserAgreement.started.type };

    expect(actual).toEqual(expected);
  });

  it('done should take boolean if the agreement is signed', () => {
    const payload: Success<FetchAgreementDetailsParams, UserAgreementData> = {
      params: { rid: 1701, agreementTypes: [AgreementType.omnivore] },
      result: { isSigned: false, displayState: 'landing' },
    };
    const actual = fetchUserAgreement.done(payload);
    const expected = { type: fetchUserAgreement.done.type, payload };

    expect(actual).toEqual(expected);
  });

  it('should take an error if it fails', () => {
    const payload = {
      error: 'rule 1 of fight club was broken',
      params: { rid: 1701, agreementTypes: [AgreementType.omnivore] },
    };
    const actual = fetchUserAgreement.failed(payload);
    const expected = { type: fetchUserAgreement.failed.type, payload, error: true };

    expect(actual).toEqual(expected);
  });
});

describe('trigger fetch user agreement epic', () => {
  describe('pos status is active', () => {
    it('should assume that terms are signed and go to active state', () => {
      const store = createAsyncMockStore({}, triggerFetchUserAgreementEpic);

      const result: UserAgreementData = { isSigned: true, displayState: 'active' };

      store.dispatch(fetchPosRideData.done({ params: 1701, result: { isPosActive: true, ride: rideResponseMock } }));
      expect(store.getActions()).toEqual([
        fetchPosRideData.done({ params: 1701, result: { isPosActive: true, ride: rideResponseMock } }),
        fetchUserAgreement.done({ params: { rid: 1701, agreementTypes: [] }, result }),
      ]);
    });
  });

  describe('pos status is inactive', () => {
    it('start the fetching user agreement with omivore for all POS except upserve', () => {
      const store = createAsyncMockStore({}, triggerFetchUserAgreementEpic);

      const fetchRideDoneAction = fetchPosRideData.done({
        params: 1701,
        result: { isPosActive: false, ride: rideResponseMock },
      });

      store.dispatch(fetchRideDoneAction);
      expect(store.getActions()).toEqual([
        fetchRideDoneAction,
        fetchUserAgreement.started({ rid: 1701, agreementTypes: [AgreementType.omnivore] }),
      ]);
    });

    it('start the fetching user agreement with generic when POS is upserve', () => {
      const store = createAsyncMockStore({}, triggerFetchUserAgreementEpic);

      const fetchRideDoneAction = fetchPosRideData.done({
        params: 1701,
        result: {
          isPosActive: false,
          ride: { ...rideResponseMock, posBrandId: SupportedPosBrandsIds.Upserve },
        },
      });

      store.dispatch(fetchRideDoneAction);
      expect(store.getActions()).toEqual([
        fetchRideDoneAction,
        fetchUserAgreement.started({ rid: 1701, agreementTypes: [AgreementType.generic] }),
      ]);
    });

    it('should start the fetching user agreement with both generic and omnivore if posBrand is null', () => {
      const store = createAsyncMockStore({}, triggerFetchUserAgreementEpic, {
        Id: SupportedPosBrandsIds.unselected,
        Name: '',
      });

      const fetchRideDoneAction = fetchPosRideData.done({
        params: 1701,
        result: {
          isPosActive: false,
          ride: { ...rideResponseMock, posBrandId: null },
        },
      });

      store.dispatch(fetchRideDoneAction);

      expect(store.getActions()).toEqual([
        fetchRideDoneAction,
        fetchUserAgreement.started({ rid: 1701, agreementTypes: [AgreementType.generic, AgreementType.omnivore] }),
      ]);
    });
  });
});

describe('fetch user agreement epic', () => {
  it('should call the api for each agreement type if no pos brand is selected', () => {
    const getUserAgreement = jest.fn(() => Observable.of({ ...mockUserAgreementResponse, isSigned: false }));
    const store = createAsyncMockStore({ getUserAgreement }, fetchUserAgreementEpic);

    const fetchUserAgreementAction = fetchUserAgreement.started({
      agreementTypes: [AgreementType.generic, AgreementType.omnivore],
      rid: 1701,
    });

    store.dispatch(fetchUserAgreementAction);
    expect(getUserAgreement).toHaveBeenCalledTimes(2);
    expect(getUserAgreement).toHaveBeenCalledWith({ rid: 1701, agreementType: AgreementType.omnivore });
    expect(getUserAgreement).toHaveBeenCalledWith({ rid: 1701, agreementType: AgreementType.generic });
    expect(store.getActions()).toEqual([
      fetchUserAgreementAction,
      fetchUserAgreement.done({
        params: { rid: 1701, agreementTypes: [AgreementType.generic, AgreementType.omnivore] },
        result: { isSigned: false, displayState: 'landing' },
      }),
    ]);
  });

  it('should set isSigned to true and navigate to nextSteps if POS is selected and agreement is signed', () => {
    const store = createAsyncMockStore(
      { getUserAgreement: () => Observable.of(mockUserAgreementResponse) },
      fetchUserAgreementEpic,
      { Id: SupportedPosBrandsIds.Toast, Name: 'Toast' },
    );

    store.dispatch(fetchUserAgreement.started({ rid: 1701, agreementTypes: [AgreementType.omnivore] }));
    expect(store.getActions()).toEqual([
      fetchUserAgreement.started({ rid: 1701, agreementTypes: [AgreementType.omnivore] }),
      fetchUserAgreement.done({
        params: { rid: 1701, agreementTypes: [AgreementType.omnivore] },
        result: { isSigned: true, displayState: 'nextSteps' },
      }),
    ]);
  });

  it('should set isSigned to true and navigate to posSelect if POS is unselected and agreement is signed', () => {
    const store = createAsyncMockStore(
      { getUserAgreement: () => Observable.of(mockUserAgreementResponse) },
      fetchUserAgreementEpic,
    );

    store.dispatch(fetchUserAgreement.started({ rid: 1701, agreementTypes: [AgreementType.omnivore] }));
    expect(store.getActions()).toEqual([
      fetchUserAgreement.started({ rid: 1701, agreementTypes: [AgreementType.omnivore] }),
      fetchUserAgreement.done({
        params: { rid: 1701, agreementTypes: [AgreementType.omnivore] },
        result: { isSigned: true, displayState: 'posSelect' },
      }),
    ]);
  });

  it('should set isSigned to false and navigate to landing page if agreement is unsigned', () => {
    const store = createAsyncMockStore(
      { getUserAgreement: () => Observable.of({ ...mockUserAgreementResponse, isSigned: false }) },
      fetchUserAgreementEpic,
    );

    store.dispatch(fetchUserAgreement.started({ rid: 1701, agreementTypes: [AgreementType.omnivore] }));
    expect(store.getActions()).toEqual([
      fetchUserAgreement.started({ rid: 1701, agreementTypes: [AgreementType.omnivore] }),
      fetchUserAgreement.done({
        params: { rid: 1701, agreementTypes: [AgreementType.omnivore] },
        result: { isSigned: false, displayState: 'landing' },
      }),
    ]);
  });

  it('should not trigger the failed action if an error is thrown', () => {
    const errorObject = {
      error: 'bad',
    };

    const mockResponse: Observable<PrimaryProductsResponse> = Observable.throw(errorObject);
    const store = createAsyncMockStore({ getUserAgreement: () => mockResponse }, fetchUserAgreementEpic);

    store.dispatch(fetchUserAgreement.started({ rid: 1987, agreementTypes: [AgreementType.omnivore] }));
    expect(store.getActions()).toEqual([
      fetchUserAgreement.started({ rid: 1987, agreementTypes: [AgreementType.omnivore] }),
      fetchUserAgreement.done({
        params: { rid: 1987, agreementTypes: [AgreementType.omnivore] },
        result: { isSigned: false, displayState: 'landing' },
      }),
    ]);
  });
});

describe('fetchUserAgreementStatus Reducer', () => {
  it('should set the fetchPosRideData to started when started', () => {
    const action = { type: fetchUserAgreement.started.type };
    const expected = { data: undefined, status: 'started' };
    const actual = fetchUserAgreementReducer(initialState, action);

    expect(actual).toEqual(expected);
  });

  it('should set fetchUserAgreement true and displayState Next Steps when agreement is Signed', () => {
    const result = { isSigned: true, displayState: 'active' };
    const action = { type: fetchUserAgreement.done.type, payload: { params: 1701, result } };
    const expected = { data: true, status: 'done' };
    const actual = fetchUserAgreementReducer(initialState, action);
    expect(actual).toEqual(expected);
  });

  it('should save the error when failed', () => {
    const startedFetchState = { data: undefined, status: 'started' };
    const action = { type: fetchUserAgreement.failed.type, payload: { error: 'I see bad times today' } };
    const expected = { data: 'I see bad times today', status: 'failed' };
    const actual = fetchUserAgreementReducer(startedFetchState, action);

    expect(actual).toEqual(expected);
  });
});
