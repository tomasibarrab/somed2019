import { Observable } from 'rxjs/Observable';
import { SupportedPosBrand } from '../types';

import { createAsyncMockStore, posBrandMocks } from './onboarding.mocks';

import {
  fetchSupportedPosBrands,
  fetchSupportedPosBrandsEpic,
  fetchSupportedPosBrandsReducer,
  initialState,
} from './supportedPosBrands';

describe('fetch supported pos brands actions', () => {
  it('should create the start action', () => {
    const actual = fetchSupportedPosBrands.started(null);
    const expected = { payload: null, type: fetchSupportedPosBrands.started.type };

    expect(actual).toEqual(expected);
  });

  it('done should take an array of POS Brands', () => {
    const payload = {
      params: null,
      result: posBrandMocks,
    };
    const actual = fetchSupportedPosBrands.done(payload);
    const expected = { type: fetchSupportedPosBrands.done.type, payload };

    expect(actual).toEqual(expected);
  });
});

describe('fetch suppoerted pos brands epic', () => {
  it('pass an array of PosBrands to fetchSupportedPosBrands.done', () => {
    const mockResponse: Observable<SupportedPosBrand[]> = Observable.of(posBrandMocks);

    const store = createAsyncMockStore({ fetchQualifiedPosBrands: () => mockResponse }, fetchSupportedPosBrandsEpic);

    store.dispatch(fetchSupportedPosBrands.started(null));
    expect(store.getActions()).toEqual([
      fetchSupportedPosBrands.started(null),
      fetchSupportedPosBrands.done({ params: null, result: posBrandMocks }),
    ]);
  });

  it('pass an error to fetchSupportedPosBrands.failed', () => {
    const mockError = { error: 'some error' };
    const mockResponse: Observable<any> = Observable.throw(mockError);

    const store = createAsyncMockStore({ fetchQualifiedPosBrands: () => mockResponse }, fetchSupportedPosBrandsEpic);

    store.dispatch(fetchSupportedPosBrands.started(null));
    expect(store.getActions()).toEqual([
      fetchSupportedPosBrands.started(null),
      fetchSupportedPosBrands.failed({ params: null, error: mockError }),
    ]);
  });
});

describe('fetch supported pos brands', () => {
  it('should set the status of supportedPos to "started"', () => {
    const action = {
      payload: null,
      type: fetchSupportedPosBrands.started.type,
    };
    const expected = {
      data: undefined,
      status: 'started',
    };
    const actual = fetchSupportedPosBrandsReducer(initialState, action);
    expect(actual).toEqual(expected);
  });

  it('should set the results of supported pos brands on state', () => {
    const action = {
      payload: { params: null, result: posBrandMocks },
      type: fetchSupportedPosBrands.done.type,
    };
    const expected = {
      data: posBrandMocks,
      status: 'done',
    };
    const actual = fetchSupportedPosBrandsReducer(initialState, action);
    expect(actual).toEqual(expected);
  });

  it('should set the error and update status on supported pos state', () => {
    const action = {
      payload: { error: 'some error' },
      type: fetchSupportedPosBrands.failed.type,
    };
    const expected = {
      data: 'some error',
      status: 'failed',
    };
    const actual = fetchSupportedPosBrandsReducer(initialState, action);
    expect(actual).toEqual(expected);
  });
});
