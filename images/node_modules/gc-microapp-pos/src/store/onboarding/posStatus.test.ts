import {
  actions as currentContextActions,
  FETCH_CONTEXT_RID_SUCCESS,
} from 'gca-react-components/src/redux-modules/currentContext';
import { Observable } from 'rxjs/Observable';
import { addNotification } from 'shared-react-smart-ui/NotificationCenter';
import { SUPPORT_LINK } from '../../constants';
import { PrimaryProduct, PrimaryProductsResponse, RideResponse, SupportedPosBrandsIds } from '../types';
import { updateDisplayState, updatePosBrand } from './onboarding';
import { createAsyncMockStore, rideResponseMock } from './onboarding.mocks';
import {
  cancelPosActivation,
  cancelPosActivationEpic,
  cancelPosActivationErrorEpic,
  cancelPosActivationReducer,
  doneFetchPosRideEpic,
  fetchPosRideData,
  fetchPosRideDataEpic,
  fetchPosRideDataReducer,
  initialState,
  triggerFetchPosRideDataEpic,
} from './posStatus';

describe('actions', () => {
  describe('fetchPosRideData', () => {
    it('should create the start action that takes a rid', () => {
      const actual = fetchPosRideData.started(8008);
      const expected = { payload: 8008, type: fetchPosRideData.started.type };

      expect(actual).toEqual(expected);
    });

    it('should create a done action that takes a supportedPos', () => {
      const payload = {
        params: 8008,
        result: { isPosActive: true, ride: rideResponseMock },
      };
      const actual = fetchPosRideData.done(payload);
      const expected = { type: fetchPosRideData.done.type, payload };

      expect(actual).toEqual(expected);
    });

    it('should create a failed action with some kind of error', () => {
      const payload = { params: 8008, error: 'blame canada!' };
      const actual = fetchPosRideData.failed(payload);
      const expected = { type: fetchPosRideData.failed.type, error: true, payload };

      expect(actual).toEqual(expected);
    });
  });

  describe('cancelPosActivation', () => {
    it('should create the start action', () => {
      const actual = cancelPosActivation.started(null);
      const expected = { payload: null, type: cancelPosActivation.started.type };

      expect(actual).toEqual(expected);
    });

    it('should create a done action', () => {
      const payload = {
        params: null,
        result: {},
      };
      const actual = cancelPosActivation.done(payload);
      const expected = { type: cancelPosActivation.done.type, payload };

      expect(actual).toEqual(expected);
    });

    it('should create a failed action with some kind of error', () => {
      const payload = { params: null, error: 'blame canada!' };
      const actual = cancelPosActivation.failed(payload);
      const expected = { type: cancelPosActivation.failed.type, error: true, payload };

      expect(actual).toEqual(expected);
    });
  });
});

describe('epics', () => {
  describe('trigger fetch status epic', () => {
    it('should be trigged by the current context being successful and find if the POS Integration is active', () => {
      const store = createAsyncMockStore({}, triggerFetchPosRideDataEpic);

      store.dispatch({
        payload: 'some type of payload',
        type: FETCH_CONTEXT_RID_SUCCESS,
      });
      expect(store.getActions()).toEqual([
        {
          payload: 'some type of payload',
          type: FETCH_CONTEXT_RID_SUCCESS,
        },
        fetchPosRideData.started(1701),
      ]);
    });
  });

  describe('preselectPosEpic', () => {
    it('should call updatePosBrand when fetchPosRideData is done', () => {
      const store = createAsyncMockStore({}, doneFetchPosRideEpic);
      const mockPosBrand = {
        Id: rideResponseMock.posBrandId,
        Name: rideResponseMock.posBrandName,
      };
      store.dispatch(fetchPosRideData.done({ params: 1701, result: { isPosActive: true, ride: rideResponseMock } }));

      expect(store.getActions()).toEqual([
        fetchPosRideData.done({ params: 1701, result: { isPosActive: true, ride: rideResponseMock } }),
        updateDisplayState('active'),
        updatePosBrand(mockPosBrand),
      ]);
    });

    it('should not call updatePosBrand when fetchPosRideData does not get a pos', () => {
      const store = createAsyncMockStore({}, doneFetchPosRideEpic);
      const mockBlankPosRideResponse = {
        ...rideResponseMock,
        posBrandId: null,
        posBrandName: null,
      };
      store.dispatch(
        fetchPosRideData.done({ params: 1701, result: { isPosActive: false, ride: mockBlankPosRideResponse } }),
      );

      expect(store.getActions()).toEqual([
        fetchPosRideData.done({ params: 1701, result: { isPosActive: false, ride: mockBlankPosRideResponse } }),
        updateDisplayState('landing'),
      ]);
    });

    it('should not call updatePosBrand when fetchPosRideData contains an unsupported pos', () => {
      const store = createAsyncMockStore({}, doneFetchPosRideEpic);
      const mockUnsupportedPosRideResponse = {
        ...rideResponseMock,
        posBrandId: 'abc999',
        posBrandName: 'Fruit Loop POS',
      };
      store.dispatch(
        fetchPosRideData.done({ params: 1701, result: { isPosActive: false, ride: mockUnsupportedPosRideResponse } }),
      );

      expect(store.getActions()).toEqual([
        fetchPosRideData.done({ params: 1701, result: { isPosActive: false, ride: mockUnsupportedPosRideResponse } }),
        updateDisplayState('landing'),
      ]);
    });

    it('should call updateDisplayState with active if pos is active', () => {
      const store = createAsyncMockStore({}, doneFetchPosRideEpic);
      const mockBlankPosRideResponse = {
        ...rideResponseMock,
        posBrandId: null,
        posBrandName: null,
      };
      store.dispatch(
        fetchPosRideData.done({ params: 1701, result: { isPosActive: true, ride: mockBlankPosRideResponse } }),
      );

      expect(store.getActions()).toEqual([
        fetchPosRideData.done({ params: 1701, result: { isPosActive: true, ride: mockBlankPosRideResponse } }),
        updateDisplayState('active'),
      ]);
    });

    it('should call updateDisplayState with landing if pos is not active', () => {
      const store = createAsyncMockStore({}, doneFetchPosRideEpic);
      const mockPosBrand = {
        Id: rideResponseMock.posBrandId,
        Name: rideResponseMock.posBrandName,
      };
      store.dispatch(fetchPosRideData.done({ params: 1701, result: { isPosActive: false, ride: rideResponseMock } }));

      expect(store.getActions()).toEqual([
        fetchPosRideData.done({ params: 1701, result: { isPosActive: false, ride: rideResponseMock } }),
        updateDisplayState('landing'),
        updatePosBrand(mockPosBrand),
      ]);
    });
  });

  describe('fetch pos ride data epic', () => {
    it('should get primary products and get restaurant data and set isPosActive to true if pos is active', () => {
      const primaryProducts: PrimaryProduct[] = [
        {
          product: 'Guest Center',
          status: 'Active',
        },
        {
          product: 'POS Integration',
          status: 'Active',
        },
      ];
      const mockPrimaryProductsResponse: Observable<PrimaryProductsResponse> = Observable.of({
        primaryProducts,
        rid: 1701,
      });

      const mockRideResponse: Observable<RideResponse> = Observable.of(rideResponseMock);
      const mockApi = {
        // getPrimaryActive: jest.fn(() => mockPrimaryProductsResponse),
        getPosActiveStatus: jest.fn(() =>
          Observable.of({
            pos_integration_enabled: true,
          }),
        ),
        getRestaurantData: jest.fn(() => mockRideResponse),
      };
      const store = createAsyncMockStore(mockApi, fetchPosRideDataEpic);

      store.dispatch(fetchPosRideData.started(1337));
      expect(mockApi.getRestaurantData).toHaveBeenCalledWith(1337);
      expect(mockApi.getPosActiveStatus).toHaveBeenCalledWith(1337);
      expect(store.getActions()).toEqual([
        fetchPosRideData.started(1337),
        fetchPosRideData.done({
          params: 1337,
          result: { isPosActive: true, ride: rideResponseMock },
        }),
      ]);
    });

    it('should set isPosActive to false if pos not active', () => {
      const primaryProducts: PrimaryProduct[] = [
        {
          product: 'Guest Center',
          status: 'Active',
        },
        {
          product: 'POS Integration',
          status: 'Pending Active',
        },
      ];
      const mockPrimaryProductsResponse: Observable<PrimaryProductsResponse> = Observable.of({
        primaryProducts,
        rid: 1701,
      });

      const mockRideResponse: Observable<RideResponse> = Observable.of(rideResponseMock);
      const mockApi = {
        // getPrimaryActive: jest.fn(() => mockPrimaryProductsResponse),
        getPosActiveStatus: jest.fn(() =>
          Observable.of({
            pos_integration_enabled: false,
          }),
        ),
        getRestaurantData: jest.fn(() => mockRideResponse),
      };
      const store = createAsyncMockStore(mockApi, fetchPosRideDataEpic);

      store.dispatch(fetchPosRideData.started(1337));
      expect(mockApi.getRestaurantData).toHaveBeenCalledWith(1337);
      // expect(mockApi.getPrimaryActive).toHaveBeenCalledWith(1337);
      expect(mockApi.getPosActiveStatus).toHaveBeenCalledWith(1337);
      expect(store.getActions()).toEqual([
        fetchPosRideData.started(1337),
        fetchPosRideData.done({
          params: 1337,
          result: { isPosActive: false, ride: rideResponseMock },
        }),
      ]);
    });

    it('should call done if ride succeeds and getPosActiveStatus returns a 404', () => {
      const mockRideResponse: Observable<RideResponse> = Observable.of(rideResponseMock);
      const mockApi = {
        getPosActiveStatus: jest.fn(() =>
          Observable.throw({
            status: 404,
          }),
        ),
        getRestaurantData: jest.fn(() => mockRideResponse),
      };
      const store = createAsyncMockStore(mockApi, fetchPosRideDataEpic);

      store.dispatch(fetchPosRideData.started(1337));
      expect(mockApi.getRestaurantData).toHaveBeenCalledWith(1337);
      expect(mockApi.getPosActiveStatus).toHaveBeenCalledWith(1337);
      expect(store.getActions()).toEqual([
        fetchPosRideData.started(1337),
        fetchPosRideData.done({
          params: 1337,
          result: { isPosActive: false, ride: rideResponseMock },
        }),
      ]);
    });
  });

  describe('cancel pos activation epic', () => {
    it('should cancel pos activation', () => {
      const mockApi = {
        cancelPosActivation: jest.fn(() =>
          Observable.of({})),
      };

      const store = createAsyncMockStore(mockApi, cancelPosActivationEpic);

      store.dispatch(cancelPosActivation.started(null));
      expect(mockApi.cancelPosActivation).toHaveBeenCalledWith(1701);
      expect(store.getActions()).toEqual([
        cancelPosActivation.started(null),
        cancelPosActivation.done({ params: null, result: {} }),
      ]);
    });

    it('should fail to cancel pos activation', () => {
      const error = {
        message: 'ajax error 403',
        response: null,
        status: 403,
      };

      const mockApi = {
        cancelPosActivation: jest.fn(() =>
          Observable.throw(error),
        ),
      };

      const store = createAsyncMockStore(mockApi, cancelPosActivationEpic);

      store.dispatch(cancelPosActivation.started(null));
      expect(mockApi.cancelPosActivation).toHaveBeenCalledWith(1701);
      expect(store.getActions()).toEqual([
        cancelPosActivation.started(null),
        cancelPosActivation.failed({ params: null, error }),
      ]);
    });
  });

  describe('cancel pos activation error epic', () => {
    it('should update display state and add notification for already active', () => {
      const store = createAsyncMockStore(
        null,
        cancelPosActivationErrorEpic,
        { Id: SupportedPosBrandsIds.Aloha, Name: 'Aloha' },
      );

      const error = {
        message: 'ajax error 403',
        response: null,
        status: 403,
      };

      store.dispatch(cancelPosActivation.failed({ error, params: null }));

      expect(store.getActions()).toEqual([
        cancelPosActivation.failed({ error, params: null }),
        updateDisplayState('active'),
        addNotification({
          messageId:  'posstatus.changepos.error',
          messageValues: {
            supportLink: SUPPORT_LINK,
            yourpos: 'Aloha',
          },
        }),
      ]);

    });
  });
});

describe('reducers', () => {
  describe('fetchPosRideData reducer', () => {
    it('should set fetchPosRideData to started when fetchStatus started', () => {
      const action = { type: fetchPosRideData.started.type };
      const expected = { data: undefined, status: 'started' };
      const actual = fetchPosRideDataReducer(initialState, action);

      expect(actual).toEqual(expected);
    });

    it('should save if the pos is active to data and set status to "done"', () => {
      const startedFetchState = { data: undefined, status: 'started' };
      const result = true;
      const action = { type: fetchPosRideData.done.type, payload: { params: 1701, result } };

      const expected = { data: true, status: 'done' };
      const actual = fetchPosRideDataReducer(startedFetchState, action);
      expect(actual).toEqual(expected);
    });

    it('should save the error when failed', () => {
      const startedFetchState = { data: undefined, status: 'started' };
      const action = { type: fetchPosRideData.failed.type, payload: { error: 'I see bad times today' } };
      const expected = { data: 'I see bad times today', status: 'failed' };
      const actual = fetchPosRideDataReducer(startedFetchState, action);

      expect(actual).toEqual(expected);
    });
  });

  describe('cancelPosActivation reducer', () => {
    it('should set cancelPosActivation to started when cancel status started', () => {
      const action = { type: cancelPosActivation.started.type };
      const expected = { data: undefined, status: 'started' };
      const actual = cancelPosActivationReducer(initialState, action);

      expect(actual).toEqual(expected);
    });

    it('should cancel and set status to "done"', () => {
      const startedCancelState = { data: null, status: 'started' };
      const result = {};
      const action = { type: cancelPosActivation.done.type, payload: { params: null, result } };

      const expected = { data: {}, status: 'done' };
      const actual = cancelPosActivationReducer(startedCancelState, action);
      expect(actual).toEqual(expected);
    });

    it('should save the error when failed', () => {
      const startedCancelState = { data: undefined, status: 'started' };
      const action = { type: cancelPosActivation.failed.type, payload: { error: 'I see bad times today' } };
      const expected = { data: 'I see bad times today', status: 'failed' };
      const actual = cancelPosActivationReducer(startedCancelState, action);

      expect(actual).toEqual(expected);
    });
  });
});
