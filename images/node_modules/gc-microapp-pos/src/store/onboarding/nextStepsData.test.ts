/* tslint:disable:object-literal-sort-keys */
import { Observable } from 'rxjs/Observable';
import { AjaxError } from 'rxjs/observable/dom/AjaxObservable';
import { addNotification, removeNotificationById } from 'shared-react-smart-ui/NotificationCenter';
import { AlohaHaspData, AlohaHaspKeyResponse } from '../types';
import {
  activateUpserveLink,
  activateUpserveLinkEpic,
  activateUpserveLinkReducer,
  AlohaHaspKeyErrorId,
  getAlohaHaspKey,
  getAlohaHaspKeyEpic,
  getAlohaHaspKeyReducer,
  initialState,
  sendAlohaHaspKey,
  sendAlohaHaspKeyEpic,
  sendAlohaHaspKeyReducer,
  verifyUpserveLink,
  verifyUpserveLinkEpic,
  verifyUpserveLinkReducer,
  verifyUpserveLinkReset,
} from './nextStepsData';
import { updateDisplayState } from './onboarding';
import { createAsyncMockStore, upserveVerifySimilarAddressesMock } from './onboarding.mocks';

describe('actions', () => {
  describe('send Aloha Hasp Key actions', () => {
    it('should create a start action with the rid and haspKey', () => {
      const payload = { rid: 1970, haspKey: '123', reseller: 'Cardinal Business' };
      const actual = sendAlohaHaspKey.started(payload);
      const expected = { payload, type: sendAlohaHaspKey.started.type };

      expect(actual).toEqual(expected);
    });

    it('should create a done action', () => {
      const payload = {
        params: { rid: 1701, haspKey: '2001', reseller: 'Business Machines Systems' },
        result: null,
      };
      const actual = sendAlohaHaspKey.done(payload);
      const expected = { type: sendAlohaHaspKey.done.type, payload };

      expect(actual).toEqual(expected);
    });

    it('should create a failed action', () => {
      const payload = {
        error: { message: 'Danger, Will Robinson!' } as AjaxError,
        params: { rid: 1965, haspKey: '39', reseller: 'Bodnar Group Consulting' },
      };
      const actual = sendAlohaHaspKey.failed(payload);
      const expected = { error: true, type: sendAlohaHaspKey.failed.type, payload };

      expect(actual).toEqual(expected);
    });
  });

  describe('getAlohaHaspKey', () => {
    it('should generate the 3 async actions', () => {
      const rid = 9001;
      expect(getAlohaHaspKey.started(rid)).toEqual({ payload: rid, type: 'GET_ALOHA_HASP_KEY_STARTED' });

      const payload = { params: rid, result: { hasp_key: 1234 } };
      expect(getAlohaHaspKey.done(payload)).toEqual({
        payload,
        type: 'GET_ALOHA_HASP_KEY_DONE',
      });

      const error = { params: rid, error: 'Danger, Robin Williamson!' };
      expect(getAlohaHaspKey.failed(error)).toEqual({
        error: true,
        payload: error,
        type: 'GET_ALOHA_HASP_KEY_FAILED',
      });
    });
  });

  describe('Verify Upserve Link actions', () => {
    it('should generate the 3 async actions', () => {
      const rid = 1999;
      const link = 'http://www.www.com';
      const upserveData = { rid, link };
      expect(verifyUpserveLink.started(upserveData)).toEqual({
        payload: upserveData,
        type: 'VERIFY_UPSERVE_LINK_STARTED',
      });

      const addressResponse = upserveVerifySimilarAddressesMock;

      const payload = { params: upserveData, result: { response: addressResponse } };
      expect(verifyUpserveLink.done(payload)).toEqual({
        payload,
        type: 'VERIFY_UPSERVE_LINK_DONE',
      });

      const error = {
        error: { message: 'Nobody is dancing in the moonlight!', status: 409 } as AjaxError,
        params: upserveData,
      };
      expect(verifyUpserveLink.failed(error)).toEqual({
        error: true,
        payload: error,
        type: 'VERIFY_UPSERVE_LINK_FAILED',
      });
    });

    it('should create a reset action', () => {
      expect(verifyUpserveLinkReset()).toEqual({
        type: 'VERIFY_UPSERVE_LINK_RESET',
      });
    });
  });

  describe('Activate Upserve Link actions', () => {
    it('should generate the 3 async actions', () => {
      const rid = 1999;
      const link = 'http://www.www.com';
      const upserveData = { rid, link };
      expect(activateUpserveLink.started(upserveData)).toEqual({
        payload: upserveData,
        type: 'ACTIVATE_UPSERVE_LINK_STARTED',
      });

      const payload = { params: upserveData, result: undefined };
      expect(activateUpserveLink.done(payload)).toEqual({
        payload,
        type: 'ACTIVATE_UPSERVE_LINK_DONE',
      });

      const error = {
        error: { message: 'Everybody is dancing in the moonlight!', status: 409 } as AjaxError,
        params: upserveData,
      };
      expect(activateUpserveLink.failed(error)).toEqual({
        error: true,
        payload: error,
        type: 'ACTIVATE_UPSERVE_LINK_FAILED',
      });
    });
  });
});

describe('epics', () => {
  describe('send Aloha Hasp Key epic', () => {
    const haspData: AlohaHaspData = { rid: 1701, haspKey: '2000', reseller: 'Merchant Card Solutions' };

    it('should pass the AlohaHaspData to the postAlohaHasp api and call done and clear the aloha error', () => {
      const mockResponse: Observable<null> = Observable.of(null);
      const mockApi = { postAlohaHasp: jest.fn(() => mockResponse) };
      const store = createAsyncMockStore(mockApi, sendAlohaHaspKeyEpic);

      store.dispatch(sendAlohaHaspKey.started(haspData));
      expect(store.getActions()).toEqual([
        sendAlohaHaspKey.started(haspData),
        removeNotificationById(AlohaHaspKeyErrorId),
        sendAlohaHaspKey.done({ params: haspData, result: null }),
      ]);

      expect(mockApi.postAlohaHasp).toHaveBeenCalledWith(haspData);
    });

    describe('failed', () => {

      it('pass an error to sendAlohaHaspKey.failure and notify the user with a general message', () => {
        const mockError = { response: null } as AjaxError;
        const mockResponse: Observable<AjaxError> = Observable.throw(mockError);
        const store = createAsyncMockStore({ postAlohaHasp: () => mockResponse }, sendAlohaHaspKeyEpic);

        store.dispatch(sendAlohaHaspKey.started(haspData));
        expect(store.getActions()).toEqual([
          sendAlohaHaspKey.started(haspData),
          sendAlohaHaspKey.failed({ params: haspData, error: mockError }),
          addNotification({ id: AlohaHaspKeyErrorId, messageId: 'app.error.general' }),
        ]);
      });
    });
  });

  describe('get Aloha Hasp Key epic', () => {

    it('should make an api call to get the hasp key and pass it to the done action', () => {
      const rid = 12345;
      const mockResponse: AlohaHaspKeyResponse = { hasp_key: 8888 };
      const mockApi = { getAlohaHaspKey: jest.fn(() => Observable.of(mockResponse)) };
      const store = createAsyncMockStore(mockApi, getAlohaHaspKeyEpic);

      store.dispatch(getAlohaHaspKey.started(rid));
      expect(store.getActions()).toEqual([
        getAlohaHaspKey.started(rid),
        getAlohaHaspKey.done({ params: rid, result: mockResponse }),
      ]);

      expect(mockApi.getAlohaHaspKey).toHaveBeenCalledWith(rid);
    });

    it('should pass an error to getAlohaHaspKey.failed', () => {
      const rid = 44;
      const mockError = { error: 'some error' };
      const mockResponse: Observable<any> = Observable.throw(mockError);
      const store = createAsyncMockStore({ getAlohaHaspKey: () => mockResponse }, getAlohaHaspKeyEpic);

      store.dispatch(getAlohaHaspKey.started(rid));
      expect(store.getActions()).toEqual([
        getAlohaHaspKey.started(rid),
        getAlohaHaspKey.failed({ params: rid, error: mockError }),
      ]);
    });
  });

  describe('verify upserve link epic', () => {

    it('should make an api call and pass in a rid and url and then update displayState to active', () => {
      const upserveData = { rid: 303, link: 'http://cowboyplanet.com' };
      const mockResponse = upserveVerifySimilarAddressesMock;
      const mockApi = { verifyUpserveLink: jest.fn(() => Observable.of({ response: mockResponse })) };
      const store = createAsyncMockStore(mockApi, verifyUpserveLinkEpic);

      store.dispatch(verifyUpserveLink.started(upserveData));
      expect(store.getActions()).toEqual([
        verifyUpserveLink.started(upserveData),
        verifyUpserveLink.done({ params: upserveData, result: mockResponse }),
      ]);

      expect(mockApi.verifyUpserveLink).toHaveBeenCalledWith(upserveData);
    });

    it('pass an error to verifyUpserveLink.failure action', () => {
      const upserveData = { rid: 66, link: 'http://route66.com' };
      const mockError = { status: 409 } as AjaxError;
      const mockResponse: Observable<AjaxError> = Observable.throw(mockError);
      const store = createAsyncMockStore({ verifyUpserveLink: () => mockResponse }, verifyUpserveLinkEpic);

      store.dispatch(verifyUpserveLink.started(upserveData));
      expect(store.getActions()).toEqual([
        verifyUpserveLink.started(upserveData),
        verifyUpserveLink.failed({ params: upserveData, error: mockError }),
      ]);
    });
  });

  describe('activate upserve link epic', () => {

    it('should make an api call and pass in a rid and url and then update displayState to active', () => {
      const upserveData = { rid: 303, link: 'http://cowboyplanet.com' };
      const mockResponse = 'literally anything';
      const mockApi = { activateUpserveLink: jest.fn(() => Observable.of(mockResponse)) };
      const store = createAsyncMockStore(mockApi, activateUpserveLinkEpic);

      store.dispatch(activateUpserveLink.started(upserveData));
      expect(store.getActions()).toEqual([
        activateUpserveLink.started(upserveData),
        activateUpserveLink.done({ params: upserveData, result: undefined }),
        updateDisplayState('active'),
      ]);

      expect(mockApi.activateUpserveLink).toHaveBeenCalledWith(upserveData);
    });

    it('pass an error to activateUpserveLink.failure action', () => {
      const upserveData = { rid: 66, link: 'http://route66.com' };
      const mockError = { status: 409 } as AjaxError;
      const mockResponse: Observable<AjaxError> = Observable.throw(mockError);
      const store = createAsyncMockStore({ activateUpserveLink: () => mockResponse }, activateUpserveLinkEpic);

      store.dispatch(activateUpserveLink.started(upserveData));
      expect(store.getActions()).toEqual([
        activateUpserveLink.started(upserveData),
        activateUpserveLink.failed({ params: upserveData, error: mockError }),
      ]);
    });
  });
});

describe('reducers', () => {

  describe('send aloha hasp key reducer', () => {

    it('should update state to started', () => {
      const action = {
        payload: { rid: 1701, haspKey: '2000' },
        type: sendAlohaHaspKey.started.type,
      };
      const expected = {
        data: undefined,
        status: 'started',
      };

      const result = sendAlohaHaspKeyReducer(initialState, action);
      expect(result).toEqual(expected);
    });

    it('should update the state to done for done action', () => {
      const action = {
        payload: { params: { rid: 1701, haspKey: '2000' }, result: null },
        type: sendAlohaHaspKey.done.type,
      };
      const expected = {
        data: undefined,
        status: 'done',
      };

      const result = sendAlohaHaspKeyReducer(initialState, action);
      expect(result).toEqual(expected);
    });

    it('should update the state to failed for failed action', () => {
      const action = {
        payload: { error: 'bad thing' },
        type: sendAlohaHaspKey.failed.type,
      };
      const expected = {
        data: 'bad thing',
        status: 'failed',
      };

      const result = sendAlohaHaspKeyReducer(initialState, action);
      expect(result).toEqual(expected);
    });
  });

  describe('get Aloha Hasp Key', () => {
    it('should update state to started', () => {
      const action = {
        payload: 666,
        type: getAlohaHaspKey.started.type,
      };
      const expected = {
        data: undefined,
        status: 'started',
      };

      const result = getAlohaHaspKeyReducer(initialState, action);
      expect(result).toEqual(expected);
    });

    it('should update the state to done for done action', () => {
      const haspData: AlohaHaspData = { rid: 1701, haspKey: '2000' };
      const action = {
        payload: { params: 777, result: haspData },
        type: getAlohaHaspKey.done.type,
      };
      const expected = {
        data: haspData,
        status: 'done',
      };

      const result = getAlohaHaspKeyReducer(initialState, action);
      expect(result).toEqual(expected);
    });

    it('should update the state to failed for failed action', () => {
      const action = {
        payload: { error: 'bad thing' },
        type: getAlohaHaspKey.failed.type,
      };
      const expected = {
        data: 'bad thing',
        status: 'failed',
      };

      const result = getAlohaHaspKeyReducer(initialState, action);
      expect(result).toEqual(expected);
    });
  });

  describe('verify upserve link reducer', () => {

    it('should update status to started', () => {
      const action = {
        payload: { rid: 4, link: 'http://anewhope.com' },
        type: verifyUpserveLink.started.type,
      };
      const expected = {
        data: undefined,
        status: 'started',
      };

      const result = verifyUpserveLinkReducer(initialState, action);
      expect(result).toEqual(expected);
    });

    it('should set the status to done', () =>
      expect(
        verifyUpserveLinkReducer(
          initialState,
          verifyUpserveLink.done({
            params: { rid: 5, link: 'http://empirestrikesback.com' },
            result: upserveVerifySimilarAddressesMock,
          }),
        ),
      ).toEqual({ data: upserveVerifySimilarAddressesMock, status: 'done' }));

    it('should set the status to failed and save error to state', () => {
      const error = { status: 409 } as AjaxError;
      expect(
        verifyUpserveLinkReducer(
          initialState,
          verifyUpserveLink.failed({
            error,
            params: { rid: 5, link: 'http://empirestrikesback.com' },
          }),
        ),
      ).toEqual({ data: error, status: 'failed' });
    });

    it('should update status to init', () => {
      const action = {
        type: verifyUpserveLinkReset.type,
      };
      const expected = initialState;

      const result = verifyUpserveLinkReducer({ data: { status: 409 }, status: 'failed' }, action);
      expect(result).toEqual(expected);
    });
  });

  describe('activate upserve link reducer', () => {

    it('should update status to started', () => {
      const action = {
        payload: { rid: 4, link: 'http://anewhope.com' },
        type: activateUpserveLink.started.type,
      };
      const expected = {
        data: undefined,
        status: 'started',
      };

      const result = activateUpserveLinkReducer(initialState, action);
      expect(result).toEqual(expected);
    });

    it('should set the status to done', () =>
      expect(
        activateUpserveLinkReducer(
          initialState,
          activateUpserveLink.done({ params: { rid: 5, link: 'http://empirestrikesback.com' }, result: undefined }),
        ),
      ).toEqual({ data: undefined, status: 'done' }));

    it('should set the status to failed and save error to state', () => {
      const error = { status: 409 } as AjaxError;
      expect(
        activateUpserveLinkReducer(
          initialState,
          activateUpserveLink.failed({
            error,
            params: { rid: 5, link: 'http://empirestrikesback.com' },
          }),
        ),
      ).toEqual({ data: error, status: 'failed' });
    });
  });
});
