import { selectors, User } from 'gca-react-components/src/redux-modules/currentContext';
import { get } from 'lodash';
import moment from 'moment';
import { combineEpics } from 'redux-observable';
import { Observable } from 'rxjs/Observable';
import { actionCreatorFactory } from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';
import { dateFormat, revertApprovalInfo } from '../../PromotedInventory/constants';
import { ApprovalInfo } from '../campaigns/campaigns.types';
import '../commonRxjs';
import { ClickOrInteractPayload } from '../gifts/gifts.types';
import { Epic, State } from '../types';
import {
  createEmptyFormSettings,
  createEmptyIncreaseSettings,
  createEmptySchedule,
  createEmptyVisibilitySettings,
  createFullSchedule,
} from './createEmptyFormSettings';
import {
  ActiveContractPrices,
  Days,
  FetchPricingInfoPayload,
  FlexiblePricingPageType,
  FlexiblePricingState,
  FormVisibilitySettings,
  isVisibilitySettingsResponse,
  PostFlexiblePricingDataPayload,
  PricingInfo,
  PricingInfoResponse,
  SetDayAndTimeForVisibilityTypePayload,
  SetFormVisibilityLevelEnabledPayload,
  Times,
  VisibilitySettings,
  VisibilitySettingsMetadata,
  VisibilitySettingsResponse,
  VisibilityType,
  VisibilityTypeSettings,
} from './flexiblepricing.types';
import { getCurrentVersion, getExpectedDiscoveryPrices } from './selectors';

// --------------------------------- //
// Actions
// --------------------------------- //

const actionCreator = actionCreatorFactory('FLEX_PRICING');

export const fetchPricingInfo = actionCreator.async<FetchPricingInfoPayload, PricingInfoResponse>('FETCH_INFO');
export const fetchActiveContractPrices = actionCreator.async<any, ActiveContractPrices>('FETCH_ACTIVE_CONTRACT_PRICES');

/* TODO: We may not need the firstFetch distinction for this action */
export const fetchVisibilitySettings = actionCreator.async<FetchPricingInfoPayload, VisibilitySettingsResponse>(
  'FETCH_SETTINGS',
);
export const postVisibilitySettings = actionCreator.async<PostFlexiblePricingDataPayload, any>('POST_SETTINGS');
export const revertToOriginalPricing = actionCreator.async('REVERT_TO_ORIGINAL_PRICING');

export const setPageType = actionCreator<FlexiblePricingPageType>('SET_PAGE_TYPE');
export const initializeForm = actionCreator<VisibilitySettings | FormVisibilitySettings>('INITIALIZE_FORM');
export const clearForm = actionCreator('CLEAR_FORM');
export const initializeApp = actionCreator('INITIALIZE_APP');
export const setFormVisibilityLevelEnabled = actionCreator<SetFormVisibilityLevelEnabledPayload>(
  'SET_FORM_VISIBILITY_LEVEL_ENABLED',
);
export const setDayAndTimeForVisibilityType = actionCreator<SetDayAndTimeForVisibilityTypePayload>('SET_DAY_AND_TIME');
export const setMonthlyBudgetEnabled = actionCreator<boolean>('SET_MONTHLY_BUDGET_ENABLED');
export const setMonthlyBudgetAmount = actionCreator<number>('SET_MONTHLY_BUDGET_AMOUNT');

// const patchGiftsUrl = actionCreator.async<PatchGiftsUrlPayload, boolean, boolean>('PATCH');
// const openTermsModal = actionCreator<OpenTermsModalPayload>('OPEN_TERMS_MODAL');
// const closeTermsModal = actionCreator('CLOSE_TERMS_MODAL');
// const showPage = actionCreator<ShowPagePayload>('SHOW_PAGE');

export const clickOrInteract = actionCreator<ClickOrInteractPayload>('CLICK_CALL_TO_ACTION');

export const actions = {
  clickOrInteract,
  // closeTermsModal,
  // fetchGiftsUrl,
  // openTermsModal,
  // patchGiftsUrl,
  // showPage,
};

// --------------------------------- //
// Reducer
// --------------------------------- //

export const initialState: FlexiblePricingState = {
  activeContract: {
    loading: true,
  },
  appInitialized: false,
  pageType: FlexiblePricingPageType.VisibilitySettings,
  pricingInfo: {
    loading: true,
  },
  sendingSettings: false,
  visibilitySettings: {
    loading: true,
  },
};

const getPriceForVisibilityType = ({ discovery }: PricingInfo, visibilityType: VisibilityType) => {
  switch (visibilityType) {
    case VisibilityType.Standard:
      return discovery.flexPrice;
    case VisibilityType.Increase:
      return discovery.increasePrice;
    case VisibilityType.Reduce:
      return discovery.decreasePrice;
  }
};

/* I wanted to do something fancy to DRY up these reducers (and got it to compile until I tried
  using the `done` actions that have different result types) where I have one reducer function
  per [started, done, failed], passed into
    `.casesWithAction(asyncFetchActions.map(({ started }) => started), (state, action) => ... )`
  that would use a mapping from action type to state location to handle, for each type of data, one
  stage of the [started, done, failed] set of stages.

  In the end it didn't result in less code though and was probably harder to read, so here we are.
  */
export const reducer = reducerWithInitialState(initialState)
  .case(fetchPricingInfo.started, state => ({
    ...state,
    appInitialized: false,
    pricingInfo: {
      loading: true,
    },
  }))
  .case(fetchPricingInfo.done, (state, { result }) => ({
    ...state,
    pricingInfo: {
      data: result,
      error: false,
      loading: false,
    },
  }))
  .case(fetchPricingInfo.failed, state => ({
    ...state,
    appInitialized: true,
    pricingInfo: {
      error: true,
      loading: false,
    },
  }))
  .case(fetchActiveContractPrices.started, state => ({
    ...state,
    activeContract: {
      loading: true,
    },
  }))
  .case(fetchActiveContractPrices.done, (state, { result }) => ({
    ...state,
    activeContract: {
      data: result,
      error: false,
      loading: false,
    },
  }))
  .case(fetchActiveContractPrices.failed, state => ({
    ...state,
    activeContract: {
      error: true,
      loading: false,
    },
  }))
  .case(fetchVisibilitySettings.started, state => ({
    ...state,
    visibilitySettings: {
      loading: true,
    },
  }))
  .case(fetchVisibilitySettings.done, (state, { result }) => ({
    ...state,
    visibilitySettings: {
      data: result,
      error: false,
      loading: false,
    },
  }))
  .case(fetchVisibilitySettings.failed, state => ({
    ...state,
    appInitialized: true,
    visibilitySettings: {
      error: true,
      loading: false,
    },
  }))
  .case(postVisibilitySettings.started, state => ({
    ...state,
    sendingSettings: true,
  }))
  .case(postVisibilitySettings.done, (state, { params }) => ({
    ...state,
    pageType: params.isEdit === true ? FlexiblePricingPageType.SuccessEdit : FlexiblePricingPageType.SuccessSignup,
    sendingSettings: false,
  }))
  .case(revertToOriginalPricing.started, state => ({
    ...state,
    sendingSettings: true,
  }))
  .case(revertToOriginalPricing.done, state => ({
    ...state,
    pageType: FlexiblePricingPageType.SuccessRevert,
    sendingSettings: false,
  }))
  .case(revertToOriginalPricing.failed, state => ({
    ...state,
    visibilitySettings: {
      error: true,
      loading: false,
    },
  }))
  .case(clearForm, state => ({
    ...state,
    formVisibilitySettings: undefined,
  }))
  .case(initializeForm, (state, settings) => {
    /* Create empty schedules if they decide to edit vis. settings that don't have any
      info for increase or reduce. If this is the first run, we have already passed in empty vis. settings */
    const increasePrice = getPriceForVisibilityType(state.pricingInfo.data!, VisibilityType.Increase);

    let increase;

    if (settings.increase) {
      const monthlyBudget = settings.increase.monthlyBudget || {
        amount: 0,
        /* We are always going to have increase prices available from BE */
        currencyCode: increasePrice!.currencyCode,
      };
      increase = {
        ...settings.increase,
        monthlyBudget,
      };
    } else {
      increase = createEmptyIncreaseSettings(increasePrice!);
    }

    const reducePrice = getPriceForVisibilityType(state.pricingInfo.data!, VisibilityType.Reduce);

    const reduce = settings.reduce || (reducePrice && createEmptyVisibilitySettings(reducePrice));

    return {
      ...state,
      formVisibilitySettings: {
        ...settings,
        /* Here we need to make sure that all visibility levels of interest (increase and decrease in our case,
          not standard since it is always synthesized later and never directly) have an object with all the editable
          information included, even if in an empty state.

          This means that increase needs to have a monthly budget even if it is disabled
          */
        // `enable` is present in settings only when output from `createEmptyFormSettings` is passed
        enable: (settings as any).enable || {
          increase: settings.increase ? true : false,
          monthlyBudget: get(settings, 'increase.monthlyBudget', false) && true,
          reduce: settings.reduce ? true : false,
        },
        increase,
        reduce,
      },
    };
  })
  .case(initializeApp, (state, settings) => ({
    ...state,
    appInitialized: true,
  }))
  .case(setFormVisibilityLevelEnabled, (state, { visibilityType, value }) => ({
    ...state,
    formVisibilitySettings: {
      ...state.formVisibilitySettings!,
      enable: {
        ...state.formVisibilitySettings!.enable,
        [visibilityType]: value,
      },
    },
  }))
  .case(setPageType, (state, pageType) => ({
    ...state,
    pageType,
  }))
  .case(setDayAndTimeForVisibilityType, (state, { visibilityType, day, time, value }) => {
    const currentVisibilityType: VisibilityTypeSettings = state.formVisibilitySettings![visibilityType]!;
    return {
      ...state,
      formVisibilitySettings: {
        ...state.formVisibilitySettings!,
        [visibilityType]: {
          ...currentVisibilityType,
          schedule: {
            ...currentVisibilityType.schedule,
            [day]: {
              ...currentVisibilityType.schedule[day],
              [time]: value,
            },
          },
        },
      },
    };
  })
  .case(setMonthlyBudgetEnabled, (state, enabled) => ({
    ...state,
    formVisibilitySettings: {
      ...state.formVisibilitySettings!,
      enable: {
        ...state.formVisibilitySettings!.enable,
        monthlyBudget: enabled,
      },
    },
  }))
  .case(setMonthlyBudgetAmount, (state, amount) => {
    /* The initialization of the form above ensures that a monthly budget object will always be present,
      inside an `increase` object that will also always be present, as long as the form has been initialized.

      The use or disuse of a monthly budget by the user will be controlled by `settings.enable.monthlyBudget`,
      which above is initialized to false if the monthly budget is not present in the form settings, but true if
      it is. */
    const increasedMonthlyBudget = state.formVisibilitySettings![VisibilityType.Increase]!.monthlyBudget!;
    return {
      ...state,
      formVisibilitySettings: {
        ...state.formVisibilitySettings!,
        [VisibilityType.Increase]: {
          ...state.formVisibilitySettings![VisibilityType.Increase]!,
          monthlyBudget: {
            amount,
            currencyCode: increasedMonthlyBudget.currencyCode,
          },
        },
      },
    };
  });

// --------------------------------- //
// Epics
// --------------------------------- //

export const fetchPricingInfoEpic: Epic = (action$, store, { api }) =>
  action$.ofType(fetchPricingInfo.started.type).switchMap(({ payload }) => {
    const state: State = store.getState();
    const rid: number = selectors.rid(state);

    return api
      .fetchPricingInfo(rid)
      .flatMap((response: PricingInfoResponse) => [
        fetchPricingInfo.done({ params: payload, result: response }),
        fetchVisibilitySettings.started(payload),
      ])
      .catch(() => [fetchPricingInfo.failed({ params: payload, error: true })]);
  });

export const fetchActiveContractPricesEpic: Epic = (action$, store, { api }) =>
  action$.ofType(fetchActiveContractPrices.started.type).switchMap(() => {
    const state: State = store.getState();
    const rid: number = selectors.rid(state);

    return api
      .fetchActiveContractPrices(rid)
      .map((response: ActiveContractPrices | {}) => fetchActiveContractPrices.done({ params: {}, result: response }))
      .catch(() => [fetchPricingInfo.failed({ params: {}, error: true })]);
  });

export const fetchVisibilitySettingsEpic: Epic = (action$, store, { api }) =>
  action$.ofType(fetchVisibilitySettings.started.type).switchMap(({ payload }) => {
    const state: State = store.getState();
    const rid: number = selectors.rid(state);
    return (
      api
        .fetchVisibilitySettings(rid)
        .map((response: VisibilitySettingsResponse) => {
          let result: any = response;
          if (Object.keys(response).length === 0) {
            result = undefined; // when there are no visibility settings we get back {} from the microsite
          }
          return fetchVisibilitySettings.done({ params: payload, result });
        })
        /* TODO: Do we want to include an error message in the error payload for these? */
        .catch(() => [fetchVisibilitySettings.failed({ params: payload, error: true })])
    );
  });

const createFilledInStandardSchedule = (reducedSchedule: VisibilityTypeSettings | undefined) => {
  const schedule = createFullSchedule();
  if (!reducedSchedule) {
    return schedule;
  }
  Object.values(Days).forEach((day: Days) => {
    Object.values(Times).forEach((time: Times) => {
      const hasReduced = get(reducedSchedule, `schedule.${day}.${time}`, false);
      if (hasReduced) {
        schedule[day][time] = false;
      }
    });
  });
  return schedule;
};

const getPostSettingsPayloadWithMetadata = ({ data, approvalInfo }: PostFlexiblePricingDataPayload, state: State) => {
  const user: User = selectors.user(state);
  const rid: number = selectors.rid(state);
  const name = `${user.firstName} ${user.lastName}`;
  const email = user.userName;
  const { increase, reduce, standard } = data;
  const discoveryPrices = getExpectedDiscoveryPrices(state);

  let metadata: VisibilitySettingsMetadata;
  /* These may exist on a campaign being edited. If so, pass them through */
  if (isVisibilitySettingsResponse(data)) {
    const { currentVersion, restaurantContactEmail, restaurantContactName, startDate } = data;
    metadata = {
      changedByUser: email,
      currentVersion,
      restaurantContactEmail,
      restaurantContactName,
      rid,
      startDate,
    };
  } else {
    /* Otherwise create new values since this is a `create` */
    metadata = {
      changedByUser: email,
      currentVersion: getCurrentVersion(state),
      restaurantContactEmail: email,
      restaurantContactName: name,
      rid,
      startDate: moment().format(dateFormat.MOMENT), // Today?
    };
  }

  const payloadWithMetadata: { data: VisibilitySettingsResponse; approvalInfo: ApprovalInfo } = {
    approvalInfo,
    data: {
      ...metadata,
      increase,
      reduce,
      standard: {
        price: discoveryPrices[VisibilityType.Standard],
        schedule: createFilledInStandardSchedule(reduce),
      },
    },
  };
  return payloadWithMetadata;
};

export const postVisibilitySettingsEpic: Epic = (action$, store, { api }) =>
  action$.ofType(postVisibilitySettings.started.type).switchMap(({ payload }) => {
    const state: State = store.getState();
    const rid: number = selectors.rid(state);

    return api
      .postVisibilitySettings(rid, getPostSettingsPayloadWithMetadata(payload, state))
      .map(() => postVisibilitySettings.done({ params: payload, result: true }))
      .catch(() => [postVisibilitySettings.failed({ params: payload, error: true })]);
  });

export const initializeAppEpic: Epic = (action$, store) =>
  action$.ofType(fetchVisibilitySettings.done.type).flatMap(({ payload }) => {
    const { result, params } = payload;
    const { firstFetch } = params;
    const discoveryPrices = getExpectedDiscoveryPrices(store.getState());
    /* TODO: Do we care about `firstFetch` */
    /* If this was the first fetch, and the result was empty, we initialize the form
    with a standard empty schedule */
    const initActions = !result
      ? [
          initializeForm(createEmptyFormSettings(discoveryPrices)),
          setPageType(FlexiblePricingPageType.VisibilitySettings),
        ]
      : [clearForm(), setPageType(FlexiblePricingPageType.Summary)];

    return Observable.from([...initActions, initializeApp()]);
  });

export const revertToOriginalPricingEpic: Epic = (action$, store, { api }) =>
  action$.ofType(revertToOriginalPricing.started.type).switchMap(() => {
    const state: State = store.getState();
    const rid: number = selectors.rid(state);
    const { userName, firstName, lastName } = selectors.user(state);

    const platform = require('platform');
    const { name, version, layout, os, description }: any = platform;
    const browserInfo = JSON.stringify({ name, version, layout, os, description });

    const payloadWithChangedByUser = {
      campaignApprovalInfo: {
        browserInfo,
        email: userName,
        name: `${firstName} ${lastName}`,
        ...revertApprovalInfo,
      },
      changedByUser: userName,
      currentVersion: getCurrentVersion(state)!,
    };
    return api
      .revertToOriginalPricing(rid, payloadWithChangedByUser)
      .map(() => revertToOriginalPricing.done({ params: {}, result: true }))
      .catch(() => [revertToOriginalPricing.failed({ params: {}, error: true })]);
  });

export const flexiblePricingEpic = combineEpics(
  fetchActiveContractPricesEpic,
  fetchPricingInfoEpic,
  fetchVisibilitySettingsEpic,
  postVisibilitySettingsEpic,
  revertToOriginalPricingEpic,
  initializeAppEpic,
);
