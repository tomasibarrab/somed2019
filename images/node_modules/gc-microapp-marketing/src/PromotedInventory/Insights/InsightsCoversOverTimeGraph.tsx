import { Graph } from 'damper';
import { selectors } from 'gca-react-components/src/redux-modules/currentContext';
import moment from 'moment';
import {
    ashLighter, ashLightest, fuchsiaLight, fuchsiaLightest, tealLight, violetLight, white,
} from 'otkit-colors/token.common';
import React, { SFC } from 'react';
import { InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';

import {
    CoverTrends, FetchCoverTrendsOptions, Filters, Granularity,
} from '../../store/insights/insights.types';
import { getCoversOverTime, getCoverTrendsParams } from '../../store/insights/selectors';
import {
    formatLocaleDateTime, getGranularityLabels, getYAxisHelper,
} from '../../store/insights/utils';
import { State } from '../../store/types';
import Tooltip from './common/Tooltip/Tooltip';
import { CAMPAIGN_OFFERS } from './helpers/constants';
import { getGranularityDate, getHoverAreaLocation } from './helpers/graph-util';
import { mapIntlText, remapLabels } from './helpers/mapping';
import {
    calculateTotal, campaignKeys, defaultHoverAreaState, getCompareIcon, getCompareStatus,
    getPercentageDiff, hasEmptyData, mapColumns, showPercentage,
} from './helpers/visualisation-helper';
import styles from './InsightsCoversOverTimeGraph.module.css';

const keys = ['covers_actual', 'covers_previous'];

interface SP {
  coversOverTimeData: CoverTrends['covers_over_time'];
  params: FetchCoverTrendsOptions;
  filters: Filters;
  restaurantLocale: string;
  dateTimeAtRestaurant: string;
}

type NonIntlProps = SP;

type Props = NonIntlProps & InjectedIntlProps;

interface ComponentState {
  tooltip: any;
}

// fake data for now
const mockData = [
  1,
  6,
  7,
  8,
  3,
  4,
  2,
  5,
  8,
  0,
  1,
  4,
  5,
  2,
  3,
  4,
  8,
  7,
  3,
  5,
  9,
  9,
  8,
  4,
  2,
  6,
  4,
  2,
  6,
  7,
  3,
  2,
  2,
  1,
  7,
  4,
  5,
  5,
  1,
  8,
  9,
  5,
  3,
  2,
  1,
  4,
  4,
  5,
  5,
  1,
  8,
  9,
  5,
  3,
  2,
  5,
  5,
  1,
  8,
  9,
  5,
  3,
  2,
];

// tslint:disable:object-literal-sort-keys
class InsightsCoversOverTimeGraph extends React.Component<Props, ComponentState> {
  constructor(props) {
    super(props);

    this.state = {
      ...defaultHoverAreaState,
    };

    this.hideToolTip = this.hideToolTip.bind(this);
    this.getTooltipContent = this.getTooltipContent.bind(this);
    this.getPromoProps = this.getPromoProps.bind(this);
  }

  public render() {
    const { intl, coversOverTimeData, params, dateTimeAtRestaurant } = this.props;
    const columns = mapColumns({
      data: coversOverTimeData,
      intl,
      key: 'date_actual',
      labelMethod: val => formatLocaleDateTime(val, intl.locale, 'shortDate'),
    });

    const areaIds = {
      areaCurrentParent: 'current-0',
      areaCurrentChild: 'current-0-1',
      areaPreviousParent: 'previous-0',
      areaPreviousChild: 'previous-0-1',
    };

    const areas = [
      {
        id: areaIds.areaCurrentParent,
        group: false,
        data: [
          {
            id: areaIds.areaCurrentChild,
            styles: currentStyles,
            data: coversOverTimeData.map(v => ({
              id: v.date_actual,
              value: v.covers_actual,
            })),
          },
        ],
      },
      {
        id: areaIds.areaPreviousParent,
        group: false,
        data: [
          {
            id: areaIds.areaPreviousChild,
            styles: previousStyles,
            data: coversOverTimeData.map(v => ({
              id: v.date_actual,
              value: v.covers_previous,
            })),
          },
        ],
      },
    ];

    let currentLayout = layout;

    // TODO: Why?
    const onGraphInfo = val => {
      const newLayout = {
        ...layout,
        width: val ? val.activeInnerArea.width : layout.width,
      };
      currentLayout = newLayout;
    };

    const onAreaMouseOver = hoveredArea => {
      const tooltip = getHoverAreaLocation({
        ...hoveredArea,
        tooltip: this.state.tooltip,
        layout: currentLayout,
      });

      const tooltipProps = this.getTooltipContent(hoveredArea.id);
      this.setState(prevState => ({
        ...prevState,
        tooltip: {
          ...prevState.tooltip,
          ...tooltip,
          tooltipProps,
        },
        hoveredAreaId: hoveredArea.id,
      }));
    };

    const onAreaMouseOut = () => {
      this.hideToolTip();
    };

    const granularity: Granularity = (params.granularity as Granularity) || Granularity.Day;

    const matchDate = columns.find(col => {
      const dateToday = moment(dateTimeAtRestaurant);
      switch (granularity) {
        case Granularity.Year:
          return dateToday.isSame(col.id, 'year');
        case Granularity.Month:
          return dateToday.isSame(col.id, 'month');
        case Granularity.Week:
          return dateToday.isSame(col.id, 'week');
        case Granularity.Day:
        default:
          return dateToday.isSame(col.id, 'day');
      }
    });

    const hasCampaign = (areaData, id, includePrevious = false) => {
      const total = calculateTotal(areaData, campaignKeys);
      if (id === areaIds.areaCurrentChild) {
        return total.total_actual > 0;
      }
      if (includePrevious && id === areaIds.areaPreviousChild) {
        return total.total_previous > 0;
      }
      return false;
    };

    const helpers = {
      ...getYAxisHelper(intl),
      area: {
        highlight: {
          show: !hasEmptyData(coversOverTimeData, keys),
          width: 1,
          start: matchDate ? matchDate.id : undefined,
          end: matchDate ? matchDate.id : undefined,
        },
        vertical: {
          show: true,
          callback: (areaId, id) => {
            const areaData = coversOverTimeData.find(v => v.date_actual === id);
            if (hasCampaign(areaData, areaId)) {
              return {
                dot: {
                  fill: white,
                  stroke: fuchsiaLight,
                },
              };
            }
            return true;
          },
        },
        points: {
          show: true,
          callback: (areaId, id) => {
            const areaData = coversOverTimeData.find(v => v.date_actual === id);
            return hasCampaign(areaData, areaId);
          },
        },
      },
    };

    return (
      <div className={styles.coversOverTimeContainer}>
        {hasEmptyData(coversOverTimeData) && this.renderNoDataMessage()}
        <Graph
          columns={getGranularityLabels(granularity, columns)}
          areas={areas}
          {...layout}
          customTheme={theme}
          helpers={helpers}
          onAreaMouseOver={onAreaMouseOver}
          onAreaMouseOut={onAreaMouseOut}
          onGraphInfo={val => onGraphInfo(val)}
        />
        {this.state.tooltip.isVisible && <Tooltip {...this.state.tooltip} />}
      </div>
    );
  }

  public componentWillUnmount() {
    this.hideToolTip();
  }

  public componentDidUpdate(prevProps) {
    if (this.props.coversOverTimeData !== prevProps.coversOverTimeData) {
      this.hideToolTip();
    }
  }

  private renderNoDataMessage() {
    return (
      <div className={styles.noDataMessage}>
        {this.props.intl.formatMessage({
          id: 'insights.dashboard.graph.no_data_for_range',
        })}
      </div>
    );
  }

  private hideToolTip() {
    this.setState(prevState => ({
      ...prevState,
      hoveredBarId: undefined,
      tooltip: {
        ...prevState.tooltip,
        isVisible: false,
      },
    }));
  }

  private getTooltipContent(id) {
    const { intl, filters, coversOverTimeData } = this.props;
    const datePeriods = filters.dateRange;
    const locale = intl.locale;

    if (!coversOverTimeData) {
      return undefined;
    }

    const areaData = coversOverTimeData.find(v => v.date_actual === id);

    if (!areaData) {
      return undefined;
    }

    const title = getGranularityDate(areaData.date_actual, datePeriods, locale);

    const description = (
      <React.Fragment>
        <span>&nbsp;vs.&nbsp;</span>
        {getGranularityDate(areaData.date_previous, datePeriods, locale)}
      </React.Fragment>
    );

    // Calculations
    const diff = areaData.covers_actual - areaData.covers_previous;
    const percentageDiff = getPercentageDiff(areaData.covers_actual, areaData.covers_previous);
    const compare = getCompareStatus(diff);
    const icon = getCompareIcon(diff, compare);

    const content = [
      {
        label: intl.formatMessage({ id: 'insights.summary.covers' }),
        value: {
          label: intl.formatNumber(areaData.covers_actual) || 0,
        },
        comparison: {
          icon,
          status: compare.status,
          label: intl.formatNumber(Math.abs(diff)),
          compare: `${showPercentage(percentageDiff)}%`,
        },
        secondary: this.getPromoProps(areaData),
      },
    ];

    return {
      title,
      description,
      content,
    };
  }

  private getPromoProps(data) {
    const intlFormat = id => this.props.intl.formatMessage({ id });
    const intlNumber = value => this.props.intl.formatNumber(value);
    const promoData = [];
    const icon = {
      type: 'circle',
      color: fuchsiaLight,
      radius: 8,
    };
    if (data.bonus_points_actual > 0) {
      promoData.push({
        icon,
        label: intlFormat('insights.common.bonus_points'),
        value: intlNumber(data.bonus_points_actual),
      });
    }
    if (data.promoted_results_actual > 0) {
      promoData.push({
        icon,
        label: intlFormat('insights.common.promoted_results'),
        value: intlNumber(data.promoted_results_actual),
      });
    }
    if (data.promoted_results_with_targeting_actual > 0) {
      promoData.push({
        icon,
        label: intlFormat('insights.common.promoted_results_with_targeting'),
        value: intlNumber(data.promoted_results_with_targeting_actual),
      });
    }
    if (data.custom_promotions_actual > 0) {
      promoData.push({
        icon,
        label: intlFormat('insights.common.custom_promotions'),
        value: intlNumber(data.custom_promotions_actual),
      });
    }
    if (data.offer_actual > 0) {
      const intlOffers = remapLabels(CAMPAIGN_OFFERS, this.props.restaurantLocale);
      // intlOffers: [CONSTANT.CAMPAIGN_SPECIALS, CAMPAIGN_OFFERS]
      promoData.push({
        icon,
        label: intlFormat(mapIntlText(intlOffers)),
        // label: intlFormat(out: ['general.campaign.specials', 'reservations.type.group.ot_platforms_covers'])
        value: intlNumber(data.offer_actual),
      });
    }

    return promoData.length > 0
      ? {
          style: {
            backgroundColor: fuchsiaLightest,
          },
          content: promoData,
        }
      : null;
  }
}

export const theme = {
  area: {
    curve: 'curveLinear',
  },
  helpers: {
    area: {
      highlight: {
        fill: tealLight,
        opacity: 1,
      },
      vertical: {
        line: {
          fill: ashLighter,
          width: 1,
          opacity: 1,
        },
        dot: {
          radius: 4,
          strokeWidth: 2,
          stroke: violetLight,
          fill: 'rgba(255, 255, 255, 1)',
          opacity: 1,
        },
      },
      points: {
        radius: 4,
        strokeWidth: 2,
        stroke: white,
        fill: fuchsiaLight,
        opacity: 1,
      },
    },
  },
  axis: {
    y: {
      stroke: {
        fill: 'transparent',
      },
      tick: {
        fill: ashLightest,
      },
    },
    x: {
      stroke: {
        fill: 'transparent',
      },
      easing: {
        opacity: 'gentle',
        x: {
          damping: 40,
          stiffness: 300,
        },
      },
    },
  },
  common: {
    strokeDasharray: '5px, 5px',
    fillOpacity: 0,
    strokeOpacity: 1,
    fill: 'transparent',
    stroke: violetLight,
    strokeWidth: '2px',
    mouseOver: {
      fill: 'transparent',
      fillOpacity: 0,
      stroke: violetLight,
      strokeOpacity: 1,
    },
  },
};

export const currentStyles = {
  common: {
    strokeDasharray: '',
    strokeWidth: 3,
  },
};

export const previousStyles = {};

const height = 200;
const padding = {
  top: 20,
  right: 20,
  bottom: 50,
  left: 70,
};

export const layout = {
  animation: 'none',
  columnOffsets: {
    left: 0,
    right: 0,
  },
  width: 1440,
  height: height + padding.top + padding.bottom,
  responsive: 'redraw',
  padding,
};

const mapStateToProps = (state: State): SP => ({
  coversOverTimeData: getCoversOverTime(state),
  filters: state.insights.filters,
  params: getCoverTrendsParams(state),
  restaurantLocale: selectors.restaurant(state).locale,
  dateTimeAtRestaurant: selectors.restaurant(state).dateTimeAtRestaurant,
});

const mapDispatchToProps = {};

//                         DP, OP //
export default connect<SP, {}, {}>(
  mapStateToProps,
  mapDispatchToProps,
)(injectIntl(InsightsCoversOverTimeGraph));
