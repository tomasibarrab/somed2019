import { AsyncContent } from 'gca-react-components';
import { get, orderBy } from 'lodash';
import React, { PureComponent } from 'react';
import { FormattedMessage, InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';

import { greenLight, red } from '../../../../../node_modules/otkit-colors/token.common';
import OTKitIcon from '../../PromotedInventory/FlexiblePricing/Shared/OTKitIcon';
import { fetchSummaryCurrent, fetchSummaryPrevious } from '../../store/insights/insights';
import { AugmentedCampaignType, CoverSummary } from '../../store/insights/insights.types';
import { getCampaignDetails } from '../../store/insights/selectors';
import { State } from '../../store/types';
import { formatCurrency, formatNumber } from '../CampaignsList/helpers/format-number-locale';
import { defaultCurrency } from '../constants';
import convertStringsToDisplayFormat from './helpers/convertStringsToDisplayFormat';
import percentChangeString from './helpers/percentChangeString';
import styles from './InsightsSummary.module.css';
import { FormattedCampaign } from './InsightsTable';

interface DedupedCampaign {
  covers: number;
  price: number;
  type: string;
  campaignCount: number;
}

interface CoverCounts {
  current: number;
  previous: number;
}

type FilteredByPeriod = 'last-year' | 'last-year-to-date' | 'previous-period';

interface SP {
  campaigns?: AugmentedCampaignType[];
  coverTypes?: {};
  currentData?: CoverSummary;
  currentLoading?: boolean;
  previousData?: CoverSummary;
  previousLoading?: boolean;
  filteredByPeriod?: FilteredByPeriod;
}

interface DP {
  fetchSummaryCurrentStarted: typeof fetchSummaryCurrent.started;
  fetchSummaryPreviousStarted: typeof fetchSummaryPrevious.started;
}

type Props = SP & DP & InjectedIntlProps;

class InsightsSummary extends PureComponent<Props> {
  public render() {
    const { insightsSummary, column, emptyState } = styles;
    const { currentData, currentLoading, previousData, previousLoading, campaigns, intl } = this.props;
    const formattedCampaigns = convertStringsToDisplayFormat(campaigns, intl).formattedCampaigns;
    const topCampaigns = this.dedupedTopCampaigns(formattedCampaigns as FormattedCampaign[]);

    return (
      <AsyncContent isLoading={currentLoading && previousLoading} isError={false} isEmpty={false}>
        <header className={insightsSummary}>
          <ul className={column}>
            <li>
              <FormattedMessage id="insights.summary.covers" tagName="h4" />
            </li>
            {this.renderCoverMetrics(
              'insights.summary.total_covers',
              {
                current: get(currentData, '[0].total_seated_covers', 0),
                previous: get(previousData, '[0].total_seated_covers', 0),
              },
              true,
            )}
          </ul>
          <ul className={column}>
            <li>
              <FormattedMessage id="insights.summary.ot_covers_by_type" tagName="h4" />
            </li>
            {this.renderCoverMetrics('insights.summary.ot_discovery', {
              current: get(currentData, '[0].channel_discovery_covers', 0),
              previous: get(previousData, '[0].channel_discovery_covers', 0),
            })}
            {this.renderCoverMetrics('insights.summary.ot_direct', {
              current: get(currentData, '[0].channel_direct_covers', 0),
              previous: get(previousData, '[0].channel_direct_covers', 0),
            })}
          </ul>
          <ul className={column}>
            <li>
              <FormattedMessage id="insights.summary.top_ot_discovery_covers" tagName="h4" />
            </li>
            {topCampaigns && topCampaigns.length > 0 ? (
              <>{this.renderTopCampaignCovers(topCampaigns as DedupedCampaign[])}</>
            ) : (
              <li className={emptyState}>
                <FormattedMessage id="insights.summary.no_campaign_covers" />
              </li>
            )}
          </ul>
        </header>
      </AsyncContent>
    );
  }

  private dedupedTopCampaigns(campaignCovers: FormattedCampaign[]) {
    const campaigns = {};
    campaignCovers.map(campaign => {
      const { type } = campaign.displayValues;
      const { covers, price } = campaign;
      if (campaigns[`${type}|${price}`]) {
        campaigns[`${type}|${price}`].campaignCount += 1;
        campaigns[`${type}|${price}`].covers += covers;
      } else {
        campaigns[`${type}|${price}`] = {
          campaignCount: 1,
          covers,
          price,
          type,
        };
      }
    });

    const arrayOfValues = Object.values(campaigns);
    const displayTopCampaigns = 3;
    return orderBy(arrayOfValues, 'covers', 'desc').slice(0, displayTopCampaigns);
  }

  private renderTopCampaignCovers(campaignCovers: DedupedCampaign[]) {
    const elements = campaignCovers.map((campaign: DedupedCampaign, index: number) => {
      const { type, campaignCount, covers, price } = campaign;
      const tooltip =
        campaignCount > 1
          ? this.props.intl.formatMessage(
              {
                id: 'insights.summary.campaign_count',
              },
              { campaignCount },
            )
          : '';

      return (
        <li key={`covers-${index}`} title={tooltip}>
          {type} {campaignCount > 1 ? `(${campaignCount})` : ''} — {formatCurrency(price, defaultCurrency)}
          <strong>{formatNumber(covers)}</strong>
        </li>
      );
    });
    return elements;
  }

  private renderCoverMetrics(stringId: string, coverCounts: CoverCounts, isTotalCovers: boolean = false) {
    const { filteredByPeriod } = this.props;
    const { metricChange, metricChangeUp, metricChangeDown, largeFont } = styles;
    const { current, previous } = coverCounts;
    const diff = !isNaN(current - previous) ? current - previous : 0;
    const iconSize = isTotalCovers ? '24px' : '18px';
    const className = isTotalCovers ? largeFont : '';

    return (
      <>
        <li>
          <FormattedMessage id={stringId} />
          <strong className={className}>{formatNumber(current)}</strong>
        </li>
        <li className={metricChange}>
          <FormattedMessage
            id={
              filteredByPeriod === 'last-year'
                ? 'insights.summary.vs_previous_year'
                : 'insights.summary.vs_previous_period'
            }
          />
          <span>
            {previous && previous > 0 && diff ? (
              <>
                <OTKitIcon
                  name={`icMetricChange${diff > 0 ? 'Up' : 'Down'}`}
                  fill={diff > 0 ? greenLight : red}
                  iconSize={iconSize}
                />
                <strong className={diff > 0 ? metricChangeUp : metricChangeDown}>
                  {formatNumber(Math.abs(diff))} {percentChangeString(previous, current)}
                </strong>
              </>
            ) : (
              '—'
            )}
          </span>
        </li>
      </>
    );
  }
}

const mapStateToProps = (state: State): SP => {
  return {
    campaigns: getCampaignDetails(state),
    currentData: get(state, 'insights.summaryCurrent.data'),
    currentLoading: get(state, 'insights.summaryCurrent.loading'),
    filteredByPeriod: get(state, 'insights.filters.compareTo'),
    previousData: get(state, 'insights.summaryPrevious.data'),
    previousLoading: get(state, 'insights.summaryPrevious.loading'),
  };
};

export default connect<SP, {}, {}>(mapStateToProps)(injectIntl(InsightsSummary));
