import moment from 'moment';
import * as React from 'react';
import { InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';

import { actions } from '../../store/campaigns/campaigns';
import {
  CampaignState,
  CampaignType,
  CampaignTypes,
  EndDateType,
  ModalType,
  OpenModalPayload,
  PatchActionPayload,
} from '../../store/campaigns/campaigns.types';
import isOpenTableEmail from '../isOpenTableEmail';
import CampaignDetailsMenu from './CampaignDetailsMenu';
import CoverPrice from './DetailLines/CoverPrice';
import DateRange from './DetailLines/DateRange';
import DateTime from './DetailLines/DateTime';
import DetailLine from './DetailLines/DetailLine';
import MonthlyBudget from './DetailLines/MonthlyBudget';
import SuppressionDates from './DetailLines/SuppressionDates';
import Targets from './DetailLines/Targets';

interface OP {
  /* Own props */
  campaign: CampaignType;
}

interface DP {
  openModal: (payload: OpenModalPayload) => void;
  patchCampaignRequest: (payload: PatchActionPayload) => void;
}

type Props = OP & DP & InjectedIntlProps;

/* React.Component<P, S> ------ P is type/interface of props, S is type/interface of state */
class CampaignDetails extends React.Component<Props, {}> {
  public render() {
    const { intl, campaign } = this.props;
    const {
      changedByUser,
      approvedByEmail,
      createdByEmail,
      isShortTerm,
      endDate,
      endTimestamp,
      liveTimestamp,
      schedule,
      state,
      startDate,
      suppressionDates,
      pauseUntil,
      pricingTier,
      maxBid,
      monthlyBudget,
      targets,
      type,
    } = campaign;

    const pauseDate: Date = moment(pauseUntil).toDate();
    /* If the campaign has already been ended automatically or manually, the `endTimestamp` being used here
      makes sense. However, if the campaign has not been ended yet, we should show the `endDate` for the
      Booking Window end date, which makes more sense than showing "No End Date" (which would show up if we
      used the `endTimestamp`). */
    const bookingWindowEndDate = endTimestamp || endDate;
    const lineItems = [];

    if (type === CampaignTypes.CustomPromotions) {
      lineItems.push(<CoverPrice messageIdSuffix="cover_price" maxBid={maxBid} pricingTier={pricingTier} />);
    }

    if (monthlyBudget) {
      lineItems.push(
        <MonthlyBudget messageIdSuffix="monthly_budget" budget={monthlyBudget} pricingTier={pricingTier} />,
      );
    }

    if (isShortTerm && this.isSingleShift(startDate, endDate, schedule.length)) {
      lineItems.push(
        <DateRange messageIdSuffix="campaign_started" start={liveTimestamp} end={liveTimestamp} />,
        <DetailLine messageIdSuffix="created_by" value={createdByEmail} />,
      );
      if (endTimestamp) {
        lineItems.push(<DateRange messageIdSuffix="campaign_ended" start={endTimestamp} end={endTimestamp} />);
      }
    } else {
      if (state === CampaignState.Paused) {
        lineItems.push(<DateTime messageIdSuffix="resumesat" date={pauseDate} />);
      }

      lineItems.push(
        <DateRange
          messageIdSuffix="bookingwindow"
          start={liveTimestamp}
          end={bookingWindowEndDate}
          endDateType={EndDateType.Campaign}
        />,
      );
      lineItems.push(
        <DateRange
          messageIdSuffix="seatingwindow"
          start={startDate}
          end={endDate}
          endDateType={EndDateType.Reservation}
        />,
      );
      if (targets && targets.length > 0) {
        lineItems.push(<Targets messageIdSuffix="guest_targeting" targets={targets} />);
      }
      if (!isShortTerm) {
        lineItems.push(
          <SuppressionDates
            messageIdSuffix="blockeddates"
            intl={intl}
            suppressionDates={suppressionDates}
            editListItem={
              state !== CampaignState.Ended && state !== CampaignState.Discarded ? (
                <li
                  className="edit-blocked-days-li"
                  key="edit-blocked-days-li"
                  onClick={() => {
                    this.props.openModal({ type: ModalType.EditBlockedDays, campaign });
                  }}
                >
                  {intl.formatMessage({ id: 'guestcampaigns.list.edit_blocked_days' })}
                </li>
              ) : null
            }
          />,
        );
      }
      if (state !== CampaignState.Draft && !isOpenTableEmail(approvedByEmail)) {
        lineItems.push(<DetailLine messageIdSuffix="approver" value={approvedByEmail ? approvedByEmail : '-'} />);
      }
    }
    if (state === CampaignState.Ended && changedByUser) {
      /* This works since you are not allowed to modify an ended campaign. */
      lineItems.push(<DetailLine messageIdSuffix="ended_by" value={changedByUser} />);
    }

    return (
      <>
        <td colSpan={2}>
          <ul>{lineItems.map(lineItem => <li key={lineItem.props.messageIdSuffix}>{lineItem}</li>)}</ul>
        </td>
        <td>
          <CampaignDetailsMenu
            campaign={campaign}
            openModal={this.props.openModal}
            patchCampaignRequest={this.props.patchCampaignRequest}
          />
        </td>
      </>
    );
  }

  private isSingleShift(startDate: string, endDate: string | undefined, scheduleLength: number) {
    return startDate === endDate && scheduleLength === 1;
  }
}

const mapDispatch = () => {
  const { openModal, patchCampaign } = actions;
  return {
    openModal,
    patchCampaignRequest: patchCampaign.started,
  };
};

export default connect<{}, DP, OP>(undefined, mapDispatch())(injectIntl(CampaignDetails));
