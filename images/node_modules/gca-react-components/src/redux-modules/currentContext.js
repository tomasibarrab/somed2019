/* eslint-disable arrow-body-style */
import { ajaxGetJSON } from 'rxjs/observable/dom/AjaxObservable';
import { fromEvent } from 'rxjs/observable/fromEvent';

import 'rxjs/add/observable/from';
import './rxjsOperators';

import safeGet from '../utils/safeGet';

/**
 * Constants
 */

export const FETCH_CURRENT_CONTEXT_REQUEST = 'gca/currentContext/FETCH_CURRENT_CONTEXT_REQUEST';
export const FETCH_CURRENT_CONTEXT_SUCCESS = 'gca/currentContext/FETCH_CURRENT_CONTEXT_SUCCESS';
export const FETCH_CURRENT_CONTEXT_FAILURE = 'gca/currentContext/FETCH_CURRENT_CONTEXT_FAILURE';

export const FETCH_CONTEXT_USER_REQUEST = 'gca/currentContext/FETCH_CONTEXT_USER_REQUEST';
export const FETCH_CONTEXT_USER_SUCCESS = 'gca/currentContext/FETCH_CONTEXT_USER_SUCCESS';
export const FETCH_CONTEXT_USER_FAILURE = 'gca/currentContext/FETCH_CONTEXT_USER_FAILURE';

export const FETCH_CONTEXT_RID_REQUEST = 'gca/currentContext/FETCH_CONTEXT_RID_REQUEST';
export const FETCH_CONTEXT_RID_SUCCESS = 'gca/currentContext/FETCH_CONTEXT_RID_SUCCESS';
export const FETCH_CONTEXT_RID_FAILURE = 'gca/currentContext/FETCH_CONTEXT_RID_FAILURE';

export const FETCH_CONTEXT_GROUP_REQUEST = 'gca/currentContext/FETCH_CONTEXT_GROUP_REQUEST';
export const FETCH_CONTEXT_GROUP_SUCCESS = 'gca/currentContext/FETCH_CONTEXT_GROUP_SUCCESS';
export const FETCH_CONTEXT_GROUP_FAILURE = 'gca/currentContext/FETCH_CONTEXT_GROUP_FAILURE';


export const types = {
  FETCH_CURRENT_CONTEXT_REQUEST,
  FETCH_CURRENT_CONTEXT_SUCCESS,
  FETCH_CURRENT_CONTEXT_FAILURE,
  FETCH_CONTEXT_USER_REQUEST,
  FETCH_CONTEXT_USER_SUCCESS,
  FETCH_CONTEXT_USER_FAILURE,
  FETCH_CONTEXT_RID_REQUEST,
  FETCH_CONTEXT_RID_SUCCESS,
  FETCH_CONTEXT_RID_FAILURE,
  FETCH_CONTEXT_GROUP_REQUEST,
  FETCH_CONTEXT_GROUP_SUCCESS,
  FETCH_CONTEXT_GROUP_FAILURE,
};

/**
 * Action Creators
 */

export function fetchCurrentContext(payload) {
  return {
    type: FETCH_CURRENT_CONTEXT_REQUEST,
    payload,
  };
}

function fetchCurrentContextSucceeded(payload) {
  return {
    type: FETCH_CURRENT_CONTEXT_SUCCESS,
    payload,
  };
}

function fetchCurrentContextFailed(error) {
  return {
    type: FETCH_CURRENT_CONTEXT_FAILURE,
    error,
  };
}

// ===================== USER

export function fetchContextUser(payload) {
  return {
    type: FETCH_CONTEXT_USER_REQUEST,
    payload,
  };
}

function fetchContextUserSucceeded(payload) {
  return {
    type: FETCH_CONTEXT_USER_SUCCESS,
    payload,
  };
}

function fetchContextUserFailed(error) {
  return {
    type: FETCH_CONTEXT_USER_FAILURE,
    error,
  };
}

// ===================== RID

export function fetchContextRid(payload) {
  return {
    type: FETCH_CONTEXT_RID_REQUEST,
    payload,
  };
}

function fetchContextRidSucceeded(payload) {
  return {
    type: FETCH_CONTEXT_RID_SUCCESS,
    payload,
  };
}

function fetchContextRidFailed(error) {
  return {
    type: FETCH_CONTEXT_RID_FAILURE,
    error,
  };
}

// ===================== Group

export function fetchContextGroup(payload) {
  return {
    type: FETCH_CONTEXT_GROUP_REQUEST,
    payload,
  };
}

function fetchContextGroupSucceeded(payload) {
  return {
    type: FETCH_CONTEXT_GROUP_SUCCESS,
    payload,
  };
}

function fetchContextGroupFailed(error) {
  return {
    type: FETCH_CONTEXT_GROUP_FAILURE,
    error,
  };
}

export const actions = {
  fetchCurrentContext,
  fetchCurrentContextSucceeded,
  fetchCurrentContextFailed,
  fetchContextUser,
  fetchContextUserSucceeded,
  fetchContextUserFailed,
  fetchContextRid,
  fetchContextRidSucceeded,
  fetchContextRidFailed,
  fetchContextGroup,
  fetchContextGroupSucceeded,
  fetchContextGroupFailed,
};

export const initialState = {
  // Initialize to loading to enable blocking app renders until currentContext is successfully fetched.
  asyncCount: 0,
  isFetching: true,
  fetchFailed: false,
  error: null,
};


/**
 *
 *
 * Selectors
 *
 *
 */

export const selectors = {
  currentContext(state) {
    return safeGet(state, ['currentContext']);
  },
  user(state) {
    return safeGet(state, ['currentContext', 'user']);
  },
  restaurant(state) {
    return safeGet(state, ['currentContext', 'restaurant']);
  },
  rid(state) {
    return safeGet(state, ['currentContext', 'restaurant', 'rid']);
  },
  productType(state) {
    return safeGet(state, ['currentContext', 'restaurant', 'productType']);
  },
  isFetching(state) {
    return safeGet(state, ['currentContext', 'isFetching']);
  },
  fetchFailed(state) {
    return safeGet(state, ['currentContext', 'fetchFailed']);
  },
};


/** DATA FETCHING
 * ==========================================================================
 */

export function getCurrentContextUrl(rid) {
  if (rid) {
    return `/gateway/proxies/gcrestaurant/api/restaurants/${rid}/currentContext`;
  }

  return '/setup/api/currentContext';
}

export function apiFetchCurrentContext(rid) {
  const url = getCurrentContextUrl(rid);
  return ajaxGetJSON(url);
}

/**
 * currentContext Epic:
 * Listen for sessionStorage events to retrieve currentContext data.
 * The following keys have been placed in sessionStorage by Chrome:
 *  gcScope: the 'restaurant' object
 *  user: the 'user' object
 */

const contextKey = 'gcContext';
const userKey = 'user';

// This function is injected into the epic below as a property of the 'api' object
// so that it can be mocked for test purposes
export function fetchContextKey(storageKey) {
  const key = storageKey.split('.')[1];
  const keyData = sessionStorage.getItem(key);
  if (!keyData) {
    throw (new Error('Storage key not found'));
  }

  const contextData = JSON.parse(keyData);
  if (contextData) {
    if (key === 'gcContext') {
      return ({ restaurant: contextData.data });
    } else if (key === 'user') {
      return ({ user: contextData });
    }
  }

  throw (new Error('Storage key not found 2'));
}

/** EPICS
 * ==========================================================================
 */

/*
 *  Listen for sessionStorage events to retrieve currentContext data:
 *   - 2 event listeners are fired to listen for 'user' and 'restaurant' sessionStorage events
 *   - 'restaurant' and 'user' objects are extracted from sessionStorage and placed in the store
 *   - The event listener resolves immediately if the storage key already exists
 *   - TBD: The event listener times out after a maximum wait time of 1000 ms
 */
export function currentContextEpic(action$, _, { api } = { fetchCurrentContext: fetchContextKey }) {
  return action$.ofType(FETCH_CURRENT_CONTEXT_REQUEST)
    .map(({ payload }) => payload && payload.rid)
    .switchMap((rid) => {
      return api.fetchCurrentContext(rid)
        .map((response) => fetchCurrentContextSucceeded(response))
        .catch((error) => [fetchCurrentContextFailed(error)]);
    });
}

export function userContextEpic(action$) {
  return action$
    .ofType(FETCH_CONTEXT_USER_REQUEST)
    .switchMap(() => fromEvent(document, `updateSessionStorage.${userKey}`))
    .map(ev => fetchContextUserSucceeded(fetchContextKey(ev.type)))
    .catch(error => fetchContextUserFailed(error));
}

export function ridContextEpic(action$) {
  return action$
    .ofType(FETCH_CONTEXT_RID_REQUEST)
    .switchMap(() => fromEvent(document, `updateSessionStorage.${contextKey}`))
    .map(ev => fetchContextRidSucceeded(fetchContextKey(ev.type)))
    .catch(error => fetchContextRidFailed(error));
}

export function groupContextEpic(action$) {
  return action$
    .ofType(FETCH_CONTEXT_GROUP_REQUEST)
    .switchMap(() => fromEvent(document, `updateSessionStorage.${contextKey}`))
    .map(ev => fetchContextGroupSucceeded(fetchContextKey(ev.type)))
    .catch(error => fetchContextGroupFailed(error));
}

/**
 * Reducer
 * ==========================================================================
 */

// helper functions
function incrAsyncCount(state) {
  return state.asyncCount + 1; // storageKeys.length;
}

function decrAsyncCount(state) {
  return state.asyncCount > 0 ? state.asyncCount - 1 : 0;
}

export function currentContextReducer(state = initialState, action) {
  let count = 0;
  switch (action.type) {
    case FETCH_CONTEXT_USER_SUCCESS:
      count = decrAsyncCount(state);
      return {
        ...state,
        asyncCount: count,
        isFetching: Boolean(count > 0),
        fetchFailed: false,
        user: action.payload.user,
      };
    case FETCH_CONTEXT_RID_SUCCESS:
      count = decrAsyncCount(state);
      return {
        ...state,
        asyncCount: count,
        isFetching: Boolean(count > 0),
        fetchFailed: false,
        restaurant: action.payload.restaurant,
      };
    case FETCH_CONTEXT_GROUP_SUCCESS: {
      count = decrAsyncCount(state);
      return {
        ...state,
        asyncCount: count,
        isFetching: Boolean(count > 0),
        fetchFailed: false,
        group: action.payload.group,
      };
    }
    case FETCH_CONTEXT_RID_REQUEST:
      return {
        ...state,
        isFetching: true,
        asyncCount: incrAsyncCount(state),
        restaurant: { rid: action.payload.id }
      };
    case FETCH_CONTEXT_GROUP_REQUEST:
      return {
        ...state,
        isFetching: true,
        asyncCount: incrAsyncCount(state),
        group: { groupId: action.payload.id }
      };
    case FETCH_CONTEXT_USER_REQUEST:
      return {
        ...state,
        isFetching: true,
        asyncCount: incrAsyncCount(state),
      };
    case FETCH_CONTEXT_USER_FAILURE:
    case FETCH_CONTEXT_RID_FAILURE:
    case FETCH_CONTEXT_GROUP_FAILURE:
      return {
        ...state,
        asyncCount: 0,
        isFetching: false,
        fetchFailed: true,
        error: action.error,
      };
    // Legacy reducers
    case FETCH_CURRENT_CONTEXT_REQUEST:
      return {
        ...state,
        isFetching: true,
        fetchFailed: false,
      };
    case FETCH_CURRENT_CONTEXT_SUCCESS:
      return {
        ...state,
        ...action.payload,
        asyncCount: 0,
        isFetching: false,
        fetchFailed: false,
      };
    case FETCH_CURRENT_CONTEXT_FAILURE:
      return {
        ...state,
        asyncCount: 0,
        isFetching: false,
        fetchFailed: true,
        error: action.error,
      };
    default:
      return state;
  }
}
