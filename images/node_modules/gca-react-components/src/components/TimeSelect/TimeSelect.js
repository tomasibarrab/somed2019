import React from 'react';
import PropTypes from 'prop-types';
import addMinutes from 'date-fns/add_minutes';
import format from 'date-fns/format';
import startOfDay from 'date-fns/start_of_day';
import range from 'lodash/range';
import { Select } from '../Select/Select';
import getTimeFormat from '../../utils/i18n/timeFormats';

const START_OF_DAY = startOfDay(new Date(1999, 1, 1));
const DEFAULT_PATTERN = 'HH:mm';

const padNumber = n => (`${n}`.length === 1 ? `0${n}` : n);

export const parseTimeToMinutes = time => {
  const parts = time.split(':');
  const hours = parseInt(parts[0], 10);
  const minutes = parseInt(parts[1], 10);
  return hours * 60 + minutes;
};

export const formatTime = absoluteMinutes => {
  const hours = Math.floor(absoluteMinutes / 60);
  const minutes = absoluteMinutes % 60;
  const paddedHours = padNumber(hours);
  const paddedMinutes = padNumber(minutes);
  return `${paddedHours}:${paddedMinutes}`;
};

export const buildTimes = (start, end, increment, labelFormat) =>
  range(parseTimeToMinutes(start), parseTimeToMinutes(end), increment).map(minutes => ({
    // format requires a Date or a datestring, but we only care about hours/minutes
    // so, build a dummy datestring that has the correct time included.
    label: format(`1999-01-01T${formatTime(minutes)}`, labelFormat),
    value: formatTime(minutes),
  }));

const buildTime = (time, increment) =>
  format(addMinutes(START_OF_DAY, parseTimeToMinutes(time) + increment), DEFAULT_PATTERN);

const stripSeconds = time =>
  time.split(':').length === 3
    ? time
      .split(':')
      .slice(0, 2)
      .join(':')
    : time;

const appendSeconds = time => time.concat(':00');

export class TimeSelect extends React.PureComponent {
  static defaultProps = {
    disabled: false,
    start: '00:00',
    end: '23:30',
    increment: 30,
    startType: 'inclusive',
    endType: 'exclusive',
  };

  onChange = val => {
    if (!this.props.outputWithSeconds) {
      this.props.onChange(val);
    } else if (typeof val === 'string') {
      this.props.onChange(appendSeconds(val));
    } else {
      this.props.onChange({ ...val, value: appendSeconds(val.value) });
    }
  };

  render() {
    const {
      value: inValue,
      start,
      end,
      increment,
      startType,
      locale,
      disabled,
      endType,
      outputWithSeconds,
      ...rest
    } = this.props;

    const value = outputWithSeconds ? stripSeconds(inValue) : inValue;

    const labelFormat = getTimeFormat(locale);
    const startTime = startType === 'inclusive' ? start : buildTime(start, increment);
    const endTime = endType === 'exclusive' ? end : buildTime(end, increment);
    const times = buildTimes(startTime, endTime, increment, labelFormat);

    return <Select {...rest} options={times} onChange={this.onChange} value={value} disabled={disabled} />;
  }
}

TimeSelect.propTypes = {
  /** option to append seconds as `:00` to the value onChange */
  outputWithSeconds: PropTypes.bool,
  /** Start time for options */
  start: PropTypes.string.isRequired,
  /** specify whether the start is inclusive or exclusive */
  startType: PropTypes.oneOf(['inclusive', 'exclusive']),
  /** End time for options */
  end: PropTypes.string.isRequired,
  /** specify whether the end is inclusive or exclusive */
  endType: PropTypes.oneOf(['inclusive', 'exclusive']),
  /** Integer, in minutes, to step select items by */
  increment: PropTypes.number,
  /** String, locale used to resolve 12 or 24-hour time format for labels */
  locale: PropTypes.string,
  /** Receives the updated value. You are responsible for updating the bound data source. */
  onChange: PropTypes.func,
  /** The text value of component. */
  value: PropTypes.string,
  /** Is it disabled? */
  disabled: PropTypes.bool,
};

export default TimeSelect;
