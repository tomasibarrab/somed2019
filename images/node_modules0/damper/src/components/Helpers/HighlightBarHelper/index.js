import React from 'react';
import PropTypes from 'prop-types';
import isObject from 'lodash.isobject';
import { Group } from '../../Svg/';

class HighlightBarHelper extends React.Component {
  static propTypes = {
    activeInnerArea: PropTypes.object.isRequired,
    data: PropTypes.object.isRequired,
    theme: PropTypes.object,
    highlightBar: PropTypes.oneOfType([
      PropTypes.bool,
      PropTypes.object,
    ]),
    helper: PropTypes.object,
  }

  static defaultProps = {
    theme: {},
  }

  renderHelper() {
    const {
      data,
      activeInnerArea,
      theme,
      helper,
    } = this.props;

    const { bars } = theme;
    let width = theme.bars.default.width;

    // Group of Bars
    if (data.group !== undefined) {

      const offsets = data.group
        .map((v) => {
          const defaultWidth = theme.bars.default.width;
          const widths = v.values.map((value) => {

            // Overwrite theme if there is any
            if (value.theme) {
              if (value.theme.style) {
                const { style: styling } = value.theme;
                const barStyle = Object.assign({}, bars.default, styling);
                return barStyle.width;
              }
            }
            return defaultWidth;
          });

          // Returns 0 offset if nothing is defined, in case needed for calculations
          // if there is a series of bars (stacked), get the widest bar (unlikely but just to be safe)
          return {
            offset: !v.offset ? 0 : v.offset,
            width: (widths.length > 0) ? Math.max(...widths) : defaultWidth,
          };
        });

      // Find the widest width
      const maxWidth = Math.max.apply(Math, offsets.map((v) => v.width));

      // Find the offsets furthest away from center (-ve and +ve) and get the objects' widths and offsets
      const calculateOffsetMixMax = (arr) => {
        const minOffset = Math.min.apply(Math, arr.map((v) => v.offset));
        const maxOffset = Math.max.apply(Math, arr.map((v) => v.offset));

        const minOffsetObject = arr.find((v) => v.offset === minOffset);
        const maxOffsetObject = arr.find((v) => v.offset === maxOffset);

        let min = 0;
        let max = 0;

        if (minOffset < 0) {
          min = (minOffsetObject.width / 2) + Math.abs(minOffsetObject.offset);
        }

        if (maxOffset > 0) {
          max = (maxOffsetObject.width / 2) + Math.abs(maxOffsetObject.offset);
        }

        return {
          offsets: {
            min: minOffset,
            max: maxOffset,
          },
          width: min + max,
        };
      };

      const minMaxOffsets = calculateOffsetMixMax(offsets);

      // If there is at least one offset, use the largest offset bar width
      // Limitation: this may not be ideal if some smaller offset has wider bars
      if (offsets.some((v) => v.offset !== 0)) {
        width = minMaxOffsets.width;
      } else {
        // If there is no offset, use the widest width to fit in
        width = maxWidth;
      }
    }

    // @TODO Limitations: This is making an assumption the offsets are always balanced on left and right of the bar.
    // e.g. If both widths are 20 and offsets are -15 and 20 respectively, the highlight bar will not aligned and fit
    const highlightBarProps = {
      width,
      height: activeInnerArea.height,
      y: -1 * activeInnerArea.height,
      x: -1 * (width / 2),
    };

    const defaultBarStyles = {
      fill: theme.helpers.bar.highlight.bar.fill,
      opacity: theme.helpers.bar.highlight.bar.opacity,
      style: {
        mixBlendMode: 'multiply',
      }
    };

    const defaultBorderStyles = {
      fill: theme.helpers.bar.highlight.border.fill,
      opacity: theme.helpers.bar.highlight.border.opacity,
      height: theme.helpers.bar.highlight.border.height,
    };

    let overwriteBarStyles = {};
    let overwriteBorderStyles = {};
    let isHighlight = true;

    // Callback
    if (typeof helper.callback === 'function') {
      const helperStylesOverwrite = helper.callback(data);

      if (isObject(helperStylesOverwrite) || typeof helperStylesOverwrite === 'boolean') {
        if (!helperStylesOverwrite) {
          isHighlight = false;
        }
        if (helperStylesOverwrite.styles) {
          overwriteBarStyles = (helperStylesOverwrite.styles.bar) ? helperStylesOverwrite.styles.bar : {};
          overwriteBorderStyles = (helperStylesOverwrite.styles.border) ? helperStylesOverwrite.styles.border : {};
        }
      } else {
        isHighlight = false;
        throw new Error('Returned value needs to be a valid object');
      }
    }

    const barProps = Object.assign(
      {},
      highlightBarProps,
      defaultBarStyles,
      overwriteBarStyles,
    );

    const borderProps = Object.assign(
      {},
      { width: highlightBarProps.width },
      { height: theme.helpers.bar.highlight.border.height },
      { x: highlightBarProps.x },
      { y: highlightBarProps.y },
      defaultBorderStyles,
      overwriteBorderStyles,
    );

    return isHighlight && (
      <Group>
        <rect {...barProps} />
        <rect {...borderProps} />
      </Group>
    );
  }

  render() {
    const { helper } = this.props;
    if (!helper.show) {
      return null;
    }
    return this.renderHelper();
  }
}

export { HighlightBarHelper };
