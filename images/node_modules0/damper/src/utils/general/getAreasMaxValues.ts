interface IColumn {
  id: string;
  label: string;
}

interface IChildChildData {
  id: string;
  value: number;
}

interface IChildData {
  id: string;
  data: IChildChildData[];
}

interface IData {
  data: IChildData[];
  group: boolean;
  id: string;
}

interface IGetAreasMaxValuesParams {
  columns: IColumn[];
  data: IData[];
}

const defaultParams = { data: [], columns: [] };

interface IGetValuesAlignedToColumnsReturn {
  [index: string]: number;
}

/**
 * Gets area values aligned to the column id
 */
const getValuesAlignedToColumns = ({ columnId, data }: { columnId: string, data: IChildData[] }): IGetValuesAlignedToColumnsReturn => {
  return data.reduce((prev, item: IChildData) => {
    const columnMatchedData = item.data.find((i: IChildChildData) => i.id === columnId);

    if (columnMatchedData) {
      return {
        ...prev,
        [item.id]: columnMatchedData.value,
      }
    }

    return prev;
  }, {});
};

/**
 * Returns all areas values and total for each column id
 */
export const getAreasMaxValues = ({ data, columns }: IGetAreasMaxValuesParams = defaultParams) => {
  if (data.length) {
    return data
      .map((set: IData) => columns
        .map((column: IColumn) => {
          const columnId = column.id;
          const data = set.data;

          const val = getValuesAlignedToColumns({ columnId, data });

          return {
            id: columnId,
            val,
          }
        })
        .map((group: any) => {
          const keys = Object.keys(group.val);
          const maxVal = keys.reduce((prev, key) => (typeof (group.val[key]) === 'number' ? prev + group.val[key] : 0), 0);

          return {
            ...group,
            maxVal,
          };
        })
      );
  }

  return [];
};
