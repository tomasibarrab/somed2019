(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Damper"] = factory();
	else
		root["Damper"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inheritsLoose.js":
/***/ (function(module, exports) {

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

module.exports = _inheritsLoose;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js":
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

/***/ }),

/***/ "./node_modules/@buffet/icon/dist/web.js":
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){if(true)module.exports=t();else { var o, n; }}(window,function(){return function(e){var t={};function n(o){if(t[o])return t[o].exports;var r=t[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(o,r,function(t){return e[t]}.bind(null,r));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=72)}([function(e,t,n){(function(t){var n;n=function(){"use strict";var e=function(e){var t=e.id,n=e.viewBox,o=e.content;this.id=t,this.viewBox=n,this.content=o};function n(e,t){return e(t={exports:{}},t.exports),t.exports}e.prototype.stringify=function(){return this.content},e.prototype.toString=function(){return this.stringify()},e.prototype.destroy=function(){var e=this;["id","viewBox","content"].forEach(function(t){return delete e[t]})},"undefined"!=typeof window?window:void 0!==t||"undefined"!=typeof self&&self;var o=n(function(e,t){e.exports=function(){function e(e){var t=e&&"object"==typeof e;return t&&"[object RegExp]"!==Object.prototype.toString.call(e)&&"[object Date]"!==Object.prototype.toString.call(e)}function t(t,n){var r,i=n&&!0===n.clone;return i&&e(t)?o((r=t,Array.isArray(r)?[]:{}),t,n):t}function n(n,r,i){var s=n.slice();return r.forEach(function(r,a){void 0===s[a]?s[a]=t(r,i):e(r)?s[a]=o(n[a],r,i):-1===n.indexOf(r)&&s.push(t(r,i))}),s}function o(r,i,s){var a=Array.isArray(i),l=s||{arrayMerge:n},u=l.arrayMerge||n;return a?Array.isArray(r)?u(r,i,s):t(i,s):function(n,r,i){var s={};return e(n)&&Object.keys(n).forEach(function(e){s[e]=t(n[e],i)}),Object.keys(r).forEach(function(a){e(r[a])&&n[a]?s[a]=o(n[a],r[a],i):s[a]=t(r[a],i)}),s}(r,i,s)}return o.all=function(e,t){if(!Array.isArray(e)||e.length<2)throw new Error("first argument should be an array with at least two elements");return e.reduce(function(e,n){return o(e,n,t)})},o}()}),r=n(function(e,t){t.default={svg:{name:"xmlns",uri:"http://www.w3.org/2000/svg"},xlink:{name:"xmlns:xlink",uri:"http://www.w3.org/1999/xlink"}},e.exports=t.default}),i=r.svg,s=r.xlink,a={};a[i.name]=i.uri,a[s.name]=s.uri;var l=function(e,t){return void 0===e&&(e=""),"<svg "+function(e){return Object.keys(e).map(function(t){return t+'="'+e[t].toString().replace(/"/g,"&quot;")+'"'}).join(" ")}(o(a,t||{}))+">"+e+"</svg>"};return function(e){function t(){e.apply(this,arguments)}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={isMounted:{}};return n.isMounted.get=function(){return!!this.node},t.createFromExistingNode=function(e){return new t({id:e.getAttribute("id"),viewBox:e.getAttribute("viewBox"),content:e.outerHTML})},t.prototype.destroy=function(){this.isMounted&&this.unmount(),e.prototype.destroy.call(this)},t.prototype.mount=function(e){if(this.isMounted)return this.node;var t="string"==typeof e?document.querySelector(e):e,n=this.render();return this.node=n,t.appendChild(n),n},t.prototype.render=function(){var e=this.stringify();return function(e){var t=!!document.importNode,n=(new DOMParser).parseFromString(e,"image/svg+xml").documentElement;return t?document.importNode(n,!0):n}(l(e)).childNodes[0]},t.prototype.unmount=function(){this.node.parentNode.removeChild(this.node)},Object.defineProperties(t.prototype,n),t}(e)},e.exports=n()}).call(this,n(6))},function(e,t,n){(function(t){var n;n=function(){"use strict";function e(e,t){return e(t={exports:{}},t.exports),t.exports}"undefined"!=typeof window?window:void 0!==t||"undefined"!=typeof self&&self;var n=e(function(e,t){e.exports=function(){function e(e){var t=e&&"object"==typeof e;return t&&"[object RegExp]"!==Object.prototype.toString.call(e)&&"[object Date]"!==Object.prototype.toString.call(e)}function t(t,n){var r,i=n&&!0===n.clone;return i&&e(t)?o((r=t,Array.isArray(r)?[]:{}),t,n):t}function n(n,r,i){var s=n.slice();return r.forEach(function(r,a){void 0===s[a]?s[a]=t(r,i):e(r)?s[a]=o(n[a],r,i):-1===n.indexOf(r)&&s.push(t(r,i))}),s}function o(r,i,s){var a=Array.isArray(i),l=s||{arrayMerge:n},u=l.arrayMerge||n;return a?Array.isArray(r)?u(r,i,s):t(i,s):function(n,r,i){var s={};return e(n)&&Object.keys(n).forEach(function(e){s[e]=t(n[e],i)}),Object.keys(r).forEach(function(a){e(r[a])&&n[a]?s[a]=o(n[a],r[a],i):s[a]=t(r[a],i)}),s}(r,i,s)}return o.all=function(e,t){if(!Array.isArray(e)||e.length<2)throw new Error("first argument should be an array with at least two elements");return e.reduce(function(e,n){return o(e,n,t)})},o}()}),o=e(function(e,t){t.default={svg:{name:"xmlns",uri:"http://www.w3.org/2000/svg"},xlink:{name:"xmlns:xlink",uri:"http://www.w3.org/1999/xlink"}},e.exports=t.default}),r=o.svg,i=o.xlink,s={};s[r.name]=r.uri,s[i.name]=i.uri;var a,l=function(e,t){return void 0===e&&(e=""),"<svg "+function(e){return Object.keys(e).map(function(t){return t+'="'+e[t].toString().replace(/"/g,"&quot;")+'"'}).join(" ")}(n(s,t||{}))+">"+e+"</svg>"},u=o.svg,c=o.xlink,d={attrs:(a={style:["position: absolute","width: 0","height: 0"].join("; ")},a[u.name]=u.uri,a[c.name]=c.uri,a)},f=function(e){this.config=n(d,e||{}),this.symbols=[]};f.prototype.add=function(e){var t=this.symbols,n=this.find(e.id);return n?(t[t.indexOf(n)]=e,!1):(t.push(e),!0)},f.prototype.remove=function(e){var t=this.symbols,n=this.find(e);return!!n&&(t.splice(t.indexOf(n),1),n.destroy(),!0)},f.prototype.find=function(e){return this.symbols.filter(function(t){return t.id===e})[0]||null},f.prototype.has=function(e){return null!==this.find(e)},f.prototype.stringify=function(){var e=this.config.attrs,t=this.symbols.map(function(e){return e.stringify()}).join("");return l(t,e)},f.prototype.toString=function(){return this.stringify()},f.prototype.destroy=function(){this.symbols.forEach(function(e){return e.destroy()})};var v=function(e){var t=e.id,n=e.viewBox,o=e.content;this.id=t,this.viewBox=n,this.content=o};v.prototype.stringify=function(){return this.content},v.prototype.toString=function(){return this.stringify()},v.prototype.destroy=function(){var e=this;["id","viewBox","content"].forEach(function(t){return delete e[t]})};var p=function(e){var t=!!document.importNode,n=(new DOMParser).parseFromString(e,"image/svg+xml").documentElement;return t?document.importNode(n,!0):n},g=function(e){function t(){e.apply(this,arguments)}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={isMounted:{}};return n.isMounted.get=function(){return!!this.node},t.createFromExistingNode=function(e){return new t({id:e.getAttribute("id"),viewBox:e.getAttribute("viewBox"),content:e.outerHTML})},t.prototype.destroy=function(){this.isMounted&&this.unmount(),e.prototype.destroy.call(this)},t.prototype.mount=function(e){if(this.isMounted)return this.node;var t="string"==typeof e?document.querySelector(e):e,n=this.render();return this.node=n,t.appendChild(n),n},t.prototype.render=function(){var e=this.stringify();return p(l(e)).childNodes[0]},t.prototype.unmount=function(){this.node.parentNode.removeChild(this.node)},Object.defineProperties(t.prototype,n),t}(v),h={autoConfigure:!0,mountTo:"body",syncUrlsWithBaseTag:!1,listenLocationChangeEvent:!0,locationChangeEvent:"locationChange",locationChangeAngularEmitter:!1,usagesToUpdate:"use[*|href]",moveGradientsOutsideSymbol:!1},m=function(e){return Array.prototype.slice.call(e,0)},w=navigator.userAgent,C={isChrome:/chrome/i.test(w),isFirefox:/firefox/i.test(w),isIE:/msie/i.test(w)||/trident/i.test(w),isEdge:/edge/i.test(w)},y=function(e){var t=[];return m(e.querySelectorAll("style")).forEach(function(e){e.textContent+="",t.push(e)}),t},L=function(e){return(e||window.location.href).split("#")[0]},x=function(e){angular.module("ng").run(["$rootScope",function(t){t.$on("$locationChangeSuccess",function(t,n,o){var r,i,s;r=e,i={oldUrl:o,newUrl:n},(s=document.createEvent("CustomEvent")).initCustomEvent(r,!1,!1,i),window.dispatchEvent(s)})}])},b=function(e,t){return void 0===t&&(t="linearGradient, radialGradient, pattern"),m(e.querySelectorAll("symbol")).forEach(function(e){m(e.querySelectorAll(t)).forEach(function(t){e.parentNode.insertBefore(t,e)})}),e},M=o.xlink.uri,B="xlink:href",k=/[{}|\\\^\[\]`"<>]/g;function _(e){return e.replace(k,function(e){return"%"+e[0].charCodeAt(0).toString(16).toUpperCase()})}var S,A=["clipPath","colorProfile","src","cursor","fill","filter","marker","markerStart","markerMid","markerEnd","mask","stroke","style"],O=A.map(function(e){return"["+e+"]"}).join(","),Z=function(e,t,n,o){var r=_(n),i=_(o);(function(e,t){return m(e).reduce(function(e,n){if(!n.attributes)return e;var o=m(n.attributes),r=t?o.filter(t):o;return e.concat(r)},[])})(e.querySelectorAll(O),function(e){var t=e.localName,n=e.value;return-1!==A.indexOf(t)&&-1!==n.indexOf("url("+r)}).forEach(function(e){return e.value=e.value.replace(r,i)}),function(e,t,n){m(e).forEach(function(e){var o=e.getAttribute(B);if(o&&0===o.indexOf(t)){var r=o.replace(t,n);e.setAttributeNS(M,B,r)}})}(t,r,i)},j={MOUNT:"mount",SYMBOL_MOUNT:"symbol_mount"},E=function(e){function t(t){var o=this;void 0===t&&(t={}),e.call(this,n(h,t));var r,i=(r=r||Object.create(null),{on:function(e,t){(r[e]||(r[e]=[])).push(t)},off:function(e,t){r[e]&&r[e].splice(r[e].indexOf(t)>>>0,1)},emit:function(e,t){(r[e]||[]).map(function(e){e(t)}),(r["*"]||[]).map(function(n){n(e,t)})}});this._emitter=i,this.node=null;var s=this.config;if(s.autoConfigure&&this._autoConfigure(t),s.syncUrlsWithBaseTag){var a=document.getElementsByTagName("base")[0].getAttribute("href");i.on(j.MOUNT,function(){return o.updateUrls("#",a)})}var l=this._handleLocationChange.bind(this);this._handleLocationChange=l,s.listenLocationChangeEvent&&window.addEventListener(s.locationChangeEvent,l),s.locationChangeAngularEmitter&&x(s.locationChangeEvent),i.on(j.MOUNT,function(e){s.moveGradientsOutsideSymbol&&b(e)}),i.on(j.SYMBOL_MOUNT,function(e){s.moveGradientsOutsideSymbol&&b(e.parentNode),(C.isIE||C.isEdge)&&y(e)})}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var o={isMounted:{}};return o.isMounted.get=function(){return!!this.node},t.prototype._autoConfigure=function(e){var t=this.config;void 0===e.syncUrlsWithBaseTag&&(t.syncUrlsWithBaseTag=void 0!==document.getElementsByTagName("base")[0]),void 0===e.locationChangeAngularEmitter&&(t.locationChangeAngularEmitter="angular"in window),void 0===e.moveGradientsOutsideSymbol&&(t.moveGradientsOutsideSymbol=C.isFirefox)},t.prototype._handleLocationChange=function(e){var t=e.detail,n=t.oldUrl,o=t.newUrl;this.updateUrls(n,o)},t.prototype.add=function(t){var n=e.prototype.add.call(this,t);return this.isMounted&&n&&(t.mount(this.node),this._emitter.emit(j.SYMBOL_MOUNT,t.node)),n},t.prototype.attach=function(e){var t=this,n=this;if(n.isMounted)return n.node;var o="string"==typeof e?document.querySelector(e):e;return n.node=o,this.symbols.forEach(function(e){e.mount(n.node),t._emitter.emit(j.SYMBOL_MOUNT,e.node)}),m(o.querySelectorAll("symbol")).forEach(function(e){var t=g.createFromExistingNode(e);t.node=e,n.add(t)}),this._emitter.emit(j.MOUNT,o),o},t.prototype.destroy=function(){var e=this.config,t=this.symbols,n=this._emitter;t.forEach(function(e){return e.destroy()}),n.off("*"),window.removeEventListener(e.locationChangeEvent,this._handleLocationChange),this.isMounted&&this.unmount()},t.prototype.mount=function(e,t){void 0===e&&(e=this.config.mountTo),void 0===t&&(t=!1);if(this.isMounted)return this.node;var n="string"==typeof e?document.querySelector(e):e,o=this.render();return this.node=o,t&&n.childNodes[0]?n.insertBefore(o,n.childNodes[0]):n.appendChild(o),this._emitter.emit(j.MOUNT,o),o},t.prototype.render=function(){return p(this.stringify())},t.prototype.unmount=function(){this.node.parentNode.removeChild(this.node)},t.prototype.updateUrls=function(e,t){if(!this.isMounted)return!1;var n=document.querySelectorAll(this.config.usagesToUpdate);return Z(this.node,n,L(e)+"#",L(t)+"#"),!0},Object.defineProperties(t.prototype,o),t}(f),z=e(function(e){var t,n,o,r,i;e.exports=(n=[],o=document,r=o.documentElement.doScroll,(i=(r?/^loaded|^c/:/^loaded|^i|^c/).test(o.readyState))||o.addEventListener("DOMContentLoaded",t=function(){for(o.removeEventListener("DOMContentLoaded",t),i=1;t=n.shift();)t()}),function(e){i?setTimeout(e,0):n.push(e)})});!!window.__SVG_SPRITE__?S=window.__SVG_SPRITE__:(S=new E({attrs:{id:"__SVG_SPRITE_NODE__"}}),window.__SVG_SPRITE__=S);var R=function(){var e=document.getElementById("__SVG_SPRITE_NODE__");e?S.attach(e):S.mount(document.body,!0)};return document.body?R():z(R),S},e.exports=n()}).call(this,n(6))},function(e,t){e.exports=__webpack_require__("./node_modules/react/index.js")},function(e,t,n){(t=e.exports=n(5)(!1)).push([e.i,"\n",""]),t.locals={"spacing-xsmall":"4px",spacingXsmall:"4px","spacing-small":"8px",spacingSmall:"8px","spacing-medium":"16px",spacingMedium:"16px","spacing-large":"32px",spacingLarge:"32px","spacing-xlarge":"64px",spacingXlarge:"64px"}},function(e,t,n){var o=n(12);"string"==typeof o&&(o=[[e.i,o,""]]);var r={hmr:!0,transform:void 0,insertInto:void 0};n(13)(o,r);o.locals&&(e.exports=o.locals)},function(e,t){e.exports=function(e){var t=[];return t.toString=function(){return this.map(function(t){var n=function(e,t){var n=e[1]||"",o=e[3];if(!o)return n;if(t&&"function"==typeof btoa){var r=(s=o,"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(s))))+" */"),i=o.sources.map(function(e){return"/*# sourceURL="+o.sourceRoot+e+" */"});return[n].concat(i).concat([r]).join("\n")}var s;return[n].join("\n")}(t,e);return t[2]?"@media "+t[2]+"{"+n+"}":n}).join("")},t.i=function(e,n){"string"==typeof e&&(e=[[null,e,""]]);for(var o={},r=0;r<this.length;r++){var i=this[r][0];"number"==typeof i&&(o[i]=!0)}for(r=0;r<e.length;r++){var s=e[r];"number"==typeof s[0]&&o[s[0]]||(n&&!s[2]?s[2]=n:n&&(s[2]="("+s[2]+") and ("+n+")"),t.push(s))}},t}},function(e,t){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(e){"object"==typeof window&&(n=window)}e.exports=n},function(e,t){e.exports=function(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t}},function(e,t){e.exports=__webpack_require__("./node_modules/classnames/index.js")},function(e,t){function n(){return e.exports=n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},n.apply(this,arguments)}e.exports=n},function(e,t){e.exports=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}},function(e,t){e.exports=__webpack_require__("./node_modules/classnames/bind.js")},function(e,t,n){(t=e.exports=n(5)(!1)).i(n(3),void 0),t.push([e.i,".icon__icon___3peb6XVBehlICUSTZCUjMX {\n  shape-rendering: geometricPrecision;\n  display: inline-block;\n  width: 24px;\n  height: 24px;\n}\n\n.icon__touchable___3q-Hjt--fbIiKZ4Da3Tku5 {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: row;\n      flex-direction: row;\n  cursor: pointer;\n  border: none;\n  margin: 0;\n  padding: 0;\n  width: auto;\n  overflow: visible;\n  background: transparent;\n\n  /* inherit font & color from ancestor */\n  color: inherit;\n  font: inherit;\n  text-align: inherit;\n\n  /* Normalize `line-height`. Cannot be changed from `normal` in Firefox 4+. */\n  line-height: 24px;\n\n  /* Corrects font smoothing for webkit */\n  -webkit-font-smoothing: inherit;\n  -moz-osx-font-smoothing: inherit;\n\n  /* Corrects inability to style clickable `input` types in iOS */\n  -webkit-appearance: none;\n}\n\n.icon__touchable___3q-Hjt--fbIiKZ4Da3Tku5:focus {\n  outline: none;\n}\n\n.icon__iconLeft___2ZFDwMjpZm7twg-na5jItA {\n  margin-right: "+n(3).locals["spacing-small"]+";\n}\n\n.icon__iconRight___NsVV4m8nJ2wl_D3qHcNt4 {\n  margin-left: "+n(3).locals["spacing-small"]+";\n  -ms-flex-order: 1;\n      order: 1;\n}\n",""]),t.locals={"spacing-small":""+n(3).locals["spacing-small"],spacingSmall:""+n(3).locals["spacing-small"],icon:"icon__icon___3peb6XVBehlICUSTZCUjMX",touchable:"icon__touchable___3q-Hjt--fbIiKZ4Da3Tku5",iconLeft:"icon__iconLeft___2ZFDwMjpZm7twg-na5jItA",iconRight:"icon__iconRight___NsVV4m8nJ2wl_D3qHcNt4"}},function(e,t,n){var o,r,i={},s=(o=function(){return window&&document&&document.all&&!window.atob},function(){return void 0===r&&(r=o.apply(this,arguments)),r}),a=function(e){var t={};return function(e,n){if("function"==typeof e)return e();if(void 0===t[e]){var o=function(e,t){return t?t.querySelector(e):document.querySelector(e)}.call(this,e,n);if(window.HTMLIFrameElement&&o instanceof window.HTMLIFrameElement)try{o=o.contentDocument.head}catch(e){o=null}t[e]=o}return t[e]}}(),l=null,u=0,c=[],d=n(14);function f(e,t){for(var n=0;n<e.length;n++){var o=e[n],r=i[o.id];if(r){r.refs++;for(var s=0;s<r.parts.length;s++)r.parts[s](o.parts[s]);for(;s<o.parts.length;s++)r.parts.push(w(o.parts[s],t))}else{var a=[];for(s=0;s<o.parts.length;s++)a.push(w(o.parts[s],t));i[o.id]={id:o.id,refs:1,parts:a}}}}function v(e,t){for(var n=[],o={},r=0;r<e.length;r++){var i=e[r],s=t.base?i[0]+t.base:i[0],a={css:i[1],media:i[2],sourceMap:i[3]};o[s]?o[s].parts.push(a):n.push(o[s]={id:s,parts:[a]})}return n}function p(e,t){var n=a(e.insertInto);if(!n)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var o=c[c.length-1];if("top"===e.insertAt)o?o.nextSibling?n.insertBefore(t,o.nextSibling):n.appendChild(t):n.insertBefore(t,n.firstChild),c.push(t);else if("bottom"===e.insertAt)n.appendChild(t);else{if("object"!=typeof e.insertAt||!e.insertAt.before)throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");var r=a(e.insertAt.before,n);n.insertBefore(t,r)}}function g(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e);var t=c.indexOf(e);t>=0&&c.splice(t,1)}function h(e){var t=document.createElement("style");if(void 0===e.attrs.type&&(e.attrs.type="text/css"),void 0===e.attrs.nonce){var o=function(){0;return n.nc}();o&&(e.attrs.nonce=o)}return m(t,e.attrs),p(e,t),t}function m(e,t){Object.keys(t).forEach(function(n){e.setAttribute(n,t[n])})}function w(e,t){var n,o,r,i;if(t.transform&&e.css){if(!(i="function"==typeof t.transform?t.transform(e.css):t.transform.default(e.css)))return function(){};e.css=i}if(t.singleton){var s=u++;n=l||(l=h(t)),o=L.bind(null,n,s,!1),r=L.bind(null,n,s,!0)}else e.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(n=function(e){var t=document.createElement("link");return void 0===e.attrs.type&&(e.attrs.type="text/css"),e.attrs.rel="stylesheet",m(t,e.attrs),p(e,t),t}(t),o=function(e,t,n){var o=n.css,r=n.sourceMap,i=void 0===t.convertToAbsoluteUrls&&r;(t.convertToAbsoluteUrls||i)&&(o=d(o));r&&(o+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */");var s=new Blob([o],{type:"text/css"}),a=e.href;e.href=URL.createObjectURL(s),a&&URL.revokeObjectURL(a)}.bind(null,n,t),r=function(){g(n),n.href&&URL.revokeObjectURL(n.href)}):(n=h(t),o=function(e,t){var n=t.css,o=t.media;o&&e.setAttribute("media",o);if(e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}.bind(null,n),r=function(){g(n)});return o(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;o(e=t)}else r()}}e.exports=function(e,t){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");(t=t||{}).attrs="object"==typeof t.attrs?t.attrs:{},t.singleton||"boolean"==typeof t.singleton||(t.singleton=s()),t.insertInto||(t.insertInto="head"),t.insertAt||(t.insertAt="bottom");var n=v(e,t);return f(n,t),function(e){for(var o=[],r=0;r<n.length;r++){var s=n[r];(a=i[s.id]).refs--,o.push(a)}e&&f(v(e,t),t);for(r=0;r<o.length;r++){var a;if(0===(a=o[r]).refs){for(var l=0;l<a.parts.length;l++)a.parts[l]();delete i[a.id]}}}};var C,y=(C=[],function(e,t){return C[e]=t,C.filter(Boolean).join("\n")});function L(e,t,n,o){var r=n?"":o.css;if(e.styleSheet)e.styleSheet.cssText=y(t,r);else{var i=document.createTextNode(r),s=e.childNodes;s[t]&&e.removeChild(s[t]),s.length?e.insertBefore(i,s[t]):e.appendChild(i)}}},function(e,t){e.exports=function(e){var t="undefined"!=typeof window&&window.location;if(!t)throw new Error("fixUrls requires window.location");if(!e||"string"!=typeof e)return e;var n=t.protocol+"//"+t.host,o=n+t.pathname.replace(/\/[^\/]*$/,"/");return e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(e,t){var r,i=t.trim().replace(/^"(.*)"$/,function(e,t){return t}).replace(/^'(.*)'$/,function(e,t){return t});return/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(i)?e:(r=0===i.indexOf("//")?i:0===i.indexOf("/")?n+i:o+i.replace(/^\.\//,""),"url("+JSON.stringify(r)+")")})}},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appAccounts",use:"svg-appAccounts-usage",viewBox:"0 0 27 27",content:'<symbol viewBox="0 0 27 27" id="svg-appAccounts">\n  <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">\n    <circle cx="13.5" cy="13.5" r="13" />\n    <path d="M5.9 24s-.2-2.1 1.2-2.8 4.2-1.6 4.2-1.6-3-2.7-2.8-6 .5-5.7 5-6" />\n    <path d="M20.8 24s.2-2.1-1.1-2.8-4.2-1.6-4.2-1.6 3-2.7 2.7-6-.5-5.7-5-6" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appAvailability",use:"svg-appAvailability-usage",viewBox:"0 0 25 25",content:'<symbol viewBox="0 0 25 25" id="svg-appAvailability">\n  <path fill="currentColor" d="M23 3c.5 0 1 .4 1 .9V23c0 .5-.4 1-.9 1H2c-.5 0-1-.4-1-.9V4c0-.5.4-1 .9-1H23m0-1H2a2 2 0 0 0-2 2v19c0 1.1.9 2 2 2h21a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z" />\n  <path fill="none" stroke="currentColor" d="M1.5 10.5h22m-22 7h22m-15-6v12m8-12v12M5.5.5v4m14-4v4" />\n  <path fill="currentColor" d="M8.1 18h8.7v6H8.1z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appBilling",use:"svg-appBilling-usage",viewBox:"0 0 26 26",content:'<symbol viewBox="0 0 26 26" id="svg-appBilling">\n  <path fill="none" stroke="currentColor" d="M13 22V4" />\n  <path fill="currentColor" d="M13 0a13 13 0 1 0 13 13A13 13 0 0 0 13 0m0 1A12 12 0 1 1 1 13 12 12 0 0 1 13 1" />\n  <path fill="none" stroke="currentColor" d="M16.9 9.2A4 4 0 0 0 13 7c-2.2 0-4 1.3-4 3s1 2.7 4 3c2.8.2 4 1.3 4 3s-1.8 3-4 3a4 4 0 0 1-3.9-2.2" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appDinerCommunication",use:"svg-appDinerCommunication-usage",viewBox:"0 0 27.4 27.6",content:'<symbol viewBox="0 0 27.4 27.6" id="svg-appDinerCommunication">\n  <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10.3 19.9H1V1h25v18.9h-9.2L10.3 26v-6.1zm-4.1-9.2h14.6m-14.6 4h14.6m-14.6-8h14.6" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appGroups",use:"svg-appGroups-usage",viewBox:"0 0 29 24",content:'<symbol viewBox="0 0 29 24" id="svg-appGroups">\n  <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">\n    <path stroke-width=".8" d="M21 6a2.9 2.9 0 1 1 0 5.8A2.9 2.9 0 0 1 21 6z" />\n    <path d="M21.2 21.1h6.7v-2.6c0-2.6-1.4-4.9-3.6-6-.8.8-1.9 1.2-3.1 1.2-1.2 0-2.3-.5-3.1-1.2M11 1.4c2.3 0 4.1 1.8 4.1 4.1S13.3 9.6 11 9.6 6.9 7.8 6.9 5.5 8.7 1.4 11 1.4z" />\n    <path d="M15.5 10.5c-1.2 1.1-2.8 1.7-4.5 1.7s-3.3-.6-4.5-1.7A9.6 9.6 0 0 0 1.4 19v3.6h19.2V19c0-3.7-2.1-6.9-5.1-8.5z" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appHelp",use:"svg-appHelp-usage",viewBox:"0 0 26 26",content:'<symbol viewBox="0 0 26 26" id="svg-appHelp">\n  <path fill="none" stroke="currentColor" d="M10 8c0-1.7 1.3-2.9 3-3s3 .9 3 2.6c0 2.4-3 2.4-3 4.4v2" />\n  <path fill="currentColor" d="M14 16c0 .6-.4 1-1 1s-1-.4-1-1 .4-1 1-1 1 .4 1 1" />\n  <path fill="none" stroke="currentColor" d="M6.1 18.7A9.7 9.7 0 0 1 2 11C2 5.5 7.1 1 13.5 1S25 5.5 25 11s-5.1 10-11.5 10l-2.4-.2-5.3 3.5.3-5.6z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appMarketing",use:"svg-appMarketing-usage",viewBox:"0 0 26 20.5",content:'<symbol viewBox="0 0 26 20.5" id="svg-appMarketing">\n  <path fill="none" stroke="currentColor" d="M23.6 19.5a2 2 0 0 1-2-2v-15a2 2 0 0 1 2-2 2 2 0 0 1 2 2v15a2 2 0 0 1-2 2zm-1.9-17L3.5 8m18.2 9.5L3.5 14M2 15.5A1.5 1.5 0 0 1 .5 14V8A1.5 1.5 0 0 1 2 6.5 1.5 1.5 0 0 1 3.5 8v6A1.5 1.5 0 0 1 2 15.5zm3.5-1v1.7A2 2 0 0 0 6.7 18l4.4 1.9a1 1 0 0 0 1.4-.9v-3.5" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appPartnerServices",use:"svg-appPartnerServices-usage",viewBox:"0 0 28.5 18.5",content:'<symbol viewBox="0 0 28.5 18.5" id="svg-appPartnerServices">\n  <circle cx="9.2" cy="9.2" r="8" fill="none" stroke="currentColor" />\n  <circle cx="19.2" cy="9.2" r="8" fill="none" stroke="currentColor" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appPointOfSale",use:"svg-appPointOfSale-usage",viewBox:"0 0 27 22",content:'<symbol viewBox="0 0 27 22" id="svg-appPointOfSale">\n  <g fill="none" stroke="currentColor">\n    <rect height="19" rx="2.5" width="23" x=".5" y=".5" />\n    <rect height="1" rx=".5" transform="matrix(-1 0 0 1 25 0)" width="11" x="7" y="21.5" />\n    <path d="m25.5022642 3.50043218.0315893 6.99774732c.5389365-.0319011.9661465-.4790662.9661465-1.02601153v-4.94433594c0-.55758944-.4439997-1.01147718-.9977358-1.02739985z" fill="#fff" />\n    <rect height="15" rx=".25" width="19" x="2.5" y="2.5" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appProblemReservation",use:"svg-appProblemReservation-usage",viewBox:"0 0 25 25",content:'<symbol viewBox="0 0 25 25" id="svg-appProblemReservation">\n  <path fill="none" stroke="currentColor" d="M18 3l-5.5 2.1L.5.5v19.4l12 4.6 12-4.7V7m-12 2.5v6m0 3v1" />\n  <circle cx="22.5" cy="2.5" r="2.5" fill="#da3743" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appReporting",use:"svg-appReporting-usage",viewBox:"0 0 25 25",content:'<symbol viewBox="0 0 25 25" id="svg-appReporting">\n  <path fill="none" stroke="currentColor" d="M.5 17.5h24V.5H.5v17z" />\n  <path fill="none" stroke="currentColor" d="M2.5 15.5h20v-13h-20v13z" />\n  <path fill="none" stroke="currentColor" d="M2.5 15.5l5-6 4.6 2.6 5.4-6.6 5 6.3m-7 5.7l3 7h-12l3-7" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appReservations",use:"svg-appReservations-usage",viewBox:"0 0 25 25",content:'<symbol viewBox="0 0 25 25" id="svg-appReservations">\n  <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M24.5 19.9V.5l-12 4.7L.5.5v19.4l12 4.6 12-4.7zm-12-14.4v18.6" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appRestaurantProfile",use:"svg-appRestaurantProfile-usage",viewBox:"0 0 26 20.4",content:'<symbol viewBox="0 0 26 20.4" id="svg-appRestaurantProfile">\n  <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M20.3 9.6v7.6H10v-5" />\n  <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M22.9 6.8V4.3H.5v15.6h22.4v-7.7M17.8.5H5.7L.5 4.3h22.4L17.8.5z" />\n  <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 9.6a2.6 2.6 0 0 0 5.2 0 2.6 2.6 0 1 0 5.1 0 2.6 2.6 0 0 0 2.6 2.6 2.6 2.6 0 0 0 2.6-2.6V7H10v5.2m-4.7-.8a2 2 0 0 0-2 2v6.4h4v-6.4a2 2 0 0 0-2-2z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appReviews",use:"svg-appReviews-usage",viewBox:"0 0 23.3 23.5",content:'<symbol viewBox="0 0 23.3 23.5" id="svg-appReviews">\n  <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11.7 1L15 8.2l7.6 1.2L17 15l1.3 8-6.7-3.8L4.8 23 6 15 .7 9.4l7.5-1.2z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appSettings",use:"svg-appSettings-usage",viewBox:"0 0 25 25",content:'<symbol viewBox="0 0 25 25" id="svg-appSettings">\n  <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M23.9 4l-4.7 4.6-2.8-2.8L21 1.1a6.2 6.2 0 0 0-8.9 5.6 5.9 5.9 0 0 0 .2 1.6l-10.9 11a3 3 0 0 0 4.4 4.3l11-10.9a5.9 5.9 0 0 0 1.5.2A6.2 6.2 0 0 0 24 4z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appShiftOverview",use:"svg-appShiftOverview-usage",viewBox:"-293 384 24 25",content:'<symbol viewBox="-293 384 24 25" id="svg-appShiftOverview">\n  <g fill="none" stroke="currentColor" stroke-linecap="round">\n    <path d="M-291.5 388.5v15m21-15v15m-21 0h21m-22-17h23m-23 2h23m-23-2v2m23-2v2m-8 20l-3.5-4.5-3.5 4.5" />\n    <path stroke-linecap="square" stroke-width="2" d="M-281 384.5v1.5m-3 11v1m-3-3v3m6-3v3m6-3v3m-3-5v5" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-checkbox",use:"svg-checkbox-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-checkbox">\n  <path d="M5 3L19 3C20.1 3 21 3.9 21 5L21 19C21 20.1 20.1 21 19 21L5 21C3.9 21 3 20.1 3 19L3 5C3 3.9 3.9 3 5 3ZM5 5L5 19 19 19 19 5 5 5Z" fill="currentColor" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-checkboxIndeterminate",use:"svg-checkboxIndeterminate-usage",viewBox:"0 0 24 24",content:'<symbol viewBox="0 0 24 24" id="svg-checkboxIndeterminate">\n  <g>\n    <path fill="currentColor" fill-rule="evenodd" d="M5 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2zm3.5 8c-.3 0-.5.2-.5.5v1c0 .3.2.5.5.5h7c.3 0 .5-.2.5-.5v-1c0-.3-.2-.5-.5-.5h-7z" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-checkboxPartial",use:"svg-checkboxPartial-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-checkboxPartial">\n  <path d="M5 3L19 3C20.1 3 21 3.9 21 5L21 19C21 20.1 20.1 21 19 21L5 21C3.9 21 3 20.1 3 19L3 5C3 3.9 3.9 3 5 3ZM5 5L5 19 19 19 19 5 5 5Z" fill="currentColor" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-checkboxSelected",use:"svg-checkboxSelected-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-checkboxSelected">\n  <path d="M10.9 12.8L9.2 11C9 10.8 8.7 10.8 8.5 11L7.8 11.7C7.6 11.9 7.6 12.2 7.8 12.4L10.6 15.2C10.7 15.3 10.8 15.4 10.9 15.4 11.1 15.4 11.2 15.3 11.3 15.2L16.2 10.3C16.4 10.1 16.4 9.8 16.2 9.6L15.5 8.9C15.3 8.7 15 8.7 14.8 8.9L10.9 12.8ZM5 3L19 3C20.1 3 21 3.9 21 5L21 19C21 20.1 20.1 21 19 21L5 21C3.9 21 3 20.1 3 19L3 5C3 3.9 3.9 3 5 3Z" fill="currentColor" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-cross",use:"svg-cross-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-cross">\n  <path fill="currentColor" d="M12 10.6L16.6 6c.2-.2.5-.2.7 0l.7.7c.2.2.2.5 0 .7L13.4 12l4.6 4.6c.2.2.2.5 0 .7l-.7.7c-.2.2-.5.2-.7 0L12 13.4 7.4 18c-.2.2-.5.2-.7 0l-.7-.7a.5.5 0 0 1 0-.7l4.6-4.6L6 7.4a.5.5 0 0 1 0-.7l.7-.7c.2-.2.5-.2.7 0l4.6 4.6z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-calendar",use:"svg-calendar-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-calendar">\n  <path fill="currentColor" fill-rule="evenodd" d="M17 5h2a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7c0-1.1.9-2 2-2h2V4a1 1 0 1 1 2 0v1h6V4a1 1 0 0 1 2 0v1zm2 4V7H5v2h14zm0 2H5v8h14v-8z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-clock",use:"svg-clock-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-clock">\n  <path fill="currentColor" fill-rule="evenodd" d="M13 11h1.5a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5V11zm-1 10a9 9 0 1 1 0-18 9 9 0 0 1 0 18zm0-2a7 7 0 1 0 0-14 7 7 0 0 0 0 14z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-cancel",use:"svg-cancel-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-cancel">\n  <path fill="currentColor" fill-rule="evenodd" d="M12 10.6L9.9 8.5a1 1 0 0 0-1.4 1.4l2 2.1-2 2.1a1 1 0 0 0 1.4 1.4l2.1-2 2.1 2a1 1 0 0 0 1.4-1.4l-2-2.1 2-2.1a1 1 0 1 0-1.4-1.4l-2.1 2zM12 21a9 9 0 1 1 0-18 9 9 0 0 1 0 18z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-chevronDown",use:"svg-chevronDown-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-chevronDown">\n  <path fill="currentColor" fill-rule="evenodd" d="M12 13.4l2.5-2.5c.2-.2.5-.2.7 0l.7.7c.2.2.2.6 0 .8L13 15.2l-.7.7c-.2.2-.6.2-.8 0L8 12.4a.5.5 0 0 1 0-.8l.7-.7c.2-.2.5-.2.7 0l2.5 2.5z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-chevronLeft",use:"svg-chevronLeft-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-chevronLeft">\n  <path fill="currentColor" fill-rule="evenodd" d="M10.8 12.2l2.5 2.5c.2.2.2.5 0 .7l-.7.7c-.2.2-.5.2-.7 0L9 13.3l-.7-.7a.5.5 0 0 1 0-.7l3.5-3.5c.2-.2.5-.2.7 0l.7.7c.2.2.2.5 0 .7l-2.5 2.4z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-chevronRight",use:"svg-chevronRight-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-chevronRight">\n  <path fill="currentColor" fill-rule="evenodd" d="M12.7 12l-2.5 2.5c-.2.2-.2.5 0 .7l.7.7c.2.2.5.2.7 0l2.8-2.8.7-.8c.2-.1.2-.5 0-.7l-3.5-3.5a.5.5 0 0 0-.7 0l-.7.7c-.2.2-.2.5 0 .7l2.5 2.5z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-chevronUp",use:"svg-chevronUp-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-chevronUp">\n  <path fill="currentColor" fill-rule="evenodd" d="M12 11.6L9.5 14c-.2.2-.5.2-.7 0l-.7-.7a.5.5 0 0 1 0-.8L11 9.8l.7-.7c.2-.2.6-.2.8 0l3.5 3.5c.2.2.2.6 0 .8l-.7.7c-.2.2-.5.2-.7 0L12 11.6z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-contact",use:"svg-contact-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-contact">\n  <g fill="none">\n    <path d="M4 17L3.5 17C3.2 17 3 16.8 3 16.5L3 15.5C3 15.2 3.2 15 3.5 15L4 15 4 13 3.5 13C3.2 13 3 12.8 3 12.5L3 11.5C3 11.2 3.2 11 3.5 11L4 11 4 9 3.5 9C3.2 9 3 8.8 3 8.5L3 7.5C3 7.2 3.2 7 3.5 7L4 7 4 5C4 3.9 4.9 3 6 3L18 3C19.1 3 20 3.9 20 5L20 19C20 20.1 19.1 21 18 21L6 21C4.9 21 4 20.1 4 19L4 17ZM6 17L6 19 18 19 18 5 6 5 6 7 6.5 7C6.8 7 7 7.2 7 7.5L7 8.5C7 8.8 6.8 9 6.5 9L6 9 6 11 6.5 11C6.8 11 7 11.2 7 11.5L7 12.5C7 12.8 6.8 13 6.5 13L6 13 6 15 6.5 15C6.8 15 7 15.2 7 15.5L7 16.5C7 16.8 6.8 17 6.5 17L6 17ZM9.5 7L15.5 7C15.8 7 16 7.2 16 7.5L16 8.5C16 8.8 15.8 9 15.5 9L9.5 9C9.2 9 9 8.8 9 8.5L9 7.5C9 7.2 9.2 7 9.5 7ZM9.5 11L15.5 11C15.8 11 16 11.2 16 11.5L16 12.5C16 12.8 15.8 13 15.5 13L9.5 13C9.2 13 9 12.8 9 12.5L9 11.5C9 11.2 9.2 11 9.5 11ZM9.5 15L15.5 15C15.8 15 16 15.2 16 15.5L16 16.5C16 16.8 15.8 17 15.5 17L9.5 17C9.2 17 9 16.8 9 16.5L9 15.5C9 15.2 9.2 15 9.5 15Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-export",use:"svg-export-usage",viewBox:"0 0 24 24",content:'<symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="svg-export">\n<g id="svg-export_icon/ic_export" fill="none" fill-rule="evenodd">\n<path d="M13,6.83578644 L13,14.5 C13,14.7761424 12.7761424,15 12.5,15 L11.5,15 C11.2238576,15 11,14.7761424 11,14.5 L11,6.82106781 L9.51776695,8.30330086 C9.32250481,8.498563 9.00592231,8.498563 8.81066017,8.30330086 L8.10355339,7.59619408 C7.90829124,7.40093193 7.90829124,7.08434944 8.10355339,6.8890873 L11.6390873,3.35355339 C11.8343494,3.15829125 12.1509319,3.15829124 12.3461941,3.35355339 L13.4068542,4.41421356 L15.881728,6.8890873 C16.0769901,7.08434944 16.0769901,7.40093194 15.881728,7.59619408 L15.1746212,8.30330086 C14.9793591,8.498563 14.6627766,8.498563 14.4675144,8.30330086 L13,6.83578644 Z M18,19 L18,12 L16.5,12 C16.2238576,12 16,11.7761424 16,11.5 L16,10.5 C16,10.2238576 16.2238576,10 16.5,10 L19,10 C19.5522847,10 20,10.4477153 20,11 L20,20 C20,20.5522847 19.5522847,21 19,21 L5,21 C4.44771525,21 4,20.5522847 4,20 L4,11 C4,10.4477153 4.44771525,10 5,10 L7.5,10 C7.77614237,10 8,10.2238576 8,10.5 L8,11.5 C8,11.7761424 7.77614237,12 7.5,12 L6,12 L6,19 L18,19 Z" id="svg-export_ic_export" fill="currentColor" fill-rule="nonzero" transform="translate(12.000000, 12.103553) scale(1, -1) translate(-12.000000, -12.103553)">\n</path>\n</g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-foodAndDrink",use:"svg-foodAndDrink-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-foodAndDrink">\n  <g fill="none">\n    <path d="M9.6 4.5L9.6 9.3C9.6 9.6 9.8 9.8 10.1 9.8 10.4 9.8 10.6 9.6 10.6 9.3L10.6 4.5C11.6 4.5 12.4 5.2 12.4 6L12.4 11.3C12.4 12.1 11.6 12.8 10.6 12.8L9.6 12.8 9.6 18.8C9.6 19.2 9.2 19.5 8.7 19.5L7.8 19.5C7.2 19.5 6.8 19.2 6.8 18.8L6.8 12.8 5.9 12.8C4.8 12.8 4 12.1 4 11.3L4 6C4 5.2 4.8 4.5 5.9 4.5L5.9 9.3C5.9 9.6 6.1 9.8 6.3 9.8 6.6 9.8 6.8 9.6 6.8 9.3L6.8 4.5 7.8 4.5 7.8 9.3C7.8 9.6 8 9.8 8.2 9.8 8.5 9.8 8.7 9.6 8.7 9.3L8.7 4.5 9.6 4.5ZM14 4.9C14 4.7 14 4.5 14 4.5 16.6 4.5 19 6.3 19 8.6L19 14.3C19 15.1 17.8 15.8 16.8 15.8L16 15.8 16 18.8C16 19.2 15.6 19.5 15.1 19.5L14 19.5C14 19.5 14 19.2 14 18.8L14 4.9Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-guestRequestsFill",use:"svg-guestRequestsFill-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-guestRequestsFill">\n  <g fill="none">\n    <path d="M4.5 8C4.5 6.3 5.8 5 7.5 5L16.5 5C18.2 5 19.5 6.3 19.5 8L19.5 14C19.5 15.7 18.2 17 16.5 17L7.5 17C5.8 17 4.5 15.7 4.5 14L4.5 8ZM7.9 8.8L7.9 10.1 16.1 10.1 16.1 8.8 7.9 8.8ZM7.9 11.3L7.9 12.6 16.1 12.6 16.1 11.3 7.9 11.3ZM9.9 20C9.5 20 9.3 19.9 9.3 19.5L9.3 17 14.7 17C14.7 17 11.3 19 10.6 19.5 10.4 19.7 10.1 20 9.9 20Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-hamburger",use:"svg-hamburger-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-hamburger">\n  <path fill="currentColor" fill-rule="evenodd" d="M4.5 5h15c.3 0 .5.2.5.5v1c0 .3-.2.5-.5.5h-15a.5.5 0 0 1-.5-.5v-1c0-.3.2-.5.5-.5zm0 6h15c.3 0 .5.2.5.5v1c0 .3-.2.5-.5.5h-15a.5.5 0 0 1-.5-.5v-1c0-.3.2-.5.5-.5zm0 6h15c.3 0 .5.2.5.5v1c0 .3-.2.5-.5.5h-15a.5.5 0 0 1-.5-.5v-1c0-.3.2-.5.5-.5z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-hide",use:"svg-hide-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-hide">\n  <path fill="currentColor" fill-rule="nonzero" d="M7.7 17.7l-1.4 1.4A1 1 0 1 1 5 17.7L6 16.6A18 18 0 0 1 2.8 13a2 2 0 0 1 0-2.3C5.6 6.8 8.6 5 12 5c1.5 0 3 .4 4.5 1.2L17.7 5A1 1 0 0 1 19 6.3l-1 1c1 .9 2.1 2 3.1 3.4a2 2 0 0 1 0 2.3C18.4 17 15.3 19 12 19c-1.5 0-3-.4-4.3-1.2zM9 16.3c1 .4 1.9.6 2.9.6 2.7 0 5.3-1.5 7.5-4.4a1 1 0 0 0 0-1.2 14 14 0 0 0-2.7-2.7l-1.3 1.3c.3.6.5 1.3.5 2a4 4 0 0 1-6 3.5l-.9 1zm-1.8-1L8.6 14A4 4 0 0 1 14 8.5l1-1C14 7.1 13 7 12 7c-2.8 0-5.3 1.4-7.6 4.4a1 1 0 0 0 0 1.2c1 1.2 1.9 2.1 2.9 2.8zm5.3-5.3a2 2 0 0 0-2.5 2.5l2.5-2.5zm1.3 1.5l-2.3 2.3a2 2 0 0 0 2.3-2.3z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-information",use:"svg-information-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-information">\n  <path d="M12 3C7 3 3 7 3 12 3 17 7 21 12 21 17 21 21 17 21 12 21 7 17 3 12 3ZM12 19C8.1 19 5 15.9 5 12 5 8.1 8.1 5 12 5 15.9 5 19 8.1 19 12 19 15.9 15.9 19 12 19ZM11.5 11C11.2 11 11 11.2 11 11.5L11 15.5C11 15.8 11.2 16 11.5 16L12.5 16C12.8 16 13 15.8 13 15.5L13 11.5C13 11.2 12.8 11 12.5 11L11.5 11ZM11.5 7.5C11.2 7.5 11 7.7 11 8L11 9C11 9.3 11.2 9.5 11.5 9.5L12.5 9.5C12.8 9.5 13 9.3 13 9L13 8C13 7.7 12.8 7.5 12.5 7.5L11.5 7.5Z" fill="currentColor" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-magnifyingGlass",use:"svg-magnifyingGlass-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-magnifyingGlass">\n  <g fill="none" fill-rule="evenodd">\n    <path fill="currentColor" fill-rule="nonzero" d="M13 16v5.5c0 .3-.2.5-.5.5h-1a.5.5 0 0 1-.5-.5v-5.6a7 7 0 1 1 2 0zM12 4a5 5 0 1 0 0 10 5 5 0 0 0 0-10z" transform="rotate(-45 12 12)" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-negative",use:"svg-negative-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-negative">\n  <path fill="currentColor" fill-rule="evenodd" d="M12 21a9 9 0 1 1 0-18 9 9 0 0 1 0 18zm-.5-13c-.3 0-.5.2-.5.5v4c0 .3.2.5.5.5h1c.3 0 .5-.2.5-.5v-4c0-.3-.2-.5-.5-.5h-1zm0 7c-.3 0-.5.2-.5.5v1c0 .3.2.5.5.5h1c.3 0 .5-.2.5-.5v-1c0-.3-.2-.5-.5-.5h-1z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-notesFill",use:"svg-notesFill-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-notesFill">\n  <g fill="none">\n    <path d="M6 17L4.5 17C4.2 17 4 16.8 4 16.5L4 15.5C4 15.2 4.2 15 4.5 15L6 15 6 13 4.5 13C4.2 13 4 12.8 4 12.5L4 11.5C4 11.2 4.2 11 4.5 11L6 11 6 9 4.5 9C4.2 9 4 8.8 4 8.5L4 7.5C4 7.2 4.2 7 4.5 7L6 7 6 6C6 4.9 6.9 4 8 4L17 4C18.1 4 19 4.9 19 6L19 18C19 19.1 18.1 20 17 20L8 20C6.9 20 6 19.1 6 18L6 17ZM9.5 7C9.2 7 9 7.2 9 7.5L9 8.5C9 8.8 9.2 9 9.5 9L15.5 9C15.8 9 16 8.8 16 8.5L16 7.5C16 7.2 15.8 7 15.5 7L9.5 7ZM9.5 11C9.2 11 9 11.2 9 11.5L9 12.5C9 12.8 9.2 13 9.5 13L15.5 13C15.8 13 16 12.8 16 12.5L16 11.5C16 11.2 15.8 11 15.5 11L9.5 11ZM9.5 15C9.2 15 9 15.2 9 15.5L9 16.5C9 16.8 9.2 17 9.5 17L15.5 17C15.8 17 16 16.8 16 16.5L16 15.5C16 15.2 15.8 15 15.5 15L9.5 15Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-noiseLevel",use:"svg-noiseLevel-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-noiseLevel">\n  <g fill="none">\n    <path d="M16 4L18 4C18.3 4 18.5 4.2 18.5 4.5L18.5 19.5C18.5 19.8 18.3 20 18 20L16 20C15.7 20 15.5 19.8 15.5 19.5L15.5 4.5C15.5 4.2 15.7 4 16 4ZM11 9L13 9C13.3 9 13.5 9.2 13.5 9.5L13.5 19.5C13.5 19.8 13.3 20 13 20L11 20C10.7 20 10.5 19.8 10.5 19.5L10.5 9.5C10.5 9.2 10.7 9 11 9ZM6 14L8 14C8.3 14 8.5 14.2 8.5 14.5L8.5 19.5C8.5 19.8 8.3 20 8 20L6 20C5.7 20 5.5 19.8 5.5 19.5L5.5 14.5C5.5 14.2 5.7 14 6 14Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-partyCount",use:"svg-partyCount-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-partyCount">\n  <g fill="none">\n    <path d="M16.3 13.3C18.2 13.7 19.6 14.8 20.5 16.6 20.7 17 20.8 17.5 20.8 18 20.8 19.7 19.5 21 17.8 21L10.2 21C9.7 21 9.2 20.9 8.8 20.7 7.3 19.9 6.8 18.1 7.5 16.6 8.4 14.8 9.8 13.7 11.7 13.3 10.5 12.5 9.6 11.1 9.6 9.5L9.6 9.4C9.6 7 11.6 5 14 5 16.4 5 18.4 7 18.4 9.4L18.4 9.5C18.4 11.1 17.5 12.5 16.3 13.3ZM14 6.8C12.6 6.8 11.4 8 11.4 9.4L11.4 9.5C11.4 10.9 12.6 12.1 14 12.1 15.4 12.1 16.6 10.9 16.6 9.5L16.6 9.4C16.6 8 15.4 6.8 14 6.8ZM19.1 17.9C18.4 15.8 16.7 14.8 14 14.8 11.3 14.8 9.6 15.8 8.9 17.9L8.9 17.9C8.7 18.4 8.9 19 9.5 19.2 9.6 19.2 9.7 19.2 9.8 19.2L18.2 19.2C18.8 19.2 19.2 18.8 19.2 18.2 19.2 18.1 19.2 18 19.1 17.9Z" fill="currentColor" />\n    <path d="M6.8 15.3L5 15.3C4.7 15.3 4.5 15.2 4.2 15.2 3.2 14.8 2.7 13.6 3.1 12.6 3.8 10.7 5.1 9.5 7 9.1 5.8 8.6 5 7.4 5 6L5 5.9C5 4 6.5 2.5 8.4 2.5 9.7 2.5 10.8 3.2 11.4 4.3 11.1 4.5 10.7 4.8 10.4 5.1 10.1 4.4 9.4 3.9 8.5 3.9 7.4 3.9 6.5 4.8 6.5 5.9L6.5 6C6.5 7.1 7.4 8 8.5 8 8.6 8 8.6 8 8.6 8 8.5 8.5 8.4 9 8.4 9.5 8.4 9.7 8.4 9.8 8.4 10 6.5 10.2 5.3 11 4.6 12.6L4.6 12.6C4.4 13.2 4.7 13.7 5.2 13.9 5.3 14 5.5 14 5.6 14L8 14C7.5 14.4 7.2 14.8 6.8 15.3Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-partyCountFill",use:"svg-partyCountFill-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-partyCountFill">\n  <g fill="none">\n    <path d="M15.5 13.4C19.7 14.7 20.4 19.8 19.1 19.8 17.6 19.8 9.6 19.8 7.8 19.8 6.2 19.8 7.2 14.3 11.8 13.2 10.8 12.6 10.1 11.4 10.1 10.1L10.1 10C10.1 8 11.8 6.3 13.8 6.3 15.8 6.3 17.5 8 17.5 10L17.5 10.1C17.5 11.5 16.7 12.7 15.5 13.4ZM6.5 15L5.4 15C5.4 15 5.3 15 5.2 14.9 4.6 14.8 4.2 14.2 4.3 13.6 4.9 11.4 6.1 10.2 7.9 9.8 6.9 9.4 6.2 8.3 6.2 7.2L6.2 7.1C6.2 5.5 7.5 4.2 9.1 4.2 10.2 4.2 11.1 4.8 11.6 5.7 9.6 6.2 8.3 8 8.5 10.1L8.5 10.1C8.6 11.2 9 12.1 9.6 12.9 8.4 13.2 7.3 14 6.5 15Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-person",use:"svg-person-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-person">\n  <g fill="none">\n    <path d="M14.6 12.3C17 12.9 18.7 14.4 19.8 16.8 19.9 17.2 20 17.6 20 18 20 19.7 18.7 21 17 21L7 21C6.6 21 6.2 20.9 5.8 20.8 4.3 20.1 3.6 18.4 4.2 16.8 5.3 14.4 7 12.9 9.4 12.3 8 11.4 7 9.8 7 8 7 5.2 9.2 3 12 3 14.8 3 17 5.2 17 8 17 9.8 16 11.4 14.6 12.3ZM12 5C10.3 5 9 6.3 9 8 9 9.7 10.3 11 12 11 13.7 11 15 9.7 15 8 15 6.3 13.7 5 12 5ZM17.9 17.7C17.1 15.2 15.1 14 12 14 8.9 14 6.9 15.2 6.1 17.7L6.1 17.7C5.9 18.2 6.2 18.8 6.7 18.9 6.8 19 6.9 19 7 19L17 19C17.5 19 18 18.6 18 18 18 17.9 18 17.8 17.9 17.7Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-print",use:"svg-print-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-print">\n  <g fill="none">\n    <path d="M16 7L16 5 8 5 8 7 6 7 6 5C6 3.9 6.9 3 8 3L16 3C17.1 3 18 3.9 18 5L18 7 16 7ZM18 19C18 20.1 17.1 21 16 21L8 21C6.9 21 6 20.1 6 19L4 19C2.9 19 2 18.1 2 17L2 9C2 7.9 2.9 7 4 7L6 7 6 5C6 3.9 6.9 3 8 3L16 3C17.1 3 18 3.9 18 5L18 7 20 7C21.1 7 22 7.9 22 9L22 17C22 18.1 21.1 19 20 19L18 19ZM18 17L20 17 20 9 4 9 4 17 6 17 6 13C6 11.9 6.9 11 8 11L16 11C17.1 11 18 11.9 18 13L18 17ZM16 7L16 5 8 5 8 7 16 7ZM8 13L8 19 16 19 16 13 8 13ZM9.5 15L14.5 15C14.8 15 15 15.2 15 15.5L15 16.5C15 16.8 14.8 17 14.5 17L9.5 17C9.2 17 9 16.8 9 16.5L9 15.5C9 15.2 9.2 15 9.5 15Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-radioButton",use:"svg-radioButton-usage",viewBox:"0 0 24 24",content:'<symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="svg-radioButton">\n  <g id="svg-radioButton_icon/ic_radio" fill="none" fill-rule="evenodd">\n    <path d="M12,3 C16.9705627,3 21,7.02943725 21,12 C21,16.9705627 16.9705627,21 12,21 C7.02943725,21 3,16.9705627 3,12 C3,7.02943725 7.02943725,3 12,3 Z M12,5 C8.13400675,5 5,8.13400675 5,12 C5,15.8659932 8.13400675,19 12,19 C15.8659932,19 19,15.8659932 19,12 C19,8.13400675 15.8659932,5 12,5 Z" id="svg-radioButton_ic_radio" fill="currentColor">\n    </path>\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-radioButtonSelected",use:"svg-radioButtonSelected-usage",viewBox:"0 0 24 24",content:'<symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="svg-radioButtonSelected">\n  <g id="svg-radioButtonSelected_icon/ic_radio_selected" fill="none" fill-rule="evenodd">\n    <path d="M12,3 C16.9705627,3 21,7.02943725 21,12 C21,16.9705627 16.9705627,21 12,21 C7.02943725,21 3,16.9705627 3,12 C3,7.02943725 7.02943725,3 12,3 Z M12,9.3 C10.5088312,9.3 9.3,10.5088312 9.3,12 C9.3,13.4911688 10.5088312,14.7 12,14.7 C13.4911688,14.7 14.7,13.4911688 14.7,12 C14.7,10.5088312 13.4911688,9.3 12,9.3 Z" id="svg-radioButtonSelected_ic_radio_selected" fill="currentColor">\n    </path>\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-reveal",use:"svg-reveal-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-reveal">\n  <path fill="currentColor" fill-rule="evenodd" d="M12 19c-3.4 0-6.4-2-9.2-5.8a2 2 0 0 1 0-2.4C5.6 7 8.6 5 12 5c3.3 0 6.4 2 9.2 5.8a2 2 0 0 1 0 2.4C18.4 17 15.3 19 12 19zm0-2c2.7 0 5.3-1.5 7.5-4.4a1 1 0 0 0 0-1.2C17.3 8.4 14.7 7 12 7c-2.8 0-5.3 1.5-7.6 4.4a1 1 0 0 0 0 1.2c2.3 3 4.8 4.4 7.6 4.4zm0-9a4 4 0 1 1 0 8 4 4 0 0 1 0-8zm0 2a2 2 0 1 0 0 4 2 2 0 0 0 0-4z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-seat",use:"svg-seat-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-seat">\n  <g fill="none">\n    <path d="M8 6L16 6C17.1 6 18 6.9 18 8L18 16C18 17.1 17.1 18 16 18L8 18C6.9 18 6 17.1 6 16L6 8C6 6.9 6.9 6 8 6ZM3 8C3.6 8 4 8.4 4 9L4 15C4 15.6 3.6 16 3 16 2.4 16 2 15.6 2 15L2 9C2 8.4 2.4 8 3 8ZM9 2L15 2C15.6 2 16 2.4 16 3 16 3.6 15.6 4 15 4L9 4C8.4 4 8 3.6 8 3 8 2.4 8.4 2 9 2ZM9 20L15 20C15.6 20 16 20.4 16 21 16 21.6 15.6 22 15 22L9 22C8.4 22 8 21.6 8 21 8 20.4 8.4 20 9 20ZM21 8C21.6 8 22 8.4 22 9L22 15C22 15.6 21.6 16 21 16 20.4 16 20 15.6 20 15L20 9C20 8.4 20.4 8 21 8ZM8 8L8 16 16 16 16 8 8 8Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-seatedFill",use:"svg-seatedFill-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-seatedFill">\n  <g fill="none">\n    <path d="M9 2L15 2C15.6 2 16 2.4 16 3 16 3.6 15.6 4 15 4L9 4C8.4 4 8 3.6 8 3 8 2.4 8.4 2 9 2ZM9 20L15 20C15.6 20 16 20.4 16 21 16 21.6 15.6 22 15 22L9 22C8.4 22 8 21.6 8 21 8 20.4 8.4 20 9 20ZM3 8C3.6 8 4 8.4 4 9L4 15C4 15.6 3.6 16 3 16 2.4 16 2 15.6 2 15L2 9C2 8.4 2.4 8 3 8ZM21 8C21.6 8 22 8.4 22 9L22 15C22 15.6 21.6 16 21 16 20.4 16 20 15.6 20 15L20 9C20 8.4 20.4 8 21 8ZM8 6L16 6C17.1 6 18 6.9 18 8L18 16C18 17.1 17.1 18 16 18L8 18C6.9 18 6 17.1 6 16L6 8C6 6.9 6.9 6 8 6Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-sort",use:"svg-sort-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-sort">\n  <path d="M12 6.61L9.55 9.06C9.36 9.26 9.04 9.26 8.85 9.06L8.15 8.36C7.95 8.16 7.95 7.85 8.15 7.65L10.88 4.91C10.9 4.89 10.92 4.86 10.94 4.84L11.63 4.15C11.83 3.95 12.15 3.95 12.34 4.15L15.85 7.67C16.05 7.86 16.05 8.18 15.85 8.37L15.16 9.07C14.96 9.26 14.65 9.26 14.45 9.07L12 6.61ZM10.88 19.09L8.15 16.35C7.95 16.15 7.95 15.84 8.15 15.64L8.85 14.94C9.04 14.74 9.36 14.74 9.55 14.94L12 17.39 14.45 14.93C14.65 14.74 14.96 14.74 15.16 14.93L15.85 15.63C16.05 15.82 16.05 16.14 15.85 16.33L12.34 19.85C12.15 20.05 11.83 20.05 11.63 19.85L10.94 19.16C10.92 19.14 10.9 19.11 10.88 19.09Z" fill="currentColor" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-specialsFill",use:"svg-specialsFill-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-specialsFill">\n  <g fill="none">\n    <path d="M13.5 5.5L13.5 5C13.5 4.4 13.9 4 14.5 4 15.1 4 15.5 4.4 15.5 5L15.5 5.5C15.5 7.7 17.3 9.5 19.5 9.5L20 9.5C20.6 9.5 21 9.9 21 10.5 21 11.1 20.6 11.5 20 11.5L19.5 11.5C17.3 11.5 15.5 13.3 15.5 15.5L15.5 16C15.5 16.6 15.1 17 14.5 17 13.9 17 13.5 16.6 13.5 16L13.5 15.5C13.5 13.3 11.7 11.5 9.5 11.5L9 11.5C8.4 11.5 8 11.1 8 10.5 8 9.9 8.4 9.5 9 9.5L9.5 9.5C11.7 9.5 13.5 7.7 13.5 5.5ZM4.5 12C3.7 12 3 11.3 3 10.5 3 9.7 3.7 9 4.5 9 5.3 9 6 9.7 6 10.5 6 11.3 5.3 12 4.5 12ZM9 16L10 16C10.6 16 11 16.4 11 17 11 17.6 10.6 18 10 18L9 18 9 19C9 19.6 8.6 20 8 20 7.4 20 7 19.6 7 19L7 18 6 18C5.4 18 5 17.6 5 17 5 16.4 5.4 16 6 16L7 16 7 15C7 14.4 7.4 14 8 14 8.6 14 9 14.4 9 15L9 16Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-success",use:"svg-success-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-success">\n  <path fill="currentColor" fill-rule="evenodd" d="M11 12.9l-1.4-1.5A1 1 0 0 0 8.2 13l2.1 2a1 1 0 0 0 1.4 0l4.3-4.2a1 1 0 1 0-1.4-1.4L11 13zm1 8.1a9 9 0 1 1 0-18 9 9 0 0 1 0 18z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-switchArrows",use:"svg-switchArrows-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-switchArrows">\n  <path fill="currentcolor" fill-rule="evenodd" d="M17.6 8.9l-2-2a1 1 0 1 1 1.5-1.4L20.7 9c.2.2.3.6.3.9 0 .6-.5 1.1-1 1.1H4a1 1 0 0 1 0-2.1h13.6zM6.4 15l2 2a1 1 0 1 1-1.5 1.4L3.3 15a1 1 0 0 1-.3-.9c0-.6.5-1.1 1-1.1h16a1 1 0 0 1 0 2.1H6.3z" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-vipFill",use:"svg-vipFill-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-vipFill">\n  <g fill="none">\n    <path d="M11.5 17.5L8.7 19C8.2 19.3 7.6 19.1 7.3 18.6 7.2 18.4 7.2 18.2 7.2 18L7.8 14.5C7.8 14.2 7.7 13.9 7.5 13.7L5.1 11.1C4.7 10.7 4.7 10.1 5.1 9.7 5.2 9.6 5.4 9.5 5.6 9.5L8.9 9C9.2 8.9 9.5 8.7 9.7 8.4L11.1 5.3C11.3 4.8 11.9 4.6 12.4 4.9 12.6 4.9 12.8 5.1 12.9 5.3L14.3 8.4C14.5 8.7 14.8 8.9 15.1 9L18.4 9.5C18.9 9.5 19.3 10 19.2 10.6 19.2 10.8 19.1 11 18.9 11.1L16.5 13.7C16.3 13.9 16.2 14.2 16.2 14.5L16.8 18C16.9 18.5 16.5 19.1 16 19.1 15.7 19.2 15.5 19.1 15.3 19L12.5 17.5C12.2 17.3 11.8 17.3 11.5 17.5Z" fill="currentColor" />\n  </g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-appHome",use:"svg-appHome-usage",viewBox:"0 0 24 24",content:'<symbol viewBox="0 0 24 24" id="svg-appHome">\n  <g><path fill="currentColor" d="M23.57,10.74,12.89.82a1.33,1.33,0,0,0-1.78,0L.43,10.74A1.31,1.31,0,0,0,1.32,13H3v9a1,1,0,0,0,1,1H20a1,1,0,0,0,1-1V13h1.68A1.31,1.31,0,0,0,23.57,10.74ZM10,22V15h4v7ZM23,11.81a.27.27,0,0,1-.28.19H20V22H15V14H9v8H4V12H1.32A.27.27,0,0,1,1,11.81a.29.29,0,0,1,.07-.34L11.79,1.56a.32.32,0,0,1,.42,0l10.68,9.91A.29.29,0,0,1,23,11.81Z" /></g>\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-checkmark",use:"svg-checkmark-usage",viewBox:"0 0 24 24",content:'<symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="svg-checkmark"><defs><path d="M9.045 15.54l9.198-9.197a1 1 0 1 1 1.414 1.414l-9.853 9.854a1 1 0 0 1-1.464.053l-4.243-4.243a1 1 0 1 1 1.414-1.414l3.534 3.534z" id="svg-checkmark_a" /></defs><use fill="currentColor" fill-rule="nonzero" xlink:href="#svg-checkmark_a" /></symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-checkboxIndeterminateNew",use:"svg-checkboxIndeterminateNew-usage",viewBox:"0 0 24 24",content:'<symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="svg-checkboxIndeterminateNew"><path d="M5 19h14V5H5v14zM19 3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14zM8 17a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H8z" fill="currentColor" fill-rule="evenodd" /></symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(0),r=n.n(o),i=n(1),s=n.n(i),a=new r.a({id:"svg-question",use:"svg-question-usage",viewBox:"0 0 24 24",content:'<symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="svg-question">\n  <path fill="currentColor" fill-rule="evenodd" d="M12,3 C16.9705627,3 21,7.02943725 21,12 C21,16.9705627 16.9705627,21 12,21 C7.02943725,21 3,16.9705627 3,12 C3,7.02943725 7.02943725,3 12,3 Z M12,5 C8.13400675,5 5,8.13400675 5,12 C5,15.8659932 8.13400675,19 12,19 C15.8659932,19 19,15.8659932 19,12 C19,8.13400675 15.8659932,5 12,5 Z M11.16,13.192 C11.02,13.192 10.894,13.08 10.894,12.926 L10.894,12.338 C10.894,11.008 12.84,10.504 12.84,9.524 C12.84,9.02 12.42,8.586 11.72,8.586 C10.866,8.586 10.488,9.132 10.208,9.314 C10.096,9.384 9.998,9.384 9.9,9.3 L9.242,8.656 C9.13,8.558 9.144,8.39 9.242,8.292 C9.242,8.292 10.194,7.06 11.986,7.06 C13.456,7.06 14.702,8.04 14.702,9.412 C14.702,11.106 12.574,11.596 12.574,12.436 L12.574,12.898 C12.574,13.066 12.476,13.192 12.294,13.192 L11.16,13.192 Z M10.572,15.992 C10.572,15.362 11.09,14.83 11.72,14.83 C12.35,14.83 12.882,15.362 12.882,15.992 C12.882,16.622 12.35,17.14 11.72,17.14 C11.09,17.14 10.572,16.622 10.572,15.992 Z" id="svg-question_ic_question" />\n</symbol>'});s.a.add(a);t.default=a},function(e,t,n){"use strict";n.r(t);var o=n(7),r=n.n(o),i=n(8),s=n.n(i),a=n(2),l=n.n(a),u=n(4),c=n.n(u),d={appAccounts:n(15).default,appAvailability:n(16).default,appBilling:n(17).default,appDinerCommunication:n(18).default,appGroups:n(19).default,appHelp:n(20).default,appMarketing:n(21).default,appPartnerServices:n(22).default,appPointOfSale:n(23).default,appProblemReservation:n(24).default,appReporting:n(25).default,appReservations:n(26).default,appRestaurantProfile:n(27).default,appReviews:n(28).default,appSettings:n(29).default,appShiftOverview:n(30).default,checkbox:n(31).default,checkboxIndeterminate:n(32).default,checkboxPartial:n(33).default,checkboxSelected:n(34).default,cross:n(35).default,calendar:n(36).default,clock:n(37).default,cancel:n(38).default,chevronDown:n(39).default,chevronLeft:n(40).default,chevronRight:n(41).default,chevronUp:n(42).default,contact:n(43).default,export:n(44).default,foodAndDrink:n(45).default,guestRequestsFill:n(46).default,hamburger:n(47).default,hide:n(48).default,information:n(49).default,magnifyingGlass:n(50).default,negative:n(51).default,notesFill:n(52).default,noiseLevel:n(53).default,partyCount:n(54).default,partyCountFill:n(55).default,person:n(56).default,print:n(57).default,radioButton:n(58).default,radioButtonSelected:n(59).default,reveal:n(60).default,seat:n(61).default,seatedFill:n(62).default,sort:n(63).default,specialsFill:n(64).default,success:n(65).default,switchArrows:n(66).default,vipFill:n(67).default,appHome:n(68).default,checkmark:n(69).default,checkboxIndeterminateNew:n(70).default,question:n(71).default},f=function(e){function t(){return e.apply(this,arguments)||this}return r()(t,e),t.prototype.render=function(){var e=this.props,t=e.className,n=e.iconId,o=s()(c.a.icon,t);return l.a.createElement("svg",{"data-testid":"iconSvg",className:o,viewBox:"0 0 24 24"},l.a.createElement("use",{xlinkHref:"#svg-"+n}))},t}(l.a.Component),v=n(9),p=n.n(v),g=n(10),h=n.n(g),m=n(11),w=n.n(m).a.bind(c.a),C=l.a.forwardRef(function(e,t){var n=e.className,o=e.iconClassName,r=e.onClick,i=e.text,s=e.iconId,a=e.iconPosition,u=void 0===a?"left":a,c=h()(e,["className","iconClassName","onClick","text","iconId","iconPosition"]),d=w("touchable",n),v=w(o,{iconLeft:"left"===u,iconRight:"left"!==u});return l.a.createElement("button",p()({ref:t,className:d,onClick:r},c),l.a.createElement(f,{iconId:s,className:v}),i)});n.d(t,"icons",function(){return d}),n.d(t,"Icon",function(){return f}),n.d(t,"Touchable",function(){return C})}])});

/***/ }),

/***/ "./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var memoize = _interopDefault(__webpack_require__("./node_modules/@emotion/is-prop-valid/node_modules/@emotion/memoize/dist/memoize.browser.cjs.js"));

var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var index = memoize(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);

exports.default = index;


/***/ }),

/***/ "./node_modules/@emotion/is-prop-valid/node_modules/@emotion/memoize/dist/memoize.browser.cjs.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

exports.default = memoize;


/***/ }),

/***/ "./node_modules/@popmotion/easing/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var reversed = function (easing) { return function (p) { return 1 - easing(1 - p); }; };
var mirrored = function (easing) { return function (p) {
    return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
}; };
var createReversedEasing = reversed;
var createMirroredEasing = mirrored;
var createExpoIn = function (power) { return function (p) { return Math.pow(p, power); }; };
var createBackIn = function (power) { return function (p) {
    return p * p * ((power + 1) * p - power);
}; };
var createAnticipateEasing = function (power) {
    var backEasing = createBackIn(power);
    return function (p) {
        return (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
    };
};
var linear = function (p) { return p; };
var easeIn = createExpoIn(2);
var easeOut = reversed(easeIn);
var easeInOut = mirrored(easeIn);
var circIn = function (p) { return 1 - Math.sin(Math.acos(p)); };
var circOut = reversed(circIn);
var circInOut = mirrored(circOut);
var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = reversed(backIn);
var backInOut = mirrored(backIn);
var anticipate = createAnticipateEasing(DEFAULT_OVERSHOOT_STRENGTH);
var BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;
var BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;
var BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;
var ca = 4356.0 / 361.0;
var cb = 35442.0 / 1805.0;
var cc = 16061.0 / 1805.0;
var bounceOut = function (p) {
    var p2 = p * p;
    return p < BOUNCE_FIRST_THRESHOLD
        ? 7.5625 * p2
        : p < BOUNCE_SECOND_THRESHOLD
            ? 9.075 * p2 - 9.9 * p + 3.4
            : p < BOUNCE_THIRD_THRESHOLD
                ? ca * p2 - cb * p + cc
                : 10.8 * p * p - 20.52 * p + 10.72;
};
var bounceIn = function (p) { return 1.0 - bounceOut(1.0 - p); };
var bounceInOut = function (p) {
    return p < 0.5
        ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0))
        : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;
};
var NEWTON_ITERATIONS = 8;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var K_SPLINE_TABLE_SIZE = 11;
var K_SAMPLE_STEP_SIZE = 1.0 / (K_SPLINE_TABLE_SIZE - 1.0);
var FLOAT_32_SUPPORTED = typeof Float32Array !== 'undefined';
var a = function (a1, a2) { return 1.0 - 3.0 * a2 + 3.0 * a1; };
var b = function (a1, a2) { return 3.0 * a2 - 6.0 * a1; };
var c = function (a1) { return 3.0 * a1; };
var getSlope = function (t, a1, a2) {
    return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);
};
var calcBezier = function (t, a1, a2) {
    return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
};
function cubicBezier(mX1, mY1, mX2, mY2) {
    var sampleValues = FLOAT_32_SUPPORTED
        ? new Float32Array(K_SPLINE_TABLE_SIZE)
        : new Array(K_SPLINE_TABLE_SIZE);
    var binarySubdivide = function (aX, aA, aB) {
        var i = 0;
        var currentX;
        var currentT;
        do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) {
                aB = currentT;
            }
            else {
                aA = currentT;
            }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION &&
            ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
    };
    var newtonRaphsonIterate = function (aX, aGuessT) {
        var i = 0;
        var currentSlope = 0;
        var currentX;
        for (; i < NEWTON_ITERATIONS; ++i) {
            currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope === 0.0) {
                return aGuessT;
            }
            currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
    };
    var calcSampleValues = function () {
        for (var i = 0; i < K_SPLINE_TABLE_SIZE; ++i) {
            sampleValues[i] = calcBezier(i * K_SAMPLE_STEP_SIZE, mX1, mX2);
        }
    };
    var getTForX = function (aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = K_SPLINE_TABLE_SIZE - 1;
        var dist = 0.0;
        var guessForT = 0.0;
        var initialSlope = 0.0;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += K_SAMPLE_STEP_SIZE;
        }
        --currentSample;
        dist =
            (aX - sampleValues[currentSample]) /
                (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        guessForT = intervalStart + dist * K_SAMPLE_STEP_SIZE;
        initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT);
        }
        else if (initialSlope === 0.0) {
            return guessForT;
        }
        else {
            return binarySubdivide(aX, intervalStart, intervalStart + K_SAMPLE_STEP_SIZE);
        }
    };
    calcSampleValues();
    var resolver = function (aX) {
        var returnValue;
        if (mX1 === mY1 && mX2 === mY2) {
            returnValue = aX;
        }
        else if (aX === 0) {
            returnValue = 0;
        }
        else if (aX === 1) {
            returnValue = 1;
        }
        else {
            returnValue = calcBezier(getTForX(aX), mY1, mY2);
        }
        return returnValue;
    };
    return resolver;
}

exports.reversed = reversed;
exports.mirrored = mirrored;
exports.createReversedEasing = createReversedEasing;
exports.createMirroredEasing = createMirroredEasing;
exports.createExpoIn = createExpoIn;
exports.createBackIn = createBackIn;
exports.createAnticipateEasing = createAnticipateEasing;
exports.linear = linear;
exports.easeIn = easeIn;
exports.easeOut = easeOut;
exports.easeInOut = easeInOut;
exports.circIn = circIn;
exports.circOut = circOut;
exports.circInOut = circInOut;
exports.backIn = backIn;
exports.backOut = backOut;
exports.backInOut = backInOut;
exports.anticipate = anticipate;
exports.bounceOut = bounceOut;
exports.bounceIn = bounceIn;
exports.bounceInOut = bounceInOut;
exports.cubicBezier = cubicBezier;


/***/ }),

/***/ "./node_modules/@popmotion/popcorn/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var styleValueTypes = __webpack_require__("./node_modules/style-value-types/lib/index.js");
var heyListen = __webpack_require__("./node_modules/hey-listen/lib/index.js");
var framesync = __webpack_require__("./node_modules/framesync/lib/index.js");
var easing = __webpack_require__("./node_modules/@popmotion/easing/lib/index.js");

var zeroPoint = {
    x: 0,
    y: 0,
    z: 0
};
var isNum = function (v) { return typeof v === 'number'; };

var radiansToDegrees = (function (radians) { return (radians * 180) / Math.PI; });

var angle = (function (a, b) {
    if (b === void 0) { b = zeroPoint; }
    return radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));
});

var applyOffset = (function (from, to) {
    var hasReceivedFrom = true;
    if (to === undefined) {
        to = from;
        hasReceivedFrom = false;
    }
    return function (v) {
        if (hasReceivedFrom) {
            return v - from + to;
        }
        else {
            from = v;
            hasReceivedFrom = true;
            return to;
        }
    };
});

var curryRange = (function (func) { return function (min, max, v) { return (v !== undefined ? func(min, max, v) : function (cv) { return func(min, max, cv); }); }; });

var clamp = function (min, max, v) {
    return Math.min(Math.max(v, min), max);
};
var clamp$1 = curryRange(clamp);

var conditional = (function (check, apply) { return function (v) {
    return check(v) ? apply(v) : v;
}; });

var degreesToRadians = (function (degrees) { return (degrees * Math.PI) / 180; });

var isPoint = (function (point) {
    return point.hasOwnProperty('x') && point.hasOwnProperty('y');
});

var isPoint3D = (function (point) {
    return isPoint(point) && point.hasOwnProperty('z');
});

var distance1D = function (a, b) { return Math.abs(a - b); };
var distance = (function (a, b) {
    if (b === void 0) { b = zeroPoint; }
    if (isNum(a) && isNum(b)) {
        return distance1D(a, b);
    }
    else if (isPoint(a) && isPoint(b)) {
        var xDelta = distance1D(a.x, b.x);
        var yDelta = distance1D(a.y, b.y);
        var zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;
        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
    }
    return 0;
});

var progress = (function (from, to, value) {
    var toFromDifference = to - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
});

var mix = (function (from, to, progress) {
    return -progress * from + progress * to + from;
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var mixLinearColor = function (from, to, v) {
    var fromExpo = from * from;
    var toExpo = to * to;
    return Math.sqrt(v * (toExpo - fromExpo) + fromExpo);
};
var colorTypes = [styleValueTypes.hex, styleValueTypes.rgba, styleValueTypes.hsla];
var getColorType = function (v) {
    return colorTypes.find(function (type) { return type.test(v); });
};
var mixColor = (function (from, to) {
    var fromColorType = getColorType(from);
    var toColorType = getColorType(to);
    heyListen.invariant(fromColorType.transform === toColorType.transform, 'Both colors must be Hex and/or RGBA, or both must be HSLA');
    var fromColor = fromColorType.parse(from);
    var toColor = toColorType.parse(to);
    var blended = __assign({}, fromColor);
    var mixFunc = fromColorType === styleValueTypes.hsla ? mix : mixLinearColor;
    return function (v) {
        for (var key in blended) {
            if (key !== 'alpha') {
                blended[key] = mixFunc(fromColor[key], toColor[key], v);
            }
        }
        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);
        return fromColorType.transform(blended);
    };
});

var combineFunctions = function (a, b) { return function (v) { return b(a(v)); }; };
var pipe = (function () {
    var transformers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        transformers[_i] = arguments[_i];
    }
    return transformers.reduce(combineFunctions);
});

var mixArray = function (from, to) {
    var output = from.slice();
    var numValues = output.length;
    var blendValue = from.map(function (fromThis, i) {
        var toThis = to[i];
        if (isNum(fromThis)) {
            return function (v) { return mix(fromThis, toThis, v); };
        }
        else if (styleValueTypes.color.test(fromThis)) {
            return mixColor(fromThis, toThis);
        }
        else {
            return mixComplex(fromThis, toThis);
        }
    });
    return function (v) {
        for (var i = 0; i < numValues; i++) {
            output[i] = blendValue[i](v);
        }
        return output;
    };
};
var mixComplex = function (from, to) {
    var valueTemplate = styleValueTypes.complex.createTransformer(from);
    heyListen.invariant(valueTemplate(from) === styleValueTypes.complex.createTransformer(to)(from), "Values '" + from + "' and '" + to + "' are of different format, or a value might have changed value type.");
    return pipe(mixArray(styleValueTypes.complex.parse(from), styleValueTypes.complex.parse(to)), valueTemplate);
};

var mixNumber = function (from, to) { return function (p) { return mix(from, to, p); }; };
function detectMixerFactory(v) {
    if (typeof v === 'number') {
        return mixNumber;
    }
    if (styleValueTypes.color.test(v)) {
        return mixColor;
    }
    else {
        return mixComplex;
    }
}
function createMixers(output, ease, customMixer) {
    var mixers = [];
    var mixerFactory = customMixer || detectMixerFactory(output[0]);
    var numMixers = output.length - 1;
    for (var i = 0; i < numMixers; i++) {
        var mixer = mixerFactory(output[i], output[i + 1]);
        if (ease) {
            var easingFunction = Array.isArray(ease) ? ease[i] : ease;
            mixer = pipe(easingFunction, mixer);
        }
        mixers.push(mixer);
    }
    return mixers;
}
function fastInterpolate(_a, _b) {
    var from = _a[0], to = _a[1];
    var mixer = _b[0];
    return function (v) { return mixer(progress(from, to, v)); };
}
function slowInterpolate(input, mixers) {
    var inputLength = input.length;
    var lastInputIndex = inputLength - 1;
    return function (v) {
        var mixerIndex = 0;
        var foundMixerIndex = false;
        if (v <= input[0]) {
            foundMixerIndex = true;
        }
        else if (v >= input[lastInputIndex]) {
            mixerIndex = lastInputIndex - 1;
            foundMixerIndex = true;
        }
        if (!foundMixerIndex) {
            var i = 1;
            for (; i < inputLength; i++) {
                if (input[i] > v || i === lastInputIndex) {
                    break;
                }
            }
            mixerIndex = i - 1;
        }
        var progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);
        return mixers[mixerIndex](progressInRange);
    };
}
function interpolate(input, output, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.clamp, clamp = _c === void 0 ? true : _c, ease = _b.ease, mixer = _b.mixer;
    var inputLength = input.length;
    heyListen.invariant(inputLength === output.length, 'Both input and output ranges must be the same length');
    heyListen.invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');
    if (input[0] > input[inputLength - 1]) {
        input = [].concat(input);
        output = [].concat(output);
        input.reverse();
        output.reverse();
    }
    var mixers = createMixers(output, ease, mixer);
    var interpolator = inputLength === 2
        ? fastInterpolate(input, mixers)
        : slowInterpolate(input, mixers);
    return clamp
        ? pipe(clamp$1(input[0], input[inputLength - 1]), interpolator)
        : interpolator;
}

var pointFromVector = (function (origin, angle, distance) {
    angle = degreesToRadians(angle);
    return {
        x: distance * Math.cos(angle) + origin.x,
        y: distance * Math.sin(angle) + origin.y
    };
});

var toDecimal = (function (num, precision) {
    if (precision === void 0) { precision = 2; }
    precision = Math.pow(10, precision);
    return Math.round(num * precision) / precision;
});

var smoothFrame = (function (prevValue, nextValue, duration, smoothing) {
    if (smoothing === void 0) { smoothing = 0; }
    return toDecimal(prevValue +
        (duration * (nextValue - prevValue)) / Math.max(smoothing, duration));
});

var smooth = (function (strength) {
    if (strength === void 0) { strength = 50; }
    var previousValue = 0;
    var lastUpdated = 0;
    return function (v) {
        var currentFramestamp = framesync.getFrameData().timestamp;
        var timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;
        var newValue = timeDelta
            ? smoothFrame(previousValue, v, timeDelta, strength)
            : previousValue;
        lastUpdated = currentFramestamp;
        previousValue = newValue;
        return newValue;
    };
});

var snap = (function (points) {
    if (typeof points === 'number') {
        return function (v) { return Math.round(v / points) * points; };
    }
    else {
        var i_1 = 0;
        var numPoints_1 = points.length;
        return function (v) {
            var lastDistance = Math.abs(points[0] - v);
            for (i_1 = 1; i_1 < numPoints_1; i_1++) {
                var point = points[i_1];
                var distance = Math.abs(point - v);
                if (distance === 0)
                    return point;
                if (distance > lastDistance)
                    return points[i_1 - 1];
                if (i_1 === numPoints_1 - 1)
                    return point;
                lastDistance = distance;
            }
        };
    }
});

var identity = function (v) { return v; };
var springForce = function (alterDisplacement) {
    if (alterDisplacement === void 0) { alterDisplacement = identity; }
    return curryRange(function (constant, origin, v) {
        var displacement = origin - v;
        var springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));
        return displacement <= 0
            ? origin + springModifiedDisplacement
            : origin - springModifiedDisplacement;
    });
};
var springForceLinear = springForce();
var springForceExpo = springForce(Math.sqrt);

var velocityPerFrame = (function (xps, frameDuration) {
    return isNum(xps) ? xps / (1000 / frameDuration) : 0;
});

var velocityPerSecond = (function (velocity, frameDuration) {
    return frameDuration ? velocity * (1000 / frameDuration) : 0;
});

var wrap = function (min, max, v) {
    var rangeSize = max - min;
    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;
};
var wrap$1 = curryRange(wrap);

var clampProgress = clamp$1(0, 1);
var steps = (function (steps, direction) {
    if (direction === void 0) { direction = 'end'; }
    return function (progress) {
        progress =
            direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);
        var expanded = progress * steps;
        var rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);
        return clampProgress(rounded / steps);
    };
});

exports.createAnticipateEasing = easing.createAnticipateEasing;
exports.createBackIn = easing.createBackIn;
exports.createExpoIn = easing.createExpoIn;
exports.cubicBezier = easing.cubicBezier;
exports.linear = easing.linear;
exports.easeIn = easing.easeIn;
exports.easeOut = easing.easeOut;
exports.easeInOut = easing.easeInOut;
exports.circIn = easing.circIn;
exports.circOut = easing.circOut;
exports.circInOut = easing.circInOut;
exports.backIn = easing.backIn;
exports.backOut = easing.backOut;
exports.backInOut = easing.backInOut;
exports.anticipate = easing.anticipate;
exports.reversed = easing.reversed;
exports.mirrored = easing.mirrored;
exports.angle = angle;
exports.applyOffset = applyOffset;
exports.clamp = clamp$1;
exports.conditional = conditional;
exports.degreesToRadians = degreesToRadians;
exports.distance = distance;
exports.interpolate = interpolate;
exports.isPoint = isPoint;
exports.isPoint3D = isPoint3D;
exports.mix = mix;
exports.mixArray = mixArray;
exports.mixColor = mixColor;
exports.mixComplex = mixComplex;
exports.pipe = pipe;
exports.pointFromVector = pointFromVector;
exports.progress = progress;
exports.radiansToDegrees = radiansToDegrees;
exports.smooth = smooth;
exports.smoothFrame = smoothFrame;
exports.snap = snap;
exports.springForce = springForce;
exports.springForceExpo = springForceExpo;
exports.springForceLinear = springForceLinear;
exports.steps = steps;
exports.toDecimal = toDecimal;
exports.velocityPerFrame = velocityPerFrame;
exports.velocityPerSecond = velocityPerSecond;
exports.wrap = wrap$1;


/***/ }),

/***/ "./node_modules/classnames/bind.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(this && this[arg] || arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(this, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(this && this[key] || key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "./node_modules/classnames/index.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/d3-array/dist/d3-array.js":
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock
(function (global, factory) {
 true ? factory(exports) :
undefined;
}(this, (function (exports) { 'use strict';

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

function pairs(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
}

function pair(a, b) {
  return [a, b];
}

function cross(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function number(x) {
  return x === null ? NaN : +x;
}

function variance(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}

function deviation(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
}

function extent(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

var array = Array.prototype;

var slice = array.slice;
var map = array.map;

function constant(x) {
  return function() {
    return x;
  };
}

function identity(x) {
  return x;
}

function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function sturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

function histogram() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

function quantile(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function freedmanDiaconis(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}

function scott(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
}

function max(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

function mean(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
}

function median(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
}

function merge(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}

function min(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}

function permute(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
}

function scan(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}

function shuffle(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

function sum(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}

function transpose(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}

function length(d) {
  return d.length;
}

function zip() {
  return transpose(arguments);
}

exports.bisect = bisectRight;
exports.bisectRight = bisectRight;
exports.bisectLeft = bisectLeft;
exports.ascending = ascending;
exports.bisector = bisector;
exports.cross = cross;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.histogram = histogram;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = sturges;
exports.max = max;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = quantile;
exports.range = range;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.ticks = ticks;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/d3-collection/dist/d3-collection.js":
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org/d3-collection/ v1.0.7 Copyright 2018 Mike Bostock
(function (global, factory) {
 true ? factory(exports) :
undefined;
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function nest() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume its an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

function keys(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
}

function values(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
}

function entries(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
}

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/d3-color/dist/d3-color.js":
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org/d3-color/ v1.2.3 Copyright 2018 Mike Bostock
(function (global, factory) {
 true ? factory(exports) :
undefined;
}(this, (function (exports) { 'use strict';

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: function() {
    return this.rgb().hex();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: function() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// https://beta.observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

exports.color = color;
exports.rgb = rgb;
exports.hsl = hsl;
exports.lab = lab;
exports.hcl = hcl;
exports.lch = lch;
exports.gray = gray;
exports.cubehelix = cubehelix;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/d3-format/dist/d3-format.js":
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org/d3-format/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
 true ? factory(exports) :
undefined;
}(this, (function (exports) { 'use strict';

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  this.fill = match[1] || " ";
  this.align = match[2] || ">";
  this.sign = match[3] || "-";
  this.symbol = match[4] || "";
  this.zero = !!match[5];
  this.width = match[6] && +match[6];
  this.comma = !!match[7];
  this.precision = match[8] && +match[8].slice(1);
  this.trim = !!match[9];
  this.type = match[10] || "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

function identity(x) {
  return x;
}

var prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/d3-interpolate-path/build/d3-interpolate-path.js":
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports, __webpack_require__("./node_modules/d3-interpolate/dist/d3-interpolate.js")) :
  undefined;
}(this, (function (exports,d3Interpolate) { 'use strict';

/**
 * de Casteljau's algorithm for drawing and splitting bezier curves.
 * Inspired by https://pomax.github.io/bezierinfo/
 *
 * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]
 *   The original segment to split.
 * @param {Number} t Where to split the curve (value between [0, 1])
 * @return {Object} An object { left, right } where left is the segment from 0..t and
 *   right is the segment from t..1.
 */
function decasteljau(points, t) {
  var left = [];
  var right = [];

  function decasteljauRecurse(points, t) {
    if (points.length === 1) {
      left.push(points[0]);
      right.push(points[0]);
    } else {
      var newPoints = Array(points.length - 1);

      for (var i = 0; i < newPoints.length; i++) {
        if (i === 0) {
          left.push(points[0]);
        }
        if (i === newPoints.length - 1) {
          right.push(points[i + 1]);
        }

        newPoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];
      }

      decasteljauRecurse(newPoints, t);
    }
  }

  if (points.length) {
    decasteljauRecurse(points, t);
  }

  return { left: left, right: right.reverse() };
}

/**
 * Convert segments represented as points back into a command object
 *
 * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]
 *   Represents a segment
 * @return {Object} A command object representing the segment.
 */
function pointsToCommand(points) {
  var command = {};

  if (points.length === 4) {
    command.x2 = points[2][0];
    command.y2 = points[2][1];
  }
  if (points.length >= 3) {
    command.x1 = points[1][0];
    command.y1 = points[1][1];
  }

  command.x = points[points.length - 1][0];
  command.y = points[points.length - 1][1];

  if (points.length === 4) {
    // start, control1, control2, end
    command.type = 'C';
  } else if (points.length === 3) {
    // start, control, end
    command.type = 'Q';
  } else {
    // start, end
    command.type = 'L';
  }

  return command;
}

/**
 * Runs de Casteljau's algorithm enough times to produce the desired number of segments.
 *
 * @param {Number[][]} points Array of [x,y] points for de Casteljau (the initial segment to split)
 * @param {Number} segmentCount Number of segments to split the original into
 * @return {Number[][][]} Array of segments
 */
function splitCurveAsPoints(points, segmentCount) {
  segmentCount = segmentCount || 2;

  var segments = [];
  var remainingCurve = points;
  var tIncrement = 1 / segmentCount;

  // x-----x-----x-----x
  // t=  0.33   0.66   1
  // x-----o-----------x
  // r=  0.33
  //       x-----o-----x
  // r=         0.5  (0.33 / (1 - 0.33))  === tIncrement / (1 - (tIncrement * (i - 1))

  // x-----x-----x-----x----x
  // t=  0.25   0.5   0.75  1
  // x-----o----------------x
  // r=  0.25
  //       x-----o----------x
  // r=         0.33  (0.25 / (1 - 0.25))
  //             x-----o----x
  // r=         0.5  (0.25 / (1 - 0.5))

  for (var i = 0; i < segmentCount - 1; i++) {
    var tRelative = tIncrement / (1 - tIncrement * i);
    var split = decasteljau(remainingCurve, tRelative);
    segments.push(split.left);
    remainingCurve = split.right;
  }

  // last segment is just to the end from the last point
  segments.push(remainingCurve);

  return segments;
}

/**
 * Convert command objects to arrays of points, run de Casteljau's algorithm on it
 * to split into to the desired number of segments.
 *
 * @param {Object} commandStart The start command object
 * @param {Object} commandEnd The end command object
 * @param {Number} segmentCount The number of segments to create
 * @return {Object[]} An array of commands representing the segments in sequence
 */
function splitCurve(commandStart, commandEnd, segmentCount) {
  var points = [[commandStart.x, commandStart.y]];
  if (commandEnd.x1 != null) {
    points.push([commandEnd.x1, commandEnd.y1]);
  }
  if (commandEnd.x2 != null) {
    points.push([commandEnd.x2, commandEnd.y2]);
  }
  points.push([commandEnd.x, commandEnd.y]);

  return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * List of params for each command type in a path `d` attribute
 */
var typeMap = {
  M: ['x', 'y'],
  L: ['x', 'y'],
  H: ['x'],
  V: ['y'],
  C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],
  S: ['x2', 'y2', 'x', 'y'],
  Q: ['x1', 'y1', 'x', 'y'],
  T: ['x', 'y'],
  A: ['rx', 'ry', 'xAxisRotation', 'largeArcFlag', 'sweepFlag', 'x', 'y']
};

function arrayOfLength(length, value) {
  var array = Array(length);
  for (var i = 0; i < length; i++) {
    array[i] = value;
  }

  return array;
}

/**
 * Convert to object representation of the command from a string
 *
 * @param {String} commandString Token string from the `d` attribute (e.g., L0,0)
 * @return {Object} An object representing this command.
 */
function commandToObject(commandString) {
  // convert all spaces to commas
  commandString = commandString.trim().replace(/ /g, ',');

  var type = commandString[0];
  var args = commandString.substring(1).split(',');
  return typeMap[type.toUpperCase()].reduce(function (obj, param, i) {
    // parse X as float since we need it to do distance checks for extending points
    obj[param] = +args[i];
    return obj;
  }, { type: type });
}

/**
 * Converts a command object to a string to be used in a `d` attribute
 * @param {Object} command A command object
 * @return {String} The string for the `d` attribute
 */
function commandToString(command) {
  var type = command.type;

  var params = typeMap[type.toUpperCase()];
  return '' + type + params.map(function (p) {
    return command[p];
  }).join(',');
}

/**
 * Converts command A to have the same type as command B.
 *
 * e.g., L0,5 -> C0,5,0,5,0,5
 *
 * Uses these rules:
 * x1 <- x
 * x2 <- x
 * y1 <- y
 * y2 <- y
 * rx <- 0
 * ry <- 0
 * xAxisRotation <- read from B
 * largeArcFlag <- read from B
 * sweepflag <- read from B
 *
 * @param {Object} aCommand Command object from path `d` attribute
 * @param {Object} bCommand Command object from path `d` attribute to match against
 * @return {Object} aCommand converted to type of bCommand
 */
function convertToSameType(aCommand, bCommand) {
  var conversionMap = {
    x1: 'x',
    y1: 'y',
    x2: 'x',
    y2: 'y'
  };

  var readFromBKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag'];

  // convert (but ignore M types)
  if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== 'M') {
    (function () {
      var aConverted = {};
      Object.keys(bCommand).forEach(function (bKey) {
        var bValue = bCommand[bKey];
        // first read from the A command
        var aValue = aCommand[bKey];

        // if it is one of these values, read from B no matter what
        if (aValue === undefined) {
          if (readFromBKeys.includes(bKey)) {
            aValue = bValue;
          } else {
            // if it wasn't in the A command, see if an equivalent was
            if (aValue === undefined && conversionMap[bKey]) {
              aValue = aCommand[conversionMap[bKey]];
            }

            // if it doesn't have a converted value, use 0
            if (aValue === undefined) {
              aValue = 0;
            }
          }
        }

        aConverted[bKey] = aValue;
      });

      // update the type to match B
      aConverted.type = bCommand.type;
      aCommand = aConverted;
    })();
  }

  return aCommand;
}

/**
 * Interpolate between command objects commandStart and commandEnd segmentCount times.
 * If the types are L, Q, or C then the curves are split as per de Casteljau's algorithm.
 * Otherwise we just copy commandStart segmentCount - 1 times, finally ending with commandEnd.
 *
 * @param {Object} commandStart Command object at the beginning of the segment
 * @param {Object} commandEnd Command object at the end of the segment
 * @param {Number} segmentCount The number of segments to split this into. If only 1
 *   Then [commandEnd] is returned.
 * @return {Object[]} Array of ~segmentCount command objects between commandStart and
 *   commandEnd. (Can be segmentCount+1 objects if commandStart is type M).
 */
function splitSegment(commandStart, commandEnd, segmentCount) {
  var segments = [];

  // line, quadratic bezier, or cubic bezier
  if (commandEnd.type === 'L' || commandEnd.type === 'Q' || commandEnd.type === 'C') {
    segments = segments.concat(splitCurve(commandStart, commandEnd, segmentCount));

    // general case - just copy the same point
  } else {
    (function () {
      var copyCommand = _extends({}, commandStart);

      // convert M to L
      if (copyCommand.type === 'M') {
        copyCommand.type = 'L';
      }

      segments = segments.concat(arrayOfLength(segmentCount - 1).map(function () {
        return copyCommand;
      }));
      segments.push(commandEnd);
    })();
  }

  return segments;
}
/**
 * Extends an array of commandsToExtend to the length of the referenceCommands by
 * splitting segments until the number of commands match. Ensures all the actual
 * points of commandsToExtend are in the extended array.
 *
 * @param {Object[]} commandsToExtend The command object array to extend
 * @param {Object[]} referenceCommands The command object array to match in length
 * @param {Function} excludeSegment a function that takes a start command object and
 *   end command object and returns true if the segment should be excluded from splitting.
 * @return {Object[]} The extended commandsToExtend array
 */
function extend(commandsToExtend, referenceCommands, excludeSegment) {
  // compute insertion points:
  // number of segments in the path to extend
  var numSegmentsToExtend = commandsToExtend.length - 1;

  // number of segments in the reference path.
  var numReferenceSegments = referenceCommands.length - 1;

  // this value is always between [0, 1].
  var segmentRatio = numSegmentsToExtend / numReferenceSegments;

  // create a map, mapping segments in referenceCommands to how many points
  // should be added in that segment (should always be >= 1 since we need each
  // point itself).
  // 0 = segment 0-1, 1 = segment 1-2, n-1 = last vertex
  var countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(function (accum, d, i) {
    var insertIndex = Math.floor(segmentRatio * i);

    // handle excluding segments
    if (excludeSegment && insertIndex < commandsToExtend.length - 1 && excludeSegment(commandsToExtend[insertIndex], commandsToExtend[insertIndex + 1])) {
      // set the insertIndex to the segment that this point should be added to:

      // round the insertIndex essentially so we split half and half on
      // neighbouring segments. hence the segmentRatio * i < 0.5
      var addToPriorSegment = segmentRatio * i % 1 < 0.5;

      // only skip segment if we already have 1 point in it (can't entirely remove a segment)
      if (accum[insertIndex]) {
        // TODO - Note this is a naive algorithm that should work for most d3-area use cases
        // but if two adjacent segments are supposed to be skipped, this will not perform as
        // expected. Could be updated to search for nearest segment to place the point in, but
        // will only do that if necessary.

        // add to the prior segment
        if (addToPriorSegment) {
          if (insertIndex > 0) {
            insertIndex -= 1;

            // not possible to add to previous so adding to next
          } else if (insertIndex < commandsToExtend.length - 1) {
            insertIndex += 1;
          }
          // add to next segment
        } else if (insertIndex < commandsToExtend.length - 1) {
          insertIndex += 1;

          // not possible to add to next so adding to previous
        } else if (insertIndex > 0) {
          insertIndex -= 1;
        }
      }
    }

    accum[insertIndex] = (accum[insertIndex] || 0) + 1;

    return accum;
  }, []);

  // extend each segment to have the correct number of points for a smooth interpolation
  var extended = countPointsPerSegment.reduce(function (extended, segmentCount, i) {
    // if last command, just add `segmentCount` number of times
    if (i === commandsToExtend.length - 1) {
      var lastCommandCopies = arrayOfLength(segmentCount, _extends({}, commandsToExtend[commandsToExtend.length - 1]));

      // convert M to L
      if (lastCommandCopies[0].type === 'M') {
        lastCommandCopies.forEach(function (d) {
          d.type = 'L';
        });
      }
      return extended.concat(lastCommandCopies);
    }

    // otherwise, split the segment segmentCount times.
    return extended.concat(splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount));
  }, []);

  // add in the very first point since splitSegment only adds in the ones after it
  extended.unshift(commandsToExtend[0]);

  return extended;
}

/**
 * Normalize a path string prior to any processing.
 * Removes trailing Z, reduces consecutive spaces to a single space,
 * trims leading and trailing spaces, removes spaces following letters
 * @param {String} pathString the `d` attribute for a path
 * @return {String} The normalized path string.
 */
function normalizePathString(pathString) {
  if (pathString == null) {
    return '';
  }

  return pathString.trim().replace(/[Z]/gi, '').replace(/\s+/, ' ').replace(/([MLCSTQAHV])\s*/gi, '$1');
}

/**
 * Interpolate from A to B by extending A and B during interpolation to have
 * the same number of points. This allows for a smooth transition when they
 * have a different number of points.
 *
 * Ignores the `Z` character in paths unless both A and B end with it.
 *
 * @param {String} a The `d` attribute for a path
 * @param {String} b The `d` attribute for a path
 * @param {Function} excludeSegment a function that takes a start command object and
 *   end command object and returns true if the segment should be excluded from splitting.
 * @returns {Function} Interpolation function that maps t ([0, 1]) to a path `d` string.
 */
function interpolatePath(a, b, excludeSegment) {
  // remove Z, remove spaces after letters as seen in IE
  var aNormalized = normalizePathString(a);
  var bNormalized = normalizePathString(b);

  // split so each command (e.g. L10,20 or M50,60) is its own entry in an array
  var aPoints = aNormalized === '' ? [] : aNormalized.split(/(?=[MLCSTQAHV])/gi);
  var bPoints = bNormalized === '' ? [] : bNormalized.split(/(?=[MLCSTQAHV])/gi);

  // if both are empty, interpolation is always the empty string.
  if (!aPoints.length && !bPoints.length) {
    return function nullInterpolator() {
      return '';
    };
  }

  // if A is empty, treat it as if it used to contain just the first point
  // of B. This makes it so the line extends out of from that first point.
  if (!aPoints.length) {
    aPoints.push(bPoints[0]);

    // otherwise if B is empty, treat it as if it contains the first point
    // of A. This makes it so the line retracts into the first point.
  } else if (!bPoints.length) {
    bPoints.push(aPoints[0]);
  }

  // convert to command objects so we can match types
  var aCommands = aPoints.map(commandToObject);
  var bCommands = bPoints.map(commandToObject);

  // extend to match equal size
  var numPointsToExtend = Math.abs(bPoints.length - aPoints.length);

  if (numPointsToExtend !== 0) {
    // B has more points than A, so add points to A before interpolating
    if (bCommands.length > aCommands.length) {
      aCommands = extend(aCommands, bCommands, excludeSegment);

      // else if A has more points than B, add more points to B
    } else if (bCommands.length < aCommands.length) {
      bCommands = extend(bCommands, aCommands, excludeSegment);
    }
  }

  // commands have same length now.
  // convert commands in A to the same type as those in B
  aCommands = aCommands.map(function (aCommand, i) {
    return convertToSameType(aCommand, bCommands[i]);
  });

  // convert back to command strings and concatenate to a path `d` string
  var aProcessed = aCommands.map(commandToString).join('');
  var bProcessed = bCommands.map(commandToString).join('');

  // if both A and B end with Z add it back in
  if ((a == null || a[a.length - 1] === 'Z') && (b == null || b[b.length - 1] === 'Z')) {
    aProcessed += 'Z';
    bProcessed += 'Z';
  }

  // use d3's string interpolator to now interpolate between two path `d` strings.
  var stringInterpolator = d3Interpolate.interpolateString(aProcessed, bProcessed);

  return function pathInterpolator(t) {
    // at 1 return the final value without the extensions used during interpolation
    if (t === 1) {
      return b == null ? '' : b;
    }

    return stringInterpolator(t);
  };
}

exports.interpolatePath = interpolatePath;

Object.defineProperty(exports, '__esModule', { value: true });

})));

/***/ }),

/***/ "./node_modules/d3-interpolate/dist/d3-interpolate.js":
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org/d3-interpolate/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
 true ? factory(exports, __webpack_require__("./node_modules/d3-color/dist/d3-color.js")) :
undefined;
}(this, (function (exports,d3Color) { 'use strict';

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

function basis$1(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function constant(x) {
  return function() {
    return x;
  };
}

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = d3Color.rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

function array(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
}

function number(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function value(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb) : string)
      : b instanceof d3Color.color ? rgb
      : b instanceof Date ? date
      : Array.isArray(b) ? array
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
}

function discrete(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

function hue$1(a, b) {
  var i = hue(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}

function round(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
}

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
function zoom(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0  u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
}

function hsl(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$1 = hsl(hue);
var hslLong = hsl(nogamma);

function lab(start, end) {
  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$1 = hcl(hue);
var hclLong = hcl(nogamma);

function cubehelix(hue$$1) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue$$1((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

var cubehelix$1 = cubehelix(hue);
var cubehelixLong = cubehelix(nogamma);

function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

function quantize(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

exports.interpolate = value;
exports.interpolateArray = array;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateDate = date;
exports.interpolateDiscrete = discrete;
exports.interpolateHue = hue$1;
exports.interpolateNumber = number;
exports.interpolateObject = object;
exports.interpolateRound = round;
exports.interpolateString = string;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = zoom;
exports.interpolateRgb = rgb;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateHsl = hsl$1;
exports.interpolateHslLong = hslLong;
exports.interpolateLab = lab;
exports.interpolateHcl = hcl$1;
exports.interpolateHclLong = hclLong;
exports.interpolateCubehelix = cubehelix$1;
exports.interpolateCubehelixLong = cubehelixLong;
exports.piecewise = piecewise;
exports.quantize = quantize;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/d3-path/dist/d3-path.js":
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org/d3-path/ v1.0.7 Copyright 2018 Mike Bostock
(function (global, factory) {
 true ? factory(exports) :
undefined;
}(this, (function (exports) { 'use strict';

var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? Were done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

exports.path = path;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/d3-scale/dist/d3-scale.js":
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org/d3-scale/ v2.2.2 Copyright 2019 Mike Bostock
(function (global, factory) {
 true ? factory(exports, __webpack_require__("./node_modules/d3-collection/dist/d3-collection.js"), __webpack_require__("./node_modules/d3-array/dist/d3-array.js"), __webpack_require__("./node_modules/d3-interpolate/dist/d3-interpolate.js"), __webpack_require__("./node_modules/d3-format/dist/d3-format.js"), __webpack_require__("./node_modules/d3-time/dist/d3-time.js"), __webpack_require__("./node_modules/d3-time-format/dist/d3-time-format.js")) :
undefined;
}(this, (function (exports,d3Collection,d3Array,d3Interpolate,d3Format,d3Time,d3TimeFormat) { 'use strict';

function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.interpolator(domain); break;
    default: this.interpolator(interpolator).domain(domain); break;
  }
  return this;
}

var array = Array.prototype;

var map = array.map;
var slice = array.slice;

var implicit = {name: "implicit"};

function ordinal() {
  var index = d3Collection.map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = d3Collection.map();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = d3Array.range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

function constant(x) {
  return function() {
    return x;
  };
}

function number(x) {
  return +x;
}

var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant(isNaN(b) ? NaN : 0.5);
}

function clamper(domain) {
  var a = domain[0], b = domain[domain.length - 1], t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = d3Array.bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3Interpolate.interpolate,
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3Interpolate.interpolateNumber)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map.call(_, number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = slice.call(_), interpolate = d3Interpolate.interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous(transform, untransform) {
  return transformer()(transform, untransform);
}

function tickFormat(start, stop, count, specifier) {
  var step = d3Array.tickStep(start, stop, count),
      precision;
  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
      return d3Format.formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return d3Format.format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = d3Array.tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = d3Array.tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = d3Array.tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous(identity, identity);

  scale.copy = function() {
    return copy(scale, linear());
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

function identity$1(domain) {
  var unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map.call(_, number), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity$1(domain).unknown(unknown);
  };

  domain = arguments.length ? map.call(domain, number) : [0, 1];

  return linearish(scale);
}

function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish(transformer()).domain([1, 10]);

  scale.copy = function() {
    return copy(scale, log()).base(scale.base());
  };

  initRange.apply(scale, arguments);

  return scale;
}

function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return linearish(scale);
}

function symlog() {
  var scale = symlogish(transformer());

  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };

  return initRange.apply(scale, arguments);
}

function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(identity, identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(identity, identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return linearish(scale);
}

function pow() {
  var scale = powish(transformer());

  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };

  initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : range[d3Array.bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(linearish(scale), arguments);
}

function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number$1(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = continuous(identity, identity),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map.call(_, number$1)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

function time() {
  return initRange.apply(calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}

function utcTime() {
  return initRange.apply(calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}

function transformer$1() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = identity,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function copy$1(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = linearish(transformer$1()(identity));

  scale.copy = function() {
    return copy$1(scale, sequential());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialLog() {
  var scale = loggish(transformer$1()).domain([1, 10]);

  scale.copy = function() {
    return copy$1(scale, sequentialLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = symlogish(transformer$1());

  scale.copy = function() {
    return copy$1(scale, sequentialSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialPow() {
  var scale = powish(transformer$1());

  scale.copy = function() {
    return copy$1(scale, sequentialPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

function sequentialQuantile() {
  var domain = [],
      interpolator = identity;

  function scale(x) {
    if (!isNaN(x = +x)) return interpolator((d3Array.bisect(domain, x) - 1) / (domain.length - 1));
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return scale;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };

  return initInterpolator.apply(scale, arguments);
}

function transformer$2() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = identity,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
    return scale;
  };
}

function diverging() {
  var scale = linearish(transformer$2()(identity));

  scale.copy = function() {
    return copy$1(scale, diverging());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingLog() {
  var scale = loggish(transformer$2()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return copy$1(scale, divergingLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSymlog() {
  var scale = symlogish(transformer$2());

  scale.copy = function() {
    return copy$1(scale, divergingSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingPow() {
  var scale = powish(transformer$2());

  scale.copy = function() {
    return copy$1(scale, divergingPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

exports.scaleBand = band;
exports.scalePoint = point;
exports.scaleIdentity = identity$1;
exports.scaleLinear = linear;
exports.scaleLog = log;
exports.scaleSymlog = symlog;
exports.scaleOrdinal = ordinal;
exports.scaleImplicit = implicit;
exports.scalePow = pow;
exports.scaleSqrt = sqrt;
exports.scaleQuantile = quantile;
exports.scaleQuantize = quantize;
exports.scaleThreshold = threshold;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.scaleSequential = sequential;
exports.scaleSequentialLog = sequentialLog;
exports.scaleSequentialPow = sequentialPow;
exports.scaleSequentialSqrt = sequentialSqrt;
exports.scaleSequentialSymlog = sequentialSymlog;
exports.scaleSequentialQuantile = sequentialQuantile;
exports.scaleDiverging = diverging;
exports.scaleDivergingLog = divergingLog;
exports.scaleDivergingPow = divergingPow;
exports.scaleDivergingSqrt = divergingSqrt;
exports.scaleDivergingSymlog = divergingSymlog;
exports.tickFormat = tickFormat;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/d3-shape/dist/d3-shape.js":
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org/d3-shape/ v1.3.4 Copyright 2019 Mike Bostock
(function (global, factory) {
 true ? factory(exports, __webpack_require__("./node_modules/d3-path/dist/d3-path.js")) :
undefined;
}(this, (function (exports,d3Path) { 'use strict';

function constant(x) {
  return function constant() {
    return x;
  };
}

var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = d3Path.path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1  r0, da1  da0.
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon)) context.moveTo(x01, y01);

      // Does the sectors outer ring have rounded corners?
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and its a circular sector?
      // Or perhaps its an annular sector collapsed due to padding?
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

      // Does the sectors inner ring (or point) have rounded corners?
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

function line() {
  var x$$1 = x,
      y$$1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), line) : x$$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), line) : y$$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area() {
  var x0 = x,
      x1 = null,
      y0 = constant(0),
      y1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity(d) {
  return d;
}

function pie() {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
}

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

function lineRadial$1() {
  return lineRadial(line().curve(curveRadialLinear));
}

function areaRadial() {
  var a = area().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
}

function pointRadial(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

var slice = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x$$1 = x,
      y$$1 = y,
      context = null;

  function link() {
    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = d3Path.path();
    curve(context, +x$$1.apply(this, (argv[0] = s, argv)), +y$$1.apply(this, argv), +x$$1.apply(this, (argv[0] = t, argv)), +y$$1.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), link) : x$$1;
  };

  link.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), link) : y$$1;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$1(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial$1);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};

var cross = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

var diamond = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810,
    kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
    kx = Math.sin(tau / 10) * kr,
    ky = -Math.cos(tau / 10) * kr;

var star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

var wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

var symbols = [
  circle,
  cross,
  diamond,
  square,
  star,
  triangle,
  wye
];

function symbol() {
  var type = constant(circle),
      size = constant(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = d3Path.path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

function noop() {}

function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basis(context) {
  return new Basis(context);
}

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisClosed(context) {
  return new BasisClosed(context);
}

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisOpen(context) {
  return new BasisOpen(context);
}

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function point$1(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$1(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = (function custom(tension) {

  function cardinal$$1(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal$$1.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal$$1;
})(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = (function custom(tension) {

  function cardinal$$1(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal$$1.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal$$1;
})(0);

function point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = (function custom(alpha) {

  function catmullRom$$1(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom$$1.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom$$1;
})(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = (function custom(alpha) {

  function catmullRom$$1(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom$$1.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom$$1;
})(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

function linearClosed(context) {
  return new LinearClosed(context);
}

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bzier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function natural(context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function step(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

function none(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function none$1(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

function stackValue(d, key) {
  return d[key];
}

function stack() {
  var keys = constant([]),
      order = none$1,
      offset = none,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
  };

  return stack;
}

function expand(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none(series, order);
}

function diverging(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
}

function silhouette(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none(series, order);
}

function wiggle(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none(series, order);
}

function appearance(series) {
  var peaks = series.map(peak);
  return none$1(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
}

function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}

function ascending(series) {
  var sums = series.map(sum);
  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

function descending$1(series) {
  return ascending(series).reverse();
}

function insideOut(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum),
      order = appearance(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function reverse(series) {
  return none$1(series).reverse();
}

exports.arc = arc;
exports.area = area;
exports.line = line;
exports.pie = pie;
exports.areaRadial = areaRadial;
exports.radialArea = areaRadial;
exports.lineRadial = lineRadial$1;
exports.radialLine = lineRadial$1;
exports.pointRadial = pointRadial;
exports.linkHorizontal = linkHorizontal;
exports.linkVertical = linkVertical;
exports.linkRadial = linkRadial;
exports.symbol = symbol;
exports.symbols = symbols;
exports.symbolCircle = circle;
exports.symbolCross = cross;
exports.symbolDiamond = diamond;
exports.symbolSquare = square;
exports.symbolStar = star;
exports.symbolTriangle = triangle;
exports.symbolWye = wye;
exports.curveBasisClosed = basisClosed;
exports.curveBasisOpen = basisOpen;
exports.curveBasis = basis;
exports.curveBundle = bundle;
exports.curveCardinalClosed = cardinalClosed;
exports.curveCardinalOpen = cardinalOpen;
exports.curveCardinal = cardinal;
exports.curveCatmullRomClosed = catmullRomClosed;
exports.curveCatmullRomOpen = catmullRomOpen;
exports.curveCatmullRom = catmullRom;
exports.curveLinearClosed = linearClosed;
exports.curveLinear = curveLinear;
exports.curveMonotoneX = monotoneX;
exports.curveMonotoneY = monotoneY;
exports.curveNatural = natural;
exports.curveStep = step;
exports.curveStepAfter = stepAfter;
exports.curveStepBefore = stepBefore;
exports.stack = stack;
exports.stackOffsetExpand = expand;
exports.stackOffsetDiverging = diverging;
exports.stackOffsetNone = none;
exports.stackOffsetSilhouette = silhouette;
exports.stackOffsetWiggle = wiggle;
exports.stackOrderAppearance = appearance;
exports.stackOrderAscending = ascending;
exports.stackOrderDescending = descending$1;
exports.stackOrderInsideOut = insideOut;
exports.stackOrderNone = none$1;
exports.stackOrderReverse = reverse;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/d3-time-format/dist/d3-time-format.js":
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org/d3-time-format/ v2.1.3 Copyright 2018 Mike Bostock
(function (global, factory) {
 true ? factory(exports, __webpack_require__("./node_modules/d3-time/dist/d3-time.js")) :
undefined;
}(this, (function (exports,d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day = week.getDay();
          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.timeFormat = locale.format;
  exports.timeParse = locale.parse;
  exports.utcFormat = locale.utcFormat;
  exports.utcParse = locale.utcParse;
  return locale;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/d3-time/dist/d3-time.js":
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org/d3-time/ v1.0.11 Copyright 2019 Mike Bostock
(function (global, factory) {
 true ? factory(exports) :
undefined;
}(this, (function (exports) { 'use strict';

var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});
var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});
var minutes = minute.range;

var hour = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});
var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});
var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});
var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};
var utcYears = utcYear.range;

exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ "./node_modules/fbjs/lib/invariant.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),

/***/ "./node_modules/framesync/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var heyListen = __webpack_require__("./node_modules/hey-listen/lib/index.js");

var prevTime = 0;
var onNextFrame = typeof window !== 'undefined' && window.requestAnimationFrame !== undefined
    ? function (callback) { return window.requestAnimationFrame(callback); }
    : function (callback) {
        var timestamp = Date.now();
        var timeToCall = Math.max(0, 16.7 - (timestamp - prevTime));
        prevTime = timestamp + timeToCall;
        setTimeout(function () { return callback(prevTime); }, timeToCall);
    };

var createStep = (function (setRunNextFrame) {
    var processToRun = [];
    var processToRunNextFrame = [];
    var numThisFrame = 0;
    var isProcessing = false;
    var i = 0;
    var cancelled = new WeakSet();
    var toKeepAlive = new WeakSet();
    var renderStep = {
        cancel: function (process) {
            var indexOfCallback = processToRunNextFrame.indexOf(process);
            cancelled.add(process);
            if (indexOfCallback !== -1) {
                processToRunNextFrame.splice(indexOfCallback, 1);
            }
        },
        process: function (frame) {
            var _a;
            isProcessing = true;
            _a = [
                processToRunNextFrame,
                processToRun
            ], processToRun = _a[0], processToRunNextFrame = _a[1];
            processToRunNextFrame.length = 0;
            numThisFrame = processToRun.length;
            if (numThisFrame) {
                var process_1;
                for (i = 0; i < numThisFrame; i++) {
                    process_1 = processToRun[i];
                    process_1(frame);
                    if (toKeepAlive.has(process_1) === true && !cancelled.has(process_1)) {
                        renderStep.schedule(process_1);
                        setRunNextFrame(true);
                    }
                }
            }
            isProcessing = false;
        },
        schedule: function (process, keepAlive, immediate) {
            if (keepAlive === void 0) { keepAlive = false; }
            if (immediate === void 0) { immediate = false; }
            heyListen.invariant(typeof process === 'function', 'Argument must be a function');
            var addToCurrentBuffer = immediate && isProcessing;
            var buffer = addToCurrentBuffer ? processToRun : processToRunNextFrame;
            cancelled.delete(process);
            if (keepAlive)
                toKeepAlive.add(process);
            if (buffer.indexOf(process) === -1) {
                buffer.push(process);
                if (addToCurrentBuffer)
                    numThisFrame = processToRun.length;
            }
        }
    };
    return renderStep;
});

var StepId;
(function (StepId) {
    StepId["Read"] = "read";
    StepId["Update"] = "update";
    StepId["Render"] = "render";
    StepId["PostRender"] = "postRender";
    StepId["FixedUpdate"] = "fixedUpdate";
})(StepId || (StepId = {}));

var maxElapsed = 40;
var defaultElapsed = (1 / 60) * 1000;
var useDefaultElapsed = true;
var willRunNextFrame = false;
var isProcessing = false;
var frame = {
    delta: 0,
    timestamp: 0
};
var stepsOrder = [
    StepId.Read,
    StepId.Update,
    StepId.Render,
    StepId.PostRender
];
var setWillRunNextFrame = function (willRun) { return (willRunNextFrame = willRun); };
var _a = stepsOrder.reduce(function (acc, key) {
    var step = createStep(setWillRunNextFrame);
    acc.sync[key] = function (process, keepAlive, immediate) {
        if (keepAlive === void 0) { keepAlive = false; }
        if (immediate === void 0) { immediate = false; }
        if (!willRunNextFrame)
            startLoop();
        step.schedule(process, keepAlive, immediate);
        return process;
    };
    acc.cancelSync[key] = function (process) { return step.cancel(process); };
    acc.steps[key] = step;
    return acc;
}, {
    steps: {},
    sync: {},
    cancelSync: {}
}), steps = _a.steps, sync = _a.sync, cancelSync = _a.cancelSync;
var processStep = function (stepId) { return steps[stepId].process(frame); };
var processFrame = function (timestamp) {
    willRunNextFrame = false;
    frame.delta = useDefaultElapsed
        ? defaultElapsed
        : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
    if (!useDefaultElapsed)
        defaultElapsed = frame.delta;
    frame.timestamp = timestamp;
    isProcessing = true;
    stepsOrder.forEach(processStep);
    isProcessing = false;
    if (willRunNextFrame) {
        useDefaultElapsed = false;
        onNextFrame(processFrame);
    }
};
var startLoop = function () {
    willRunNextFrame = true;
    useDefaultElapsed = true;
    if (!isProcessing)
        onNextFrame(processFrame);
};
var getFrameData = function () { return frame; };

exports.default = sync;
exports.cancelSync = cancelSync;
exports.getFrameData = getFrameData;


/***/ }),

/***/ "./node_modules/hey-listen/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var HEY_LISTEN = 'Hey, listen! ';
exports.warning = function () { };
exports.invariant = function () { };
if (false) {}


/***/ }),

/***/ "./node_modules/lodash.flattendeep/index.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Recursively flattens `array`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flattenDeep([1, [2, [3, [4]], 5]]);
 * // => [1, 2, 3, 4, 5]
 */
function flattenDeep(array) {
  var length = array ? array.length : 0;
  return length ? baseFlatten(array, INFINITY) : [];
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = flattenDeep;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash.isequal/index.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = isEqual;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash.isobject/index.js":
/***/ (function(module, exports) {

/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash.merge/index.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  return key == '__proto__'
    ? undefined
    : object[key];
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeMax = Math.max,
    nativeNow = Date.now;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = merge;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash.range/index.js":
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

module.exports = range;


/***/ }),

/***/ "./node_modules/lodash.times/index.js":
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * Invokes the iteratee `n` times, returning an array of the results of
 * each invocation. The iteratee is invoked with one argument; (index).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * _.times(3, String);
 * // => ['0', '1', '2']
 *
 *  _.times(4, _.constant(0));
 * // => [0, 0, 0, 0]
 */
function times(n, iteratee) {
  n = toInteger(n);
  if (n < 1 || n > MAX_SAFE_INTEGER) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH,
      length = nativeMin(n, MAX_ARRAY_LENGTH);

  iteratee = typeof iteratee == 'function' ? iteratee : identity;
  n -= MAX_ARRAY_LENGTH;

  var result = baseTimes(length, iteratee);
  while (++index < n) {
    iteratee(index);
  }
  return result;
}

module.exports = times;


/***/ }),

/***/ "./node_modules/memoize-one/dist/memoize-one.cjs.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var shallowEqual = function shallowEqual(newValue, oldValue) {
  return newValue === oldValue;
};

var simpleIsEqual = function simpleIsEqual(newArgs, lastArgs) {
  return newArgs.length === lastArgs.length && newArgs.every(function (newArg, index) {
    return shallowEqual(newArg, lastArgs[index]);
  });
};

function index (resultFn, isEqual) {
  if (isEqual === void 0) {
    isEqual = simpleIsEqual;
  }

  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;

  var result = function result() {
    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      newArgs[_key] = arguments[_key];
    }

    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
      return lastResult;
    }

    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  };

  return result;
}

module.exports = index;


/***/ }),

/***/ "./node_modules/object-assign/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/otkit-colors/token.common.js":
/***/ (function(module, exports) {

module.exports = {
  greenDark: "#194829",
  fuchsiaLight: "#df4e96",
  aquaLightest: "#eefcf9",
  tealLightest: "#eef8fb",
  purpleLightest: "#f8f0fa",
  orangeDarker: "#441a0e",
  blueLightest: "#eef1fc",
  blueLight: "#6c8ae4",
  green: "#2f864d",
  violetDark: "#4d1fd6",
  orangeLighter: "#e69b84",
  tealLight: "#2b9abf",
  aquaLight: "#1fa888",
  purpleLight: "#bb6acd",
  fuchsiaLightest: "#fceef5",
  tealDark: "#154a5b",
  ashLightest: "#f1f2f4",
  purpleDark: "#7c2f8e",
  redLighter: "#eea0a5",
  aquaDark: "#0c4134",
  violetLight: "#9d82ed",
  white: "#ffffff",
  blueDark: "#2146b5",
  yellowLightest: "#fff8eb",
  yellowLighter: "#fdc958",
  fuchsiaDark: "#971c59",
  greenLight: "#39a25e",
  redLightest: "#fceeef",
  ashLighter: "#d8d9db",
  ashDark: "#2d333f",
  greenDarker: "#153c23",
  fuchsiaLighter: "#eb93bf",
  orange: "#c84f29",
  yellowDark: "#885e01",
  orangeLightest: "#fcf1ee",
  blueLighter: "#b1c1f1",
  red: "#da3743",
  violetDarker: "#1a0a47",
  tealLighter: "#61bddb",
  aquaLighter: "#3ddbb6",
  redDark: "#931b23",
  purpleLighter: "#d7a7e2",
  yellow: "#d99502",
  purpleDarker: "#36143d",
  aquaDarker: "#09342a",
  tealDarker: "#0f3643",
  violetLighter: "#d5c9f7",
  orangeDark: "#83331b",
  ash: "#6f737b",
  blueDarker: "#0d1b45",
  orangeLight: "#d86441",
  fuchsia: "#d82c82",
  fuchsiaDarker: "#450d29",
  greenLighter: "#64c987",
  greenLightest: "#f0faf3",
  blue: "#4a6fde",
  redLight: "#e15b64",
  ashDarker: "#141a26",
  yellowDarker: "#513701",
  teal: "#247f9e",
  aqua: "#18856b",
  purple: "#ad4cc3",
  yellowLight: "#fdaf08",
  violetLightest: "#f1edfc",
  violet: "#7f5ce8",
  ashLight: "#91949a",
  redDarker: "#450d10",
};

/***/ }),

/***/ "./node_modules/popmotion-pose/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var popmotion = __webpack_require__("./node_modules/popmotion-pose/node_modules/popmotion/lib/index.js");
var easing = __webpack_require__("./node_modules/@popmotion/easing/lib/index.js");
var styleValueTypes = __webpack_require__("./node_modules/style-value-types/lib/index.js");
var poseFactory = _interopDefault(__webpack_require__("./node_modules/pose-core/lib/index.js"));
var heyListen = __webpack_require__("./node_modules/hey-listen/lib/index.js");

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

var BoundingBoxDimension;
(function (BoundingBoxDimension) {
    BoundingBoxDimension["width"] = "width";
    BoundingBoxDimension["height"] = "height";
    BoundingBoxDimension["left"] = "left";
    BoundingBoxDimension["right"] = "right";
    BoundingBoxDimension["top"] = "top";
    BoundingBoxDimension["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));

var measureWithoutTransform = function (element) {
    var transform = element.style.transform;
    element.style.transform = '';
    var bbox = element.getBoundingClientRect();
    element.style.transform = transform;
    return bbox;
};
var resolveProp = function (target, props) {
    return typeof target === 'function' ? target(props) : target;
};

var interpolate = popmotion.transform.interpolate;
var singleAxisPointer = function (axis) { return function (from) {
    var _a;
    return popmotion.pointer((_a = {},
        _a[axis] = typeof from === 'string' ? parseFloat(from) : from,
        _a)).pipe(function (v) { return v[axis]; });
}; };
var pointerX = singleAxisPointer('x');
var pointerY = singleAxisPointer('y');
var createPointer = function (axisPointerCreator, min, max, measurement) { return function (transitionProps) {
    var from = transitionProps.from, type = transitionProps.type, dimensions = transitionProps.dimensions, dragBounds = transitionProps.dragBounds;
    var axisPointer = axisPointerCreator(dimensions.measurementAsPixels(measurement, from, type));
    var transformQueue = [];
    if (dragBounds) {
        var resolvedDragBounds_1 = resolveProp(dragBounds, transitionProps);
        if (resolvedDragBounds_1[min] !== undefined) {
            transformQueue.push(function (v) {
                return Math.max(v, dimensions.measurementAsPixels(measurement, resolvedDragBounds_1[min], type));
            });
        }
        if (resolvedDragBounds_1[max] !== undefined) {
            transformQueue.push(function (v) {
                return Math.min(v, dimensions.measurementAsPixels(measurement, resolvedDragBounds_1[max], type));
            });
        }
    }
    if (type === styleValueTypes.percent) {
        transformQueue.push(interpolate([0, dimensions.get(measurement)], [0, 100], { clamp: false }), function (v) { return v + '%'; });
    }
    return transformQueue.length
        ? axisPointer.pipe.apply(axisPointer, transformQueue) : axisPointer;
}; };
var just = function (from) {
    return popmotion.action(function (_a) {
        var update = _a.update, complete = _a.complete;
        update(from);
        complete();
    });
};
var underDampedSpring = function (_a) {
    var from = _a.from, velocity = _a.velocity, to = _a.to;
    return popmotion.spring({
        from: from,
        to: to,
        velocity: velocity,
        stiffness: 500,
        damping: 25,
        restDelta: 0.5,
        restSpeed: 10
    });
};
var overDampedSpring = function (_a) {
    var from = _a.from, velocity = _a.velocity, to = _a.to;
    return popmotion.spring({ from: from, to: to, velocity: velocity, stiffness: 700, damping: to === 0 ? 100 : 35 });
};
var linearTween = function (_a) {
    var from = _a.from, to = _a.to;
    return popmotion.tween({ from: from, to: to, ease: easing.linear });
};
var intelligentTransition = {
    x: underDampedSpring,
    y: underDampedSpring,
    z: underDampedSpring,
    rotate: underDampedSpring,
    rotateX: underDampedSpring,
    rotateY: underDampedSpring,
    rotateZ: underDampedSpring,
    scaleX: overDampedSpring,
    scaleY: overDampedSpring,
    scale: overDampedSpring,
    opacity: linearTween,
    default: popmotion.tween
};
var dragAction = __assign({}, intelligentTransition, { x: createPointer(pointerX, 'left', 'right', BoundingBoxDimension.width), y: createPointer(pointerY, 'top', 'bottom', BoundingBoxDimension.height) });
var justAxis = function (_a) {
    var from = _a.from;
    return just(from);
};
var intelligentDragEnd = __assign({}, intelligentTransition, { x: justAxis, y: justAxis });
var defaultTransitions = new Map([
    ['default', intelligentTransition],
    ['drag', dragAction],
    ['dragEnd', intelligentDragEnd]
]);

var animationLookup = {
    tween: popmotion.tween,
    spring: popmotion.spring,
    decay: popmotion.decay,
    keyframes: popmotion.keyframes,
    physics: popmotion.physics
};
var linear = popmotion.easing.linear, easeIn = popmotion.easing.easeIn, easeOut = popmotion.easing.easeOut, easeInOut = popmotion.easing.easeInOut, circIn = popmotion.easing.circIn, circOut = popmotion.easing.circOut, circInOut = popmotion.easing.circInOut, backIn = popmotion.easing.backIn, backOut = popmotion.easing.backOut, backInOut = popmotion.easing.backInOut, anticipate = popmotion.easing.anticipate;
var easingLookup = {
    linear: linear,
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut,
    circIn: circIn,
    circOut: circOut,
    circInOut: circInOut,
    backIn: backIn,
    backOut: backOut,
    backInOut: backInOut,
    anticipate: anticipate
};

var auto = {
    test: function (v) { return v === 'auto'; },
    parse: function (v) { return v; }
};
var valueTypeTests = [styleValueTypes.number, styleValueTypes.degrees, styleValueTypes.percent, styleValueTypes.px, styleValueTypes.vw, styleValueTypes.vh, auto];
var testValueType = function (v) { return function (type) { return type.test(v); }; };
var getValueType = function (v) { return valueTypeTests.find(testValueType(v)); };

var createPassiveValue = function (init, parent, transform) {
    var raw = popmotion.value(transform(init));
    parent.raw.subscribe(function (v) { return raw.update(transform(v)); });
    return { raw: raw };
};
var createValue = function (init) {
    var type = getValueType(init);
    var raw = popmotion.value(init);
    return { raw: raw, type: type };
};
var addActionDelay = function (delay, transition) {
    if (delay === void 0) { delay = 0; }
    return popmotion.chain(popmotion.delay(delay), transition);
};
var isCubicBezierArgs = function (args) { return typeof args[0] === 'number'; };
var getAction = function (v, _a, _b) {
    var from = _b.from, to = _b.to, velocity = _b.velocity;
    var _c = _a.type, type = _c === void 0 ? 'tween' : _c, definedEase = _a.ease, def = __rest(_a, ["type", "ease"]);
    heyListen.invariant(animationLookup[type] !== undefined, "Invalid transition type '" + type + "'. Valid transition types are: tween, spring, decay, physics and keyframes.");
    var ease;
    if (type === 'tween') {
        if (typeof definedEase !== 'function') {
            if (typeof definedEase === 'string') {
                heyListen.invariant(easingLookup[definedEase] !== undefined, "Invalid easing type '" + definedEase + "'. popmotion.io/pose/api/config");
                ease = easingLookup[definedEase];
            }
            else if (Array.isArray(definedEase) && isCubicBezierArgs(definedEase)) {
                heyListen.invariant(definedEase.length === 4, "Cubic bezier arrays must contain four numerical values.");
                var x1 = definedEase[0], y1 = definedEase[1], x2 = definedEase[2], y2 = definedEase[3];
                ease = popmotion.easing.cubicBezier(x1, y1, x2, y2);
            }
        }
    }
    ease = ease || definedEase;
    var baseProps = type !== 'keyframes'
        ? {
            from: from,
            to: to,
            velocity: velocity,
            ease: ease
        }
        : { ease: ease };
    return animationLookup[type](__assign({}, baseProps, def));
};
var isAction = function (action) {
    return typeof action.start !== 'undefined';
};
var pose = function (_a) {
    var transformPose = _a.transformPose, addListenerToValue = _a.addListenerToValue, extendAPI = _a.extendAPI, readValueFromSource = _a.readValueFromSource, posePriority = _a.posePriority, setValueNative = _a.setValueNative;
    return poseFactory({
        bindOnChange: function (values, onChange) { return function (key) {
            if (!values.has(key))
                return;
            var raw = values.get(key).raw;
            raw.subscribe(onChange[key]);
        }; },
        readValue: function (_a) {
            var raw = _a.raw;
            return raw.get();
        },
        setValue: function (_a, to) {
            var raw = _a.raw;
            return raw.update(to);
        },
        createValue: function (init, key, _a, _b) {
            var elementStyler = _a.elementStyler;
            var _c = _b === void 0 ? {} : _b, passiveParent = _c.passiveParent, passiveProps = _c.passiveProps;
            var val = passiveParent
                ? createPassiveValue(init, passiveParent, passiveProps)
                : createValue(init);
            if (addListenerToValue) {
                val.raw.subscribe(addListenerToValue(key, elementStyler));
            }
            return val;
        },
        convertValue: function (raw, key, _a) {
            var elementStyler = _a.elementStyler;
            if (addListenerToValue) {
                raw.subscribe(addListenerToValue(key, elementStyler));
            }
            return {
                raw: raw,
                type: getValueType(raw.get())
            };
        },
        getTransitionProps: function (_a, to) {
            var raw = _a.raw, type = _a.type;
            return ({
                from: raw.get(),
                velocity: raw.getVelocity(),
                to: to,
                type: type
            });
        },
        resolveTarget: function (_, to) { return to; },
        selectValueToRead: function (_a) {
            var raw = _a.raw;
            return raw;
        },
        startAction: function (_a, action, complete) {
            var raw = _a.raw;
            var reaction = {
                update: function (v) { return raw.update(v); },
                complete: complete
            };
            return action.start(reaction);
        },
        stopAction: function (action) { return action.stop(); },
        getInstantTransition: function (_, _a) {
            var to = _a.to;
            return just(to);
        },
        convertTransitionDefinition: function (val, def, props) {
            if (isAction(def))
                return def;
            var delay = def.delay, min = def.min, max = def.max, round = def.round, remainingDef = __rest(def, ["delay", "min", "max", "round"]);
            var action = getAction(val, remainingDef, props);
            var outputPipe = [];
            if (delay)
                action = addActionDelay(delay, action);
            if (min !== undefined)
                outputPipe.push(function (v) { return Math.max(v, min); });
            if (max !== undefined)
                outputPipe.push(function (v) { return Math.min(v, max); });
            if (round)
                outputPipe.push(Math.round);
            return outputPipe.length ? action.pipe.apply(action, outputPipe) : action;
        },
        setValueNative: setValueNative,
        addActionDelay: addActionDelay,
        defaultTransitions: defaultTransitions,
        transformPose: transformPose,
        readValueFromSource: readValueFromSource,
        posePriority: posePriority,
        extendAPI: extendAPI
    });
};

var createDimensions = (function (element) {
    var hasMeasured = false;
    var current = {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
    };
    return {
        get: function (measurement) { return (measurement ? current[measurement] : current); },
        measure: function () {
            current = element.getBoundingClientRect();
            hasMeasured = true;
            return current;
        },
        measurementAsPixels: function (measurement, value, type) {
            return type === styleValueTypes.percent
                ? (typeof value === 'string' ? parseFloat(value) : value) /
                    100 *
                    current[measurement]
                : value;
        },
        has: function () { return hasMeasured; }
    };
});

var makeUIEventApplicator = function (_a) {
    var startEvents = _a.startEvents, endEvents = _a.endEvents, startPose = _a.startPose, endPose = _a.endPose, startCallback = _a.startCallback, endCallback = _a.endCallback, useDocumentToEnd = _a.useDocumentToEnd, preventScroll = _a.preventScroll;
    return function (element, activeActions, poser, config) {
        var startListener = startPose + 'Start';
        var endListener = startPose + 'End';
        var moveListener = startPose + 'Move';
        if (preventScroll) {
            var touchMoveListener = popmotion.listen(element, 'touchmove', {
                passive: false
            }).start(function (e) {
                e.preventDefault();
            });
            activeActions.set(moveListener, touchMoveListener);
        }
        var eventStartListener = popmotion.listen(element, startEvents).start(function (startEvent) {
            poser.set(startPose);
            if (startCallback && config[startCallback])
                config[startCallback](startEvent);
            var eventEndListener = popmotion.listen(useDocumentToEnd ? document.documentElement : element, endEvents + (useDocumentToEnd ? ' mouseenter' : '')).start(function (endEvent) {
                if (useDocumentToEnd &&
                    endEvent.type === 'mouseenter' &&
                    endEvent.buttons === 1) {
                    return;
                }
                activeActions.get(endListener).stop();
                poser.unset(startPose);
                poser.set(endPose);
                if (endCallback && config[endCallback])
                    config[endCallback](endEvent);
            });
            activeActions.set(endListener, eventEndListener);
        });
        activeActions.set(startListener, eventStartListener);
    };
};
var events = {
    draggable: makeUIEventApplicator({
        startEvents: 'mousedown touchstart',
        endEvents: 'mouseup touchend',
        startPose: 'drag',
        endPose: 'dragEnd',
        startCallback: 'onDragStart',
        endCallback: 'onDragEnd',
        useDocumentToEnd: true,
        preventScroll: true
    }),
    hoverable: makeUIEventApplicator({
        startEvents: 'mouseenter',
        endEvents: 'mouseleave',
        startPose: 'hover',
        endPose: 'hoverEnd'
    }),
    focusable: makeUIEventApplicator({
        startEvents: 'focus',
        endEvents: 'blur',
        startPose: 'focus',
        endPose: 'blur'
    }),
    pressable: makeUIEventApplicator({
        startEvents: 'mousedown touchstart',
        endEvents: 'mouseup touchend',
        startPose: 'press',
        endPose: 'pressEnd',
        startCallback: 'onPressStart',
        endCallback: 'onPressEnd',
        useDocumentToEnd: true
    })
};
var eventKeys = Object.keys(events);
var appendEventListeners = (function (element, activeActions, poser, _a) {
    var props = _a.props;
    return eventKeys.forEach(function (key) {
        if (props[key])
            events[key](element, activeActions, poser, props);
    });
});

var ORIGIN_START = 0;
var ORIGIN_CENTER = '50%';
var ORIGIN_END = '100%';
var findCenter = function (_a) {
    var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
    return ({
        x: (left + right) / 2,
        y: (top + bottom) / 2
    });
};
var positionalProps = ['width', 'height', 'top', 'left', 'bottom', 'right'];
var positionalPropsDict = new Set(positionalProps);
var checkPositionalProp = function (key) { return positionalPropsDict.has(key); };
var hasPositionalProps = function (pose) {
    return Object.keys(pose).some(checkPositionalProp);
};
var isFlipPose = function (flip, key, state) {
    return state.props.element instanceof HTMLElement &&
        (flip === true || key === 'flip');
};
var setValue = function (_a, key, to) {
    var values = _a.values, props = _a.props;
    if (values.has(key)) {
        var raw = values.get(key).raw;
        raw.update(to);
        raw.update(to);
    }
    else {
        values.set(key, {
            raw: popmotion.value(to, function (v) { return props.elementStyler.set(key, v); })
        });
    }
};
var explicitlyFlipPose = function (state, nextPose) {
    var _a = state.props, dimensions = _a.dimensions, elementStyler = _a.elementStyler;
    dimensions.measure();
    var width = nextPose.width, height = nextPose.height, top = nextPose.top, left = nextPose.left, bottom = nextPose.bottom, right = nextPose.right, position = nextPose.position, remainingPose = __rest(nextPose, ["width", "height", "top", "left", "bottom", "right", "position"]);
    var propsToSet = positionalProps.concat('position').reduce(function (acc, key) {
        if (nextPose[key] !== undefined) {
            acc[key] = resolveProp(nextPose[key], state.props);
        }
        return acc;
    }, {});
    elementStyler.set(propsToSet).render();
    return implicitlyFlipPose(state, remainingPose);
};
var implicitlyFlipPose = function (state, nextPose) {
    var _a = state.props, dimensions = _a.dimensions, element = _a.element, elementStyler = _a.elementStyler;
    if (!dimensions.has())
        return {};
    var prev = dimensions.get();
    var next = measureWithoutTransform(element);
    var originX = prev.left === next.left
        ? ORIGIN_START
        : prev.right === next.right ? ORIGIN_END : ORIGIN_CENTER;
    var originY = prev.top === next.top
        ? ORIGIN_START
        : prev.bottom === next.bottom ? ORIGIN_END : ORIGIN_CENTER;
    elementStyler.set({ originX: originX, originY: originY });
    if (prev.width !== next.width) {
        setValue(state, 'scaleX', prev.width / next.width);
        nextPose.scaleX = 1;
    }
    if (prev.height !== next.height) {
        setValue(state, 'scaleY', prev.height / next.height);
        nextPose.scaleY = 1;
    }
    var prevCenter = findCenter(prev);
    var nextCenter = findCenter(next);
    if (originX === ORIGIN_CENTER) {
        setValue(state, 'x', prevCenter.x - nextCenter.x);
        nextPose.x = 0;
    }
    if (originY === ORIGIN_CENTER) {
        setValue(state, 'y', prevCenter.y - nextCenter.y);
        nextPose.y = 0;
    }
    elementStyler.render();
    return nextPose;
};
var flipPose = function (props, nextPose) {
    return hasPositionalProps(nextPose)
        ? explicitlyFlipPose(props, nextPose)
        : implicitlyFlipPose(props, nextPose);
};

var getPosFromMatrix = function (matrix, pos) {
    return parseFloat(matrix.split(', ')[pos]);
};
var getTranslateFromMatrix = function (pos2, pos3) { return function (element, bbox, _a) {
    var transform = _a.transform;
    if (transform === 'none')
        return 0;
    var matrix3d = transform.match(/^matrix3d\((.+)\)$/);
    if (matrix3d)
        return getPosFromMatrix(matrix3d[1], pos3);
    return getPosFromMatrix(transform.match(/^matrix\((.+)\)$/)[1], pos2);
}; };
var positionalValues = {
    width: function (element, _a) {
        var width = _a.width;
        return width;
    },
    height: function (element, _a) {
        var height = _a.height;
        return height;
    },
    top: function (element, bbox, _a) {
        var top = _a.top;
        return parseFloat(top);
    },
    left: function (element, bbox, _a) {
        var left = _a.left;
        return parseFloat(left);
    },
    bottom: function (element, _a, _b) {
        var height = _a.height;
        var top = _b.top;
        return parseFloat(top) + height;
    },
    right: function (element, _a, _b) {
        var width = _a.width;
        var left = _b.left;
        return parseFloat(left) + width;
    },
    x: getTranslateFromMatrix(4, 13),
    y: getTranslateFromMatrix(5, 14)
};
var isPositionalKey = function (v) { return positionalValues[v] !== undefined; };
var isPositional = function (pose) {
    return Object.keys(pose).some(isPositionalKey);
};
var convertPositionalUnits = function (state, nextPose) {
    var values = state.values, props = state.props;
    var element = props.element, elementStyler = props.elementStyler;
    var positionalPoseKeys = Object.keys(nextPose).filter(isPositionalKey);
    var changedPositionalKeys = [];
    var elementComputedStyle = getComputedStyle(element);
    var applyAtEndHasBeenCopied = false;
    positionalPoseKeys.forEach(function (key) {
        var value = values.get(key);
        var fromValueType = getValueType(value.raw.get());
        var to = resolveProp(nextPose[key], props);
        var toValueType = getValueType(to);
        if (fromValueType !== toValueType) {
            changedPositionalKeys.push(key);
            if (!applyAtEndHasBeenCopied) {
                applyAtEndHasBeenCopied = true;
                nextPose.applyAtEnd = nextPose.applyAtEnd
                    ? __assign({}, nextPose.applyAtEnd) : {};
            }
            nextPose.applyAtEnd[key] = nextPose.applyAtEnd[key] || nextPose[key];
            setValue(state, key, to);
        }
    });
    if (!changedPositionalKeys.length)
        return nextPose;
    var originBbox = element.getBoundingClientRect();
    var top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;
    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };
    elementStyler.render();
    var targetBbox = element.getBoundingClientRect();
    changedPositionalKeys.forEach(function (key) {
        setValue(state, key, positionalValues[key](element, originBbox, originComputedStyle));
        nextPose[key] = positionalValues[key](element, targetBbox, elementComputedStyle);
    });
    elementStyler.render();
    return nextPose;
};

var getCurrent = function (prop) { return function (_a) {
    var elementStyler = _a.elementStyler;
    return elementStyler.get(prop);
}; };
var dragPoses = function (draggable) {
    var drag = {
        preTransition: function (_a) {
            var dimensions = _a.dimensions;
            return dimensions.measure();
        }
    };
    var dragEnd = {};
    if (draggable === true || draggable === 'x') {
        drag.x = dragEnd.x = getCurrent('x');
    }
    if (draggable === true || draggable === 'y') {
        drag.y = dragEnd.y = getCurrent('y');
    }
    return { drag: drag, dragEnd: dragEnd };
};
var createPoseConfig = function (element, _a) {
    var onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, onPressStart = _a.onPressStart, onPressEnd = _a.onPressEnd, draggable = _a.draggable, hoverable = _a.hoverable, focusable = _a.focusable, pressable = _a.pressable, dragBounds = _a.dragBounds, config = __rest(_a, ["onDragStart", "onDragEnd", "onPressStart", "onPressEnd", "draggable", "hoverable", "focusable", "pressable", "dragBounds"]);
    var poseConfig = __assign({ flip: {} }, config, { props: __assign({}, config.props, { onDragStart: onDragStart,
            onDragEnd: onDragEnd,
            onPressStart: onPressStart,
            onPressEnd: onPressEnd,
            dragBounds: dragBounds,
            draggable: draggable,
            hoverable: hoverable,
            focusable: focusable,
            pressable: pressable,
            element: element, elementStyler: popmotion.styler(element, { preparseOutput: false }), dimensions: createDimensions(element) }) });
    if (draggable) {
        var _b = dragPoses(draggable), drag = _b.drag, dragEnd = _b.dragEnd;
        poseConfig.drag = __assign({}, poseConfig.drag, drag);
        poseConfig.dragEnd = __assign({}, poseConfig.dragEnd, dragEnd);
    }
    return poseConfig;
};
var domPose = pose({
    posePriority: ['drag', 'press', 'focus', 'hover'],
    transformPose: function (_a, name, state) {
        var flip = _a.flip, pose$$1 = __rest(_a, ["flip"]);
        if (isFlipPose(flip, name, state)) {
            return flipPose(state, pose$$1);
        }
        else if (isPositional(pose$$1)) {
            return convertPositionalUnits(state, pose$$1);
        }
        return pose$$1;
    },
    forceRender: function (_a) {
        var elementStyler = _a.elementStyler;
        elementStyler.render();
    },
    addListenerToValue: function (key, elementStyler) { return function (v) { return elementStyler.set(key, v); }; },
    readValueFromSource: function (key, _a) {
        var elementStyler = _a.elementStyler, dragBounds = _a.dragBounds;
        var value = elementStyler.get(key);
        if (dragBounds && (key === 'x' || key === 'y')) {
            var bound = key === 'x'
                ? dragBounds.left || dragBounds.right
                : dragBounds.top || dragBounds.bottom;
            if (bound) {
                var boundType = getValueType(bound);
                value = boundType.transform(value);
            }
        }
        return isNaN(value) ? value : parseFloat(value);
    },
    setValueNative: function (key, to, _a) {
        var elementStyler = _a.elementStyler;
        return elementStyler.set(key, to);
    },
    extendAPI: function (api, _a, config) {
        var props = _a.props, activeActions = _a.activeActions;
        var measure = props.dimensions.measure;
        var poserApi = __assign({}, api, { addChild: function (element, childConfig) {
                return api._addChild(createPoseConfig(element, childConfig), domPose);
            }, measure: measure, flip: function (op) {
                if (op) {
                    measure();
                    op();
                }
                return api.set('flip');
            } });
        props.elementStyler.render();
        appendEventListeners(props.element, activeActions, poserApi, config);
        return poserApi;
    }
});
var domPose$1 = (function (element, config) {
    return domPose(createPoseConfig(element, config));
});

exports.default = domPose$1;


/***/ }),

/***/ "./node_modules/popmotion-pose/node_modules/popmotion/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.js");
var popcorn = __webpack_require__("./node_modules/@popmotion/popcorn/lib/index.js");
var sync = __webpack_require__("./node_modules/framesync/lib/index.js");
var sync__default = _interopDefault(sync);
var styleValueTypes = __webpack_require__("./node_modules/style-value-types/lib/index.js");
var heyListen = __webpack_require__("./node_modules/hey-listen/lib/index.js");
var easing = __webpack_require__("./node_modules/@popmotion/easing/lib/index.js");
var styler = _interopDefault(__webpack_require__("./node_modules/stylefire/lib/index.js"));

var Chainable = (function () {
    function Chainable(props) {
        if (props === void 0) { props = {}; }
        this.props = props;
    }
    Chainable.prototype.applyMiddleware = function (middleware) {
        return this.create(tslib_1.__assign({}, this.props, { middleware: this.props.middleware
                ? [middleware].concat(this.props.middleware) : [middleware] }));
    };
    Chainable.prototype.pipe = function () {
        var funcs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            funcs[_i] = arguments[_i];
        }
        var pipedUpdate = funcs.length === 1 ? funcs[0] : popcorn.pipe.apply(void 0, funcs);
        return this.applyMiddleware(function (update) { return function (v) { return update(pipedUpdate(v)); }; });
    };
    Chainable.prototype.while = function (predicate) {
        return this.applyMiddleware(function (update, complete) { return function (v) {
            return predicate(v) ? update(v) : complete();
        }; });
    };
    Chainable.prototype.filter = function (predicate) {
        return this.applyMiddleware(function (update) { return function (v) { return predicate(v) && update(v); }; });
    };
    return Chainable;
}());

var Observer = (function () {
    function Observer(_a, observer) {
        var middleware = _a.middleware, onComplete = _a.onComplete;
        var _this = this;
        this.isActive = true;
        this.update = function (v) {
            if (_this.observer.update)
                _this.updateObserver(v);
        };
        this.complete = function () {
            if (_this.observer.complete && _this.isActive)
                _this.observer.complete();
            if (_this.onComplete)
                _this.onComplete();
            _this.isActive = false;
        };
        this.error = function (err) {
            if (_this.observer.error && _this.isActive)
                _this.observer.error(err);
            _this.isActive = false;
        };
        this.observer = observer;
        this.updateObserver = function (v) { return observer.update(v); };
        this.onComplete = onComplete;
        if (observer.update && middleware && middleware.length) {
            middleware.forEach(function (m) { return _this.updateObserver = m(_this.updateObserver, _this.complete); });
        }
    }
    return Observer;
}());
var createObserver = (function (observerCandidate, _a, onComplete) {
    var middleware = _a.middleware;
    if (typeof observerCandidate === 'function') {
        return new Observer({ middleware: middleware, onComplete: onComplete }, { update: observerCandidate });
    }
    else {
        return new Observer({ middleware: middleware, onComplete: onComplete }, observerCandidate);
    }
});

var Action = (function (_super) {
    tslib_1.__extends(Action, _super);
    function Action() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Action.prototype.create = function (props) {
        return new Action(props);
    };
    Action.prototype.start = function (observerCandidate) {
        if (observerCandidate === void 0) { observerCandidate = {}; }
        var isComplete = false;
        var subscription = {
            stop: function () { return undefined; }
        };
        var _a = this.props, init = _a.init, observerProps = tslib_1.__rest(_a, ["init"]);
        var observer = createObserver(observerCandidate, observerProps, function () {
            isComplete = true;
            subscription.stop();
        });
        var api = init(observer);
        subscription = api
            ? tslib_1.__assign({}, subscription, api) : subscription;
        if (observerCandidate.registerParent) {
            observerCandidate.registerParent(subscription);
        }
        if (isComplete)
            subscription.stop();
        return subscription;
    };
    return Action;
}(Chainable));
var action = (function (init) { return new Action({ init: init }); });

var BaseMulticast = (function (_super) {
    tslib_1.__extends(BaseMulticast, _super);
    function BaseMulticast() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.subscribers = [];
        return _this;
    }
    BaseMulticast.prototype.complete = function () {
        this.subscribers.forEach(function (subscriber) { return subscriber.complete(); });
    };
    BaseMulticast.prototype.error = function (err) {
        this.subscribers.forEach(function (subscriber) { return subscriber.error(err); });
    };
    BaseMulticast.prototype.update = function (v) {
        for (var i = 0; i < this.subscribers.length; i++) {
            this.subscribers[i].update(v);
        }
    };
    BaseMulticast.prototype.subscribe = function (observerCandidate) {
        var _this = this;
        var observer = createObserver(observerCandidate, this.props);
        this.subscribers.push(observer);
        var subscription = {
            unsubscribe: function () {
                var index = _this.subscribers.indexOf(observer);
                if (index !== -1)
                    _this.subscribers.splice(index, 1);
            }
        };
        return subscription;
    };
    BaseMulticast.prototype.stop = function () {
        if (this.parent)
            this.parent.stop();
    };
    BaseMulticast.prototype.registerParent = function (subscription) {
        this.stop();
        this.parent = subscription;
    };
    return BaseMulticast;
}(Chainable));

var Multicast = (function (_super) {
    tslib_1.__extends(Multicast, _super);
    function Multicast() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Multicast.prototype.create = function (props) {
        return new Multicast(props);
    };
    return Multicast;
}(BaseMulticast));
var multicast = (function () { return new Multicast(); });

var stepProgress = function (steps, progress) {
    var segment = 1 / (steps - 1);
    var subsegment = 1 / (2 * (steps - 1));
    var percentProgressOfTarget = Math.min(progress, 1);
    var subsegmentProgressOfTarget = percentProgressOfTarget / subsegment;
    var segmentProgressOfTarget = Math.floor((subsegmentProgressOfTarget + 1) / 2);
    return segmentProgressOfTarget * segment;
};

var calc = /*#__PURE__*/Object.freeze({
  angle: popcorn.angle,
  degreesToRadians: popcorn.degreesToRadians,
  distance: popcorn.distance,
  isPoint3D: popcorn.isPoint3D,
  isPoint: popcorn.isPoint,
  dilate: popcorn.mix,
  getValueFromProgress: popcorn.mix,
  pointFromAngleAndDistance: popcorn.pointFromVector,
  getProgressFromValue: popcorn.progress,
  radiansToDegrees: popcorn.radiansToDegrees,
  smooth: popcorn.smoothFrame,
  speedPerFrame: popcorn.velocityPerFrame,
  speedPerSecond: popcorn.velocityPerSecond,
  stepProgress: stepProgress
});

var isValueList = function (v) { return Array.isArray(v); };
var isSingleValue = function (v) {
    var typeOfV = typeof v;
    return typeOfV === 'string' || typeOfV === 'number';
};
var ValueReaction = (function (_super) {
    tslib_1.__extends(ValueReaction, _super);
    function ValueReaction(props) {
        var _this = _super.call(this, props) || this;
        _this.scheduleVelocityCheck = function () { return sync__default.postRender(_this.velocityCheck); };
        _this.velocityCheck = function (_a) {
            var timestamp = _a.timestamp;
            if (timestamp !== _this.lastUpdated) {
                _this.prev = _this.current;
            }
        };
        _this.prev = _this.current = props.value || 0;
        if (isSingleValue(_this.current)) {
            _this.updateCurrent = function (v) { return (_this.current = v); };
            _this.getVelocityOfCurrent = function () {
                return _this.getSingleVelocity(_this.current, _this.prev);
            };
        }
        else if (isValueList(_this.current)) {
            _this.updateCurrent = function (v) { return (_this.current = v.slice()); };
            _this.getVelocityOfCurrent = function () { return _this.getListVelocity(); };
        }
        else {
            _this.updateCurrent = function (v) {
                _this.current = {};
                for (var key in v) {
                    if (v.hasOwnProperty(key)) {
                        _this.current[key] = v[key];
                    }
                }
            };
            _this.getVelocityOfCurrent = function () { return _this.getMapVelocity(); };
        }
        if (props.initialSubscription)
            _this.subscribe(props.initialSubscription);
        return _this;
    }
    ValueReaction.prototype.create = function (props) {
        return new ValueReaction(props);
    };
    ValueReaction.prototype.get = function () {
        return this.current;
    };
    ValueReaction.prototype.getVelocity = function () {
        return this.getVelocityOfCurrent();
    };
    ValueReaction.prototype.update = function (v) {
        _super.prototype.update.call(this, v);
        this.prev = this.current;
        this.updateCurrent(v);
        var _a = sync.getFrameData(), delta = _a.delta, timestamp = _a.timestamp;
        this.timeDelta = delta;
        this.lastUpdated = timestamp;
        sync__default.postRender(this.scheduleVelocityCheck);
    };
    ValueReaction.prototype.subscribe = function (observerCandidate) {
        var sub = _super.prototype.subscribe.call(this, observerCandidate);
        this.subscribers[this.subscribers.length - 1].update(this.current);
        return sub;
    };
    ValueReaction.prototype.getSingleVelocity = function (current, prev) {
        return typeof current === 'number' && typeof prev === 'number'
            ? popcorn.velocityPerSecond(current - prev, this.timeDelta)
            : popcorn.velocityPerSecond(parseFloat(current) - parseFloat(prev), this.timeDelta) || 0;
    };
    ValueReaction.prototype.getListVelocity = function () {
        var _this = this;
        return this.current.map(function (c, i) {
            return _this.getSingleVelocity(c, _this.prev[i]);
        });
    };
    ValueReaction.prototype.getMapVelocity = function () {
        var velocity = {};
        for (var key in this.current) {
            if (this.current.hasOwnProperty(key)) {
                velocity[key] = this.getSingleVelocity(this.current[key], this.prev[key]);
            }
        }
        return velocity;
    };
    return ValueReaction;
}(BaseMulticast));
var value = (function (value, initialSubscription) {
    return new ValueReaction({ value: value, initialSubscription: initialSubscription });
});

var multi = function (_a) {
    var getCount = _a.getCount, getFirst = _a.getFirst, getOutput = _a.getOutput, mapApi = _a.mapApi, setProp = _a.setProp, startActions = _a.startActions;
    return function (actions) {
        return action(function (_a) {
            var update = _a.update, complete = _a.complete, error = _a.error;
            var numActions = getCount(actions);
            var output = getOutput();
            var updateOutput = function () { return update(output); };
            var numCompletedActions = 0;
            var subs = startActions(actions, function (a, name) {
                var hasCompleted = false;
                return a.start({
                    complete: function () {
                        if (!hasCompleted) {
                            hasCompleted = true;
                            numCompletedActions++;
                            if (numCompletedActions === numActions)
                                sync__default.update(complete);
                        }
                    },
                    error: error,
                    update: function (v) {
                        setProp(output, name, v);
                        sync__default.update(updateOutput, false, true);
                    }
                });
            });
            return Object.keys(getFirst(subs)).reduce(function (api, methodName) {
                api[methodName] = mapApi(subs, methodName);
                return api;
            }, {});
        });
    };
};

var composite = multi({
    getOutput: function () { return ({}); },
    getCount: function (subs) { return Object.keys(subs).length; },
    getFirst: function (subs) { return subs[Object.keys(subs)[0]]; },
    mapApi: function (subs, methodName) { return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return Object.keys(subs)
            .reduce(function (output, propKey) {
            var _a;
            if (subs[propKey][methodName]) {
                (args[0] && args[0][propKey] !== undefined)
                    ? output[propKey] = subs[propKey][methodName](args[0][propKey])
                    : output[propKey] = (_a = subs[propKey])[methodName].apply(_a, args);
            }
            return output;
        }, {});
    }; },
    setProp: function (output, name, v) { return output[name] = v; },
    startActions: function (actions, starter) { return Object.keys(actions)
        .reduce(function (subs, key) {
        subs[key] = starter(actions[key], key);
        return subs;
    }, {}); }
});

var parallel = multi({
    getOutput: function () { return ([]); },
    getCount: function (subs) { return subs.length; },
    getFirst: function (subs) { return subs[0]; },
    mapApi: function (subs, methodName) { return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return subs.map(function (sub, i) {
            if (sub[methodName]) {
                return Array.isArray(args[0])
                    ? sub[methodName](args[0][i])
                    : sub[methodName].apply(sub, args);
            }
        });
    }; },
    setProp: function (output, name, v) { return output[name] = v; },
    startActions: function (actions, starter) { return actions.map(function (action, i) { return starter(action, i); }); }
});
var parallel$1 = (function () {
    var actions = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        actions[_i] = arguments[_i];
    }
    return parallel(actions);
});

var createVectorTests = function (typeTests) {
    var testNames = Object.keys(typeTests);
    var isVectorProp = function (prop, key) {
        return prop !== undefined && !typeTests[key](prop);
    };
    var getVectorKeys = function (props) {
        return testNames.reduce(function (vectorKeys, key) {
            if (isVectorProp(props[key], key))
                vectorKeys.push(key);
            return vectorKeys;
        }, []);
    };
    var testVectorProps = function (props) {
        return props && testNames.some(function (key) { return isVectorProp(props[key], key); });
    };
    return { getVectorKeys: getVectorKeys, testVectorProps: testVectorProps };
};
var unitTypes = [styleValueTypes.px, styleValueTypes.percent, styleValueTypes.degrees, styleValueTypes.vh, styleValueTypes.vw];
var findUnitType = function (prop) { return unitTypes.find(function (type) { return type.test(prop); }); };
var isUnitProp = function (prop) { return Boolean(findUnitType(prop)); };
var createAction = function (action, props) { return action(props); };
var reduceArrayValue = function (i) { return function (props, key) {
    props[key] = props[key][i];
    return props;
}; };
var createArrayAction = function (action, props, vectorKeys) {
    var firstVectorKey = vectorKeys[0];
    var actionList = props[firstVectorKey].map(function (v, i) {
        var childActionProps = vectorKeys.reduce(reduceArrayValue(i), tslib_1.__assign({}, props));
        return getActionCreator(v)(action, childActionProps);
    });
    return parallel$1.apply(void 0, actionList);
};
var reduceObjectValue = function (key) { return function (props, propKey) {
    props[propKey] = props[propKey][key];
    return props;
}; };
var createObjectAction = function (action, props, vectorKeys) {
    var firstVectorKey = vectorKeys[0];
    var actionMap = Object.keys(props[firstVectorKey]).reduce(function (map, key) {
        var childActionProps = vectorKeys.reduce(reduceObjectValue(key), tslib_1.__assign({}, props));
        map[key] = getActionCreator(props[firstVectorKey][key])(action, childActionProps);
        return map;
    }, {});
    return composite(actionMap);
};
var createUnitAction = function (action, _a) {
    var from = _a.from, to = _a.to, props = tslib_1.__rest(_a, ["from", "to"]);
    var unitType = findUnitType(from) || findUnitType(to);
    var transform = unitType.transform, parse = unitType.parse;
    return action(tslib_1.__assign({}, props, { from: typeof from === 'string' ? parse(from) : from, to: typeof to === 'string' ? parse(to) : to })).pipe(transform);
};
var createColorAction = function (action, _a) {
    var from = _a.from, to = _a.to, props = tslib_1.__rest(_a, ["from", "to"]);
    return action(tslib_1.__assign({}, props, { from: 0, to: 1 })).pipe(popcorn.mixColor(from, to), styleValueTypes.color.transform);
};
var createComplexAction = function (action, _a) {
    var from = _a.from, to = _a.to, props = tslib_1.__rest(_a, ["from", "to"]);
    var valueTemplate = styleValueTypes.complex.createTransformer(from);
    heyListen.invariant(valueTemplate(from) === styleValueTypes.complex.createTransformer(to)(from), "Values '" + from + "' and '" + to + "' are of different format, or a value might have changed value type.");
    return action(tslib_1.__assign({}, props, { from: 0, to: 1 })).pipe(popcorn.mixArray(styleValueTypes.complex.parse(from), styleValueTypes.complex.parse(to)), valueTemplate);
};
var createVectorAction = function (action, typeTests) {
    var _a = createVectorTests(typeTests), testVectorProps = _a.testVectorProps, getVectorKeys = _a.getVectorKeys;
    var vectorAction = function (props) {
        var isVector = testVectorProps(props);
        if (!isVector)
            return action(props);
        var vectorKeys = getVectorKeys(props);
        var testKey = vectorKeys[0];
        var testProp = props[testKey];
        return getActionCreator(testProp)(action, props, vectorKeys);
    };
    return vectorAction;
};
var getActionCreator = function (prop) {
    var actionCreator = createAction;
    if (typeof prop === 'number') {
        actionCreator = createAction;
    }
    else if (Array.isArray(prop)) {
        actionCreator = createArrayAction;
    }
    else if (isUnitProp(prop)) {
        actionCreator = createUnitAction;
    }
    else if (styleValueTypes.color.test(prop)) {
        actionCreator = createColorAction;
    }
    else if (styleValueTypes.complex.test(prop)) {
        actionCreator = createComplexAction;
    }
    else if (typeof prop === 'object') {
        actionCreator = createObjectAction;
    }
    return actionCreator;
};

var decay = function (props) {
    if (props === void 0) { props = {}; }
    return action(function (_a) {
        var complete = _a.complete, update = _a.update;
        var _b = props.velocity, velocity = _b === void 0 ? 0 : _b, _c = props.from, from = _c === void 0 ? 0 : _c, _d = props.power, power = _d === void 0 ? 0.8 : _d, _e = props.timeConstant, timeConstant = _e === void 0 ? 350 : _e, _f = props.restDelta, restDelta = _f === void 0 ? 0.5 : _f, modifyTarget = props.modifyTarget;
        var elapsed = 0;
        var amplitude = power * velocity;
        var idealTarget = Math.round(from + amplitude);
        var target = typeof modifyTarget === 'undefined'
            ? idealTarget
            : modifyTarget(idealTarget);
        var process = sync__default.update(function (_a) {
            var frameDelta = _a.delta;
            elapsed += frameDelta;
            var delta = -amplitude * Math.exp(-elapsed / timeConstant);
            var isMoving = delta > restDelta || delta < -restDelta;
            var current = isMoving ? target + delta : target;
            update(current);
            if (!isMoving) {
                sync.cancelSync.update(process);
                complete();
            }
        }, true);
        return {
            stop: function () { return sync.cancelSync.update(process); }
        };
    });
};
var vectorDecay = createVectorAction(decay, {
    from: styleValueTypes.number.test,
    modifyTarget: function (func) { return typeof func === 'function'; },
    velocity: styleValueTypes.number.test
});

var spring = function (props) {
    if (props === void 0) { props = {}; }
    return action(function (_a) {
        var update = _a.update, complete = _a.complete;
        var _b = props.velocity, velocity = _b === void 0 ? 0.0 : _b;
        var _c = props.from, from = _c === void 0 ? 0.0 : _c, _d = props.to, to = _d === void 0 ? 0.0 : _d, _e = props.stiffness, stiffness = _e === void 0 ? 100 : _e, _f = props.damping, damping = _f === void 0 ? 10 : _f, _g = props.mass, mass = _g === void 0 ? 1.0 : _g, _h = props.restSpeed, restSpeed = _h === void 0 ? 0.01 : _h, _j = props.restDelta, restDelta = _j === void 0 ? 0.01 : _j;
        var initialVelocity = velocity ? -(velocity / 1000) : 0.0;
        var t = 0;
        var delta = to - from;
        var position = from;
        var prevPosition = position;
        var process = sync__default.update(function (_a) {
            var timeDelta = _a.delta;
            t += timeDelta;
            var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
            var angularFreq = Math.sqrt(stiffness / mass) / 1000;
            prevPosition = position;
            if (dampingRatio < 1) {
                var envelope = Math.exp(-dampingRatio * angularFreq * t);
                var expoDecay = angularFreq * Math.sqrt(1.0 - dampingRatio * dampingRatio);
                position =
                    to -
                        envelope *
                            (((initialVelocity + dampingRatio * angularFreq * delta) /
                                expoDecay) *
                                Math.sin(expoDecay * t) +
                                delta * Math.cos(expoDecay * t));
            }
            else {
                var envelope = Math.exp(-angularFreq * t);
                position =
                    to -
                        envelope * (delta + (initialVelocity + angularFreq * delta) * t);
            }
            velocity = popcorn.velocityPerSecond(position - prevPosition, timeDelta);
            var isBelowVelocityThreshold = Math.abs(velocity) <= restSpeed;
            var isBelowDisplacementThreshold = Math.abs(to - position) <= restDelta;
            if (isBelowVelocityThreshold && isBelowDisplacementThreshold) {
                position = to;
                update(position);
                sync.cancelSync.update(process);
                complete();
            }
            else {
                update(position);
            }
        }, true);
        return {
            stop: function () { return sync.cancelSync.update(process); }
        };
    });
};
var vectorSpring = createVectorAction(spring, {
    from: styleValueTypes.number.test,
    to: styleValueTypes.number.test,
    stiffness: styleValueTypes.number.test,
    damping: styleValueTypes.number.test,
    mass: styleValueTypes.number.test,
    velocity: styleValueTypes.number.test
});

var inertia = function (_a) {
    var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.velocity, velocity = _c === void 0 ? 0 : _c, min = _a.min, max = _a.max, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant = _e === void 0 ? 700 : _e, _f = _a.bounceStiffness, bounceStiffness = _f === void 0 ? 500 : _f, _g = _a.bounceDamping, bounceDamping = _g === void 0 ? 10 : _g, _h = _a.restDelta, restDelta = _h === void 0 ? 1 : _h, modifyTarget = _a.modifyTarget;
    return action(function (_a) {
        var update = _a.update, complete = _a.complete;
        var current = value(from);
        var activeAnimation;
        var isSpring = false;
        var isLessThanMin = function (v) { return min !== undefined && v <= min; };
        var isMoreThanMax = function (v) { return max !== undefined && v >= max; };
        var isOutOfBounds = function (v) { return isLessThanMin(v) || isMoreThanMax(v); };
        var isTravellingAwayFromBounds = function (v, currentVelocity) {
            return ((isLessThanMin(v) && currentVelocity < 0) ||
                (isMoreThanMax(v) && currentVelocity > 0));
        };
        var startAnimation = function (animation, onComplete) {
            activeAnimation && activeAnimation.stop();
            activeAnimation = animation.start({
                update: function (v) { return current.update(v); },
                complete: function () {
                    complete();
                    onComplete && onComplete();
                }
            });
        };
        var startSpring = function (props) {
            isSpring = true;
            startAnimation(vectorSpring(tslib_1.__assign({}, props, { to: isLessThanMin(props.from) ? min : max, stiffness: bounceStiffness, damping: bounceDamping, restDelta: restDelta })));
        };
        current.subscribe(function (v) {
            update(v);
            var currentVelocity = current.getVelocity();
            if (activeAnimation &&
                !isSpring &&
                isTravellingAwayFromBounds(v, currentVelocity)) {
                startSpring({ from: v, velocity: currentVelocity });
            }
        });
        if ((isOutOfBounds(from) && velocity === 0) ||
            isTravellingAwayFromBounds(from, velocity)) {
            startSpring({ from: from, velocity: velocity });
        }
        else if (velocity !== 0) {
            var animation = vectorDecay({
                from: from,
                velocity: velocity,
                timeConstant: timeConstant,
                power: power,
                restDelta: isOutOfBounds(from) ? 20 : restDelta,
                modifyTarget: modifyTarget
            });
            startAnimation(animation, function () {
                var v = current.get();
                if (isOutOfBounds(v)) {
                    startSpring({ from: v, velocity: current.getVelocity() });
                }
            });
        }
        else {
            complete();
        }
        return {
            stop: function () { return activeAnimation && activeAnimation.stop(); }
        };
    });
};
var index = createVectorAction(inertia, {
    from: styleValueTypes.number.test,
    velocity: styleValueTypes.number.test,
    min: styleValueTypes.number.test,
    max: styleValueTypes.number.test,
    damping: styleValueTypes.number.test,
    stiffness: styleValueTypes.number.test,
    modifyTarget: function (func) { return typeof func === 'function'; }
});

var frame = function () {
    return action(function (_a) {
        var update = _a.update;
        var initialTime = 0;
        var process = sync__default.update(function (_a) {
            var timestamp = _a.timestamp;
            if (!initialTime)
                initialTime = timestamp;
            update(timestamp - initialTime);
        }, true, true);
        return {
            stop: function () { return sync.cancelSync.update(process); }
        };
    });
};

var scrubber = function (_a) {
    var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? 1 : _c, _d = _a.ease, ease = _d === void 0 ? easing.linear : _d;
    return action(function (_a) {
        var update = _a.update;
        return ({
            seek: function (progress) { return update(progress); }
        });
    }).pipe(ease, function (v) { return popcorn.mix(from, to, v); });
};
var vectorScrubber = createVectorAction(scrubber, {
    ease: function (func) { return typeof func === 'function'; },
    from: styleValueTypes.number.test,
    to: styleValueTypes.number.test
});

var clampProgress = popcorn.clamp(0, 1);
var tween = function (props) {
    if (props === void 0) { props = {}; }
    return action(function (_a) {
        var update = _a.update, complete = _a.complete;
        var _b = props.duration, duration = _b === void 0 ? 300 : _b, _c = props.ease, ease = _c === void 0 ? easing.easeOut : _c, _d = props.flip, flip = _d === void 0 ? 0 : _d, _e = props.loop, loop = _e === void 0 ? 0 : _e, _f = props.yoyo, yoyo = _f === void 0 ? 0 : _f;
        var _g = props.from, from = _g === void 0 ? 0 : _g, _h = props.to, to = _h === void 0 ? 1 : _h, _j = props.elapsed, elapsed = _j === void 0 ? 0 : _j, _k = props.playDirection, playDirection = _k === void 0 ? 1 : _k, _l = props.flipCount, flipCount = _l === void 0 ? 0 : _l, _m = props.yoyoCount, yoyoCount = _m === void 0 ? 0 : _m, _o = props.loopCount, loopCount = _o === void 0 ? 0 : _o;
        var playhead = vectorScrubber({ from: from, to: to, ease: ease }).start(update);
        var currentProgress = 0;
        var process;
        var isActive = false;
        var reverseTween = function () {
            if (elapsed > duration) {
                var remainder = elapsed - duration;
                elapsed = elapsed - remainder * 2;
            }
            else if (elapsed < 0) {
                var remainder = -1 * elapsed;
                elapsed = elapsed + remainder * 2;
            }
            playDirection *= -1;
        };
        var isTweenComplete = function () {
            var _a;
            var isComplete = playDirection === 1
                ? isActive && elapsed >= duration
                : isActive && elapsed <= 0;
            if (!isComplete)
                return false;
            if (isComplete && !loop && !flip && !yoyo)
                return true;
            var isStepTaken = false;
            if (loop && loopCount < loop) {
                elapsed = duration - elapsed;
                loopCount++;
                isStepTaken = true;
            }
            else if (flip && flipCount < flip) {
                elapsed = duration - elapsed;
                _a = [to, from], from = _a[0], to = _a[1];
                playhead = vectorScrubber({ from: from, to: to, ease: ease }).start(update);
                flipCount++;
                isStepTaken = true;
            }
            else if (yoyo && yoyoCount < yoyo) {
                reverseTween();
                yoyoCount++;
                isStepTaken = true;
            }
            return !isStepTaken;
        };
        var updateTween = function () {
            currentProgress = clampProgress(popcorn.progress(0, duration, elapsed));
            playhead.seek(currentProgress);
        };
        var startTimer = function () {
            isActive = true;
            process = sync__default.update(function (_a) {
                var delta = _a.delta;
                elapsed += delta * playDirection;
                updateTween();
                if (isTweenComplete() && complete) {
                    sync.cancelSync.update(process);
                    sync__default.update(complete, false, true);
                }
            }, true);
        };
        var stopTimer = function () {
            isActive = false;
            if (process)
                sync.cancelSync.update(process);
        };
        startTimer();
        return {
            isActive: function () { return isActive; },
            getElapsed: function () { return popcorn.clamp(0, duration, elapsed); },
            getProgress: function () { return currentProgress; },
            stop: function () {
                stopTimer();
            },
            pause: function () {
                stopTimer();
                return this;
            },
            resume: function () {
                if (!isActive)
                    startTimer();
                return this;
            },
            seek: function (newProgress) {
                elapsed = popcorn.mix(0, duration, newProgress);
                sync__default.update(updateTween, false, true);
                return this;
            },
            reverse: function () {
                reverseTween();
                return this;
            }
        };
    });
};

var clampProgress$1 = popcorn.clamp(0, 1);
var defaultEasings = function (values, easing$$1) {
    return values.map(function () { return easing$$1 || easing.easeOut; }).splice(0, values.length - 1);
};
var defaultTimings = function (values) {
    var numValues = values.length;
    return values.map(function (value, i) { return (i !== 0 ? i / (numValues - 1) : 0); });
};
var interpolateScrubbers = function (input, scrubbers, update) {
    var rangeLength = input.length;
    var finalInputIndex = rangeLength - 1;
    var finalScrubberIndex = finalInputIndex - 1;
    var subs = scrubbers.map(function (scrub) { return scrub.start(update); });
    return function (v) {
        if (v <= input[0]) {
            subs[0].seek(0);
        }
        if (v >= input[finalInputIndex]) {
            subs[finalScrubberIndex].seek(1);
        }
        var i = 1;
        for (; i < rangeLength; i++) {
            if (input[i] > v || i === finalInputIndex)
                break;
        }
        var progressInRange = popcorn.progress(input[i - 1], input[i], v);
        subs[i - 1].seek(clampProgress$1(progressInRange));
    };
};
var keyframes = function (_a) {
    var easings = _a.easings, _b = _a.ease, ease = _b === void 0 ? easing.linear : _b, times = _a.times, values = _a.values, tweenProps = tslib_1.__rest(_a, ["easings", "ease", "times", "values"]);
    easings = Array.isArray(easings)
        ? easings
        : defaultEasings(values, easings);
    times = times || defaultTimings(values);
    var scrubbers = easings.map(function (easing$$1, i) {
        return vectorScrubber({
            from: values[i],
            to: values[i + 1],
            ease: easing$$1
        });
    });
    return tween(tslib_1.__assign({}, tweenProps, { ease: ease })).applyMiddleware(function (update) { return interpolateScrubbers(times, scrubbers, update); });
};

var physics = function (props) {
    if (props === void 0) { props = {}; }
    return action(function (_a) {
        var complete = _a.complete, update = _a.update;
        var _b = props.acceleration, acceleration = _b === void 0 ? 0 : _b, _c = props.friction, friction = _c === void 0 ? 0 : _c, _d = props.velocity, velocity = _d === void 0 ? 0 : _d, springStrength = props.springStrength, to = props.to;
        var _e = props.restSpeed, restSpeed = _e === void 0 ? 0.001 : _e, _f = props.from, from = _f === void 0 ? 0 : _f;
        var current = from;
        var process = sync__default.update(function (_a) {
            var delta = _a.delta;
            var elapsed = Math.max(delta, 16);
            if (acceleration)
                velocity += popcorn.velocityPerFrame(acceleration, elapsed);
            if (friction)
                velocity *= Math.pow((1 - friction), (elapsed / 100));
            if (springStrength !== undefined && to !== undefined) {
                var distanceToTarget = to - current;
                velocity += distanceToTarget * popcorn.velocityPerFrame(springStrength, elapsed);
            }
            current += popcorn.velocityPerFrame(velocity, elapsed);
            update(current);
            var isComplete = restSpeed !== false && (!velocity || Math.abs(velocity) <= restSpeed);
            if (isComplete) {
                sync.cancelSync.update(process);
                complete();
            }
        }, true);
        return {
            set: function (v) {
                current = v;
                return this;
            },
            setAcceleration: function (v) {
                acceleration = v;
                return this;
            },
            setFriction: function (v) {
                friction = v;
                return this;
            },
            setSpringStrength: function (v) {
                springStrength = v;
                return this;
            },
            setSpringTarget: function (v) {
                to = v;
                return this;
            },
            setVelocity: function (v) {
                velocity = v;
                return this;
            },
            stop: function () { return sync.cancelSync.update(process); }
        };
    });
};
var vectorPhysics = createVectorAction(physics, {
    acceleration: styleValueTypes.number.test,
    friction: styleValueTypes.number.test,
    velocity: styleValueTypes.number.test,
    from: styleValueTypes.number.test,
    to: styleValueTypes.number.test,
    springStrength: styleValueTypes.number.test
});

var DEFAULT_DURATION = 300;
var flattenTimings = function (instructions) {
    var flatInstructions = [];
    var lastArg = instructions[instructions.length - 1];
    var isStaggered = typeof lastArg === 'number';
    var staggerDelay = isStaggered ? lastArg : 0;
    var segments = isStaggered ? instructions.slice(0, -1) : instructions;
    var numSegments = segments.length;
    var offset = 0;
    segments.forEach(function (item, i) {
        flatInstructions.push(item);
        if (i !== numSegments - 1) {
            var duration = item.duration || DEFAULT_DURATION;
            offset += staggerDelay;
            flatInstructions.push("-" + (duration - offset));
        }
    });
    return flatInstructions;
};
var flattenArrayInstructions = function (instructions, instruction) {
    Array.isArray(instruction)
        ? instructions.push.apply(instructions, flattenTimings(instruction)) : instructions.push(instruction);
    return instructions;
};
var convertDefToProps = function (props, def, i) {
    var duration = props.duration, easings = props.easings, times = props.times, values = props.values;
    var numValues = values.length;
    var prevTimeTo = times[numValues - 1];
    var timeFrom = def.at === 0 ? 0 : def.at / duration;
    var timeTo = (def.at + def.duration) / duration;
    if (i === 0) {
        values.push(def.from);
        times.push(timeFrom);
    }
    else {
        if (prevTimeTo !== timeFrom) {
            if (def.from !== undefined) {
                values.push(values[numValues - 1]);
                times.push(timeFrom);
                easings.push(easing.linear);
            }
            var from = def.from !== undefined ? def.from : values[numValues - 1];
            values.push(from);
            times.push(timeFrom);
            easings.push(easing.linear);
        }
        else if (def.from !== undefined) {
            values.push(def.from);
            times.push(timeFrom);
            easings.push(easing.linear);
        }
    }
    values.push(def.to);
    times.push(timeTo);
    easings.push(def.ease || easing.easeInOut);
    return props;
};
var timeline = function (instructions, _a) {
    var _b = _a === void 0 ? {} : _a, duration = _b.duration, elapsed = _b.elapsed, ease = _b.ease, loop = _b.loop, flip = _b.flip, yoyo = _b.yoyo;
    var playhead = 0;
    var calculatedDuration = 0;
    var flatInstructions = instructions.reduce(flattenArrayInstructions, []);
    var animationDefs = [];
    flatInstructions.forEach(function (instruction) {
        if (typeof instruction === 'string') {
            playhead += parseFloat(instruction);
        }
        else if (typeof instruction === 'number') {
            playhead = instruction;
        }
        else {
            var def = tslib_1.__assign({}, instruction, { at: playhead });
            def.duration =
                def.duration === undefined ? DEFAULT_DURATION : def.duration;
            animationDefs.push(def);
            playhead += def.duration;
            calculatedDuration = Math.max(calculatedDuration, def.at + def.duration);
        }
    });
    var tracks = {};
    var numDefs = animationDefs.length;
    for (var i = 0; i < numDefs; i++) {
        var def = animationDefs[i];
        var track = def.track;
        if (track === undefined) {
            throw new Error('No track defined');
        }
        if (!tracks.hasOwnProperty(track))
            tracks[track] = [];
        tracks[track].push(def);
    }
    var trackKeyframes = {};
    for (var key in tracks) {
        if (tracks.hasOwnProperty(key)) {
            var keyframeProps = tracks[key].reduce(convertDefToProps, {
                duration: calculatedDuration,
                easings: [],
                times: [],
                values: []
            });
            trackKeyframes[key] = keyframes(tslib_1.__assign({}, keyframeProps, { duration: duration || calculatedDuration, ease: ease,
                elapsed: elapsed,
                loop: loop,
                yoyo: yoyo,
                flip: flip }));
        }
    }
    return composite(trackKeyframes);
};

var listen = function (element, events, options) { return action(function (_a) {
    var update = _a.update;
    var eventNames = events.split(' ').map(function (eventName) {
        element.addEventListener(eventName, update, options);
        return eventName;
    });
    return {
        stop: function () { return eventNames.forEach(function (eventName) { return element.removeEventListener(eventName, update, options); }); }
    };
}); };

var defaultPointerPos = function () { return ({
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    x: 0,
    y: 0
}); };
var eventToPoint = function (e, point) {
    if (point === void 0) { point = defaultPointerPos(); }
    point.clientX = point.x = e.clientX;
    point.clientY = point.y = e.clientY;
    point.pageX = e.pageX;
    point.pageY = e.pageY;
    return point;
};

var points = [defaultPointerPos()];
var isTouchDevice = false;
if (typeof document !== 'undefined') {
    var updatePointsLocation = function (_a) {
        var touches = _a.touches;
        isTouchDevice = true;
        var numTouches = touches.length;
        points.length = 0;
        for (var i = 0; i < numTouches; i++) {
            var thisTouch = touches[i];
            points.push(eventToPoint(thisTouch));
        }
    };
    listen(document, 'touchstart touchmove', {
        passive: true,
        capture: true
    }).start(updatePointsLocation);
}
var multitouch = function (_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.preventDefault, preventDefault = _c === void 0 ? true : _c, _d = _b.scale, scale = _d === void 0 ? 1.0 : _d, _e = _b.rotate, rotate = _e === void 0 ? 0.0 : _e;
    return action(function (_a) {
        var update = _a.update;
        var output = {
            touches: points,
            scale: scale,
            rotate: rotate
        };
        var initialDistance = 0.0;
        var initialRotation = 0.0;
        var isGesture = points.length > 1;
        if (isGesture) {
            var firstTouch = points[0], secondTouch = points[1];
            initialDistance = popcorn.distance(firstTouch, secondTouch);
            initialRotation = popcorn.angle(firstTouch, secondTouch);
        }
        var updatePoint = function () {
            if (isGesture) {
                var firstTouch = points[0], secondTouch = points[1];
                var newDistance = popcorn.distance(firstTouch, secondTouch);
                var newRotation = popcorn.angle(firstTouch, secondTouch);
                output.scale = scale * (newDistance / initialDistance);
                output.rotate = rotate + (newRotation - initialRotation);
            }
            update(output);
        };
        var onMove = function (e) {
            if (preventDefault || e.touches.length > 1)
                e.preventDefault();
            sync__default.update(updatePoint);
        };
        var updateOnMove = listen(document, 'touchmove', {
            passive: !preventDefault
        }).start(onMove);
        if (isTouchDevice)
            sync__default.update(updatePoint);
        return {
            stop: function () {
                sync.cancelSync.update(updatePoint);
                updateOnMove.stop();
            }
        };
    });
};
var getIsTouchDevice = function () { return isTouchDevice; };

var point = defaultPointerPos();
var isMouseDevice = false;
if (typeof document !== 'undefined') {
    var updatePointLocation = function (e) {
        isMouseDevice = true;
        eventToPoint(e, point);
    };
    listen(document, 'mousedown mousemove', true).start(updatePointLocation);
}
var mouse = function (_a) {
    var _b = (_a === void 0 ? {} : _a).preventDefault, preventDefault = _b === void 0 ? true : _b;
    return action(function (_a) {
        var update = _a.update;
        var updatePoint = function () { return update(point); };
        var onMove = function (e) {
            if (preventDefault)
                e.preventDefault();
            sync__default.update(updatePoint);
        };
        var updateOnMove = listen(document, 'mousemove').start(onMove);
        if (isMouseDevice)
            sync__default.update(updatePoint);
        return {
            stop: function () {
                sync.cancelSync.update(updatePoint);
                updateOnMove.stop();
            }
        };
    });
};

var getFirstTouch = function (_a) {
    var firstTouch = _a[0];
    return firstTouch;
};
var pointer = function (props) {
    if (props === void 0) { props = {}; }
    return getIsTouchDevice()
        ? multitouch(props).pipe(function (_a) {
            var touches = _a.touches;
            return touches;
        }, getFirstTouch)
        : mouse(props);
};
var index$1 = (function (_a) {
    if (_a === void 0) { _a = {}; }
    var x = _a.x, y = _a.y, props = tslib_1.__rest(_a, ["x", "y"]);
    if (x !== undefined || y !== undefined) {
        var applyXOffset_1 = popcorn.applyOffset(x || 0);
        var applyYOffset_1 = popcorn.applyOffset(y || 0);
        var delta_1 = { x: 0, y: 0 };
        return pointer(props).pipe(function (point) {
            delta_1.x = applyXOffset_1(point.x);
            delta_1.y = applyYOffset_1(point.y);
            return delta_1;
        });
    }
    else {
        return pointer(props);
    }
});

var chain = function () {
    var actions = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        actions[_i] = arguments[_i];
    }
    return action(function (_a) {
        var update = _a.update, complete = _a.complete;
        var i = 0;
        var current;
        var playCurrent = function () {
            current = actions[i].start({
                complete: function () {
                    i++;
                    (i >= actions.length) ? complete() : playCurrent();
                },
                update: update
            });
        };
        playCurrent();
        return {
            stop: function () { return current && current.stop(); }
        };
    });
};

var crossfade = function (a, b) {
    return action(function (observer) {
        var balance = 0;
        var fadable = parallel$1(a, b).start(tslib_1.__assign({}, observer, { update: function (_a) {
                var va = _a[0], vb = _a[1];
                observer.update(popcorn.mix(va, vb, balance));
            } }));
        return {
            setBalance: function (v) { return (balance = v); },
            stop: function () { return fadable.stop(); }
        };
    });
};

var delay = function (timeToDelay) { return action(function (_a) {
    var complete = _a.complete;
    var timeout = setTimeout(complete, timeToDelay);
    return {
        stop: function () { return clearTimeout(timeout); }
    };
}); };

var merge = function () {
    var actions = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        actions[_i] = arguments[_i];
    }
    return action(function (observer) {
        var subs = actions.map(function (thisAction) { return thisAction.start(observer); });
        return {
            stop: function () { return subs.forEach(function (sub) { return sub.stop(); }); }
        };
    });
};

var schedule = function (scheduler, schedulee) { return action(function (_a) {
    var update = _a.update, complete = _a.complete;
    var latest;
    var schedulerSub = scheduler.start({
        update: function () { return latest !== undefined && update(latest); },
        complete: complete
    });
    var scheduleeSub = schedulee.start({
        update: function (v) { return latest = v; },
        complete: complete
    });
    return {
        stop: function () {
            schedulerSub.stop();
            scheduleeSub.stop();
        }
    };
}); };

var stagger = function (actions, interval) {
    var intervalIsNumber = typeof interval === 'number';
    var actionsWithDelay = actions.map(function (a, i) {
        var timeToDelay = intervalIsNumber ? interval * i : interval(i);
        return chain(delay(timeToDelay), a);
    });
    return parallel$1.apply(void 0, actionsWithDelay);
};

var appendUnit = function (unit) { return function (v) { return "" + v + unit; }; };
var steps = function (st, min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 1; }
    return function (v) {
        var current = popcorn.progress(min, max, v);
        return popcorn.mix(min, max, stepProgress(st, current));
    };
};
var transformMap = function (childTransformers) { return function (v) {
    var output = tslib_1.__assign({}, v);
    for (var key in childTransformers) {
        if (childTransformers.hasOwnProperty(key)) {
            var childTransformer = childTransformers[key];
            output[key] = childTransformer(v[key]);
        }
    }
    return output;
}; };

var transformers = /*#__PURE__*/Object.freeze({
  applyOffset: popcorn.applyOffset,
  clamp: popcorn.clamp,
  conditional: popcorn.conditional,
  interpolate: popcorn.interpolate,
  blendArray: popcorn.mixArray,
  blendColor: popcorn.mixColor,
  pipe: popcorn.pipe,
  smooth: popcorn.smooth,
  snap: popcorn.snap,
  generateStaticSpring: popcorn.springForce,
  nonlinearSpring: popcorn.springForceExpo,
  linearSpring: popcorn.springForceLinear,
  wrap: popcorn.wrap,
  appendUnit: appendUnit,
  steps: steps,
  transformMap: transformMap
});

var css = function (element, props) {
    heyListen.warning(false, 'css() is deprecated, use styler instead');
    return styler(element, props);
};
var svg = function (element, props) {
    heyListen.warning(false, 'svg() is deprecated, use styler instead');
    return styler(element, props);
};

exports.valueTypes = styleValueTypes;
exports.easing = easing;
exports.styler = styler;
exports.action = action;
exports.multicast = multicast;
exports.value = value;
exports.decay = vectorDecay;
exports.inertia = index;
exports.keyframes = keyframes;
exports.everyFrame = frame;
exports.physics = vectorPhysics;
exports.spring = vectorSpring;
exports.timeline = timeline;
exports.tween = tween;
exports.listen = listen;
exports.pointer = index$1;
exports.mouse = mouse;
exports.multitouch = multitouch;
exports.chain = chain;
exports.composite = composite;
exports.crossfade = crossfade;
exports.delay = delay;
exports.merge = merge;
exports.parallel = parallel$1;
exports.schedule = schedule;
exports.stagger = stagger;
exports.calc = calc;
exports.transform = transformers;
exports.css = css;
exports.svg = svg;
exports.Action = Action;
exports.ValueReaction = ValueReaction;


/***/ }),

/***/ "./node_modules/popmotion/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.js");
var popcorn = __webpack_require__("./node_modules/@popmotion/popcorn/lib/index.js");
var sync = __webpack_require__("./node_modules/framesync/lib/index.js");
var sync__default = _interopDefault(sync);
var styleValueTypes = __webpack_require__("./node_modules/style-value-types/lib/index.js");
var heyListen = __webpack_require__("./node_modules/hey-listen/lib/index.js");
var easing = __webpack_require__("./node_modules/@popmotion/easing/lib/index.js");
var styler = _interopDefault(__webpack_require__("./node_modules/stylefire/lib/index.js"));

var Chainable = (function () {
    function Chainable(props) {
        if (props === void 0) { props = {}; }
        this.props = props;
    }
    Chainable.prototype.applyMiddleware = function (middleware) {
        return this.create(tslib_1.__assign({}, this.props, { middleware: this.props.middleware
                ? [middleware].concat(this.props.middleware) : [middleware] }));
    };
    Chainable.prototype.pipe = function () {
        var funcs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            funcs[_i] = arguments[_i];
        }
        var pipedUpdate = funcs.length === 1 ? funcs[0] : popcorn.pipe.apply(void 0, funcs);
        return this.applyMiddleware(function (update) { return function (v) { return update(pipedUpdate(v)); }; });
    };
    Chainable.prototype.while = function (predicate) {
        return this.applyMiddleware(function (update, complete) { return function (v) {
            return predicate(v) ? update(v) : complete();
        }; });
    };
    Chainable.prototype.filter = function (predicate) {
        return this.applyMiddleware(function (update) { return function (v) { return predicate(v) && update(v); }; });
    };
    return Chainable;
}());

var Observer = (function () {
    function Observer(_a, observer) {
        var middleware = _a.middleware, onComplete = _a.onComplete;
        var _this = this;
        this.isActive = true;
        this.update = function (v) {
            if (_this.observer.update)
                _this.updateObserver(v);
        };
        this.complete = function () {
            if (_this.observer.complete && _this.isActive)
                _this.observer.complete();
            if (_this.onComplete)
                _this.onComplete();
            _this.isActive = false;
        };
        this.error = function (err) {
            if (_this.observer.error && _this.isActive)
                _this.observer.error(err);
            _this.isActive = false;
        };
        this.observer = observer;
        this.updateObserver = function (v) { return observer.update(v); };
        this.onComplete = onComplete;
        if (observer.update && middleware && middleware.length) {
            middleware.forEach(function (m) { return _this.updateObserver = m(_this.updateObserver, _this.complete); });
        }
    }
    return Observer;
}());
var createObserver = (function (observerCandidate, _a, onComplete) {
    var middleware = _a.middleware;
    if (typeof observerCandidate === 'function') {
        return new Observer({ middleware: middleware, onComplete: onComplete }, { update: observerCandidate });
    }
    else {
        return new Observer({ middleware: middleware, onComplete: onComplete }, observerCandidate);
    }
});

var Action = (function (_super) {
    tslib_1.__extends(Action, _super);
    function Action() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Action.prototype.create = function (props) {
        return new Action(props);
    };
    Action.prototype.start = function (observerCandidate) {
        if (observerCandidate === void 0) { observerCandidate = {}; }
        var isComplete = false;
        var subscription = {
            stop: function () { return undefined; }
        };
        var _a = this.props, init = _a.init, observerProps = tslib_1.__rest(_a, ["init"]);
        var observer = createObserver(observerCandidate, observerProps, function () {
            isComplete = true;
            subscription.stop();
        });
        var api = init(observer);
        subscription = api
            ? tslib_1.__assign({}, subscription, api) : subscription;
        if (observerCandidate.registerParent) {
            observerCandidate.registerParent(subscription);
        }
        if (isComplete)
            subscription.stop();
        return subscription;
    };
    return Action;
}(Chainable));
var action = (function (init) { return new Action({ init: init }); });

var BaseMulticast = (function (_super) {
    tslib_1.__extends(BaseMulticast, _super);
    function BaseMulticast() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.subscribers = [];
        return _this;
    }
    BaseMulticast.prototype.complete = function () {
        this.subscribers.forEach(function (subscriber) { return subscriber.complete(); });
    };
    BaseMulticast.prototype.error = function (err) {
        this.subscribers.forEach(function (subscriber) { return subscriber.error(err); });
    };
    BaseMulticast.prototype.update = function (v) {
        for (var i = 0; i < this.subscribers.length; i++) {
            this.subscribers[i].update(v);
        }
    };
    BaseMulticast.prototype.subscribe = function (observerCandidate) {
        var _this = this;
        var observer = createObserver(observerCandidate, this.props);
        this.subscribers.push(observer);
        var subscription = {
            unsubscribe: function () {
                var index = _this.subscribers.indexOf(observer);
                if (index !== -1)
                    _this.subscribers.splice(index, 1);
            }
        };
        return subscription;
    };
    BaseMulticast.prototype.stop = function () {
        if (this.parent)
            this.parent.stop();
    };
    BaseMulticast.prototype.registerParent = function (subscription) {
        this.stop();
        this.parent = subscription;
    };
    return BaseMulticast;
}(Chainable));

var Multicast = (function (_super) {
    tslib_1.__extends(Multicast, _super);
    function Multicast() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Multicast.prototype.create = function (props) {
        return new Multicast(props);
    };
    return Multicast;
}(BaseMulticast));
var multicast = (function () { return new Multicast(); });

var stepProgress = function (steps, progress) {
    var segment = 1 / (steps - 1);
    var subsegment = 1 / (2 * (steps - 1));
    var percentProgressOfTarget = Math.min(progress, 1);
    var subsegmentProgressOfTarget = percentProgressOfTarget / subsegment;
    var segmentProgressOfTarget = Math.floor((subsegmentProgressOfTarget + 1) / 2);
    return segmentProgressOfTarget * segment;
};

var calc = /*#__PURE__*/Object.freeze({
  angle: popcorn.angle,
  degreesToRadians: popcorn.degreesToRadians,
  distance: popcorn.distance,
  isPoint3D: popcorn.isPoint3D,
  isPoint: popcorn.isPoint,
  dilate: popcorn.mix,
  getValueFromProgress: popcorn.mix,
  pointFromAngleAndDistance: popcorn.pointFromVector,
  getProgressFromValue: popcorn.progress,
  radiansToDegrees: popcorn.radiansToDegrees,
  smooth: popcorn.smoothFrame,
  speedPerFrame: popcorn.velocityPerFrame,
  speedPerSecond: popcorn.velocityPerSecond,
  stepProgress: stepProgress
});

var isValueList = function (v) { return Array.isArray(v); };
var isSingleValue = function (v) {
    var typeOfV = typeof v;
    return typeOfV === 'string' || typeOfV === 'number';
};
var ValueReaction = (function (_super) {
    tslib_1.__extends(ValueReaction, _super);
    function ValueReaction(props) {
        var _this = _super.call(this, props) || this;
        _this.scheduleVelocityCheck = function () { return sync__default.postRender(_this.velocityCheck); };
        _this.velocityCheck = function (_a) {
            var timestamp = _a.timestamp;
            if (timestamp !== _this.lastUpdated) {
                _this.prev = _this.current;
            }
        };
        _this.prev = _this.current = props.value || 0;
        if (isSingleValue(_this.current)) {
            _this.updateCurrent = function (v) { return (_this.current = v); };
            _this.getVelocityOfCurrent = function () {
                return _this.getSingleVelocity(_this.current, _this.prev);
            };
        }
        else if (isValueList(_this.current)) {
            _this.updateCurrent = function (v) { return (_this.current = v.slice()); };
            _this.getVelocityOfCurrent = function () { return _this.getListVelocity(); };
        }
        else {
            _this.updateCurrent = function (v) {
                _this.current = {};
                for (var key in v) {
                    if (v.hasOwnProperty(key)) {
                        _this.current[key] = v[key];
                    }
                }
            };
            _this.getVelocityOfCurrent = function () { return _this.getMapVelocity(); };
        }
        if (props.initialSubscription)
            _this.subscribe(props.initialSubscription);
        return _this;
    }
    ValueReaction.prototype.create = function (props) {
        return new ValueReaction(props);
    };
    ValueReaction.prototype.get = function () {
        return this.current;
    };
    ValueReaction.prototype.getVelocity = function () {
        return this.getVelocityOfCurrent();
    };
    ValueReaction.prototype.update = function (v) {
        _super.prototype.update.call(this, v);
        this.prev = this.current;
        this.updateCurrent(v);
        var _a = sync.getFrameData(), delta = _a.delta, timestamp = _a.timestamp;
        this.timeDelta = delta;
        this.lastUpdated = timestamp;
        sync__default.postRender(this.scheduleVelocityCheck);
    };
    ValueReaction.prototype.subscribe = function (observerCandidate) {
        var sub = _super.prototype.subscribe.call(this, observerCandidate);
        this.subscribers[this.subscribers.length - 1].update(this.current);
        return sub;
    };
    ValueReaction.prototype.getSingleVelocity = function (current, prev) {
        return typeof current === 'number' && typeof prev === 'number'
            ? popcorn.velocityPerSecond(current - prev, this.timeDelta)
            : popcorn.velocityPerSecond(parseFloat(current) - parseFloat(prev), this.timeDelta) || 0;
    };
    ValueReaction.prototype.getListVelocity = function () {
        var _this = this;
        return this.current.map(function (c, i) {
            return _this.getSingleVelocity(c, _this.prev[i]);
        });
    };
    ValueReaction.prototype.getMapVelocity = function () {
        var velocity = {};
        for (var key in this.current) {
            if (this.current.hasOwnProperty(key)) {
                velocity[key] = this.getSingleVelocity(this.current[key], this.prev[key]);
            }
        }
        return velocity;
    };
    return ValueReaction;
}(BaseMulticast));
var value = (function (value, initialSubscription) {
    return new ValueReaction({ value: value, initialSubscription: initialSubscription });
});

var multi = function (_a) {
    var getCount = _a.getCount, getFirst = _a.getFirst, getOutput = _a.getOutput, mapApi = _a.mapApi, setProp = _a.setProp, startActions = _a.startActions;
    return function (actions) {
        return action(function (_a) {
            var update = _a.update, complete = _a.complete, error = _a.error;
            var numActions = getCount(actions);
            var output = getOutput();
            var updateOutput = function () { return update(output); };
            var numCompletedActions = 0;
            var subs = startActions(actions, function (a, name) {
                var hasCompleted = false;
                return a.start({
                    complete: function () {
                        if (!hasCompleted) {
                            hasCompleted = true;
                            numCompletedActions++;
                            if (numCompletedActions === numActions)
                                sync__default.update(complete);
                        }
                    },
                    error: error,
                    update: function (v) {
                        setProp(output, name, v);
                        sync__default.update(updateOutput, false, true);
                    }
                });
            });
            return Object.keys(getFirst(subs)).reduce(function (api, methodName) {
                api[methodName] = mapApi(subs, methodName);
                return api;
            }, {});
        });
    };
};

var composite = multi({
    getOutput: function () { return ({}); },
    getCount: function (subs) { return Object.keys(subs).length; },
    getFirst: function (subs) { return subs[Object.keys(subs)[0]]; },
    mapApi: function (subs, methodName) { return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return Object.keys(subs)
            .reduce(function (output, propKey) {
            var _a;
            if (subs[propKey][methodName]) {
                (args[0] && args[0][propKey] !== undefined)
                    ? output[propKey] = subs[propKey][methodName](args[0][propKey])
                    : output[propKey] = (_a = subs[propKey])[methodName].apply(_a, args);
            }
            return output;
        }, {});
    }; },
    setProp: function (output, name, v) { return output[name] = v; },
    startActions: function (actions, starter) { return Object.keys(actions)
        .reduce(function (subs, key) {
        subs[key] = starter(actions[key], key);
        return subs;
    }, {}); }
});

var parallel = multi({
    getOutput: function () { return ([]); },
    getCount: function (subs) { return subs.length; },
    getFirst: function (subs) { return subs[0]; },
    mapApi: function (subs, methodName) { return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return subs.map(function (sub, i) {
            if (sub[methodName]) {
                return Array.isArray(args[0])
                    ? sub[methodName](args[0][i])
                    : sub[methodName].apply(sub, args);
            }
        });
    }; },
    setProp: function (output, name, v) { return output[name] = v; },
    startActions: function (actions, starter) { return actions.map(function (action, i) { return starter(action, i); }); }
});
var parallel$1 = (function () {
    var actions = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        actions[_i] = arguments[_i];
    }
    return parallel(actions);
});

var createVectorTests = function (typeTests) {
    var testNames = Object.keys(typeTests);
    var isVectorProp = function (prop, key) {
        return prop !== undefined && !typeTests[key](prop);
    };
    var getVectorKeys = function (props) {
        return testNames.reduce(function (vectorKeys, key) {
            if (isVectorProp(props[key], key))
                vectorKeys.push(key);
            return vectorKeys;
        }, []);
    };
    var testVectorProps = function (props) {
        return props && testNames.some(function (key) { return isVectorProp(props[key], key); });
    };
    return { getVectorKeys: getVectorKeys, testVectorProps: testVectorProps };
};
var unitTypes = [styleValueTypes.px, styleValueTypes.percent, styleValueTypes.degrees, styleValueTypes.vh, styleValueTypes.vw];
var findUnitType = function (prop) { return unitTypes.find(function (type) { return type.test(prop); }); };
var isUnitProp = function (prop) { return Boolean(findUnitType(prop)); };
var createAction = function (action, props) { return action(props); };
var reduceArrayValue = function (i) { return function (props, key) {
    props[key] = props[key][i];
    return props;
}; };
var createArrayAction = function (action, props, vectorKeys) {
    var firstVectorKey = vectorKeys[0];
    var actionList = props[firstVectorKey].map(function (v, i) {
        var childActionProps = vectorKeys.reduce(reduceArrayValue(i), tslib_1.__assign({}, props));
        return getActionCreator(v)(action, childActionProps);
    });
    return parallel$1.apply(void 0, actionList);
};
var reduceObjectValue = function (key) { return function (props, propKey) {
    props[propKey] = props[propKey][key];
    return props;
}; };
var createObjectAction = function (action, props, vectorKeys) {
    var firstVectorKey = vectorKeys[0];
    var actionMap = Object.keys(props[firstVectorKey]).reduce(function (map, key) {
        var childActionProps = vectorKeys.reduce(reduceObjectValue(key), tslib_1.__assign({}, props));
        map[key] = getActionCreator(props[firstVectorKey][key])(action, childActionProps);
        return map;
    }, {});
    return composite(actionMap);
};
var createUnitAction = function (action, _a) {
    var from = _a.from, to = _a.to, props = tslib_1.__rest(_a, ["from", "to"]);
    var unitType = findUnitType(from) || findUnitType(to);
    var transform = unitType.transform, parse = unitType.parse;
    return action(tslib_1.__assign({}, props, { from: typeof from === 'string' ? parse(from) : from, to: typeof to === 'string' ? parse(to) : to })).pipe(transform);
};
var createColorAction = function (action, _a) {
    var from = _a.from, to = _a.to, props = tslib_1.__rest(_a, ["from", "to"]);
    return action(tslib_1.__assign({}, props, { from: 0, to: 1 })).pipe(popcorn.mixColor(from, to), styleValueTypes.color.transform);
};
var createComplexAction = function (action, _a) {
    var from = _a.from, to = _a.to, props = tslib_1.__rest(_a, ["from", "to"]);
    var valueTemplate = styleValueTypes.complex.createTransformer(from);
    heyListen.invariant(valueTemplate(from) === styleValueTypes.complex.createTransformer(to)(from), "Values '" + from + "' and '" + to + "' are of different format, or a value might have changed value type.");
    return action(tslib_1.__assign({}, props, { from: 0, to: 1 })).pipe(popcorn.mixArray(styleValueTypes.complex.parse(from), styleValueTypes.complex.parse(to)), valueTemplate);
};
var createVectorAction = function (action, typeTests) {
    var _a = createVectorTests(typeTests), testVectorProps = _a.testVectorProps, getVectorKeys = _a.getVectorKeys;
    var vectorAction = function (props) {
        var isVector = testVectorProps(props);
        if (!isVector)
            return action(props);
        var vectorKeys = getVectorKeys(props);
        var testKey = vectorKeys[0];
        var testProp = props[testKey];
        return getActionCreator(testProp)(action, props, vectorKeys);
    };
    return vectorAction;
};
var getActionCreator = function (prop) {
    var actionCreator = createAction;
    if (typeof prop === 'number') {
        actionCreator = createAction;
    }
    else if (Array.isArray(prop)) {
        actionCreator = createArrayAction;
    }
    else if (isUnitProp(prop)) {
        actionCreator = createUnitAction;
    }
    else if (styleValueTypes.color.test(prop)) {
        actionCreator = createColorAction;
    }
    else if (styleValueTypes.complex.test(prop)) {
        actionCreator = createComplexAction;
    }
    else if (typeof prop === 'object') {
        actionCreator = createObjectAction;
    }
    return actionCreator;
};

var decay = function (props) {
    if (props === void 0) { props = {}; }
    return action(function (_a) {
        var complete = _a.complete, update = _a.update;
        var _b = props.velocity, velocity = _b === void 0 ? 0 : _b, _c = props.from, from = _c === void 0 ? 0 : _c, _d = props.power, power = _d === void 0 ? 0.8 : _d, _e = props.timeConstant, timeConstant = _e === void 0 ? 350 : _e, _f = props.restDelta, restDelta = _f === void 0 ? 0.5 : _f, modifyTarget = props.modifyTarget;
        var elapsed = 0;
        var amplitude = power * velocity;
        var idealTarget = Math.round(from + amplitude);
        var target = typeof modifyTarget === 'undefined'
            ? idealTarget
            : modifyTarget(idealTarget);
        var process = sync__default.update(function (_a) {
            var frameDelta = _a.delta;
            elapsed += frameDelta;
            var delta = -amplitude * Math.exp(-elapsed / timeConstant);
            var isMoving = delta > restDelta || delta < -restDelta;
            var current = isMoving ? target + delta : target;
            update(current);
            if (!isMoving) {
                sync.cancelSync.update(process);
                complete();
            }
        }, true);
        return {
            stop: function () { return sync.cancelSync.update(process); }
        };
    });
};
var vectorDecay = createVectorAction(decay, {
    from: styleValueTypes.number.test,
    modifyTarget: function (func) { return typeof func === 'function'; },
    velocity: styleValueTypes.number.test
});

var spring = function (props) {
    if (props === void 0) { props = {}; }
    return action(function (_a) {
        var update = _a.update, complete = _a.complete;
        var _b = props.velocity, velocity = _b === void 0 ? 0.0 : _b;
        var _c = props.from, from = _c === void 0 ? 0.0 : _c, _d = props.to, to = _d === void 0 ? 0.0 : _d, _e = props.stiffness, stiffness = _e === void 0 ? 100 : _e, _f = props.damping, damping = _f === void 0 ? 10 : _f, _g = props.mass, mass = _g === void 0 ? 1.0 : _g, _h = props.restSpeed, restSpeed = _h === void 0 ? 0.01 : _h, _j = props.restDelta, restDelta = _j === void 0 ? 0.01 : _j;
        var initialVelocity = velocity ? -(velocity / 1000) : 0.0;
        var t = 0;
        var delta = to - from;
        var position = from;
        var prevPosition = position;
        var process = sync__default.update(function (_a) {
            var timeDelta = _a.delta;
            t += timeDelta;
            var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
            var angularFreq = Math.sqrt(stiffness / mass) / 1000;
            prevPosition = position;
            if (dampingRatio < 1) {
                var envelope = Math.exp(-dampingRatio * angularFreq * t);
                var expoDecay = angularFreq * Math.sqrt(1.0 - dampingRatio * dampingRatio);
                position =
                    to -
                        envelope *
                            (((initialVelocity + dampingRatio * angularFreq * delta) /
                                expoDecay) *
                                Math.sin(expoDecay * t) +
                                delta * Math.cos(expoDecay * t));
            }
            else {
                var envelope = Math.exp(-angularFreq * t);
                position =
                    to -
                        envelope * (delta + (initialVelocity + angularFreq * delta) * t);
            }
            velocity = popcorn.velocityPerSecond(position - prevPosition, timeDelta);
            var isBelowVelocityThreshold = Math.abs(velocity) <= restSpeed;
            var isBelowDisplacementThreshold = Math.abs(to - position) <= restDelta;
            if (isBelowVelocityThreshold && isBelowDisplacementThreshold) {
                position = to;
                update(position);
                sync.cancelSync.update(process);
                complete();
            }
            else {
                update(position);
            }
        }, true);
        return {
            stop: function () { return sync.cancelSync.update(process); }
        };
    });
};
var vectorSpring = createVectorAction(spring, {
    from: styleValueTypes.number.test,
    to: styleValueTypes.number.test,
    stiffness: styleValueTypes.number.test,
    damping: styleValueTypes.number.test,
    mass: styleValueTypes.number.test,
    velocity: styleValueTypes.number.test
});

var inertia = function (_a) {
    var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.velocity, velocity = _c === void 0 ? 0 : _c, min = _a.min, max = _a.max, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant = _e === void 0 ? 700 : _e, _f = _a.bounceStiffness, bounceStiffness = _f === void 0 ? 500 : _f, _g = _a.bounceDamping, bounceDamping = _g === void 0 ? 10 : _g, _h = _a.restDelta, restDelta = _h === void 0 ? 1 : _h, modifyTarget = _a.modifyTarget;
    return action(function (_a) {
        var update = _a.update, complete = _a.complete;
        var current = value(from);
        var activeAnimation;
        var isSpring = false;
        var isLessThanMin = function (v) { return min !== undefined && v <= min; };
        var isMoreThanMax = function (v) { return max !== undefined && v >= max; };
        var isOutOfBounds = function (v) { return isLessThanMin(v) || isMoreThanMax(v); };
        var isTravellingAwayFromBounds = function (v, currentVelocity) {
            return ((isLessThanMin(v) && currentVelocity < 0) ||
                (isMoreThanMax(v) && currentVelocity > 0));
        };
        var startAnimation = function (animation, onComplete) {
            activeAnimation && activeAnimation.stop();
            activeAnimation = animation.start({
                update: function (v) { return current.update(v); },
                complete: function () {
                    complete();
                    onComplete && onComplete();
                }
            });
        };
        var startSpring = function (props) {
            isSpring = true;
            startAnimation(vectorSpring(tslib_1.__assign({}, props, { to: isLessThanMin(props.from) ? min : max, stiffness: bounceStiffness, damping: bounceDamping, restDelta: restDelta })));
        };
        current.subscribe(function (v) {
            update(v);
            var currentVelocity = current.getVelocity();
            if (activeAnimation &&
                !isSpring &&
                isTravellingAwayFromBounds(v, currentVelocity)) {
                startSpring({ from: v, velocity: currentVelocity });
            }
        });
        if ((isOutOfBounds(from) && velocity === 0) ||
            isTravellingAwayFromBounds(from, velocity)) {
            startSpring({ from: from, velocity: velocity });
        }
        else if (velocity !== 0) {
            var animation = vectorDecay({
                from: from,
                velocity: velocity,
                timeConstant: timeConstant,
                power: power,
                restDelta: isOutOfBounds(from) ? 20 : restDelta,
                modifyTarget: modifyTarget
            });
            startAnimation(animation, function () {
                var v = current.get();
                if (isOutOfBounds(v)) {
                    startSpring({ from: v, velocity: current.getVelocity() });
                }
            });
        }
        else {
            complete();
        }
        return {
            stop: function () { return activeAnimation && activeAnimation.stop(); }
        };
    });
};
var index = createVectorAction(inertia, {
    from: styleValueTypes.number.test,
    velocity: styleValueTypes.number.test,
    min: styleValueTypes.number.test,
    max: styleValueTypes.number.test,
    damping: styleValueTypes.number.test,
    stiffness: styleValueTypes.number.test,
    modifyTarget: function (func) { return typeof func === 'function'; }
});

var frame = function () {
    return action(function (_a) {
        var update = _a.update;
        var initialTime = 0;
        var process = sync__default.update(function (_a) {
            var timestamp = _a.timestamp;
            if (!initialTime)
                initialTime = timestamp;
            update(timestamp - initialTime);
        }, true, true);
        return {
            stop: function () { return sync.cancelSync.update(process); }
        };
    });
};

var scrubber = function (_a) {
    var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? 1 : _c, _d = _a.ease, ease = _d === void 0 ? easing.linear : _d;
    return action(function (_a) {
        var update = _a.update;
        return ({
            seek: function (progress) { return update(progress); }
        });
    }).pipe(ease, function (v) { return popcorn.mix(from, to, v); });
};
var vectorScrubber = createVectorAction(scrubber, {
    ease: function (func) { return typeof func === 'function'; },
    from: styleValueTypes.number.test,
    to: styleValueTypes.number.test
});

var clampProgress = popcorn.clamp(0, 1);
var tween = function (props) {
    if (props === void 0) { props = {}; }
    return action(function (_a) {
        var update = _a.update, complete = _a.complete;
        var _b = props.duration, duration = _b === void 0 ? 300 : _b, _c = props.ease, ease = _c === void 0 ? easing.easeOut : _c, _d = props.flip, flip = _d === void 0 ? 0 : _d, _e = props.loop, loop = _e === void 0 ? 0 : _e, _f = props.yoyo, yoyo = _f === void 0 ? 0 : _f;
        var _g = props.from, from = _g === void 0 ? 0 : _g, _h = props.to, to = _h === void 0 ? 1 : _h, _j = props.elapsed, elapsed = _j === void 0 ? 0 : _j, _k = props.playDirection, playDirection = _k === void 0 ? 1 : _k, _l = props.flipCount, flipCount = _l === void 0 ? 0 : _l, _m = props.yoyoCount, yoyoCount = _m === void 0 ? 0 : _m, _o = props.loopCount, loopCount = _o === void 0 ? 0 : _o;
        var playhead = vectorScrubber({ from: from, to: to, ease: ease }).start(update);
        var currentProgress = 0;
        var process;
        var isActive = false;
        var reverseTween = function () {
            if (elapsed > duration) {
                var remainder = elapsed - duration;
                elapsed = elapsed - remainder * 2;
            }
            else if (elapsed < 0) {
                var remainder = -1 * elapsed;
                elapsed = elapsed + remainder * 2;
            }
            playDirection *= -1;
        };
        var isTweenComplete = function () {
            var _a;
            var isComplete = playDirection === 1
                ? isActive && elapsed >= duration
                : isActive && elapsed <= 0;
            if (!isComplete)
                return false;
            if (isComplete && !loop && !flip && !yoyo)
                return true;
            var isStepTaken = false;
            if (loop && loopCount < loop) {
                elapsed = duration - elapsed;
                loopCount++;
                isStepTaken = true;
            }
            else if (flip && flipCount < flip) {
                elapsed = duration - elapsed;
                _a = [to, from], from = _a[0], to = _a[1];
                playhead = vectorScrubber({ from: from, to: to, ease: ease }).start(update);
                flipCount++;
                isStepTaken = true;
            }
            else if (yoyo && yoyoCount < yoyo) {
                reverseTween();
                yoyoCount++;
                isStepTaken = true;
            }
            return !isStepTaken;
        };
        var updateTween = function () {
            currentProgress = clampProgress(popcorn.progress(0, duration, elapsed));
            playhead.seek(currentProgress);
        };
        var startTimer = function () {
            isActive = true;
            process = sync__default.update(function (_a) {
                var delta = _a.delta;
                elapsed += delta * playDirection;
                updateTween();
                if (isTweenComplete() && complete) {
                    sync.cancelSync.update(process);
                    sync__default.update(complete, false, true);
                }
            }, true);
        };
        var stopTimer = function () {
            isActive = false;
            if (process)
                sync.cancelSync.update(process);
        };
        startTimer();
        return {
            isActive: function () { return isActive; },
            getElapsed: function () { return popcorn.clamp(0, duration, elapsed); },
            getProgress: function () { return currentProgress; },
            stop: function () {
                stopTimer();
            },
            pause: function () {
                stopTimer();
                return this;
            },
            resume: function () {
                if (!isActive)
                    startTimer();
                return this;
            },
            seek: function (newProgress) {
                elapsed = popcorn.mix(0, duration, newProgress);
                sync__default.update(updateTween, false, true);
                return this;
            },
            reverse: function () {
                reverseTween();
                return this;
            }
        };
    });
};

var clampProgress$1 = popcorn.clamp(0, 1);
var defaultEasings = function (values, easing$$1) {
    return values.map(function () { return easing$$1 || easing.easeOut; }).splice(0, values.length - 1);
};
var defaultTimings = function (values) {
    var numValues = values.length;
    return values.map(function (value, i) { return (i !== 0 ? i / (numValues - 1) : 0); });
};
var interpolateScrubbers = function (input, scrubbers, update) {
    var rangeLength = input.length;
    var finalInputIndex = rangeLength - 1;
    var finalScrubberIndex = finalInputIndex - 1;
    var subs = scrubbers.map(function (scrub) { return scrub.start(update); });
    return function (v) {
        if (v <= input[0]) {
            subs[0].seek(0);
        }
        if (v >= input[finalInputIndex]) {
            subs[finalScrubberIndex].seek(1);
        }
        var i = 1;
        for (; i < rangeLength; i++) {
            if (input[i] > v || i === finalInputIndex)
                break;
        }
        var progressInRange = popcorn.progress(input[i - 1], input[i], v);
        subs[i - 1].seek(clampProgress$1(progressInRange));
    };
};
var keyframes = function (_a) {
    var easings = _a.easings, _b = _a.ease, ease = _b === void 0 ? easing.linear : _b, times = _a.times, values = _a.values, tweenProps = tslib_1.__rest(_a, ["easings", "ease", "times", "values"]);
    easings = Array.isArray(easings)
        ? easings
        : defaultEasings(values, easings);
    times = times || defaultTimings(values);
    var scrubbers = easings.map(function (easing$$1, i) {
        return vectorScrubber({
            from: values[i],
            to: values[i + 1],
            ease: easing$$1
        });
    });
    return tween(tslib_1.__assign({}, tweenProps, { ease: ease })).applyMiddleware(function (update) { return interpolateScrubbers(times, scrubbers, update); });
};

var physics = function (props) {
    if (props === void 0) { props = {}; }
    return action(function (_a) {
        var complete = _a.complete, update = _a.update;
        var _b = props.acceleration, acceleration = _b === void 0 ? 0 : _b, _c = props.friction, friction = _c === void 0 ? 0 : _c, _d = props.velocity, velocity = _d === void 0 ? 0 : _d, springStrength = props.springStrength, to = props.to;
        var _e = props.restSpeed, restSpeed = _e === void 0 ? 0.001 : _e, _f = props.from, from = _f === void 0 ? 0 : _f;
        var current = from;
        var process = sync__default.update(function (_a) {
            var delta = _a.delta;
            var elapsed = Math.max(delta, 16);
            if (acceleration)
                velocity += popcorn.velocityPerFrame(acceleration, elapsed);
            if (friction)
                velocity *= Math.pow((1 - friction), (elapsed / 100));
            if (springStrength !== undefined && to !== undefined) {
                var distanceToTarget = to - current;
                velocity += distanceToTarget * popcorn.velocityPerFrame(springStrength, elapsed);
            }
            current += popcorn.velocityPerFrame(velocity, elapsed);
            update(current);
            var isComplete = restSpeed !== false && (!velocity || Math.abs(velocity) <= restSpeed);
            if (isComplete) {
                sync.cancelSync.update(process);
                complete();
            }
        }, true);
        return {
            set: function (v) {
                current = v;
                return this;
            },
            setAcceleration: function (v) {
                acceleration = v;
                return this;
            },
            setFriction: function (v) {
                friction = v;
                return this;
            },
            setSpringStrength: function (v) {
                springStrength = v;
                return this;
            },
            setSpringTarget: function (v) {
                to = v;
                return this;
            },
            setVelocity: function (v) {
                velocity = v;
                return this;
            },
            stop: function () { return sync.cancelSync.update(process); }
        };
    });
};
var vectorPhysics = createVectorAction(physics, {
    acceleration: styleValueTypes.number.test,
    friction: styleValueTypes.number.test,
    velocity: styleValueTypes.number.test,
    from: styleValueTypes.number.test,
    to: styleValueTypes.number.test,
    springStrength: styleValueTypes.number.test
});

var DEFAULT_DURATION = 300;
var flattenTimings = function (instructions) {
    var flatInstructions = [];
    var lastArg = instructions[instructions.length - 1];
    var isStaggered = typeof lastArg === 'number';
    var staggerDelay = isStaggered ? lastArg : 0;
    var segments = isStaggered ? instructions.slice(0, -1) : instructions;
    var numSegments = segments.length;
    var offset = 0;
    segments.forEach(function (item, i) {
        flatInstructions.push(item);
        if (i !== numSegments - 1) {
            var duration = item.duration || DEFAULT_DURATION;
            offset += staggerDelay;
            flatInstructions.push("-" + (duration - offset));
        }
    });
    return flatInstructions;
};
var flattenArrayInstructions = function (instructions, instruction) {
    Array.isArray(instruction)
        ? instructions.push.apply(instructions, flattenTimings(instruction)) : instructions.push(instruction);
    return instructions;
};
var convertDefToProps = function (props, def, i) {
    var duration = props.duration, easings = props.easings, times = props.times, values = props.values;
    var numValues = values.length;
    var prevTimeTo = times[numValues - 1];
    var timeFrom = def.at === 0 ? 0 : def.at / duration;
    var timeTo = (def.at + def.duration) / duration;
    if (i === 0) {
        values.push(def.from);
        times.push(timeFrom);
    }
    else {
        if (prevTimeTo !== timeFrom) {
            if (def.from !== undefined) {
                values.push(values[numValues - 1]);
                times.push(timeFrom);
                easings.push(easing.linear);
            }
            var from = def.from !== undefined ? def.from : values[numValues - 1];
            values.push(from);
            times.push(timeFrom);
            easings.push(easing.linear);
        }
        else if (def.from !== undefined) {
            values.push(def.from);
            times.push(timeFrom);
            easings.push(easing.linear);
        }
    }
    values.push(def.to);
    times.push(timeTo);
    easings.push(def.ease || easing.easeInOut);
    return props;
};
var timeline = function (instructions, _a) {
    var _b = _a === void 0 ? {} : _a, duration = _b.duration, elapsed = _b.elapsed, ease = _b.ease, loop = _b.loop, flip = _b.flip, yoyo = _b.yoyo;
    var playhead = 0;
    var calculatedDuration = 0;
    var flatInstructions = instructions.reduce(flattenArrayInstructions, []);
    var animationDefs = [];
    flatInstructions.forEach(function (instruction) {
        if (typeof instruction === 'string') {
            playhead += parseFloat(instruction);
        }
        else if (typeof instruction === 'number') {
            playhead = instruction;
        }
        else {
            var def = tslib_1.__assign({}, instruction, { at: playhead });
            def.duration =
                def.duration === undefined ? DEFAULT_DURATION : def.duration;
            animationDefs.push(def);
            playhead += def.duration;
            calculatedDuration = Math.max(calculatedDuration, def.at + def.duration);
        }
    });
    var tracks = {};
    var numDefs = animationDefs.length;
    for (var i = 0; i < numDefs; i++) {
        var def = animationDefs[i];
        var track = def.track;
        if (track === undefined) {
            throw new Error('No track defined');
        }
        if (!tracks.hasOwnProperty(track))
            tracks[track] = [];
        tracks[track].push(def);
    }
    var trackKeyframes = {};
    for (var key in tracks) {
        if (tracks.hasOwnProperty(key)) {
            var keyframeProps = tracks[key].reduce(convertDefToProps, {
                duration: calculatedDuration,
                easings: [],
                times: [],
                values: []
            });
            trackKeyframes[key] = keyframes(tslib_1.__assign({}, keyframeProps, { duration: duration || calculatedDuration, ease: ease,
                elapsed: elapsed,
                loop: loop,
                yoyo: yoyo,
                flip: flip }));
        }
    }
    return composite(trackKeyframes);
};

var listen = function (element, events, options) { return action(function (_a) {
    var update = _a.update;
    var eventNames = events.split(' ').map(function (eventName) {
        element.addEventListener(eventName, update, options);
        return eventName;
    });
    return {
        stop: function () { return eventNames.forEach(function (eventName) { return element.removeEventListener(eventName, update, options); }); }
    };
}); };

var defaultPointerPos = function () { return ({
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    x: 0,
    y: 0
}); };
var eventToPoint = function (e, point) {
    if (point === void 0) { point = defaultPointerPos(); }
    point.clientX = point.x = e.clientX;
    point.clientY = point.y = e.clientY;
    point.pageX = e.pageX;
    point.pageY = e.pageY;
    return point;
};

var points = [defaultPointerPos()];
var isTouchDevice = false;
if (typeof document !== 'undefined') {
    var updatePointsLocation = function (_a) {
        var touches = _a.touches;
        isTouchDevice = true;
        var numTouches = touches.length;
        points.length = 0;
        for (var i = 0; i < numTouches; i++) {
            var thisTouch = touches[i];
            points.push(eventToPoint(thisTouch));
        }
    };
    listen(document, 'touchstart touchmove', {
        passive: true,
        capture: true
    }).start(updatePointsLocation);
}
var multitouch = function (_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.preventDefault, preventDefault = _c === void 0 ? true : _c, _d = _b.scale, scale = _d === void 0 ? 1.0 : _d, _e = _b.rotate, rotate = _e === void 0 ? 0.0 : _e;
    return action(function (_a) {
        var update = _a.update;
        var output = {
            touches: points,
            scale: scale,
            rotate: rotate
        };
        var initialDistance = 0.0;
        var initialRotation = 0.0;
        var isGesture = points.length > 1;
        if (isGesture) {
            var firstTouch = points[0], secondTouch = points[1];
            initialDistance = popcorn.distance(firstTouch, secondTouch);
            initialRotation = popcorn.angle(firstTouch, secondTouch);
        }
        var updatePoint = function () {
            if (isGesture) {
                var firstTouch = points[0], secondTouch = points[1];
                var newDistance = popcorn.distance(firstTouch, secondTouch);
                var newRotation = popcorn.angle(firstTouch, secondTouch);
                output.scale = scale * (newDistance / initialDistance);
                output.rotate = rotate + (newRotation - initialRotation);
            }
            update(output);
        };
        var onMove = function (e) {
            if (preventDefault || e.touches.length > 1)
                e.preventDefault();
            sync__default.update(updatePoint);
        };
        var updateOnMove = listen(document, 'touchmove', {
            passive: !preventDefault
        }).start(onMove);
        if (isTouchDevice)
            sync__default.update(updatePoint);
        return {
            stop: function () {
                sync.cancelSync.update(updatePoint);
                updateOnMove.stop();
            }
        };
    });
};
var getIsTouchDevice = function () { return isTouchDevice; };

var point = defaultPointerPos();
var isMouseDevice = false;
if (typeof document !== 'undefined') {
    var updatePointLocation = function (e) {
        isMouseDevice = true;
        eventToPoint(e, point);
    };
    listen(document, 'mousedown mousemove', true).start(updatePointLocation);
}
var mouse = function (_a) {
    var _b = (_a === void 0 ? {} : _a).preventDefault, preventDefault = _b === void 0 ? true : _b;
    return action(function (_a) {
        var update = _a.update;
        var updatePoint = function () { return update(point); };
        var onMove = function (e) {
            if (preventDefault)
                e.preventDefault();
            sync__default.update(updatePoint);
        };
        var updateOnMove = listen(document, 'mousemove').start(onMove);
        if (isMouseDevice)
            sync__default.update(updatePoint);
        return {
            stop: function () {
                sync.cancelSync.update(updatePoint);
                updateOnMove.stop();
            }
        };
    });
};

var getFirstTouch = function (_a) {
    var firstTouch = _a[0];
    return firstTouch;
};
var pointer = function (props) {
    if (props === void 0) { props = {}; }
    return getIsTouchDevice()
        ? multitouch(props).pipe(function (_a) {
            var touches = _a.touches;
            return touches;
        }, getFirstTouch)
        : mouse(props);
};
var index$1 = (function (_a) {
    if (_a === void 0) { _a = {}; }
    var x = _a.x, y = _a.y, props = tslib_1.__rest(_a, ["x", "y"]);
    if (x !== undefined || y !== undefined) {
        var applyXOffset_1 = popcorn.applyOffset(x || 0);
        var applyYOffset_1 = popcorn.applyOffset(y || 0);
        var delta_1 = { x: 0, y: 0 };
        return pointer(props).pipe(function (point) {
            delta_1.x = applyXOffset_1(point.x);
            delta_1.y = applyYOffset_1(point.y);
            return delta_1;
        });
    }
    else {
        return pointer(props);
    }
});

var chain = function () {
    var actions = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        actions[_i] = arguments[_i];
    }
    return action(function (_a) {
        var update = _a.update, complete = _a.complete;
        var i = 0;
        var current;
        var playCurrent = function () {
            current = actions[i].start({
                complete: function () {
                    i++;
                    (i >= actions.length) ? complete() : playCurrent();
                },
                update: update
            });
        };
        playCurrent();
        return {
            stop: function () { return current && current.stop(); }
        };
    });
};

var crossfade = function (a, b) {
    return action(function (observer) {
        var balance = 0;
        var fadable = parallel$1(a, b).start(tslib_1.__assign({}, observer, { update: function (_a) {
                var va = _a[0], vb = _a[1];
                observer.update(popcorn.mix(va, vb, balance));
            } }));
        return {
            setBalance: function (v) { return (balance = v); },
            stop: function () { return fadable.stop(); }
        };
    });
};

var delay = function (timeToDelay) { return action(function (_a) {
    var complete = _a.complete;
    var timeout = setTimeout(complete, timeToDelay);
    return {
        stop: function () { return clearTimeout(timeout); }
    };
}); };

var merge = function () {
    var actions = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        actions[_i] = arguments[_i];
    }
    return action(function (observer) {
        var subs = actions.map(function (thisAction) { return thisAction.start(observer); });
        return {
            stop: function () { return subs.forEach(function (sub) { return sub.stop(); }); }
        };
    });
};

var schedule = function (scheduler, schedulee) { return action(function (_a) {
    var update = _a.update, complete = _a.complete;
    var latest;
    var schedulerSub = scheduler.start({
        update: function () { return latest !== undefined && update(latest); },
        complete: complete
    });
    var scheduleeSub = schedulee.start({
        update: function (v) { return latest = v; },
        complete: complete
    });
    return {
        stop: function () {
            schedulerSub.stop();
            scheduleeSub.stop();
        }
    };
}); };

var stagger = function (actions, interval) {
    var intervalIsNumber = typeof interval === 'number';
    var actionsWithDelay = actions.map(function (a, i) {
        var timeToDelay = intervalIsNumber ? interval * i : interval(i);
        return chain(delay(timeToDelay), a);
    });
    return parallel$1.apply(void 0, actionsWithDelay);
};

var appendUnit = function (unit) { return function (v) { return "" + v + unit; }; };
var steps = function (st, min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 1; }
    return function (v) {
        var current = popcorn.progress(min, max, v);
        return popcorn.mix(min, max, stepProgress(st, current));
    };
};
var transformMap = function (childTransformers) { return function (v) {
    var output = tslib_1.__assign({}, v);
    for (var key in childTransformers) {
        if (childTransformers.hasOwnProperty(key)) {
            var childTransformer = childTransformers[key];
            output[key] = childTransformer(v[key]);
        }
    }
    return output;
}; };

var transformers = /*#__PURE__*/Object.freeze({
  applyOffset: popcorn.applyOffset,
  clamp: popcorn.clamp,
  conditional: popcorn.conditional,
  interpolate: popcorn.interpolate,
  blendArray: popcorn.mixArray,
  blendColor: popcorn.mixColor,
  pipe: popcorn.pipe,
  smooth: popcorn.smooth,
  snap: popcorn.snap,
  generateStaticSpring: popcorn.springForce,
  nonlinearSpring: popcorn.springForceExpo,
  linearSpring: popcorn.springForceLinear,
  wrap: popcorn.wrap,
  appendUnit: appendUnit,
  steps: steps,
  transformMap: transformMap
});

var css = function (element, props) {
    heyListen.warning(false, 'css() is deprecated, use styler instead');
    return styler(element, props);
};
var svg = function (element, props) {
    heyListen.warning(false, 'svg() is deprecated, use styler instead');
    return styler(element, props);
};

exports.valueTypes = styleValueTypes;
exports.easing = easing;
exports.styler = styler;
exports.action = action;
exports.multicast = multicast;
exports.value = value;
exports.decay = vectorDecay;
exports.inertia = index;
exports.keyframes = keyframes;
exports.everyFrame = frame;
exports.physics = vectorPhysics;
exports.spring = vectorSpring;
exports.timeline = timeline;
exports.tween = tween;
exports.listen = listen;
exports.pointer = index$1;
exports.mouse = mouse;
exports.multitouch = multitouch;
exports.chain = chain;
exports.composite = composite;
exports.crossfade = crossfade;
exports.delay = delay;
exports.merge = merge;
exports.parallel = parallel$1;
exports.schedule = schedule;
exports.stagger = stagger;
exports.calc = calc;
exports.transform = transformers;
exports.css = css;
exports.svg = svg;
exports.Action = Action;
exports.ValueReaction = ValueReaction;


/***/ }),

/***/ "./node_modules/pose-core/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.js");
var heyListen = __webpack_require__("./node_modules/hey-listen/lib/index.js");

var getPoseValues = function (_a) {
    var transition = _a.transition, flip = _a.flip, delay = _a.delay, delayChildren = _a.delayChildren, staggerChildren = _a.staggerChildren, staggerDirection = _a.staggerDirection, afterChildren = _a.afterChildren, beforeChildren = _a.beforeChildren, preTransition = _a.preTransition, applyAtStart = _a.applyAtStart, applyAtEnd = _a.applyAtEnd, props = tslib_1.__rest(_a, ["transition", "flip", "delay", "delayChildren", "staggerChildren", "staggerDirection", "afterChildren", "beforeChildren", "preTransition", "applyAtStart", "applyAtEnd"]);
    return props;
};
var selectPoses = function (_a) {
    var label = _a.label, props = _a.props, values = _a.values, parentValues = _a.parentValues, ancestorValues = _a.ancestorValues, onChange = _a.onChange, passive = _a.passive, initialPose = _a.initialPose, poses = tslib_1.__rest(_a, ["label", "props", "values", "parentValues", "ancestorValues", "onChange", "passive", "initialPose"]);
    return poses;
};
var selectAllValues = function (values, selectValue) {
    var allValues = {};
    values.forEach(function (value, key) { return (allValues[key] = selectValue(value)); });
    return allValues;
};

var resolveProp = function (target, props) {
    return typeof target === 'function' ? target(props) : target;
};
var poseDefault = function (pose, prop, defaultValue, resolveProps) {
    return pose && pose[prop] !== undefined
        ? resolveProp(pose[prop], resolveProps)
        : defaultValue;
};
var startChildAnimations = function (children, next, pose, props) {
    var animations = [];
    var delay = poseDefault(pose, 'delayChildren', 0, props);
    var stagger = poseDefault(pose, 'staggerChildren', 0, props);
    var staggerDirection = poseDefault(pose, 'staggerDirection', 1, props);
    var maxStaggerDuration = (children.size - 1) * stagger;
    var generateStaggerDuration = staggerDirection === 1
        ? function (i) { return i * stagger; }
        : function (i) { return maxStaggerDuration - i * stagger; };
    Array.from(children).forEach(function (child, i) {
        animations.push(child.set(next, {
            delay: delay + generateStaggerDuration(i)
        }));
    });
    return animations;
};
var resolveTransition = function (transition, key, value, props, convertTransitionDefinition, getInstantTransition) {
    var resolvedTransition;
    if (typeof transition === 'function') {
        var resolvedTransitionMap = transition(props);
        resolvedTransition = resolveTransition(resolvedTransitionMap, key, value, props, convertTransitionDefinition, getInstantTransition);
    }
    else if (transition[key] || transition.default) {
        var keyTransition = transition[key] || transition.default;
        if (typeof keyTransition === 'function') {
            resolvedTransition = keyTransition(props);
        }
        else {
            resolvedTransition = keyTransition;
        }
    }
    else {
        resolvedTransition = transition;
    }
    return resolvedTransition === false
        ? getInstantTransition(value, props)
        : convertTransitionDefinition(value, resolvedTransition, props);
};
var findInsertionIndex = function (poseList, priorityList, priorityIndex) {
    var insertionIndex = 0;
    for (var i = priorityIndex - 1; i >= 0; i--) {
        var nextHighestPriorityIndex = poseList.indexOf(priorityList[i]);
        if (nextHighestPriorityIndex !== -1) {
            insertionIndex = nextHighestPriorityIndex + 1;
            break;
        }
    }
    return insertionIndex;
};
var applyValues = function (toApply, values, props, setValue, setValueNative) {
    heyListen.invariant(typeof toApply === 'object', 'applyAtStart and applyAtEnd must be of type object');
    return Object.keys(toApply).forEach(function (key) {
        var valueToSet = resolveProp(toApply[key], props);
        values.has(key)
            ? setValue(values.get(key), valueToSet)
            : setValueNative(key, valueToSet, props);
    });
};
var createPoseSetter = function (setterProps) {
    var state = setterProps.state, poses = setterProps.poses, startAction = setterProps.startAction, stopAction = setterProps.stopAction, getInstantTransition = setterProps.getInstantTransition, addActionDelay = setterProps.addActionDelay, getTransitionProps = setterProps.getTransitionProps, resolveTarget = setterProps.resolveTarget, transformPose = setterProps.transformPose, posePriority = setterProps.posePriority, convertTransitionDefinition = setterProps.convertTransitionDefinition, setValue = setterProps.setValue, setValueNative = setterProps.setValueNative, forceRender = setterProps.forceRender;
    return function (next, nextProps, propagate) {
        if (nextProps === void 0) { nextProps = {}; }
        if (propagate === void 0) { propagate = true; }
        var children = state.children, values = state.values, props = state.props, activeActions = state.activeActions, activePoses = state.activePoses;
        var _a = nextProps.delay, delay = _a === void 0 ? 0 : _a;
        var hasChildren = children.size;
        var baseTransitionProps = tslib_1.__assign({}, props, nextProps);
        var nextPose = poses[next];
        var getChildAnimations = function () {
            return hasChildren && propagate
                ? startChildAnimations(children, next, nextPose, baseTransitionProps)
                : [];
        };
        var getParentAnimations = function () {
            if (!nextPose)
                return [];
            var applyAtStart = nextPose.applyAtStart;
            if (applyAtStart) {
                applyValues(applyAtStart, values, baseTransitionProps, setValue, setValueNative);
                if (forceRender)
                    forceRender(baseTransitionProps);
            }
            if (transformPose)
                nextPose = transformPose(nextPose, next, state);
            var preTransition = nextPose.preTransition, getTransition = nextPose.transition, applyAtEnd = nextPose.applyAtEnd;
            if (preTransition)
                preTransition(baseTransitionProps);
            var animations = Object.keys(getPoseValues(nextPose)).map(function (key) {
                var valuePoses = activePoses.has(key)
                    ? activePoses.get(key)
                    : (activePoses.set(key, []), activePoses.get(key));
                var existingIndex = valuePoses.indexOf(next);
                if (existingIndex !== -1)
                    valuePoses.splice(existingIndex, 1);
                var priority = posePriority ? posePriority.indexOf(next) : 0;
                var insertionIndex = priority <= 0
                    ? 0
                    : findInsertionIndex(valuePoses, posePriority, priority);
                valuePoses.splice(insertionIndex, 0, next);
                return insertionIndex === 0
                    ? new Promise(function (complete) {
                        var value = values.get(key);
                        var transitionProps = tslib_1.__assign({}, baseTransitionProps, { key: key,
                            value: value });
                        var target = resolveTarget(value, resolveProp(nextPose[key], transitionProps));
                        if (activeActions.has(key))
                            stopAction(activeActions.get(key));
                        var resolveTransitionProps = tslib_1.__assign({ to: target }, transitionProps, getTransitionProps(value, target, transitionProps));
                        var transition = resolveTransition(getTransition, key, value, resolveTransitionProps, convertTransitionDefinition, getInstantTransition);
                        var poseDelay = delay || resolveProp(nextPose.delay, transitionProps);
                        if (poseDelay) {
                            transition = addActionDelay(poseDelay, transition);
                        }
                        activeActions.set(key, startAction(value, transition, complete));
                    })
                    : Promise.resolve();
            });
            return applyAtEnd
                ? [
                    Promise.all(animations).then(function () {
                        applyValues(applyAtEnd, values, baseTransitionProps, setValue, setValueNative);
                    })
                ]
                : animations;
        };
        if (nextPose && hasChildren) {
            if (resolveProp(nextPose.beforeChildren, baseTransitionProps)) {
                return Promise.all(getParentAnimations()).then(function () {
                    return Promise.all(getChildAnimations());
                });
            }
            else if (resolveProp(nextPose.afterChildren, baseTransitionProps)) {
                return Promise.all(getChildAnimations()).then(function () {
                    return Promise.all(getParentAnimations());
                });
            }
        }
        return Promise.all(getParentAnimations().concat(getChildAnimations()));
    };
};

var DEFAULT_INITIAL_POSE = 'init';
var isScale = function (key) { return key.includes('scale'); };
var defaultReadValueFromSource = function (key) { return (isScale(key) ? 1 : 0); };
var readValueFromPose = function (pose, key, props) {
    var valueToResolve = pose.applyAtEnd && pose.applyAtEnd[key] !== undefined
        ? pose.applyAtEnd[key]
        : pose[key] !== undefined
            ? pose[key]
            : pose.applyAtStart && pose.applyAtStart[key] !== undefined
                ? pose.applyAtStart[key]
                : 0;
    return resolveProp(valueToResolve, props);
};
var getPosesToSearch = function (pose) {
    var posesToSearch = Array.isArray(pose) ? pose : [pose];
    posesToSearch.push(DEFAULT_INITIAL_POSE);
    return posesToSearch;
};
var getInitialValue = function (poses, key, initialPose, props, readValueFromSource, activePoses) {
    if (readValueFromSource === void 0) { readValueFromSource = defaultReadValueFromSource; }
    var posesToSearch = getPosesToSearch(initialPose);
    var pose = posesToSearch.filter(Boolean).find(function (name) {
        var thisPose = poses[name];
        return (thisPose &&
            (thisPose[key] !== undefined ||
                (thisPose.applyAtStart && thisPose.applyAtStart[key] !== undefined) ||
                (thisPose.applyAtEnd && thisPose.applyAtEnd[key] !== undefined)));
    });
    activePoses.set(key, [pose || DEFAULT_INITIAL_POSE]);
    return pose
        ? readValueFromPose(poses[pose], key, props)
        : readValueFromSource(key, props);
};
var createValues = function (values, _a) {
    var userSetValues = _a.userSetValues, createValue = _a.createValue, convertValue = _a.convertValue, readValueFromSource = _a.readValueFromSource, initialPose = _a.initialPose, poses = _a.poses, activePoses = _a.activePoses, props = _a.props;
    return function (key) {
        if (values.has(key))
            return;
        var value;
        if (userSetValues && userSetValues[key] !== undefined) {
            value = convertValue(userSetValues[key], key, props);
        }
        else {
            var initValue = getInitialValue(poses, key, initialPose, props, readValueFromSource, activePoses);
            value = createValue(initValue, key, props);
        }
        values.set(key, value);
    };
};
var scrapeValuesFromPose = function (values, props) { return function (key) {
    var pose = props.poses[key];
    Object.keys(getPoseValues(pose)).forEach(createValues(values, props));
}; };
var getAncestorValue = function (key, fromParent, ancestors) {
    if (fromParent === true) {
        return ancestors[0] && ancestors[0].values.get(key);
    }
    else {
        var foundAncestor = ancestors.find(function (_a) {
            var label = _a.label;
            return label === fromParent;
        });
        return foundAncestor && foundAncestor.values.get(key);
    }
};
var bindPassiveValues = function (values, _a) {
    var passive = _a.passive, ancestorValues = _a.ancestorValues, createValue = _a.createValue, readValue = _a.readValue, props = _a.props;
    return function (key) {
        var _a = passive[key], valueKey = _a[0], passiveProps = _a[1], fromParent = _a[2];
        var valueToBind = fromParent && ancestorValues.length
            ? getAncestorValue(valueKey, fromParent, ancestorValues)
            : values.has(valueKey)
                ? values.get(valueKey)
                : false;
        if (!valueToBind)
            return;
        var newValue = createValue(readValue(valueToBind), key, props, {
            passiveParentKey: valueKey,
            passiveParent: valueToBind,
            passiveProps: passiveProps
        });
        values.set(key, newValue);
    };
};
var setNativeValues = function (_a) {
    var setValueNative = _a.setValueNative, initialPose = _a.initialPose, props = _a.props, poses = _a.poses;
    var valuesHaveSet = new Set();
    var setValues = function (pose, propKey) {
        if (pose[propKey]) {
            for (var key in pose[propKey]) {
                if (!valuesHaveSet.has(key)) {
                    valuesHaveSet.add(key);
                    setValueNative(key, resolveProp(pose[propKey][key], props), props);
                }
            }
        }
    };
    getPosesToSearch(initialPose).forEach(function (poseKey) {
        var pose = poses[poseKey];
        if (pose) {
            setValues(pose, 'applyAtEnd');
            setValues(pose, 'applyAtStart');
        }
    });
};
var createValueMap = function (props) {
    var poses = props.poses, passive = props.passive;
    var values = new Map();
    Object.keys(poses).forEach(scrapeValuesFromPose(values, props));
    setNativeValues(props);
    if (passive)
        Object.keys(passive).forEach(bindPassiveValues(values, props));
    return values;
};

var applyDefaultTransition = function (pose, key, defaultTransitions) {
    return tslib_1.__assign({}, pose, { transition: defaultTransitions.has(key)
            ? defaultTransitions.get(key)
            : defaultTransitions.get('default') });
};
var generateTransitions = function (poses, defaultTransitions) {
    Object.keys(poses).forEach(function (key) {
        var pose = poses[key];
        heyListen.invariant(typeof pose === 'object', "Pose '" + key + "' is of invalid type. All poses should be objects.");
        poses[key] =
            pose.transition !== undefined
                ? pose
                : applyDefaultTransition(pose, key, defaultTransitions);
    });
    return poses;
};

var sortByReversePriority = function (priorityOrder) { return function (a, b) {
    var aP = priorityOrder.indexOf(a);
    var bP = priorityOrder.indexOf(b);
    if (aP === -1 && bP !== -1)
        return -1;
    if (aP !== -1 && bP === -1)
        return 1;
    return aP - bP;
}; };

var poseFactory = function (_a) {
    var getDefaultProps = _a.getDefaultProps, defaultTransitions = _a.defaultTransitions, bindOnChange = _a.bindOnChange, startAction = _a.startAction, stopAction = _a.stopAction, readValue = _a.readValue, readValueFromSource = _a.readValueFromSource, resolveTarget = _a.resolveTarget, setValue = _a.setValue, setValueNative = _a.setValueNative, createValue = _a.createValue, convertValue = _a.convertValue, getInstantTransition = _a.getInstantTransition, getTransitionProps = _a.getTransitionProps, addActionDelay = _a.addActionDelay, selectValueToRead = _a.selectValueToRead, convertTransitionDefinition = _a.convertTransitionDefinition, transformPose = _a.transformPose, posePriority = _a.posePriority, forceRender = _a.forceRender, extendAPI = _a.extendAPI;
    return function (config) {
        var parentValues = config.parentValues, _a = config.ancestorValues, ancestorValues = _a === void 0 ? [] : _a;
        if (parentValues)
            ancestorValues.unshift({ values: parentValues });
        var activeActions = new Map();
        var activePoses = new Map();
        var children = new Set();
        var poses = generateTransitions(selectPoses(config), defaultTransitions);
        var _b = config.props, props = _b === void 0 ? {} : _b;
        if (getDefaultProps)
            props = tslib_1.__assign({}, getDefaultProps(config), props);
        var passive = config.passive, userSetValues = config.values, _c = config.initialPose, initialPose = _c === void 0 ? DEFAULT_INITIAL_POSE : _c;
        var values = createValueMap({
            poses: poses,
            passive: passive,
            ancestorValues: ancestorValues,
            readValue: readValue,
            setValueNative: setValueNative,
            createValue: createValue,
            convertValue: convertValue,
            readValueFromSource: readValueFromSource,
            userSetValues: userSetValues,
            initialPose: initialPose,
            activePoses: activePoses,
            props: props
        });
        var state = {
            activeActions: activeActions,
            activePoses: activePoses,
            children: children,
            props: props,
            values: values
        };
        var onChange = config.onChange;
        if (onChange)
            Object.keys(onChange).forEach(bindOnChange(values, onChange));
        var set = createPoseSetter({
            state: state,
            poses: poses,
            getInstantTransition: getInstantTransition,
            getTransitionProps: getTransitionProps,
            convertTransitionDefinition: convertTransitionDefinition,
            setValue: setValue,
            setValueNative: setValueNative,
            startAction: startAction,
            stopAction: stopAction,
            resolveTarget: resolveTarget,
            addActionDelay: addActionDelay,
            transformPose: transformPose,
            posePriority: posePriority,
            forceRender: forceRender
        });
        var has = function (poseName) { return !!poses[poseName]; };
        var api = {
            set: set,
            unset: function (poseName, poseProps) {
                var posesToSet = [];
                activePoses.forEach(function (valuePoses) {
                    var poseIndex = valuePoses.indexOf(poseName);
                    if (poseIndex === -1)
                        return;
                    var currentPose = valuePoses[0];
                    valuePoses.splice(poseIndex, 1);
                    var nextPose = valuePoses[0];
                    if (nextPose === currentPose)
                        return;
                    if (posesToSet.indexOf(nextPose) === -1) {
                        posesToSet.push(nextPose);
                    }
                });
                var animationsToResolve = posesToSet
                    .sort(sortByReversePriority(posePriority))
                    .map(function (poseToSet) { return set(poseToSet, poseProps, false); });
                children.forEach(function (child) {
                    return animationsToResolve.push(child.unset(poseName));
                });
                return Promise.all(animationsToResolve);
            },
            get: function (valueName) {
                return valueName
                    ? selectValueToRead(values.get(valueName))
                    : selectAllValues(values, selectValueToRead);
            },
            has: has,
            setProps: function (newProps) { return (state.props = tslib_1.__assign({}, state.props, newProps)); },
            _addChild: function (childConfig, factory) {
                var child = factory(tslib_1.__assign({ initialPose: initialPose }, childConfig, { ancestorValues: [{ label: config.label, values: values }].concat(ancestorValues) }));
                children.add(child);
                return child;
            },
            removeChild: function (child) { return children.delete(child); },
            clearChildren: function () {
                children.forEach(function (child) { return child.destroy(); });
                children.clear();
            },
            destroy: function () {
                activeActions.forEach(stopAction);
                children.forEach(function (child) { return child.destroy(); });
            }
        };
        return extendAPI(api, state, config);
    };
};

exports.default = poseFactory;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithThrowingShims.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__("./node_modules/fbjs/lib/emptyFunction.js");
var invariant = __webpack_require__("./node_modules/fbjs/lib/invariant.js");
var ReactPropTypesSecret = __webpack_require__("./node_modules/prop-types/lib/ReactPropTypesSecret.js");

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, isValidElement, REACT_ELEMENT_TYPE; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__("./node_modules/prop-types/factoryWithThrowingShims.js")();
}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-measure/dist/index.cjs.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/extends.js"));
var _objectWithoutPropertiesLoose = _interopDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"));
var _inheritsLoose = _interopDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inheritsLoose.js"));
var react = __webpack_require__("./node_modules/react/index.js");
var PropTypes = _interopDefault(__webpack_require__("./node_modules/react-measure/node_modules/prop-types/index.js"));
var ResizeObserver = _interopDefault(__webpack_require__("./node_modules/resize-observer-polyfill/dist/ResizeObserver.js"));

var types = ['client', 'offset', 'scroll', 'bounds', 'margin'];
function getTypes(props) {
  var allowedTypes = [];
  types.forEach(function (type) {
    if (props[type]) {
      allowedTypes.push(type);
    }
  });
  return allowedTypes;
}

function getContentRect(node, types) {
  var calculations = {};

  if (types.indexOf('client') > -1) {
    calculations.client = {
      top: node.clientTop,
      left: node.clientLeft,
      width: node.clientWidth,
      height: node.clientHeight
    };
  }

  if (types.indexOf('offset') > -1) {
    calculations.offset = {
      top: node.offsetTop,
      left: node.offsetLeft,
      width: node.offsetWidth,
      height: node.offsetHeight
    };
  }

  if (types.indexOf('scroll') > -1) {
    calculations.scroll = {
      top: node.scrollTop,
      left: node.scrollLeft,
      width: node.scrollWidth,
      height: node.scrollHeight
    };
  }

  if (types.indexOf('bounds') > -1) {
    var rect = node.getBoundingClientRect();
    calculations.bounds = {
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left,
      width: rect.width,
      height: rect.height
    };
  }

  if (types.indexOf('margin') > -1) {
    var styles = getComputedStyle(node);
    calculations.margin = {
      top: styles ? parseInt(styles.marginTop) : 0,
      right: styles ? parseInt(styles.marginRight) : 0,
      bottom: styles ? parseInt(styles.marginBottom) : 0,
      left: styles ? parseInt(styles.marginLeft) : 0
    };
  }

  return calculations;
}

function withContentRect(types) {
  return function (WrappedComponent) {
    var _class, _temp;

    return _temp = _class =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(WithContentRect, _Component);

      function WithContentRect() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        _this.state = {
          contentRect: {
            entry: {},
            client: {},
            offset: {},
            scroll: {},
            bounds: {},
            margin: {}
          }
        };
        _this._animationFrameID = null;
        _this._resizeObserver = null;
        _this._node = null;

        _this.measure = function (entries) {
          var contentRect = getContentRect(_this._node, types || getTypes(_this.props));

          if (entries) {
            contentRect.entry = entries[0].contentRect;
          }

          _this._animationFrameID = window.requestAnimationFrame(function () {
            if (_this._resizeObserver !== null) {
              _this.setState({
                contentRect: contentRect
              });
            }
          });

          if (typeof _this.props.onResize === 'function') {
            _this.props.onResize(contentRect);
          }
        };

        _this._handleRef = function (node) {
          if (_this._resizeObserver !== null && _this._node !== null) {
            _this._resizeObserver.unobserve(_this._node);
          }

          _this._node = node;

          if (_this._resizeObserver !== null && _this._node !== null) {
            _this._resizeObserver.observe(_this._node);
          }

          var innerRef = _this.props.innerRef;

          if (innerRef) {
            if (typeof innerRef === 'function') {
              innerRef(_this._node);
            } else {
              innerRef.current = _this._node;
            }
          }
        };

        return _this;
      }

      var _proto = WithContentRect.prototype;

      _proto.componentDidMount = function componentDidMount() {
        this._resizeObserver = new ResizeObserver(this.measure);

        if (this._node !== null) {
          this._resizeObserver.observe(this._node);
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        if (this._resizeObserver !== null) {
          this._resizeObserver.disconnect();

          this._resizeObserver = null;
        }

        window.cancelAnimationFrame(this._animationFrameID);
      };

      _proto.render = function render() {
        var _this$props = this.props,
            innerRef = _this$props.innerRef,
            onResize = _this$props.onResize,
            props = _objectWithoutPropertiesLoose(_this$props, ["innerRef", "onResize"]);

        return react.createElement(WrappedComponent, _extends({}, props, {
          measureRef: this._handleRef,
          measure: this.measure,
          contentRect: this.state.contentRect
        }));
      };

      return WithContentRect;
    }(react.Component), _class.propTypes = {
      client: PropTypes.bool,
      offset: PropTypes.bool,
      scroll: PropTypes.bool,
      bounds: PropTypes.bool,
      margin: PropTypes.bool,
      innerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
      onResize: PropTypes.func
    }, _temp;
  };
}

var Measure = withContentRect()(function (_ref) {
  var measure = _ref.measure,
      measureRef = _ref.measureRef,
      contentRect = _ref.contentRect,
      children = _ref.children;
  return children({
    measure: measure,
    measureRef: measureRef,
    contentRect: contentRect
  });
});
Measure.displayName = 'Measure';
Measure.propTypes.children = PropTypes.func;

exports.default = Measure;
exports.withContentRect = withContentRect;


/***/ }),

/***/ "./node_modules/react-measure/node_modules/prop-types/factoryWithThrowingShims.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__("./node_modules/react-measure/node_modules/prop-types/lib/ReactPropTypesSecret.js");

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/react-measure/node_modules/prop-types/index.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__("./node_modules/react-measure/node_modules/prop-types/factoryWithThrowingShims.js")();
}


/***/ }),

/***/ "./node_modules/react-measure/node_modules/prop-types/lib/ReactPropTypesSecret.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-pose/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.js");
var React = __webpack_require__("./node_modules/react/index.js");
var React__default = _interopDefault(React);
var poseFactory = _interopDefault(__webpack_require__("./node_modules/popmotion-pose/lib/index.js"));
var isValidProp = _interopDefault(__webpack_require__("./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js"));
var heyListen = __webpack_require__("./node_modules/hey-listen/lib/index.js");

var hasChanged = function (prev, next) {
    if (prev === next)
        return false;
    var prevIsArray = Array.isArray(prev);
    var nextIsArray = Array.isArray(next);
    if (prevIsArray !== nextIsArray || (!prevIsArray && !nextIsArray)) {
        return true;
    }
    else if (prevIsArray && nextIsArray) {
        var numPrev = prev.length;
        var numNext = next.length;
        if (numPrev !== numNext)
            return true;
        for (var i = 0; i < numPrev; i++) {
            if (prev[i] !== next[i])
                return true;
        }
    }
    return false;
};

var pickAssign = function (shouldPick, sources) {
    return sources.reduce(function (picked, source) {
        for (var key in source) {
            if (shouldPick(key)) {
                picked[key] = source[key];
            }
        }
        return picked;
    }, {});
};

var _a = React.createContext({}), PoseParentConsumer = _a.Consumer, PoseParentProvider = _a.Provider;
var calcPopFromFlowStyle = function (el) {
    var offsetTop = el.offsetTop, offsetLeft = el.offsetLeft, offsetWidth = el.offsetWidth, offsetHeight = el.offsetHeight;
    return {
        position: 'absolute',
        top: offsetTop,
        left: offsetLeft,
        width: offsetWidth,
        height: offsetHeight
    };
};
var hasPose = function (pose, key) {
    return Array.isArray(pose) ? pose.indexOf(key) !== -1 : pose === key;
};
var objectToMap = function (obj) {
    return Object.keys(obj).reduce(function (map, key) {
        map.set(key, { raw: obj[key] });
        return map;
    }, new Map());
};
var testAlwaysTrue = function () { return true; };
var filterProps = function (_a) {
    var elementType = _a.elementType, poseConfig = _a.poseConfig, onValueChange = _a.onValueChange, innerRef = _a.innerRef, _pose = _a._pose, pose = _a.pose, initialPose = _a.initialPose, poseKey = _a.poseKey, onPoseComplete = _a.onPoseComplete, getParentPoseConfig = _a.getParentPoseConfig, registerChild = _a.registerChild, onUnmount = _a.onUnmount, getInitialPoseFromParent = _a.getInitialPoseFromParent, popFromFlow = _a.popFromFlow, values = _a.values, parentValues = _a.parentValues, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, onPressStart = _a.onPressStart, onPressEnd = _a.onPressEnd, props = tslib_1.__rest(_a, ["elementType", "poseConfig", "onValueChange", "innerRef", "_pose", "pose", "initialPose", "poseKey", "onPoseComplete", "getParentPoseConfig", "registerChild", "onUnmount", "getInitialPoseFromParent", "popFromFlow", "values", "parentValues", "onDragStart", "onDragEnd", "onPressStart", "onPressEnd"]);
    return props;
};
var PoseElement = (function (_super) {
    tslib_1.__extends(PoseElement, _super);
    function PoseElement(props) {
        var _this = _super.call(this, props) || this;
        _this.children = new Set();
        _this.childrenHandlers = {
            registerChild: function (props) {
                _this.children.add(props);
                if (_this.poser)
                    _this.flushChildren();
            },
            onUnmount: function (child) { return _this.poser.removeChild(child); },
            getParentPoseConfig: function () { return _this.poseConfig; },
            getInitialPoseFromParent: function () { return _this.getInitialPose(); }
        };
        _this.setRef = function (ref) {
            heyListen.warning(ref === null || (ref instanceof Element && _this.ref === undefined), 'ref must be provided to the same DOM component for the entire lifecycle of a posed component.');
            _this.ref = ref;
            var innerRef = _this.props.innerRef;
            if (!innerRef)
                return;
            if (typeof innerRef === 'function') {
                innerRef(ref);
            }
            else {
                innerRef.current = ref;
            }
        };
        _this.shouldForwardProp =
            typeof _this.props.elementType === 'string' ? isValidProp : testAlwaysTrue;
        var poseConfig = _this.props.poseConfig;
        _this.poseConfig =
            typeof poseConfig === 'function'
                ? poseConfig(filterProps(props))
                : poseConfig;
        return _this;
    }
    PoseElement.prototype.getInitialPose = function () {
        var _a = this.props, getInitialPoseFromParent = _a.getInitialPoseFromParent, pose = _a.pose, _pose = _a._pose, initialPose = _a.initialPose;
        if (initialPose) {
            return initialPose;
        }
        else {
            var parentPose = getInitialPoseFromParent && getInitialPoseFromParent();
            var initialPoses = (Array.isArray(parentPose)
                ? parentPose
                : [parentPose])
                .concat(pose, _pose)
                .filter(Boolean);
            return initialPoses.length > 0 ? initialPoses : undefined;
        }
    };
    PoseElement.prototype.getFirstPose = function () {
        var _a = this.props, initialPose = _a.initialPose, pose = _a.pose, _pose = _a._pose;
        if (!initialPose)
            return;
        var firstPose = (Array.isArray(pose) ? pose : [pose])
            .concat(_pose)
            .filter(Boolean);
        return firstPose.length === 1 ? firstPose[0] : firstPose;
    };
    PoseElement.prototype.getSetProps = function () {
        var props = filterProps(this.props);
        if (this.props.popFromFlow && this.ref && this.ref instanceof HTMLElement) {
            if (!this.popStyle) {
                props.style = tslib_1.__assign({}, props.style, calcPopFromFlowStyle(this.ref));
                this.popStyle = props.style;
            }
            else {
                props.style = this.popStyle;
            }
        }
        else {
            this.popStyle = null;
        }
        return props;
    };
    PoseElement.prototype.componentDidMount = function () {
        var _this = this;
        heyListen.invariant(this.ref instanceof Element, "No valid DOM ref found. If you're converting an existing component via posed(Component), you must ensure you're passing the ref to the host DOM node via the React.forwardRef function.");
        var _a = this.props, onValueChange = _a.onValueChange, registerChild = _a.registerChild, values = _a.values, parentValues = _a.parentValues, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, onPressStart = _a.onPressStart, onPressEnd = _a.onPressEnd;
        var config = tslib_1.__assign({}, this.poseConfig, { initialPose: this.getInitialPose(), values: values || this.poseConfig.values, parentValues: parentValues ? objectToMap(parentValues) : undefined, props: this.getSetProps(), onDragStart: onDragStart,
            onDragEnd: onDragEnd,
            onPressStart: onPressStart,
            onPressEnd: onPressEnd, onChange: onValueChange });
        if (!registerChild) {
            this.initPoser(poseFactory(this.ref, config));
        }
        else {
            registerChild({
                element: this.ref,
                poseConfig: config,
                onRegistered: function (poser) { return _this.initPoser(poser); }
            });
        }
    };
    PoseElement.prototype.getSnapshotBeforeUpdate = function () {
        var _a = this.props, pose = _a.pose, _pose = _a._pose;
        if (hasPose(pose, 'flip') || hasPose(_pose, 'flip'))
            this.poser.measure();
        return null;
    };
    PoseElement.prototype.componentDidUpdate = function (prevProps) {
        var _a = this.props, pose = _a.pose, _pose = _a._pose, poseKey = _a.poseKey;
        this.poser.setProps(this.getSetProps());
        if (poseKey !== prevProps.poseKey ||
            hasChanged(prevProps.pose, pose) ||
            pose === 'flip') {
            this.setPose(pose);
        }
        if (_pose !== prevProps._pose || _pose === 'flip')
            this.setPose(_pose);
    };
    PoseElement.prototype.componentWillUnmount = function () {
        if (!this.poser)
            return;
        var onUnmount = this.props.onUnmount;
        if (onUnmount)
            onUnmount(this.poser);
        this.poser.destroy();
    };
    PoseElement.prototype.initPoser = function (poser) {
        this.poser = poser;
        this.flushChildren();
        var firstPose = this.getFirstPose();
        if (firstPose)
            this.setPose(firstPose);
    };
    PoseElement.prototype.setPose = function (pose) {
        var _this = this;
        var onPoseComplete = this.props.onPoseComplete;
        var poseList = Array.isArray(pose) ? pose : [pose];
        Promise.all(poseList.map(function (key) { return key && _this.poser.set(key); })).then(function () { return onPoseComplete && onPoseComplete(pose); });
    };
    PoseElement.prototype.flushChildren = function () {
        var _this = this;
        this.children.forEach(function (_a) {
            var element = _a.element, poseConfig = _a.poseConfig, onRegistered = _a.onRegistered;
            return onRegistered(_this.poser.addChild(element, poseConfig));
        });
        this.children.clear();
    };
    PoseElement.prototype.render = function () {
        var elementType = this.props.elementType;
        return (React__default.createElement(PoseParentProvider, { value: this.childrenHandlers }, React.createElement(elementType, pickAssign(this.shouldForwardProp, [
            this.getSetProps(),
            { ref: this.setRef }
        ]))));
    };
    return PoseElement;
}(React.PureComponent));

var supportedElements = [
    'a',
    'article',
    'aside',
    'audio',
    'b',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dialog',
    'div',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'i',
    'iframe',
    'img',
    'input',
    'label',
    'legend',
    'li',
    'nav',
    'object',
    'ol',
    'option',
    'p',
    'param',
    'picture',
    'pre',
    'progress',
    'q',
    'section',
    'select',
    'span',
    'strong',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'ul',
    'video',
    'circle',
    'clipPath',
    'defs',
    'ellipse',
    'g',
    'image',
    'line',
    'linearGradient',
    'mask',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialGradient',
    'rect',
    'stop',
    'svg',
    'text',
    'tspan'
];

var componentCache = new Map();
var createComponentFactory = function (key) {
    var componentFactory = function (poseConfig) {
        if (poseConfig === void 0) { poseConfig = {}; }
        return React.forwardRef(function (_a, ref) {
            var _b = _a.withParent, withParent = _b === void 0 ? true : _b, props = tslib_1.__rest(_a, ["withParent"]);
            heyListen.warning(props.innerRef === undefined, 'innerRef is deprecated. Please use ref instead.');
            return !withParent || props.parentValues ? (React__default.createElement(PoseElement, tslib_1.__assign({ poseConfig: poseConfig, innerRef: ref, elementType: key }, props))) : (React__default.createElement(PoseParentConsumer, null, function (parentCtx) { return (React__default.createElement(PoseElement, tslib_1.__assign({ poseConfig: poseConfig, elementType: key, innerRef: ref }, props, parentCtx))); }));
        });
    };
    componentCache.set(key, componentFactory);
    return componentFactory;
};
var getComponentFactory = function (key) {
    return componentCache.has(key)
        ? componentCache.get(key)
        : createComponentFactory(key);
};
var posed = (function (component) {
    return getComponentFactory(component);
});
supportedElements.reduce(function (acc, key) {
    acc[key] = createComponentFactory(key);
    return acc;
}, posed);

var getKey = function (child) {
    heyListen.invariant(child && child.key !== null, 'Every child of Transition must be given a unique key');
    var childKey = typeof child.key === 'number' ? child.key.toString() : child.key;
    return childKey.replace('.$', '');
};
var prependProps = function (element, props) {
    return React.createElement(element.type, tslib_1.__assign({ key: element.key, ref: element.ref }, props, element.props));
};
var handleTransition = function (_a, _b) {
    var displayedChildren = _b.displayedChildren, finishedLeaving = _b.finishedLeaving, hasInitialized = _b.hasInitialized, indexedChildren = _b.indexedChildren, scheduleChildRemoval = _b.scheduleChildRemoval;
    var incomingChildren = _a.children, preEnterPose = _a.preEnterPose, enterPose = _a.enterPose, exitPose = _a.exitPose, animateOnMount = _a.animateOnMount, enterAfterExit = _a.enterAfterExit, flipMove = _a.flipMove, onRest = _a.onRest, propsForChildren = tslib_1.__rest(_a, ["children", "preEnterPose", "enterPose", "exitPose", "animateOnMount", "enterAfterExit", "flipMove", "onRest"]);
    var targetChildren = makeChildList(incomingChildren);
    var nextState = {
        displayedChildren: []
    };
    if (false) {}
    var prevKeys = displayedChildren.map(getKey);
    var nextKeys = targetChildren.map(getKey);
    var hasPropsForChildren = Object.keys(propsForChildren).length !== 0;
    var entering = new Set(nextKeys.filter(function (key) { return finishedLeaving.hasOwnProperty(key) || prevKeys.indexOf(key) === -1; }));
    entering.forEach(function (key) { return delete finishedLeaving[key]; });
    var leaving = [];
    var newlyLeaving = {};
    prevKeys.forEach(function (key) {
        if (entering.has(key)) {
            return;
        }
        var isLeaving = finishedLeaving.hasOwnProperty(key);
        if (!isLeaving && nextKeys.indexOf(key) !== -1) {
            return;
        }
        leaving.push(key);
        if (!isLeaving) {
            finishedLeaving[key] = false;
            newlyLeaving[key] = true;
        }
    });
    var moving = new Set(prevKeys.filter(function (key, i) {
        return !entering.has(key) || leaving.indexOf(key) === -1;
    }));
    targetChildren.forEach(function (child) {
        var newChildProps = {};
        if (entering.has(child.key)) {
            if (hasInitialized || animateOnMount) {
                newChildProps.initialPose = preEnterPose;
            }
            newChildProps._pose = enterPose;
        }
        else if (moving.has(child.key) && flipMove) {
            newChildProps._pose = [enterPose, 'flip'];
        }
        else {
            newChildProps._pose = enterPose;
        }
        var newChild = React.cloneElement(child, newChildProps);
        indexedChildren[child.key] = newChild;
        nextState.displayedChildren.push(hasPropsForChildren ? prependProps(newChild, propsForChildren) : newChild);
    });
    leaving.forEach(function (key) {
        var child = indexedChildren[key];
        var newChild = newlyLeaving[key]
            ? React.cloneElement(child, {
                _pose: exitPose,
                onPoseComplete: function (pose) {
                    if (pose === exitPose)
                        scheduleChildRemoval(key);
                    var onPoseComplete = child.props.onPoseComplete;
                    if (onPoseComplete)
                        onPoseComplete(pose);
                },
                popFromFlow: flipMove
            })
            : child;
        var insertionIndex = prevKeys.indexOf(key);
        indexedChildren[child.key] = newChild;
        nextState.displayedChildren.splice(insertionIndex, 0, hasPropsForChildren ? prependProps(newChild, propsForChildren) : newChild);
    });
    return nextState;
};
var handleChildrenTransitions = (function (props, state) {
    var newState = handleTransition(props, state);
    newState.hasInitialized = true;
    return newState;
});
var makeChildList = function (children) {
    var list = [];
    React.Children.forEach(children, function (child) { return child && list.push(child); });
    return list;
};

var Transition = (function (_super) {
    tslib_1.__extends(Transition, _super);
    function Transition() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            displayedChildren: [],
            finishedLeaving: {},
            hasInitialized: false,
            indexedChildren: {},
            scheduleChildRemoval: function (key) { return _this.removeChild(key); }
        };
        return _this;
    }
    Transition.prototype.removeChild = function (key) {
        var _a = this.state, displayedChildren = _a.displayedChildren, finishedLeaving = _a.finishedLeaving;
        var _b = this.props, enterAfterExit = _b.enterAfterExit, onRest = _b.onRest;
        if (!finishedLeaving.hasOwnProperty(key))
            return;
        finishedLeaving[key] = true;
        if (!Object.keys(finishedLeaving).every(function (leavingKey) { return finishedLeaving[leavingKey]; })) {
            return;
        }
        var targetChildren = displayedChildren.filter(function (child) { return !finishedLeaving.hasOwnProperty(child.key); });
        var newState = enterAfterExit
            ? tslib_1.__assign({ finishedLeaving: {} }, handleChildrenTransitions(tslib_1.__assign({}, this.props, { enterAfterExit: false }), tslib_1.__assign({}, this.state, { displayedChildren: targetChildren }))) : {
            finishedLeaving: {},
            displayedChildren: targetChildren
        };
        this.setState(newState, onRest);
    };
    Transition.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        return this.state !== nextState;
    };
    Transition.prototype.render = function () {
        return this.state.displayedChildren;
    };
    Transition.defaultProps = {
        flipMove: false,
        enterAfterExit: false,
        preEnterPose: 'exit',
        enterPose: 'enter',
        exitPose: 'exit'
    };
    Transition.getDerivedStateFromProps = handleChildrenTransitions;
    return Transition;
}(React.Component));

var PoseGroup = (function (_super) {
    tslib_1.__extends(PoseGroup, _super);
    function PoseGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PoseGroup.prototype.render = function () {
        return React.createElement(Transition, tslib_1.__assign({}, this.props));
    };
    PoseGroup.defaultProps = {
        flipMove: true
    };
    return PoseGroup;
}(React.Component));

exports.default = posed;
exports.Transition = Transition;
exports.PoseGroup = PoseGroup;


/***/ }),

/***/ "./node_modules/react/cjs/react.production.min.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.8.4
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var k=__webpack_require__("./node_modules/object-assign/index.js"),n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.concurrent_mode"):60111,y=n?Symbol.for("react.forward_ref"):60112,z=n?Symbol.for("react.suspense"):60113,aa=n?Symbol.for("react.memo"):
60115,ba=n?Symbol.for("react.lazy"):60116,A="function"===typeof Symbol&&Symbol.iterator;function ca(a,b,d,c,e,g,h,f){if(!a){a=void 0;if(void 0===b)a=Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var l=[d,c,e,g,h,f],m=0;a=Error(b.replace(/%s/g,function(){return l[m++]}));a.name="Invariant Violation"}a.framesToPop=1;throw a;}}
function B(a){for(var b=arguments.length-1,d="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=0;c<b;c++)d+="&args[]="+encodeURIComponent(arguments[c+1]);ca(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",d)}var C={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},D={};
function E(a,b,d){this.props=a;this.context=b;this.refs=D;this.updater=d||C}E.prototype.isReactComponent={};E.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?B("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E.prototype;function G(a,b,d){this.props=a;this.context=b;this.refs=D;this.updater=d||C}var H=G.prototype=new F;
H.constructor=G;k(H,E.prototype);H.isPureReactComponent=!0;var I={current:null},J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,d){var c=void 0,e={},g=null,h=null;if(null!=b)for(c in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=b[c]);var f=arguments.length-2;if(1===f)e.children=d;else if(1<f){for(var l=Array(f),m=0;m<f;m++)l[m]=arguments[m+2];e.children=l}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===e[c]&&(e[c]=f[c]);return{$$typeof:p,type:a,key:g,ref:h,props:e,_owner:J.current}}
function da(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var O=/\/+/g,P=[];function Q(a,b,d,c){if(P.length){var e=P.pop();e.result=a;e.keyPrefix=b;e.func=d;e.context=c;e.count=0;return e}return{result:a,keyPrefix:b,func:d,context:c,count:0}}
function R(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>P.length&&P.push(a)}
function S(a,b,d,c){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var g=!1;if(null===a)g=!0;else switch(e){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return d(c,a,""===b?"."+T(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var h=0;h<a.length;h++){e=a[h];var f=b+T(e,h);g+=S(e,f,d,c)}else if(null===a||"object"!==typeof a?f=null:(f=A&&a[A]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),h=
0;!(e=a.next()).done;)e=e.value,f=b+T(e,h++),g+=S(e,f,d,c);else"object"===e&&(d=""+a,B("31","[object Object]"===d?"object with keys {"+Object.keys(a).join(", ")+"}":d,""));return g}function U(a,b,d){return null==a?0:S(a,"",b,d)}function T(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function ea(a,b){a.func.call(a.context,b,a.count++)}
function fa(a,b,d){var c=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?V(a,c,d,function(a){return a}):null!=a&&(N(a)&&(a=da(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(O,"$&/")+"/")+d)),c.push(a))}function V(a,b,d,c,e){var g="";null!=d&&(g=(""+d).replace(O,"$&/")+"/");b=Q(b,g,c,e);U(a,fa,b);R(b)}function W(){var a=I.current;null===a?B("307"):void 0;return a}
var X={Children:{map:function(a,b,d){if(null==a)return a;var c=[];V(a,c,null,b,d);return c},forEach:function(a,b,d){if(null==a)return a;b=Q(null,null,b,d);U(a,ea,b);R(b)},count:function(a){return U(a,function(){return null},null)},toArray:function(a){var b=[];V(a,b,null,function(a){return a});return b},only:function(a){N(a)?void 0:B("143");return a}},createRef:function(){return{current:null}},Component:E,PureComponent:G,createContext:function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,
_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a},forwardRef:function(a){return{$$typeof:y,render:a}},lazy:function(a){return{$$typeof:ba,_ctor:a,_status:-1,_result:null}},memo:function(a,b){return{$$typeof:aa,type:a,compare:void 0===b?null:b}},useCallback:function(a,b){return W().useCallback(a,b)},useContext:function(a,b){return W().useContext(a,b)},useEffect:function(a,b){return W().useEffect(a,b)},useImperativeHandle:function(a,
b,d){return W().useImperativeHandle(a,b,d)},useDebugValue:function(){},useLayoutEffect:function(a,b){return W().useLayoutEffect(a,b)},useMemo:function(a,b){return W().useMemo(a,b)},useReducer:function(a,b,d){return W().useReducer(a,b,d)},useRef:function(a){return W().useRef(a)},useState:function(a){return W().useState(a)},Fragment:r,StrictMode:t,Suspense:z,createElement:M,cloneElement:function(a,b,d){null===a||void 0===a?B("267",a):void 0;var c=void 0,e=k({},a.props),g=a.key,h=a.ref,f=a._owner;if(null!=
b){void 0!==b.ref&&(h=b.ref,f=J.current);void 0!==b.key&&(g=""+b.key);var l=void 0;a.type&&a.type.defaultProps&&(l=a.type.defaultProps);for(c in b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=void 0===b[c]&&void 0!==l?l[c]:b[c])}c=arguments.length-2;if(1===c)e.children=d;else if(1<c){l=Array(c);for(var m=0;m<c;m++)l[m]=arguments[m+2];e.children=l}return{$$typeof:p,type:a.type,key:g,ref:h,props:e,_owner:f}},createFactory:function(a){var b=M.bind(null,a);b.type=a;return b},isValidElement:N,version:"16.8.4",
unstable_ConcurrentMode:x,unstable_Profiler:u,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentDispatcher:I,ReactCurrentOwner:J,assign:k}},Y={default:X},Z=Y&&X||Y;module.exports=Z.default||Z;


/***/ }),

/***/ "./node_modules/react/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__("./node_modules/react/cjs/react.production.min.js");
} else {}


/***/ }),

/***/ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {
     true ? module.exports = factory() :
    undefined;
}(this, (function () { 'use strict';

    /**
     * A collection of shims that provide minimal functionality of the ES6 collections.
     *
     * These implementations are not meant to be used outside of the ResizeObserver
     * modules as they cover only a limited range of use cases.
     */
    /* eslint-disable require-jsdoc, valid-jsdoc */
    var MapShim = (function () {
        if (typeof Map !== 'undefined') {
            return Map;
        }
        /**
         * Returns index in provided array that matches the specified key.
         *
         * @param {Array<Array>} arr
         * @param {*} key
         * @returns {number}
         */
        function getIndex(arr, key) {
            var result = -1;
            arr.some(function (entry, index) {
                if (entry[0] === key) {
                    result = index;
                    return true;
                }
                return false;
            });
            return result;
        }
        return /** @class */ (function () {
            function class_1() {
                this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
                /**
                 * @returns {boolean}
                 */
                get: function () {
                    return this.__entries__.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * @param {*} key
             * @returns {*}
             */
            class_1.prototype.get = function (key) {
                var index = getIndex(this.__entries__, key);
                var entry = this.__entries__[index];
                return entry && entry[1];
            };
            /**
             * @param {*} key
             * @param {*} value
             * @returns {void}
             */
            class_1.prototype.set = function (key, value) {
                var index = getIndex(this.__entries__, key);
                if (~index) {
                    this.__entries__[index][1] = value;
                }
                else {
                    this.__entries__.push([key, value]);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.delete = function (key) {
                var entries = this.__entries__;
                var index = getIndex(entries, key);
                if (~index) {
                    entries.splice(index, 1);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.has = function (key) {
                return !!~getIndex(this.__entries__, key);
            };
            /**
             * @returns {void}
             */
            class_1.prototype.clear = function () {
                this.__entries__.splice(0);
            };
            /**
             * @param {Function} callback
             * @param {*} [ctx=null]
             * @returns {void}
             */
            class_1.prototype.forEach = function (callback, ctx) {
                if (ctx === void 0) { ctx = null; }
                for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                    var entry = _a[_i];
                    callback.call(ctx, entry[1], entry[0]);
                }
            };
            return class_1;
        }());
    })();

    /**
     * Detects whether window and document objects are available in current environment.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

    // Returns global object of a current environment.
    var global$1 = (function () {
        if (typeof global !== 'undefined' && global.Math === Math) {
            return global;
        }
        if (typeof self !== 'undefined' && self.Math === Math) {
            return self;
        }
        if (typeof window !== 'undefined' && window.Math === Math) {
            return window;
        }
        // eslint-disable-next-line no-new-func
        return Function('return this')();
    })();

    /**
     * A shim for the requestAnimationFrame which falls back to the setTimeout if
     * first one is not supported.
     *
     * @returns {number} Requests' identifier.
     */
    var requestAnimationFrame$1 = (function () {
        if (typeof requestAnimationFrame === 'function') {
            // It's required to use a bounded function because IE sometimes throws
            // an "Invalid calling object" error if rAF is invoked without the global
            // object on the left hand side.
            return requestAnimationFrame.bind(global$1);
        }
        return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
    })();

    // Defines minimum timeout before adding a trailing call.
    var trailingTimeout = 2;
    /**
     * Creates a wrapper function which ensures that provided callback will be
     * invoked only once during the specified delay period.
     *
     * @param {Function} callback - Function to be invoked after the delay period.
     * @param {number} delay - Delay after which to invoke callback.
     * @returns {Function}
     */
    function throttle (callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        /**
         * Invokes the original callback function and schedules new invocation if
         * the "proxy" was called during current request.
         *
         * @returns {void}
         */
        function resolvePending() {
            if (leadingCall) {
                leadingCall = false;
                callback();
            }
            if (trailingCall) {
                proxy();
            }
        }
        /**
         * Callback invoked after the specified delay. It will further postpone
         * invocation of the original function delegating it to the
         * requestAnimationFrame.
         *
         * @returns {void}
         */
        function timeoutCallback() {
            requestAnimationFrame$1(resolvePending);
        }
        /**
         * Schedules invocation of the original function.
         *
         * @returns {void}
         */
        function proxy() {
            var timeStamp = Date.now();
            if (leadingCall) {
                // Reject immediately following calls.
                if (timeStamp - lastCallTime < trailingTimeout) {
                    return;
                }
                // Schedule new call to be in invoked when the pending one is resolved.
                // This is important for "transitions" which never actually start
                // immediately so there is a chance that we might miss one if change
                // happens amids the pending invocation.
                trailingCall = true;
            }
            else {
                leadingCall = true;
                trailingCall = false;
                setTimeout(timeoutCallback, delay);
            }
            lastCallTime = timeStamp;
        }
        return proxy;
    }

    // Minimum delay before invoking the update of observers.
    var REFRESH_DELAY = 20;
    // A list of substrings of CSS properties used to find transition events that
    // might affect dimensions of observed elements.
    var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
    // Check if MutationObserver is available.
    var mutationObserverSupported = typeof MutationObserver !== 'undefined';
    /**
     * Singleton controller class which handles updates of ResizeObserver instances.
     */
    var ResizeObserverController = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserverController.
         *
         * @private
         */
        function ResizeObserverController() {
            /**
             * Indicates whether DOM listeners have been added.
             *
             * @private {boolean}
             */
            this.connected_ = false;
            /**
             * Tells that controller has subscribed for Mutation Events.
             *
             * @private {boolean}
             */
            this.mutationEventsAdded_ = false;
            /**
             * Keeps reference to the instance of MutationObserver.
             *
             * @private {MutationObserver}
             */
            this.mutationsObserver_ = null;
            /**
             * A list of connected observers.
             *
             * @private {Array<ResizeObserverSPI>}
             */
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
        }
        /**
         * Adds observer to observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be added.
         * @returns {void}
         */
        ResizeObserverController.prototype.addObserver = function (observer) {
            if (!~this.observers_.indexOf(observer)) {
                this.observers_.push(observer);
            }
            // Add listeners if they haven't been added yet.
            if (!this.connected_) {
                this.connect_();
            }
        };
        /**
         * Removes observer from observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be removed.
         * @returns {void}
         */
        ResizeObserverController.prototype.removeObserver = function (observer) {
            var observers = this.observers_;
            var index = observers.indexOf(observer);
            // Remove observer if it's present in registry.
            if (~index) {
                observers.splice(index, 1);
            }
            // Remove listeners if controller has no connected observers.
            if (!observers.length && this.connected_) {
                this.disconnect_();
            }
        };
        /**
         * Invokes the update of observers. It will continue running updates insofar
         * it detects changes.
         *
         * @returns {void}
         */
        ResizeObserverController.prototype.refresh = function () {
            var changesDetected = this.updateObservers_();
            // Continue running updates if changes have been detected as there might
            // be future ones caused by CSS transitions.
            if (changesDetected) {
                this.refresh();
            }
        };
        /**
         * Updates every observer from observers list and notifies them of queued
         * entries.
         *
         * @private
         * @returns {boolean} Returns "true" if any observer has detected changes in
         *      dimensions of it's elements.
         */
        ResizeObserverController.prototype.updateObservers_ = function () {
            // Collect observers that have active observations.
            var activeObservers = this.observers_.filter(function (observer) {
                return observer.gatherActive(), observer.hasActive();
            });
            // Deliver notifications in a separate cycle in order to avoid any
            // collisions between observers, e.g. when multiple instances of
            // ResizeObserver are tracking the same element and the callback of one
            // of them changes content dimensions of the observed target. Sometimes
            // this may result in notifications being blocked for the rest of observers.
            activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
            return activeObservers.length > 0;
        };
        /**
         * Initializes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.connect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already added.
            if (!isBrowser || this.connected_) {
                return;
            }
            // Subscription to the "Transitionend" event is used as a workaround for
            // delayed transitions. This way it's possible to capture at least the
            // final state of an element.
            document.addEventListener('transitionend', this.onTransitionEnd_);
            window.addEventListener('resize', this.refresh);
            if (mutationObserverSupported) {
                this.mutationsObserver_ = new MutationObserver(this.refresh);
                this.mutationsObserver_.observe(document, {
                    attributes: true,
                    childList: true,
                    characterData: true,
                    subtree: true
                });
            }
            else {
                document.addEventListener('DOMSubtreeModified', this.refresh);
                this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
        };
        /**
         * Removes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.disconnect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already removed.
            if (!isBrowser || !this.connected_) {
                return;
            }
            document.removeEventListener('transitionend', this.onTransitionEnd_);
            window.removeEventListener('resize', this.refresh);
            if (this.mutationsObserver_) {
                this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
                document.removeEventListener('DOMSubtreeModified', this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
        };
        /**
         * "Transitionend" event handler.
         *
         * @private
         * @param {TransitionEvent} event
         * @returns {void}
         */
        ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
            var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
            // Detect whether transition may affect dimensions of an element.
            var isReflowProperty = transitionKeys.some(function (key) {
                return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
                this.refresh();
            }
        };
        /**
         * Returns instance of the ResizeObserverController.
         *
         * @returns {ResizeObserverController}
         */
        ResizeObserverController.getInstance = function () {
            if (!this.instance_) {
                this.instance_ = new ResizeObserverController();
            }
            return this.instance_;
        };
        /**
         * Holds reference to the controller's instance.
         *
         * @private {ResizeObserverController}
         */
        ResizeObserverController.instance_ = null;
        return ResizeObserverController;
    }());

    /**
     * Defines non-writable/enumerable properties of the provided target object.
     *
     * @param {Object} target - Object for which to define properties.
     * @param {Object} props - Properties to be defined.
     * @returns {Object} Target object.
     */
    var defineConfigurable = (function (target, props) {
        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
            var key = _a[_i];
            Object.defineProperty(target, key, {
                value: props[key],
                enumerable: false,
                writable: false,
                configurable: true
            });
        }
        return target;
    });

    /**
     * Returns the global object associated with provided element.
     *
     * @param {Object} target
     * @returns {Object}
     */
    var getWindowOf = (function (target) {
        // Assume that the element is an instance of Node, which means that it
        // has the "ownerDocument" property from which we can retrieve a
        // corresponding global object.
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        // Return the local global object if it's not possible extract one from
        // provided element.
        return ownerGlobal || global$1;
    });

    // Placeholder of an empty content rectangle.
    var emptyRect = createRectInit(0, 0, 0, 0);
    /**
     * Converts provided string to a number.
     *
     * @param {number|string} value
     * @returns {number}
     */
    function toFloat(value) {
        return parseFloat(value) || 0;
    }
    /**
     * Extracts borders size from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @param {...string} positions - Borders positions (top, right, ...)
     * @returns {number}
     */
    function getBordersSize(styles) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function (size, position) {
            var value = styles['border-' + position + '-width'];
            return size + toFloat(value);
        }, 0);
    }
    /**
     * Extracts paddings sizes from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @returns {Object} Paddings box.
     */
    function getPaddings(styles) {
        var positions = ['top', 'right', 'bottom', 'left'];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
            var position = positions_1[_i];
            var value = styles['padding-' + position];
            paddings[position] = toFloat(value);
        }
        return paddings;
    }
    /**
     * Calculates content rectangle of provided SVG element.
     *
     * @param {SVGGraphicsElement} target - Element content rectangle of which needs
     *      to be calculated.
     * @returns {DOMRectInit}
     */
    function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
    }
    /**
     * Calculates content rectangle of provided HTMLElement.
     *
     * @param {HTMLElement} target - Element for which to calculate the content rectangle.
     * @returns {DOMRectInit}
     */
    function getHTMLElementContentRect(target) {
        // Client width & height properties can't be
        // used exclusively as they provide rounded values.
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        // By this condition we can catch all non-replaced inline, hidden and
        // detached elements. Though elements with width & height properties less
        // than 0.5 will be discarded as well.
        //
        // Without it we would need to implement separate methods for each of
        // those cases and it's not possible to perform a precise and performance
        // effective test for hidden elements. E.g. even jQuery's ':visible' filter
        // gives wrong results for elements with width & height less than 0.5.
        if (!clientWidth && !clientHeight) {
            return emptyRect;
        }
        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        // Computed styles of width & height are being used because they are the
        // only dimensions available to JS that contain non-rounded values. It could
        // be possible to utilize the getBoundingClientRect if only it's data wasn't
        // affected by CSS transformations let alone paddings, borders and scroll bars.
        var width = toFloat(styles.width), height = toFloat(styles.height);
        // Width & height include paddings and borders when the 'border-box' box
        // model is applied (except for IE).
        if (styles.boxSizing === 'border-box') {
            // Following conditions are required to handle Internet Explorer which
            // doesn't include paddings and borders to computed CSS dimensions.
            //
            // We can say that if CSS dimensions + paddings are equal to the "client"
            // properties then it's either IE, and thus we don't need to subtract
            // anything, or an element merely doesn't have paddings/borders styles.
            if (Math.round(width + horizPad) !== clientWidth) {
                width -= getBordersSize(styles, 'left', 'right') + horizPad;
            }
            if (Math.round(height + vertPad) !== clientHeight) {
                height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
            }
        }
        // Following steps can't be applied to the document's root element as its
        // client[Width/Height] properties represent viewport area of the window.
        // Besides, it's as well not necessary as the <html> itself neither has
        // rendered scroll bars nor it can be clipped.
        if (!isDocumentElement(target)) {
            // In some browsers (only in Firefox, actually) CSS width & height
            // include scroll bars size which can be removed at this step as scroll
            // bars are the only difference between rounded dimensions + paddings
            // and "client" properties, though that is not always true in Chrome.
            var vertScrollbar = Math.round(width + horizPad) - clientWidth;
            var horizScrollbar = Math.round(height + vertPad) - clientHeight;
            // Chrome has a rather weird rounding of "client" properties.
            // E.g. for an element with content width of 314.2px it sometimes gives
            // the client width of 315px and for the width of 314.7px it may give
            // 314px. And it doesn't happen all the time. So just ignore this delta
            // as a non-relevant.
            if (Math.abs(vertScrollbar) !== 1) {
                width -= vertScrollbar;
            }
            if (Math.abs(horizScrollbar) !== 1) {
                height -= horizScrollbar;
            }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
    }
    /**
     * Checks whether provided element is an instance of the SVGGraphicsElement.
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    var isSVGGraphicsElement = (function () {
        // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
        // interface.
        if (typeof SVGGraphicsElement !== 'undefined') {
            return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
        }
        // If it's so, then check that element is at least an instance of the
        // SVGElement and that it has the "getBBox" method.
        // eslint-disable-next-line no-extra-parens
        return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
            typeof target.getBBox === 'function'); };
    })();
    /**
     * Checks whether provided element is a document element (<html>).
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
    }
    /**
     * Calculates an appropriate content rectangle for provided html or svg element.
     *
     * @param {Element} target - Element content rectangle of which needs to be calculated.
     * @returns {DOMRectInit}
     */
    function getContentRect(target) {
        if (!isBrowser) {
            return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
            return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
    }
    /**
     * Creates rectangle with an interface of the DOMRectReadOnly.
     * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
     *
     * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
     * @returns {DOMRectReadOnly}
     */
    function createReadOnlyRect(_a) {
        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        // If DOMRectReadOnly is available use it as a prototype for the rectangle.
        var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        // Rectangle's properties are not writable and non-enumerable.
        defineConfigurable(rect, {
            x: x, y: y, width: width, height: height,
            top: y,
            right: x + width,
            bottom: height + y,
            left: x
        });
        return rect;
    }
    /**
     * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
     * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
     *
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} width - Rectangle's width.
     * @param {number} height - Rectangle's height.
     * @returns {DOMRectInit}
     */
    function createRectInit(x, y, width, height) {
        return { x: x, y: y, width: width, height: height };
    }

    /**
     * Class that is responsible for computations of the content rectangle of
     * provided DOM element and for keeping track of it's changes.
     */
    var ResizeObservation = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObservation.
         *
         * @param {Element} target - Element to be observed.
         */
        function ResizeObservation(target) {
            /**
             * Broadcasted width of content rectangle.
             *
             * @type {number}
             */
            this.broadcastWidth = 0;
            /**
             * Broadcasted height of content rectangle.
             *
             * @type {number}
             */
            this.broadcastHeight = 0;
            /**
             * Reference to the last observed content rectangle.
             *
             * @private {DOMRectInit}
             */
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
        }
        /**
         * Updates content rectangle and tells whether it's width or height properties
         * have changed since the last broadcast.
         *
         * @returns {boolean}
         */
        ResizeObservation.prototype.isActive = function () {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return (rect.width !== this.broadcastWidth ||
                rect.height !== this.broadcastHeight);
        };
        /**
         * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
         * from the corresponding properties of the last observed content rectangle.
         *
         * @returns {DOMRectInit} Last observed content rectangle.
         */
        ResizeObservation.prototype.broadcastRect = function () {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
        };
        return ResizeObservation;
    }());

    var ResizeObserverEntry = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObserverEntry.
         *
         * @param {Element} target - Element that is being observed.
         * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
         */
        function ResizeObserverEntry(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            // According to the specification following properties are not writable
            // and are also not enumerable in the native implementation.
            //
            // Property accessors are not being used as they'd require to define a
            // private WeakMap storage which may cause memory leaks in browsers that
            // don't support this type of collections.
            defineConfigurable(this, { target: target, contentRect: contentRect });
        }
        return ResizeObserverEntry;
    }());

    var ResizeObserverSPI = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback function that is invoked
         *      when one of the observed elements changes it's content dimensions.
         * @param {ResizeObserverController} controller - Controller instance which
         *      is responsible for the updates of observer.
         * @param {ResizeObserver} callbackCtx - Reference to the public
         *      ResizeObserver instance which will be passed to callback function.
         */
        function ResizeObserverSPI(callback, controller, callbackCtx) {
            /**
             * Collection of resize observations that have detected changes in dimensions
             * of elements.
             *
             * @private {Array<ResizeObservation>}
             */
            this.activeObservations_ = [];
            /**
             * Registry of the ResizeObservation instances.
             *
             * @private {Map<Element, ResizeObservation>}
             */
            this.observations_ = new MapShim();
            if (typeof callback !== 'function') {
                throw new TypeError('The callback provided as parameter 1 is not a function.');
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
        }
        /**
         * Starts observing provided element.
         *
         * @param {Element} target - Element to be observed.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.observe = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is already being observed.
            if (observations.has(target)) {
                return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            // Force the update of observations.
            this.controller_.refresh();
        };
        /**
         * Stops observing provided element.
         *
         * @param {Element} target - Element to stop observing.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.unobserve = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is not being observed.
            if (!observations.has(target)) {
                return;
            }
            observations.delete(target);
            if (!observations.size) {
                this.controller_.removeObserver(this);
            }
        };
        /**
         * Stops observing all elements.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.disconnect = function () {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
        };
        /**
         * Collects observation instances the associated element of which has changed
         * it's content rectangle.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.gatherActive = function () {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function (observation) {
                if (observation.isActive()) {
                    _this.activeObservations_.push(observation);
                }
            });
        };
        /**
         * Invokes initial callback function with a list of ResizeObserverEntry
         * instances collected from active resize observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.broadcastActive = function () {
            // Do nothing if observer doesn't have active observations.
            if (!this.hasActive()) {
                return;
            }
            var ctx = this.callbackCtx_;
            // Create ResizeObserverEntry instance for every active observation.
            var entries = this.activeObservations_.map(function (observation) {
                return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
        };
        /**
         * Clears the collection of active observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.clearActive = function () {
            this.activeObservations_.splice(0);
        };
        /**
         * Tells whether observer has active observations.
         *
         * @returns {boolean}
         */
        ResizeObserverSPI.prototype.hasActive = function () {
            return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI;
    }());

    // Registry of internal observers. If WeakMap is not available use current shim
    // for the Map collection as it has all required methods and because WeakMap
    // can't be fully polyfilled anyway.
    var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
    /**
     * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
     * exposing only those methods and properties that are defined in the spec.
     */
    var ResizeObserver = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback that is invoked when
         *      dimensions of the observed elements change.
         */
        function ResizeObserver(callback) {
            if (!(this instanceof ResizeObserver)) {
                throw new TypeError('Cannot call a class as a function.');
            }
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
        }
        return ResizeObserver;
    }());
    // Expose public methods of ResizeObserver.
    [
        'observe',
        'unobserve',
        'disconnect'
    ].forEach(function (method) {
        ResizeObserver.prototype[method] = function () {
            var _a;
            return (_a = observers.get(this))[method].apply(_a, arguments);
        };
    });

    var index = (function () {
        // Export existing implementation if available.
        if (typeof global$1.ResizeObserver !== 'undefined') {
            return global$1.ResizeObserver;
        }
        return ResizeObserver;
    })();

    return index;

})));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__("./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/style-value-types/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var clamp = function (min, max) { return function (v) {
    return Math.max(Math.min(v, max), min);
}; };
var isFirstChars = function (term) { return function (v) {
    return typeof v === 'string' && v.indexOf(term) === 0;
}; };
var getValueFromFunctionString = function (value) {
    return value.substring(value.indexOf('(') + 1, value.lastIndexOf(')'));
};
var splitCommaDelimited = function (value) {
    return typeof value === 'string' ? value.split(/,\s*/) : [value];
};
var sanitize = function (v) { return (v % 1 ? Number(v.toFixed(5)) : v); };

var number = {
    test: function (v) { return typeof v === 'number'; },
    parse: parseFloat,
    transform: function (v) { return v; }
};
var alpha = __assign({}, number, { transform: clamp(0, 1) });
var scale = __assign({}, number, { default: 1 });

var createUnitType = function (unit) { return ({
    test: function (v) {
        return typeof v === 'string' && v.endsWith(unit) && v.split(' ').length === 1;
    },
    parse: parseFloat,
    transform: function (v) { return "" + v + unit; }
}); };
var degrees = createUnitType('deg');
var percent = createUnitType('%');
var px = createUnitType('px');
var vh = createUnitType('vh');
var vw = createUnitType('vw');
var progressPercentage = __assign({}, percent, { parse: function (v) { return percent.parse(v) / 100; }, transform: function (v) { return percent.transform(v * 100); } });

var clampRgbUnit = clamp(0, 255);
var onlyColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))$/i;
var isRgba = function (v) { return v.red !== undefined; };
var isHsla = function (v) { return v.hue !== undefined; };
var splitColorValues = function (terms) {
    var numTerms = terms.length;
    return function (v) {
        if (typeof v !== 'string')
            return v;
        var values = {};
        var valuesArray = splitCommaDelimited(getValueFromFunctionString(v));
        for (var i = 0; i < numTerms; i++) {
            values[terms[i]] =
                valuesArray[i] !== undefined ? parseFloat(valuesArray[i]) : 1;
        }
        return values;
    };
};
var rgbaTemplate = function (_a) {
    var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;
    return "rgba(" + red + ", " + green + ", " + blue + ", " + alpha$$1 + ")";
};
var hslaTemplate = function (_a) {
    var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;
    return "hsla(" + hue + ", " + saturation + ", " + lightness + ", " + alpha$$1 + ")";
};
var rgbUnit = __assign({}, number, { transform: function (v) { return Math.round(clampRgbUnit(v)); } });
var testRgbaString = isFirstChars('rgb');
var rgba = {
    test: function (v) { return (typeof v === 'string' ? testRgbaString(v) : isRgba(v)); },
    parse: splitColorValues(['red', 'green', 'blue', 'alpha']),
    transform: function (_a) {
        var red = _a.red, green = _a.green, blue = _a.blue, alpha$$1 = _a.alpha;
        return rgbaTemplate({
            red: rgbUnit.transform(red),
            green: rgbUnit.transform(green),
            blue: rgbUnit.transform(blue),
            alpha: sanitize(alpha$$1)
        });
    }
};
var testHslaString = isFirstChars('hsl');
var hsla = {
    test: function (v) { return (typeof v === 'string' ? testHslaString(v) : isHsla(v)); },
    parse: splitColorValues(['hue', 'saturation', 'lightness', 'alpha']),
    transform: function (_a) {
        var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, alpha$$1 = _a.alpha;
        return hslaTemplate({
            hue: Math.round(hue),
            saturation: percent.transform(sanitize(saturation)),
            lightness: percent.transform(sanitize(lightness)),
            alpha: sanitize(alpha$$1)
        });
    }
};
var hex = __assign({}, rgba, { test: isFirstChars('#'), parse: function (v) {
        var r = '';
        var g = '';
        var b = '';
        if (v.length > 4) {
            r = v.substr(1, 2);
            g = v.substr(3, 2);
            b = v.substr(5, 2);
        }
        else {
            r = v.substr(1, 1);
            g = v.substr(2, 1);
            b = v.substr(3, 1);
            r += r;
            g += g;
            b += b;
        }
        return {
            red: parseInt(r, 16),
            green: parseInt(g, 16),
            blue: parseInt(b, 16),
            alpha: 1
        };
    } });
var color = {
    test: function (v) {
        return (typeof v === 'string' && onlyColorRegex.test(v)) ||
            rgba.test(v) ||
            hsla.test(v) ||
            hex.test(v);
    },
    parse: function (v) {
        if (rgba.test(v)) {
            return rgba.parse(v);
        }
        else if (hsla.test(v)) {
            return hsla.parse(v);
        }
        else if (hex.test(v)) {
            return hex.parse(v);
        }
        return v;
    },
    transform: function (v) {
        if (isRgba(v)) {
            return rgba.transform(v);
        }
        else if (isHsla(v)) {
            return hsla.transform(v);
        }
        return v;
    }
};

var floatRegex = /(-)?(\d[\d\.]*)/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var COLOR_TOKEN = '${c}';
var NUMBER_TOKEN = '${n}';
var complex = {
    test: function (v) {
        if (typeof v !== 'string' || !isNaN(v))
            return false;
        var numValues = 0;
        var foundNumbers = v.match(floatRegex);
        var foundColors = v.match(colorRegex);
        if (foundNumbers)
            numValues += foundNumbers.length;
        if (foundColors)
            numValues += foundColors.length;
        return numValues > 0;
    },
    parse: function (v) {
        var input = v;
        var parsed = [];
        var foundColors = input.match(colorRegex);
        if (foundColors) {
            input = input.replace(colorRegex, COLOR_TOKEN);
            parsed.push.apply(parsed, foundColors.map(color.parse));
        }
        var foundNumbers = input.match(floatRegex);
        if (foundNumbers) {
            parsed.push.apply(parsed, foundNumbers.map(number.parse));
        }
        return parsed;
    },
    createTransformer: function (prop) {
        var template = prop;
        var token = 0;
        var foundColors = prop.match(colorRegex);
        var numColors = foundColors ? foundColors.length : 0;
        if (foundColors) {
            for (var i = 0; i < numColors; i++) {
                template = template.replace(foundColors[i], COLOR_TOKEN);
                token++;
            }
        }
        var foundNumbers = template.match(floatRegex);
        var numNumbers = foundNumbers ? foundNumbers.length : 0;
        if (foundNumbers) {
            for (var i = 0; i < numNumbers; i++) {
                template = template.replace(foundNumbers[i], NUMBER_TOKEN);
                token++;
            }
        }
        return function (v) {
            var output = template;
            for (var i = 0; i < token; i++) {
                output = output.replace(i < numColors ? COLOR_TOKEN : NUMBER_TOKEN, i < numColors ? color.transform(v[i]) : sanitize(v[i]));
            }
            return output;
        };
    }
};

exports.number = number;
exports.scale = scale;
exports.alpha = alpha;
exports.degrees = degrees;
exports.percent = percent;
exports.progressPercentage = progressPercentage;
exports.px = px;
exports.vw = vw;
exports.vh = vh;
exports.rgba = rgba;
exports.rgbUnit = rgbUnit;
exports.hsla = hsla;
exports.hex = hex;
exports.color = color;
exports.complex = complex;


/***/ }),

/***/ "./node_modules/stylefire/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var sync = _interopDefault(__webpack_require__("./node_modules/framesync/lib/index.js"));
var styleValueTypes = __webpack_require__("./node_modules/style-value-types/lib/index.js");
var heyListen = __webpack_require__("./node_modules/hey-listen/lib/index.js");

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

var createStyler = function (_a) {
    var onRead = _a.onRead, onRender = _a.onRender, _b = _a.uncachedValues, uncachedValues = _b === void 0 ? new Set() : _b, _c = _a.useCache, useCache = _c === void 0 ? true : _c;
    return function (props) {
        var state = {};
        var changedValues = [];
        var hasChanged = false;
        var setValue = function (key, value) {
            var currentValue = state[key];
            state[key] = value;
            if (state[key] !== currentValue) {
                if (changedValues.indexOf(key) === -1) {
                    changedValues.push(key);
                }
                if (!hasChanged) {
                    hasChanged = true;
                    sync.render(render);
                }
            }
        };
        function render(forceRender) {
            if (forceRender === void 0) { forceRender = false; }
            if (forceRender === true || hasChanged) {
                onRender(state, props, changedValues);
                hasChanged = false;
                changedValues.length = 0;
            }
            return this;
        }
        return {
            get: function (key) {
                return key
                    ? useCache && !uncachedValues.has(key) && state[key] !== undefined
                        ? state[key]
                        : onRead(key, props)
                    : state;
            },
            set: function (values, value) {
                if (typeof values === 'string') {
                    if (value !== undefined) {
                        setValue(values, value);
                    }
                    else {
                        return function (v) { return setValue(values, v); };
                    }
                }
                else {
                    for (var key in values) {
                        if (values.hasOwnProperty(key)) {
                            setValue(key, values[key]);
                        }
                    }
                }
                return this;
            },
            render: render
        };
    };
};

var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = '$1-$2';
var camelToDash = function (str) { return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase(); };
var setDomAttrs = function (element, attrs) {
    for (var key in attrs) {
        if (attrs.hasOwnProperty(key)) {
            element.setAttribute(key, attrs[key]);
        }
    }
};

var camelCache = new Map();
var dashCache = new Map();
var prefixes = ['Webkit', 'Moz', 'O', 'ms', ''];
var numPrefixes = prefixes.length;
var isBrowser = typeof document !== 'undefined';
var testElement;
var setDashPrefix = function (key, prefixed) {
    return dashCache.set(key, camelToDash(prefixed));
};
var testPrefix = function (key) {
    testElement = testElement || document.createElement('div');
    for (var i = 0; i < numPrefixes; i++) {
        var prefix = prefixes[i];
        var noPrefix = prefix === '';
        var prefixedPropertyName = noPrefix
            ? key
            : prefix + key.charAt(0).toUpperCase() + key.slice(1);
        if (prefixedPropertyName in testElement.style || noPrefix) {
            camelCache.set(key, prefixedPropertyName);
            setDashPrefix(key, "" + (noPrefix ? '' : '-') + camelToDash(prefixedPropertyName));
        }
    }
};
var setServerProperty = function (key) { return setDashPrefix(key, key); };
var prefixer = function (key, asDashCase) {
    if (asDashCase === void 0) { asDashCase = false; }
    var cache = asDashCase ? dashCache : camelCache;
    if (!cache.has(key))
        isBrowser ? testPrefix(key) : setServerProperty(key);
    return cache.get(key) || key;
};

var axes = ['', 'X', 'Y', 'Z'];
var order = ['scale', 'rotate', 'skew', 'transformPerspective'];
var transformProps = order.reduce(function (acc, key) {
    return axes.reduce(function (axesAcc, axesKey) {
        axesAcc.push(key + axesKey);
        return axesAcc;
    }, acc);
}, ['x', 'y', 'z']);
var transformPropDictionary = transformProps.reduce(function (dict, key) {
    dict[key] = true;
    return dict;
}, {});
var isTransformProp = function (key) {
    return transformPropDictionary[key] === true;
};
var sortTransformProps = function (a, b) {
    return transformProps.indexOf(a) - transformProps.indexOf(b);
};
var isTransformOriginProp = function (key) {
    return key === 'originX' || key === 'originY';
};

var valueTypes = {
    color: styleValueTypes.color,
    backgroundColor: styleValueTypes.color,
    outlineColor: styleValueTypes.color,
    fill: styleValueTypes.color,
    stroke: styleValueTypes.color,
    borderColor: styleValueTypes.color,
    borderTopColor: styleValueTypes.color,
    borderRightColor: styleValueTypes.color,
    borderBottomColor: styleValueTypes.color,
    borderLeftColor: styleValueTypes.color,
    borderWidth: styleValueTypes.px,
    borderTopWidth: styleValueTypes.px,
    borderRightWidth: styleValueTypes.px,
    borderBottomWidth: styleValueTypes.px,
    borderLeftWidth: styleValueTypes.px,
    borderRadius: styleValueTypes.px,
    borderTopLeftRadius: styleValueTypes.px,
    borderTopRightRadius: styleValueTypes.px,
    borderBottomRightRadius: styleValueTypes.px,
    borderBottomLeftRadius: styleValueTypes.px,
    width: styleValueTypes.px,
    maxWidth: styleValueTypes.px,
    height: styleValueTypes.px,
    maxHeight: styleValueTypes.px,
    top: styleValueTypes.px,
    right: styleValueTypes.px,
    bottom: styleValueTypes.px,
    left: styleValueTypes.px,
    padding: styleValueTypes.px,
    paddingTop: styleValueTypes.px,
    paddingRight: styleValueTypes.px,
    paddingBottom: styleValueTypes.px,
    paddingLeft: styleValueTypes.px,
    margin: styleValueTypes.px,
    marginTop: styleValueTypes.px,
    marginRight: styleValueTypes.px,
    marginBottom: styleValueTypes.px,
    marginLeft: styleValueTypes.px,
    rotate: styleValueTypes.degrees,
    rotateX: styleValueTypes.degrees,
    rotateY: styleValueTypes.degrees,
    rotateZ: styleValueTypes.degrees,
    scale: styleValueTypes.scale,
    scaleX: styleValueTypes.scale,
    scaleY: styleValueTypes.scale,
    scaleZ: styleValueTypes.scale,
    skew: styleValueTypes.degrees,
    skewX: styleValueTypes.degrees,
    skewY: styleValueTypes.degrees,
    distance: styleValueTypes.px,
    x: styleValueTypes.px,
    y: styleValueTypes.px,
    z: styleValueTypes.px,
    perspective: styleValueTypes.px,
    opacity: styleValueTypes.alpha,
    originX: styleValueTypes.percent,
    originY: styleValueTypes.percent,
    originZ: styleValueTypes.px
};
var getValueType = (function (key) { return valueTypes[key]; });

var SCROLL_LEFT = 'scrollLeft';
var SCROLL_TOP = 'scrollTop';
var scrollKeys = new Set([SCROLL_LEFT, SCROLL_TOP]);

var blacklist = new Set([SCROLL_LEFT, SCROLL_TOP, 'transform']);
var aliasMap = {
    x: 'translateX',
    y: 'translateY',
    z: 'translateZ'
};
var isCustomTemplate = function (v) {
    return typeof v === 'function';
};
var buildTransform = function (state, transform, transformKeys, transformIsDefault, enableHardwareAcceleration) {
    var transformString = '';
    var transformHasZ = false;
    transformKeys.sort(sortTransformProps);
    var numTransformKeys = transformKeys.length;
    for (var i = 0; i < numTransformKeys; i++) {
        var key = transformKeys[i];
        transformString += (aliasMap[key] || key) + "(" + transform[key] + ") ";
        transformHasZ = key === 'z' ? true : transformHasZ;
    }
    if (!transformHasZ && enableHardwareAcceleration) {
        transformString += 'translateZ(0)';
    }
    else {
        transformString = transformString.trim();
    }
    if (isCustomTemplate(state.transform)) {
        transformString = state.transform(transform, transformString);
    }
    else if (transformIsDefault) {
        transformString = 'none';
    }
    return transformString;
};
var buildStyleProperty = function (state, enableHardwareAcceleration, styles, transform, transformOrigin, transformKeys, isDashCase) {
    if (enableHardwareAcceleration === void 0) { enableHardwareAcceleration = true; }
    if (styles === void 0) { styles = {}; }
    if (transform === void 0) { transform = {}; }
    if (transformOrigin === void 0) { transformOrigin = {}; }
    if (transformKeys === void 0) { transformKeys = []; }
    if (isDashCase === void 0) { isDashCase = false; }
    var transformIsDefault = true;
    var hasTransform = false;
    var hasTransformOrigin = false;
    for (var key in state) {
        var value = state[key];
        var valueType = getValueType(key);
        var valueAsType = typeof value === 'number' && valueType
            ? valueType.transform(value)
            : value;
        if (isTransformProp(key)) {
            hasTransform = true;
            transform[key] = valueAsType;
            transformKeys.push(key);
            if (transformIsDefault) {
                if ((valueType.default && value !== valueType.default) ||
                    (!valueType.default && value !== 0)) {
                    transformIsDefault = false;
                }
            }
        }
        else if (isTransformOriginProp(key)) {
            transformOrigin[key] = valueAsType;
            hasTransformOrigin = true;
        }
        else if (!blacklist.has(key) || !isCustomTemplate(valueAsType)) {
            styles[prefixer(key, isDashCase)] = valueAsType;
        }
    }
    if (hasTransform || typeof state.transform === 'function') {
        styles.transform = buildTransform(state, transform, transformKeys, transformIsDefault, enableHardwareAcceleration);
    }
    if (hasTransformOrigin) {
        styles.transformOrigin = (transformOrigin.originX ||
            0) + " " + (transformOrigin.originY || 0) + " " + (transformOrigin.originZ || 0);
    }
    return styles;
};
var createStyleBuilder = function (enableHardwareAcceleration) {
    if (enableHardwareAcceleration === void 0) { enableHardwareAcceleration = true; }
    var styles = {};
    var transform = {};
    var transformOrigin = {};
    var transformKeys = [];
    return function (state) {
        transformKeys.length = 0;
        buildStyleProperty(state, enableHardwareAcceleration, styles, transform, transformOrigin, transformKeys, true);
        return styles;
    };
};

var cssStyler = createStyler({
    onRead: function (key, _a) {
        var element = _a.element, preparseOutput = _a.preparseOutput;
        var valueType = getValueType(key);
        if (isTransformProp(key)) {
            return valueType ? valueType.default || 0 : 0;
        }
        else if (scrollKeys.has(key)) {
            return element[key];
        }
        else {
            var domValue = window
                .getComputedStyle(element, null)
                .getPropertyValue(prefixer(key, true)) || 0;
            return preparseOutput && valueType && valueType.parse
                ? valueType.parse(domValue)
                : domValue;
        }
    },
    onRender: function (state, _a, changedValues) {
        var element = _a.element, buildStyles = _a.buildStyles;
        Object.assign(element.style, buildStyles(state));
        if (changedValues.indexOf(SCROLL_LEFT) !== -1)
            element.scrollLeft = state.scrollLeft;
        if (changedValues.indexOf(SCROLL_TOP) !== -1)
            element.scrollTop = state.scrollTop;
    },
    uncachedValues: scrollKeys
});
var css = (function (element, _a) {
    if (_a === void 0) { _a = {}; }
    var enableHardwareAcceleration = _a.enableHardwareAcceleration, props = __rest(_a, ["enableHardwareAcceleration"]);
    return cssStyler(__assign({ element: element, buildStyles: createStyleBuilder(enableHardwareAcceleration), preparseOutput: true }, props));
});

var camelCaseAttributes = new Set([
    'baseFrequency',
    'diffuseConstant',
    'kernelMatrix',
    'kernelUnitLength',
    'keySplines',
    'keyTimes',
    'limitingConeAngle',
    'markerHeight',
    'markerWidth',
    'numOctaves',
    'targetX',
    'targetY',
    'surfaceScale',
    'specularConstant',
    'specularExponent',
    'stdDeviation',
    'tableValues'
]);

var ZERO_NOT_ZERO = 0.0000001;
var percentToPixels = function (percent, length) {
    return (percent / 100) * length + 'px';
};
var build = function (state, dimensions, isPath, pathLength) {
    var hasTransform = false;
    var hasDashArray = false;
    var props = {};
    var dashArrayStyles = isPath
        ? {
            pathLength: '0',
            pathSpacing: "" + pathLength
        }
        : undefined;
    var scale = state.scale !== undefined
        ? state.scale || ZERO_NOT_ZERO
        : state.scaleX || 1;
    var scaleY = state.scaleY !== undefined ? state.scaleY || ZERO_NOT_ZERO : scale || 1;
    var transformOriginX = dimensions.width * ((state.originX || 50) / 100) + dimensions.x;
    var transformOriginY = dimensions.height * ((state.originY || 50) / 100) + dimensions.y;
    var scaleTransformX = -transformOriginX * (scale * 1);
    var scaleTransformY = -transformOriginY * (scaleY * 1);
    var scaleReplaceX = transformOriginX / scale;
    var scaleReplaceY = transformOriginY / scaleY;
    var transform = {
        translate: "translate(" + state.x + ", " + state.y + ") ",
        scale: "translate(" + scaleTransformX + ", " + scaleTransformY + ") scale(" + scale + ", " + scaleY + ") translate(" + scaleReplaceX + ", " + scaleReplaceY + ") ",
        rotate: "rotate(" + state.rotate + ", " + transformOriginX + ", " + transformOriginY + ") ",
        skewX: "skewX(" + state.skewX + ") ",
        skewY: "skewY(" + state.skewY + ") "
    };
    for (var key in state) {
        if (state.hasOwnProperty(key)) {
            var value = state[key];
            if (isTransformProp(key)) {
                hasTransform = true;
            }
            else if (isPath &&
                (key === 'pathLength' || key === 'pathSpacing') &&
                typeof value === 'number') {
                hasDashArray = true;
                dashArrayStyles[key] = percentToPixels(value, pathLength);
            }
            else if (isPath && key === 'pathOffset') {
                props['stroke-dashoffset'] = percentToPixels(-value, pathLength);
            }
            else {
                var attrKey = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
                props[attrKey] = value;
            }
        }
    }
    if (hasDashArray) {
        props['stroke-dasharray'] =
            dashArrayStyles.pathLength + ' ' + dashArrayStyles.pathSpacing;
    }
    if (hasTransform) {
        props.transform = '';
        for (var key in transform) {
            if (transform.hasOwnProperty(key)) {
                var defaultValue = key === 'scale' ? '1' : '0';
                props.transform += transform[key].replace(/undefined/g, defaultValue);
            }
        }
    }
    return props;
};

var int = __assign({}, styleValueTypes.number, { transform: Math.round });
var valueTypes$1 = {
    fill: styleValueTypes.color,
    stroke: styleValueTypes.color,
    scale: styleValueTypes.scale,
    scaleX: styleValueTypes.scale,
    scaleY: styleValueTypes.scale,
    opacity: styleValueTypes.alpha,
    fillOpacity: styleValueTypes.alpha,
    strokeOpacity: styleValueTypes.alpha,
    numOctaves: int
};
var getValueType$1 = (function (key) { return valueTypes$1[key]; });

var getDimensions = function (element) {
    return typeof element.getBBox === 'function'
        ? element.getBBox()
        : element.getBoundingClientRect();
};
var getSVGElementDimensions = function (element) {
    try {
        return getDimensions(element);
    }
    catch (e) {
        return { x: 0, y: 0, width: 0, height: 0 };
    }
};

var svgStyler = createStyler({
    onRead: function (key, _a) {
        var element = _a.element;
        if (!isTransformProp(key)) {
            return element.getAttribute(key);
        }
        else {
            var valueType = getValueType$1(key);
            return valueType ? valueType.default : 0;
        }
    },
    onRender: function (state, _a) {
        var dimensions = _a.dimensions, element = _a.element, isPath = _a.isPath, pathLength = _a.pathLength;
        setDomAttrs(element, build(state, dimensions, isPath, pathLength));
    }
});
var svg = (function (element) {
    var dimensions = getSVGElementDimensions(element);
    var props = {
        element: element,
        dimensions: dimensions,
        isPath: false
    };
    if (element.tagName === 'path') {
        props.isPath = true;
        props.pathLength = element.getTotalLength();
    }
    return svgStyler(props);
});

var viewport = createStyler({
    useCache: false,
    onRead: function (key) {
        return key === 'scrollTop' ? window.pageYOffset : window.pageXOffset;
    },
    onRender: function (_a) {
        var _b = _a.scrollTop, scrollTop = _b === void 0 ? 0 : _b, _c = _a.scrollLeft, scrollLeft = _c === void 0 ? 0 : _c;
        return window.scrollTo(scrollLeft, scrollTop);
    }
});

var cache = new WeakMap();
var createDOMStyler = function (node, props) {
    var styler;
    if (node instanceof HTMLElement) {
        styler = css(node, props);
    }
    else if (node instanceof SVGElement) {
        styler = svg(node);
    }
    else if (node === window) {
        styler = viewport(node);
    }
    heyListen.invariant(styler !== undefined, 'No valid node provided. Node must be HTMLElement, SVGElement or window.');
    cache.set(node, styler);
    return styler;
};
var getStyler = function (node, props) {
    return cache.has(node) ? cache.get(node) : createDOMStyler(node, props);
};
function index (nodeOrSelector, props) {
    var node = typeof nodeOrSelector === 'string'
        ? document.querySelector(nodeOrSelector)
        : nodeOrSelector;
    return getStyler(node, props);
}

exports.default = index;
exports.createStylerFactory = createStyler;
exports.buildStyleProperty = buildStyleProperty;
exports.isTransformProp = isTransformProp;


/***/ }),

/***/ "./node_modules/tslib/tslib.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (exports) { factory(createExporter(root, createExporter(exports))); }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else {}
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-borders/token.cssmodules.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\n", ""]);

// exports
exports.locals = {
	"border-radius-small": "4px",
	"borderRadiusSmall": "4px"
};

/***/ }),

/***/ "./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\n", ""]);

// exports
exports.locals = {
	"green-dark": "#194829",
	"greenDark": "#194829",
	"fuchsia-light": "#df4e96",
	"fuchsiaLight": "#df4e96",
	"aqua-lightest": "#eefcf9",
	"aquaLightest": "#eefcf9",
	"teal-lightest": "#eef8fb",
	"tealLightest": "#eef8fb",
	"purple-lightest": "#f8f0fa",
	"purpleLightest": "#f8f0fa",
	"orange-darker": "#441a0e",
	"orangeDarker": "#441a0e",
	"blue-lightest": "#eef1fc",
	"blueLightest": "#eef1fc",
	"blue-light": "#6c8ae4",
	"blueLight": "#6c8ae4",
	"green": "#2f864d",
	"violet-dark": "#4d1fd6",
	"violetDark": "#4d1fd6",
	"orange-lighter": "#e69b84",
	"orangeLighter": "#e69b84",
	"teal-light": "#2b9abf",
	"tealLight": "#2b9abf",
	"aqua-light": "#1fa888",
	"aquaLight": "#1fa888",
	"purple-light": "#bb6acd",
	"purpleLight": "#bb6acd",
	"fuchsia-lightest": "#fceef5",
	"fuchsiaLightest": "#fceef5",
	"teal-dark": "#154a5b",
	"tealDark": "#154a5b",
	"ash-lightest": "#f1f2f4",
	"ashLightest": "#f1f2f4",
	"purple-dark": "#7c2f8e",
	"purpleDark": "#7c2f8e",
	"red-lighter": "#eea0a5",
	"redLighter": "#eea0a5",
	"aqua-dark": "#0c4134",
	"aquaDark": "#0c4134",
	"violet-light": "#9d82ed",
	"violetLight": "#9d82ed",
	"white": "#fff",
	"blue-dark": "#2146b5",
	"blueDark": "#2146b5",
	"yellow-lightest": "#fff8eb",
	"yellowLightest": "#fff8eb",
	"yellow-lighter": "#fdc958",
	"yellowLighter": "#fdc958",
	"fuchsia-dark": "#971c59",
	"fuchsiaDark": "#971c59",
	"green-light": "#39a25e",
	"greenLight": "#39a25e",
	"red-lightest": "#fceeef",
	"redLightest": "#fceeef",
	"ash-lighter": "#d8d9db",
	"ashLighter": "#d8d9db",
	"ash-dark": "#2d333f",
	"ashDark": "#2d333f",
	"green-darker": "#153c23",
	"greenDarker": "#153c23",
	"fuchsia-lighter": "#eb93bf",
	"fuchsiaLighter": "#eb93bf",
	"orange": "#c84f29",
	"yellow-dark": "#885e01",
	"yellowDark": "#885e01",
	"orange-lightest": "#fcf1ee",
	"orangeLightest": "#fcf1ee",
	"blue-lighter": "#b1c1f1",
	"blueLighter": "#b1c1f1",
	"red": "#da3743",
	"violet-darker": "#1a0a47",
	"violetDarker": "#1a0a47",
	"teal-lighter": "#61bddb",
	"tealLighter": "#61bddb",
	"aqua-lighter": "#3ddbb6",
	"aquaLighter": "#3ddbb6",
	"red-dark": "#931b23",
	"redDark": "#931b23",
	"purple-lighter": "#d7a7e2",
	"purpleLighter": "#d7a7e2",
	"yellow": "#d99502",
	"purple-darker": "#36143d",
	"purpleDarker": "#36143d",
	"aqua-darker": "#09342a",
	"aquaDarker": "#09342a",
	"teal-darker": "#0f3643",
	"tealDarker": "#0f3643",
	"violet-lighter": "#d5c9f7",
	"violetLighter": "#d5c9f7",
	"orange-dark": "#83331b",
	"orangeDark": "#83331b",
	"ash": "#6f737b",
	"blue-darker": "#0d1b45",
	"blueDarker": "#0d1b45",
	"orange-light": "#d86441",
	"orangeLight": "#d86441",
	"fuchsia": "#d82c82",
	"fuchsia-darker": "#450d29",
	"fuchsiaDarker": "#450d29",
	"green-lighter": "#64c987",
	"greenLighter": "#64c987",
	"green-lightest": "#f0faf3",
	"greenLightest": "#f0faf3",
	"blue": "#4a6fde",
	"red-light": "#e15b64",
	"redLight": "#e15b64",
	"ash-darker": "#141a26",
	"ashDarker": "#141a26",
	"yellow-darker": "#513701",
	"yellowDarker": "#513701",
	"teal": "#247f9e",
	"aqua": "#18856b",
	"purple": "#ad4cc3",
	"yellow-light": "#fdaf08",
	"yellowLight": "#fdaf08",
	"violet-lightest": "#f1edfc",
	"violetLightest": "#f1edfc",
	"violet": "#7f5ce8",
	"ash-light": "#91949a",
	"ashLight": "#91949a",
	"red-darker": "#450d10",
	"redDarker": "#450d10"
};

/***/ }),

/***/ "./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-spacing/token.cssmodules.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\n", ""]);

// exports
exports.locals = {
	"spacing-xsmall": "4px",
	"spacingXsmall": "4px",
	"spacing-small": "8px",
	"spacingSmall": "8px",
	"spacing-medium": "16px",
	"spacingMedium": "16px",
	"spacing-large": "32px",
	"spacingLarge": "32px",
	"spacing-xlarge": "64px",
	"spacingXlarge": "64px"
};

/***/ }),

/***/ "./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./src/components/SlideController/SlideNav.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(false);
// imports
exports.i(__webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css"), undefined);
exports.i(__webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-borders/token.cssmodules.css"), undefined);
exports.i(__webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-spacing/token.cssmodules.css"), undefined);

// module
exports.push([module.i, ".SlideNav__button___2Lx_d8N017oktiiUcnpNsW{padding:" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-spacing/token.cssmodules.css").locals["spacing-xsmall"] + ";background-color:" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css").locals["white"] + ";border:1px solid " + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css").locals["ash-lighter"] + ";cursor:pointer;margin:0 " + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-spacing/token.cssmodules.css").locals["spacing-xsmall"] + ";line-height:10px;border-radius:" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-borders/token.cssmodules.css").locals["border-radius-small"] + ";box-shadow:2px 2px 4px rgba(45,51,63,0.2);transition:opacity 0.3s ease-out}.SlideNav__button___2Lx_d8N017oktiiUcnpNsW:hover{border-color:" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css").locals["teal"] + "}.SlideNav__icon___2gY86w0-KufvolyaqKYtXk{margin:0}.SlideNav__button___2Lx_d8N017oktiiUcnpNsW[disabled]{border-color:" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css").locals["ash-lightest"] + ";opacity:0;cursor:default}.SlideNav__button___2Lx_d8N017oktiiUcnpNsW[disabled] svg{color:" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css").locals["ash-lightest"] + "}\n", ""]);

// exports
exports.locals = {
	"white": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css").locals["white"] + "",
	"ash-lighter": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css").locals["ash-lighter"] + "",
	"ashLighter": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css").locals["ash-lighter"] + "",
	"ash-lightest": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css").locals["ash-lightest"] + "",
	"ashLightest": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css").locals["ash-lightest"] + "",
	"teal": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-colors/token.cssmodules.css").locals["teal"] + "",
	"border-radius-small": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-borders/token.cssmodules.css").locals["border-radius-small"] + "",
	"borderRadiusSmall": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-borders/token.cssmodules.css").locals["border-radius-small"] + "",
	"spacing-xsmall": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-spacing/token.cssmodules.css").locals["spacing-xsmall"] + "",
	"spacingXsmall": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-spacing/token.cssmodules.css").locals["spacing-xsmall"] + "",
	"spacing-small": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-spacing/token.cssmodules.css").locals["spacing-small"] + "",
	"spacingSmall": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-spacing/token.cssmodules.css").locals["spacing-small"] + "",
	"spacing-medium": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-spacing/token.cssmodules.css").locals["spacing-medium"] + "",
	"spacingMedium": "" + __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./node_modules/otkit-spacing/token.cssmodules.css").locals["spacing-medium"] + "",
	"button": "SlideNav__button___2Lx_d8N017oktiiUcnpNsW",
	"icon": "SlideNav__icon___2gY86w0-KufvolyaqKYtXk"
};

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/components/Area/Area.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Area = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

var _reactPose = __webpack_require__("./node_modules/react-pose/lib/index.js");

var _components = __webpack_require__("./src/components/index.ts");

var _utils = __webpack_require__("./src/utils/index.ts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Area =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Area, _React$Component);

  function Area(props) {
    var _this;

    _classCallCheck(this, Area);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Area).call(this, props));
    _this.getComponentTheme = _this.getComponentTheme.bind(_assertThisInitialized(_this));
    _this.renderArea = _this.renderArea.bind(_assertThisInitialized(_this));
    _this.getMouseLocation = _this.getMouseLocation.bind(_assertThisInitialized(_this));
    _this.getMouseActions = _this.getMouseActions.bind(_assertThisInitialized(_this));
    _this.generateAreaGraph = _this.generateAreaGraph.bind(_assertThisInitialized(_this));
    _this.generateLineGraph = _this.generateLineGraph.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Area, [{
    key: "getComponentTheme",
    value: function getComponentTheme() {
      var _this$props = this.props,
          theme = _this$props.theme,
          isMouseOver = _this$props.isMouseOver;
      return {
        cursor: theme.area.cursor,
        fill: isMouseOver ? theme.common.mouseOver.fill : theme.common.fill,
        fillOpacity: isMouseOver ? theme.common.mouseOver.fillOpacity : theme.common.fillOpacity,
        strokeWidth: theme.common.strokeWidth,
        strokeOpacity: isMouseOver ? theme.common.mouseOver.strokeOpacity : theme.common.strokeOpacity,
        strokeDasharray: theme.common.strokeDasharray,
        stroke: isMouseOver ? theme.common.mouseOver.stroke : theme.common.stroke,
        radius: theme.area.single.radius,
        eventFill: theme.area.path.eventFill,
        eventFillOpacity: theme.area.path.eventFillOpacity,
        eventStroke: theme.area.path.eventStroke,
        eventStrokeOpacity: theme.area.path.eventOpacity,
        eventStrokeWidth: theme.area.path.eventStrokeWidth
      };
    }
  }, {
    key: "setMouseEvent",
    value: function setMouseEvent(id, flag) {
      var events = this.state.events.map(function (v) {
        var item = v;

        if (item.id === id) {
          item.isMouseOver = flag;
          return item;
        }

        return item;
      });
      this.setState({
        events: events
      });
    }
  }, {
    key: "getMouseLocation",
    value: function getMouseLocation(e) {
      var findAncestor = function findAncestor(el, sel) {
        while ((el = el.parentElement) && !(el.matches || el.matchesSelector).call(el, sel)) {
          ;
        } // eslint-disable-line


        return el;
      };

      var parentSVG = findAncestor(e.target, 'svg');
      var x = e.clientX - parentSVG.getBoundingClientRect().left;
      var y = e.clientY - parentSVG.getBoundingClientRect().top;
      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "getMouseActions",
    value: function getMouseActions() {
      var _this2 = this;

      var id = this.props.id;
      return {
        onClick: function onClick(e) {
          var mouseLoc = _this2.getMouseLocation(e);

          _this2.props.onMouseClickEvent(_objectSpread({
            id: id
          }, mouseLoc));
        },
        onMouseOver: function onMouseOver(e) {
          var mouseLoc = _this2.getMouseLocation(e);

          _this2.props.onMouseOverEvent(_objectSpread({
            id: id,
            flag: true
          }, mouseLoc));
        },
        onMouseMove: function onMouseMove(e) {
          var mouseLoc = _this2.getMouseLocation(e);

          _this2.props.onMouseOverEvent(_objectSpread({
            id: id,
            flag: true
          }, mouseLoc));
        },
        onMouseOut: function onMouseOut(e) {
          var mouseLoc = _this2.getMouseLocation(e);

          _this2.props.onMouseOutEvent(_objectSpread({
            id: id,
            flag: false
          }, mouseLoc));
        }
      };
    }
  }, {
    key: "updateMouseEvents",
    value: function updateMouseEvents(_ref) {
      var data = _ref.data;
      var events = data.map(function (v) {
        return {
          id: v.id,
          isMouseOver: false
        };
      });
      this.setState({
        events: events
      });
    } // Graph for a single point data

  }, {
    key: "generateCircle",
    value: function generateCircle(dataPoint, actions, style) {
      var _this$props2 = this.props,
          animation = _this$props2.animation,
          theme = _this$props2.theme;
      var setData = dataPoint;

      var props = _objectSpread({
        cx: setData.style.x,
        cy: setData.style.y0,
        r: style.radius,
        style: {
          fill: style.fill,
          fillOpacity: style.fillOpacity,
          strokeWidth: style.strokeWidth,
          strokeOpacity: style.strokeOpacity,
          strokeDasharray: style.strokeDasharray,
          stroke: style.stroke
        }
      }, actions);

      if (animation.animate) {
        var animatedProps = _objectSpread({}, props, {
          key: 1,
          poseKey: props,
          dotsVal: _objectSpread({}, props, {
            index: 1,
            theme: theme.area.single
          })
        });

        return _react.default.createElement(_reactPose.PoseGroup, {
          animateOnMount: true
        }, _react.default.createElement(_components.AnimatedCircle, animatedProps));
      }

      return _react.default.createElement(_components.Circle, props);
    }
  }, {
    key: "generateAreaGraph",
    value: function generateAreaGraph(dataPointStyle, actions, style) {
      var _this$props3 = this.props,
          animation = _this$props3.animation,
          theme = _this$props3.theme,
          index = _this$props3.index,
          id = _this$props3.id;
      var pathData = (0, _utils.generatePathData)(dataPointStyle, theme);

      var props = _objectSpread({}, actions, {
        key: id,
        id: id,
        d: pathData,
        style: style
      });

      if (animation.animate) {
        var animatedProps = _objectSpread({}, props, {
          pose: 'pose',
          poseKey: dataPointStyle,
          posePathVal: {
            data: dataPointStyle,
            index: index,
            theme: theme
          }
        });

        return _react.default.createElement(_reactPose.PoseGroup, {
          animateOnMount: true
        }, _react.default.createElement(_components.AnimatedPath, animatedProps));
      }

      return _react.default.createElement(_components.Path, props);
    }
  }, {
    key: "generateLineGraph",
    value: function generateLineGraph(dataPointStyle, actions, style) {
      var _this$props4 = this.props,
          animation = _this$props4.animation,
          theme = _this$props4.theme,
          index = _this$props4.index,
          id = _this$props4.id;
      var pathData = (0, _utils.generatePathData)(dataPointStyle, theme);
      var hiddenStyle = {
        fill: style.eventFill,
        fillOpacity: style.eventFillOpacity,
        stroke: style.eventStroke,
        strokeOpacity: style.eventStrokeOpacity,
        strokeWidth: style.eventStrokeWidth
      };
      var labelPathHidden = "path_hidden_".concat(id);
      var labelPathVisual = "path_visual_".concat(id);
      var labelPathGroup = "path_group_".concat(id);
      var props = {
        d: pathData
      };

      if (animation.animate) {
        var animatedProps = _objectSpread({}, props, {
          pose: 'pose',
          poseKey: dataPointStyle,
          posePathVal: {
            data: dataPointStyle,
            index: index,
            theme: theme
          }
        });

        return _react.default.createElement(_components.Group, {
          key: labelPathGroup
        }, _react.default.createElement(_reactPose.PoseGroup, {
          animateOnMount: true
        }, _react.default.createElement(_components.AnimatedPath, _extends({
          key: labelPathHidden,
          id: labelPathHidden,
          style: hiddenStyle
        }, actions, animatedProps)), _react.default.createElement(_components.AnimatedPath, _extends({
          key: labelPathVisual,
          id: labelPathVisual,
          style: _objectSpread({}, style, {
            pointerEvents: 'none'
          })
        }, animatedProps))));
      }

      return _react.default.createElement(_components.Group, {
        key: labelPathGroup
      }, _react.default.createElement(_components.Path, _extends({
        id: labelPathHidden,
        style: hiddenStyle
      }, actions, props)), _react.default.createElement(_components.Path, _extends({
        id: labelPathVisual,
        style: _objectSpread({}, style, {
          pointerEvents: 'none'
        })
      }, props)));
    }
  }, {
    key: "renderArea",
    value: function renderArea(dataPointStyle) {
      var theme = this.props.theme;
      var hasData = dataPointStyle.some(function (d) {
        return d.style.val > 0;
      });

      if (!hasData) {
        return null;
      }

      var actions = this.getMouseActions();
      var style = this.getComponentTheme(); // If there is only one data point, do not render path and use circle instead

      if (dataPointStyle.length === 1) {
        return this.generateCircle(dataPointStyle[0], actions, style);
      }
      /*
        If area is a line graph, an extra invisible path is added to
        allow extra space for mouse events
      */


      var isArea = typeof theme.common.fill !== 'undefined' && theme.common.fill !== 'transparent';

      if (!isArea) {
        return this.generateLineGraph(dataPointStyle, actions, style);
      }

      return this.generateAreaGraph(dataPointStyle, actions, style);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props5 = this.props,
          id = _this$props5.id,
          data = _this$props5.data;
      return _react.default.createElement(_components.Group, {
        id: "areagroup-".concat(id)
      }, this.renderArea(data));
    }
  }]);

  return Area;
}(_react.default.Component);

exports.Area = Area;

_defineProperty(Area, "propTypes", {
  animation: _propTypes.default.object.isRequired,
  activeInnerArea: _propTypes.default.object.isRequired,
  id: _propTypes.default.string.isRequired,
  index: _propTypes.default.number,
  data: _propTypes.default.array.isRequired,
  theme: _propTypes.default.object.isRequired,
  isInteractive: _propTypes.default.bool,
  isMouseOver: _propTypes.default.bool,
  onMouseClickEvent: _propTypes.default.func,
  onMouseOverEvent: _propTypes.default.func,
  onMouseOutEvent: _propTypes.default.func
});

_defineProperty(Area, "defaultProps", {
  index: 0,
  isMouseOver: false,
  isInteractive: false,
  onMouseClickEvent: function onMouseClickEvent() {},
  onMouseOverEvent: function onMouseOverEvent() {},
  onMouseOutEvent: function onMouseOutEvent() {}
});

/***/ }),

/***/ "./src/components/Area/index.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/components/Area/Area.js");
/* harmony import */ var _Area__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Area__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Area", function() { return _Area__WEBPACK_IMPORTED_MODULE_0__["Area"]; });




/***/ }),

/***/ "./src/components/Areas/Areas.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Areas = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

var _lodash = _interopRequireDefault(__webpack_require__("./node_modules/lodash.merge/index.js"));

var _index = __webpack_require__("./src/components/index.ts");

var _Area = __webpack_require__("./src/components/Area/index.ts");

var _Helpers = __webpack_require__("./src/components/Helpers/index.js");

var _utils = __webpack_require__("./src/utils/index.ts");

var _SlideController = __webpack_require__("./src/components/SlideController/index.ts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Areas =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Areas, _React$Component);

  function Areas(props) {
    var _this;

    _classCallCheck(this, Areas);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Areas).call(this, props));
    _this.state = {
      activeInfo: null,
      mouseState: {
        id: null,
        flag: null // isOver === true

      }
    };
    _this.onMouseClickEvent = _this.onMouseClickEvent.bind(_assertThisInitialized(_this));
    _this.onMouseOverEvent = _this.onMouseOverEvent.bind(_assertThisInitialized(_this));
    _this.onMouseOutEvent = _this.onMouseOutEvent.bind(_assertThisInitialized(_this));
    _this.getPathProps = _this.getPathProps.bind(_assertThisInitialized(_this));
    _this.updateMouseEvents = _this.updateMouseEvents.bind(_assertThisInitialized(_this));
    _this.renderArea = _this.renderArea.bind(_assertThisInitialized(_this));
    _this.getLocationInfo = _this.getLocationInfo.bind(_assertThisInitialized(_this));
    _this.getAnimationState = _this.getAnimationState.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Areas, [{
    key: "onMouseClickEvent",
    value: function onMouseClickEvent(getLocationInfo) {
      var _this2 = this;

      return function (_ref) {
        var id = _ref.id,
            x = _ref.x,
            y = _ref.y;
        var activeInfo = getLocationInfo({
          x: x,
          y: y,
          id: id
        });

        _this2.props.actions.onClick(activeInfo);

        _this2.setState(function (prevState) {
          return _objectSpread({}, prevState, {
            activeInfo: undefined
          });
        });
      };
    }
  }, {
    key: "onMouseOverEvent",
    value: function onMouseOverEvent(getLocationInfo) {
      var _this3 = this;

      return function (_ref2) {
        var id = _ref2.id,
            flag = _ref2.flag,
            x = _ref2.x,
            y = _ref2.y;
        var activeInfo = getLocationInfo({
          x: x,
          y: y,
          id: id
        });

        _this3.props.actions.onMouseOver(activeInfo);

        _this3.setState(function (prevState) {
          return _objectSpread({}, prevState, {
            activeInfo: activeInfo,
            mouseState: {
              id: id,
              flag: flag
            }
          });
        });
      };
    }
  }, {
    key: "onMouseOutEvent",
    value: function onMouseOutEvent(getLocationInfo) {
      var _this4 = this;

      return function (_ref3) {
        var id = _ref3.id,
            flag = _ref3.flag,
            x = _ref3.x,
            y = _ref3.y;
        var activeInfo = getLocationInfo({
          x: x,
          y: y,
          id: id
        });

        _this4.props.actions.onMouseOut(activeInfo);

        _this4.setState(function (prevState) {
          return _objectSpread({}, prevState, {
            activeInfo: undefined,
            mouseState: {
              id: id,
              flag: flag
            }
          });
        });
      };
    }
  }, {
    key: "getLocationInfo",
    value: function getLocationInfo(animData) {
      var _this5 = this;

      return function (_ref4) {
        var x = _ref4.x,
            y = _ref4.y,
            id = _ref4.id;
        var scales = _this5.props.activeInnerArea.scales;
        var _this5$props = _this5.props,
            columns = _this5$props.columns,
            theme = _this5$props.theme;
        var area = theme.area;
        var location = {
          x: Math.round(x),
          y: Math.round(y)
        };

        if (area.snap.some(function (v) {
          return v !== 'auto' && Number.isNaN(parseFloat(v));
        })) {
          throw new Error('Only numbers or "auto" values are accepted');
        } // Find parent and area info


        var areaParent = animData.find(function (v) {
          return v.data.some(function (currArea) {
            return currArea.id === id;
          });
        });
        var areaPoint = areaParent ? areaParent.data.find(function (v) {
          return v.id === id;
        }) : undefined; // Get the range using D3 x scale

        var range = columns.map(function (v, index) {
          var xLoc = scales.x(index);
          var xLocMin = scales.x(index);
          var xLocMax = scales.x(index + 1);
          var portion = (xLocMax - xLocMin) / 2; // If auto, snap is 50%

          var min = area.snap[0] === 'auto' ? xLocMin - portion : xLoc - area.snap[0];
          var max = area.snap[1] === 'auto' ? xLocMax - portion : xLocMin + area.snap[1];
          return {
            id: v.id,
            x: xLoc,
            min: min,
            max: max
          };
        }); // Find out if x matches the range
        // If range has only one datapoint, just return the only range

        var column = range.length === 1 ? range[0] : range.find(function (v) {
          return x > v.min && x < v.max;
        }); // Get y based on the x location found

        var colY = areaParent && column ? areaPoint.data.find(function (v) {
          return v.key === column.id;
        }) : undefined;
        var colYIndex = areaParent && column ? areaPoint.data.findIndex(function (v) {
          return v.key === column.id;
        }) : undefined; // Find out percentage along cols

        var percentageAlongColumns = null;

        if (colYIndex) {
          percentageAlongColumns = colYIndex / areaPoint.data.length;
        }

        var getColYVal = function getColYVal() {
          if (colY.style) {
            return _typeof(colY.style.y0) === 'object' ? colY.style.y0.val : colY.style.y0;
          }

          return null;
        };

        return {
          data: {
            id: areaPoint.id,
            parentId: areaParent.id
          },
          id: column ? column.id : null,
          location: _objectSpread({}, location, {
            colX: column ? column.x : null,
            // Return snap x
            colY: colY ? getColYVal() : null,
            // Return snap y
            percentageAlongColumns: percentageAlongColumns
          })
        };
      };
    }
  }, {
    key: "getPathProps",
    value: function getPathProps(activeInnerArea, animation, columns, data, theme) {
      var graphType = 'area';
      var _activeInnerArea$scal = activeInnerArea.scales,
          x = _activeInnerArea$scal.x,
          yInverted = _activeInnerArea$scal.yInverted;

      if (!data) {
        return [];
      } // Render empty data sets
      // If receives empty data, animate previous data to 0 (in this case, max height as we need to animate down not up)
      // if (data.length <= 0) {
      //   return this.constructEmptyPathProps();
      // }
      // Render with available data set


      if (data.length && columns.length) {
        var animData = data.map(function (graph) {
          var getYValue = function getYValue(sets, key, limiter) {
            var keys = Object.keys(sets);
            return keys.reduce(function (prev, curr, index) {
              var total = prev;

              if (index < limiter) {
                return total + sets[curr];
              }

              return total;
            }, 0);
          };

          var groupData = (0, _utils.getAreas)({
            data: graph.data,
            columns: columns,
            id: graph.id
          });
          var graphData = graph.data.map(function (v, i) {
            var styles = (0, _utils.assignPartialTheme)({
              theme: theme,
              keys: [graphType],
              customTheme: v.styles
            });
            var sets = groupData.data.map(function (set, index) {
              // The value of this point
              var setValue = set.data[v.id]; // The value of this point + previous point, this creates the stack

              var combinedValue = setValue + getYValue(set.data, v, i);
              var y0 = yInverted(combinedValue);
              var y1 = yInverted(getYValue(set.data, v, i));
              return {
                key: set.id,
                style: {
                  x: x(index),
                  y0: y0,
                  y1: animation.animate ? y1 : y1,
                  // @TODO Animation toggle
                  val: setValue > 0 ? combinedValue : 0
                }
              };
            });
            return {
              id: v.id,
              styles: styles,
              isMouseOver: false,
              isInteractive: false,
              data: sets
            };
          });
          return {
            id: graph.id,
            group: graph.group,
            data: graphData
          };
        });
        return animData;
      }

      return [];
    }
  }, {
    key: "getAnimationState",
    value: function getAnimationState(animationSetting) {
      // @TODO: onchange is currently set as true. We need to allow animation when onchange and not oninit
      var isAnimated = typeof (0, _utils.getAnimationMode)(animationSetting) === 'boolean' ? (0, _utils.getAnimationMode)(animationSetting) : false;
      return {
        mode: animationSetting,
        animate: isAnimated
      };
    }
  }, {
    key: "getHelperTheme",
    value: function getHelperTheme(_ref5) {
      var theme = _ref5.theme,
          helper = _ref5.helper;
      var helperTheme = (0, _utils.assignPartialTheme)({
        theme: theme,
        keys: ['helpers']
      });
      var customStyles = Object.keys(helper).reduce(function (prev, curr) {
        return _objectSpread({}, prev, _defineProperty({}, curr, helper[curr].styles || {}));
      }, {});
      helperTheme.helpers.area = (0, _lodash.default)({}, helperTheme.helpers.area, customStyles);
      return helperTheme;
    } // Checks for mouseover events for every area. Mouseover events should reflect if it has multiple areas as a group or not
    // If it is a grouped (e.g. stacked graph), mouse events on one of the areas should update the others as well.

  }, {
    key: "updateMouseEvents",
    value: function updateMouseEvents(animationData, id, flag) {
      if (animationData && animationData.length && id) {
        var parent = animationData.find(function (i) {
          return i.data.some(function (v) {
            return v.id === id;
          });
        });
        var parentId = parent ? parent.id : null;
        var animData = animationData.map(function (parent) {
          var _parent = parent;

          if (_parent.id === parentId) {
            return _objectSpread({}, _parent, {
              data: _parent.data.map(function (child) {
                var _child = child;

                if (_parent.group) {
                  _child.isMouseOver = flag;
                } else if (_child.id === id) {
                  _child.isMouseOver = flag;
                }

                return _objectSpread({}, _child);
              })
            });
          }

          return _objectSpread({}, _parent);
        });
        return animData;
      }

      return animationData;
    }
  }, {
    key: "constructEmptyPathProps",
    value: function constructEmptyPathProps() {//   const animData = this.state.animData.map((graph) => ({
      //     ...graph,
      //     data: graph.data.map((set) => { // eslint-disable-line
      //       return {
      //         ...set,
      //         isInteractive: true, // mark to true to tell this graph is empty
      //         data: set.data.map((point) => {
      //           const y = yInverted(activeInnerArea.height);
      //           return {
      //             ...point,
      //             style: {
      //               ...point.style,
      //               y0: y,
      //               y1: y,
      //             },
      //           };
      //         }),
      //       };
      //     }),
      //   }));
      //   return animData;
    }
  }, {
    key: "renderArea",
    value: function renderArea(_ref6) {
      var animation = _ref6.animation,
          areaData = _ref6.areaData,
          getLocationInfo = _ref6.getLocationInfo,
          helperTheme = _ref6.helperTheme,
          index = _ref6.index;
      var activeInnerArea = this.props.activeInnerArea;

      if (!areaData) {
        return null;
      } // Pass mouse events only if there is data


      var actions = areaData.isInteractive ? {} : {
        onMouseClickEvent: this.onMouseClickEvent(getLocationInfo),
        onMouseOverEvent: this.onMouseOverEvent(getLocationInfo),
        onMouseOutEvent: this.onMouseOutEvent(getLocationInfo)
      };
      var theme = areaData.styles; // Parse helper theme into Area

      if (Object.keys(helperTheme).length > 0) {
        theme = _objectSpread({}, helperTheme, areaData.styles);
      }

      return _react.default.createElement(_Area.Area, _extends({
        activeInnerArea: activeInnerArea,
        animation: animation,
        id: areaData.id,
        index: index,
        key: "area-".concat(areaData.id),
        data: areaData.data,
        theme: theme,
        isMouseOver: areaData.isMouseOver,
        isInteractive: areaData.isInteractive
      }, actions));
    }
  }, {
    key: "render",
    value: function render() {
      var _this6 = this;

      var _this$props = this.props,
          activeInnerArea = _this$props.activeInnerArea,
          columns = _this$props.columns,
          data = _this$props.data,
          helper = _this$props.helper,
          slideProps = _this$props.slideProps,
          theme = _this$props.theme;
      var helperTheme = this.getHelperTheme(this.props);
      var animation = this.getAnimationState(this.props.animation);
      var animData = this.getPathProps(activeInnerArea, animation, columns, data, theme);
      var getLocationInfoFunc = this.getLocationInfo(animData);
      animData = this.updateMouseEvents(animData, this.state.mouseState.id, this.state.mouseState.flag);

      if (!animData.length) {
        return null;
      }

      var xOffset = 0;
      var clipPathProps;

      if (slideProps && !slideProps.isDisabled) {
        xOffset = slideProps.offset;
        clipPathProps = {
          clipPath: 'url(#mask)'
        };
      }

      var animateSlideOffsetProps = {
        pose: 'pose',
        poseKey: xOffset,
        xOffset: xOffset
      };
      return _react.default.createElement("g", clipPathProps, _react.default.createElement(_SlideController.AnimateSlideOffset, animateSlideOffsetProps, _react.default.createElement(_index.Group, {
        id: "areas".concat((0, _utils.generateId)())
      }, _react.default.createElement(_Helpers.HighlightHelper, {
        activeInnerArea: activeInnerArea,
        animation: animation,
        columns: columns,
        helper: helper.highlight,
        helperTheme: helperTheme
      }), animData.map(function (area) {
        return _react.default.createElement(_index.Group, {
          id: "".concat(area.id, "-").concat((0, _utils.generateId)()),
          key: "".concat(area.id),
          transform: "translate(0 ".concat(activeInnerArea.top, ")")
        }, area.data.map(function (areaData, index) {
          return _this6.renderArea({
            animation: animation,
            areaData: areaData,
            getLocationInfo: getLocationInfoFunc,
            helperTheme: helperTheme,
            index: index
          });
        }), _react.default.createElement(_Helpers.AreaPointsHelper, {
          area: area,
          animation: animation,
          helper: helper.points,
          helperTheme: helperTheme,
          key: "".concat(area.id)
        }));
      }), _react.default.createElement(_Helpers.VerticalLocationHelper, {
        activeInfo: this.state.activeInfo,
        activeInnerArea: activeInnerArea,
        animation: animation,
        animData: animData,
        helper: helper.vertical,
        helperTheme: helperTheme
      }))));
    }
  }]);

  return Areas;
}(_react.default.Component);

exports.Areas = Areas;

_defineProperty(Areas, "propTypes", {
  animation: _propTypes.default.string.isRequired,
  actions: _propTypes.default.shape({
    onMouseOver: _propTypes.default.func,
    onMouseOut: _propTypes.default.func,
    onClick: _propTypes.default.func
  }),
  activeInnerArea: _propTypes.default.object.isRequired,
  columns: _propTypes.default.array.isRequired,
  data: _propTypes.default.array,
  theme: _propTypes.default.object.isRequired,
  helper: _propTypes.default.object.isRequired
});

_defineProperty(Areas, "defaultProps", {
  actions: {
    onMouseOver: function onMouseOver() {},
    onMouseOut: function onMouseOut() {},
    onClick: function onClick() {}
  },
  data: null
});

/***/ }),

/***/ "./src/components/Areas/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Areas", {
  enumerable: true,
  get: function get() {
    return _Areas.Areas;
  }
});

var _Areas = __webpack_require__("./src/components/Areas/Areas.js");

/***/ }),

/***/ "./src/components/Axis/AxisX/AxisX.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AxisX = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

var _reactPose = _interopRequireWildcard(__webpack_require__("./node_modules/react-pose/lib/index.js"));

var _Tick = __webpack_require__("./src/components/Axis/AxisX/Tick/index.js");

var _SlideController = __webpack_require__("./src/components/SlideController/index.ts");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var AnimateTickGroup = _reactPose.default.g({
  pose: {
    opacity: 1,
    x: function x(_ref) {
      var tickGroupPoseVals = _ref.tickGroupPoseVals;
      return tickGroupPoseVals.x;
    },
    transition: {
      x: {
        type: 'spring',
        stiffness: 210,
        damping: 20
      },
      opacity: {
        duration: 200,
        ease: 'easeIn'
      }
    }
  },
  exit: {
    x: function x(_ref2) {
      var tickGroupPoseVals = _ref2.tickGroupPoseVals;
      var offsetDistance = 200;
      var index = tickGroupPoseVals.index,
          dataLength = tickGroupPoseVals.dataLength;

      if (index > dataLength / 2) {
        return tickGroupPoseVals.maxX + offsetDistance;
      }

      return tickGroupPoseVals.minX - offsetDistance;
    },
    opacity: 0,
    transition: {
      x: {
        type: 'spring',
        stiffness: 210,
        damping: 20
      },
      opacity: {
        duration: 200,
        ease: 'easeOut'
      }
    }
  }
});

var AxisX =
/*#__PURE__*/
function (_React$Component) {
  _inherits(AxisX, _React$Component);

  function AxisX(props) {
    var _this;

    _classCallCheck(this, AxisX);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AxisX).call(this, props));
    _this.renderTick = _this.renderTick.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(AxisX, [{
    key: "getYOffset",
    value: function getYOffset() {
      var _this$props = this.props,
          activeOuterArea = _this$props.activeOuterArea,
          axisYOffset = _this$props.axisYOffset;
      var halfAxisGroupHeight = axisYOffset * -1;
      var distanceFromTop = activeOuterArea.height + activeOuterArea.top - halfAxisGroupHeight;
      return distanceFromTop;
    }
  }, {
    key: "getTickProps",
    value: function getTickProps(_ref3) {
      var label = _ref3.label,
          styles = _ref3.styles;
      var theme = this.props.theme;
      return {
        label: label,
        styles: styles,
        theme: theme,
        x: 0,
        y: 0
      };
    }
  }, {
    key: "renderTick",
    value: function renderTick(tickData, index) {
      var _this$props2 = this.props,
          data = _this$props2.data,
          isAnimated = _this$props2.isAnimated,
          scale = _this$props2.scale;
      var xRange = scale.range();
      var tickX = scale(index);

      if (isAnimated) {
        var tickGroupProps = {
          key: tickData.id,
          pose: 'pose',
          poseKey: ['pose'],
          tickGroupPoseVals: {
            minX: xRange[0],
            x: tickX,
            maxX: xRange[1],
            index: index,
            dataLength: data.length
          }
        };
        return _react.default.createElement(AnimateTickGroup, tickGroupProps, _react.default.createElement(_Tick.Tick, _extends({
          key: tickData.id
        }, this.getTickProps(tickData, index))));
      }

      return _react.default.createElement("g", {
        key: tickData.id,
        transform: "translate(".concat(tickX, ", 0)")
      }, _react.default.createElement(_Tick.Tick, _extends({
        key: tickData.id
      }, this.getTickProps(tickData, index))));
    }
  }, {
    key: "render",
    value: function render() {
      if (this.props.data.length === 0) return null;
      var slideProps = this.props.slideProps;
      var groupProps = {
        transform: "translate(0 ".concat(this.getYOffset(), ")")
      };
      var xOffset = 0;
      var clipPathProps;

      if (slideProps && !slideProps.isDisabled) {
        xOffset = slideProps.offset;
        clipPathProps = {
          clipPath: 'url(#mask)'
        };
      }

      var animateSlideOffsetProps = {
        pose: 'pose',
        poseKey: xOffset,
        xOffset: xOffset
      };

      if (this.props.isAnimated) {
        return _react.default.createElement("g", clipPathProps, _react.default.createElement(_SlideController.AnimateSlideOffset, animateSlideOffsetProps, _react.default.createElement("g", groupProps, _react.default.createElement(_reactPose.PoseGroup, null, this.props.data.map(this.renderTick)))));
      }

      return _react.default.createElement("g", clipPathProps, _react.default.createElement(_SlideController.AnimateSlideOffset, animateSlideOffsetProps, _react.default.createElement("g", groupProps, this.props.data.map(this.renderTick))));
    }
  }]);

  return AxisX;
}(_react.default.Component);

exports.AxisX = AxisX;

_defineProperty(AxisX, "propTypes", {
  activeOuterArea: _propTypes.default.shape({
    height: _propTypes.default.number.isRequired,
    top: _propTypes.default.number.isRequired
  }).isRequired,
  animationOffsetDistance: _propTypes.default.number,
  axisYOffset: _propTypes.default.number,
  data: _propTypes.default.array.isRequired,
  isAnimated: _propTypes.default.bool,
  responsive: _propTypes.default.oneOf(['scale', 'redraw', 'none']),
  scale: _propTypes.default.func.isRequired,
  slideProps: _propTypes.default.shape({
    isDisabled: _propTypes.default.bool,
    minWidth: _propTypes.default.number,
    offset: _propTypes.default.number,
    windowWidth: _propTypes.default.number
  }),
  theme: _propTypes.default.object.isRequired
});

_defineProperty(AxisX, "defaultProps", {
  axisYOffset: 20,
  animationOffsetDistance: 2,
  isAnimated: true,
  responsive: 'none'
});

/***/ }),

/***/ "./src/components/Axis/AxisX/Tick/Tick.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tick = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

var _TickLabel = __webpack_require__("./src/components/Axis/AxisX/Tick/TickLabel.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Tick =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Tick, _React$Component);

  function Tick() {
    _classCallCheck(this, Tick);

    return _possibleConstructorReturn(this, _getPrototypeOf(Tick).apply(this, arguments));
  }

  _createClass(Tick, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          label = _this$props.label,
          styles = _this$props.styles,
          theme = _this$props.theme;
      var fill = theme.axis.x.stroke.fill;
      return _react.default.createElement("g", null, _react.default.createElement("rect", {
        y: "-20",
        width: "1",
        height: "8",
        fill: fill
      }), _react.default.createElement(_TickLabel.TickLabel, {
        label: label,
        styles: styles.label,
        theme: theme
      }));
    }
  }]);

  return Tick;
}(_react.default.Component);

exports.Tick = Tick;

_defineProperty(Tick, "propTypes", {
  label: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.array, _propTypes.default.element]),
  styles: _propTypes.default.object,
  theme: _propTypes.default.object.isRequired
});

_defineProperty(Tick, "defaultProps", {
  label: '',
  styles: {}
});

/***/ }),

/***/ "./src/components/Axis/AxisX/Tick/TickLabel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TickLabel = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TickLabel =
/*#__PURE__*/
function (_React$Component) {
  _inherits(TickLabel, _React$Component);

  function TickLabel(props) {
    var _this;

    _classCallCheck(this, TickLabel);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TickLabel).call(this, props));
    var color = props.theme.axis.x.label.color;
    _this.styles = {
      text: _objectSpread({
        fontSize: 14,
        textAnchor: 'middle',
        color: color
      }, props.styles.text)
    };
    return _this;
  }

  _createClass(TickLabel, [{
    key: "renderMultilineLabel",
    value: function renderMultilineLabel(_ref) {
      var label = _ref.label,
          textStyles = _ref.textStyles;
      var lineHeight = this.props.lineHeight;

      var y = function y(i) {
        return i * (lineHeight * textStyles.fontSize);
      };

      return label.map(function (labelText, i) {
        return _react.default.createElement("text", _extends({
          key: "label-text-".concat(i)
        }, textStyles, {
          y: y(i)
        }), labelText);
      });
    }
  }, {
    key: "renderLabel",
    value: function renderLabel(_ref2) {
      var label = _ref2.label;
      var textStyles = this.styles.text; // If multi-line array

      if (Array.isArray(label)) {
        return this.renderMultilineLabel({
          label: label,
          textStyles: textStyles
        });
      } // If single-line string


      if (typeof label === 'string') {
        return _react.default.createElement("text", textStyles, label);
      }

      var LabelElement = label; // If it's an element, render it

      return _react.default.createElement(LabelElement, _extends({}, textStyles, {
        lineheight: this.props.lineHeight
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          label = _this$props.label,
          offset = _this$props.offset;
      return _react.default.createElement("g", {
        transform: "translate(0 ".concat(offset, ")")
      }, this.renderLabel({
        label: label
      }));
    }
  }]);

  return TickLabel;
}(_react.default.Component);

exports.TickLabel = TickLabel;

_defineProperty(TickLabel, "propTypes", {
  label: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.array, _propTypes.default.element]),
  lineHeight: _propTypes.default.number,
  offset: _propTypes.default.number,
  styles: _propTypes.default.object,
  theme: _propTypes.default.object.isRequired
});

_defineProperty(TickLabel, "defaultProps", {
  label: '',
  lineHeight: 1.4,
  offset: 5,
  styles: {}
});

/***/ }),

/***/ "./src/components/Axis/AxisX/Tick/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Tick", {
  enumerable: true,
  get: function get() {
    return _Tick.Tick;
  }
});

var _Tick = __webpack_require__("./src/components/Axis/AxisX/Tick/Tick.js");

/***/ }),

/***/ "./src/components/Axis/AxisX/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AxisX", {
  enumerable: true,
  get: function get() {
    return _AxisX.AxisX;
  }
});

var _AxisX = __webpack_require__("./src/components/Axis/AxisX/AxisX.js");

/***/ }),

/***/ "./src/components/Axis/AxisY/AxisY.tsx":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AxisY; });
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/d3-scale/dist/d3-scale.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3_scale__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_times__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/lodash.times/index.js");
/* harmony import */ var lodash_times__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_times__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var AxisY = /** @class */ (function (_super) {
    __extends(AxisY, _super);
    function AxisY(props) {
        var _this = _super.call(this, props) || this;
        _this.getTickArray = _this.getTickArray.bind(_this);
        _this.renderTick = _this.renderTick.bind(_this);
        _this.formatTickVal = _this.formatTickVal.bind(_this);
        return _this;
    }
    AxisY.prototype.getAxisCount = function () {
        var highestValue = this.props.highestValue;
        var count = 5;
        if (this.props.overrideCount) {
            return this.props.count;
        }
        if (highestValue >= count) {
            return count;
        }
        return highestValue + 1;
    };
    AxisY.prototype.getLabelScale = function () {
        var highestValue = this.props.highestValue;
        var count = this.getAxisCount();
        return Object(d3_scale__WEBPACK_IMPORTED_MODULE_0__["scaleLinear"])().domain([1, count]).range([0, highestValue]);
    };
    AxisY.prototype.getRectProps = function () {
        var _a = this.props.activeOuterArea, top = _a.top, left = _a.left, height = _a.height;
        var _b = this.props.theme.axis.y.stroke, fill = _b.fill, width = _b.width;
        return {
            fill: fill,
            height: height,
            width: width,
            x: left,
            y: top,
        };
    };
    AxisY.prototype.getTickArray = function () {
        var _a = this.props, activeOuterArea = _a.activeOuterArea, theme = _a.theme, helper = _a.helper;
        var count = this.getAxisCount();
        var labelScale = this.getLabelScale();
        var scale = activeOuterArea.scales.y.domain([count, 1]);
        var hideZero = helper.hideZero;
        // If there are no Y-values default to having 5 ticks without
        // any labels
        if (count === 1) {
            return lodash_times__WEBPACK_IMPORTED_MODULE_1___default()(5, function (index) {
                var i = index + 1;
                return {
                    barLength: '100%',
                    i: i,
                    isVisible: true,
                    key: "tick-" + index,
                    styles: theme.axis.y,
                    val: '',
                    xPosition: activeOuterArea.left,
                    yPosition: activeOuterArea.scales.y.domain([5, 1])(i),
                };
            });
        }
        return lodash_times__WEBPACK_IMPORTED_MODULE_1___default()(count, function (index) {
            var i = index + 1;
            // If hidezero is added to the helper hide the label from
            // the bottom tick only
            if (hideZero && i !== 1) {
                hideZero = false;
            }
            return {
                barLength: '100%',
                i: i,
                isVisible: !hideZero,
                key: "tick-" + index,
                styles: theme.axis.y,
                val: hideZero ? '' : labelScale(i),
                xPosition: activeOuterArea.left,
                yPosition: scale(i),
            };
        });
    };
    AxisY.prototype.formatTickVal = function (val) {
        var _a = this.props.helper, commaLargeValues = _a.commaLargeValues, commaLargeValuesUtil = _a.commaLargeValuesUtil;
        var tickVal = Math.round(val);
        if (commaLargeValues && typeof commaLargeValuesUtil === 'function') {
            tickVal = commaLargeValuesUtil(tickVal);
        }
        return tickVal;
    };
    AxisY.prototype.renderTick = function (_a) {
        var barLength = _a.barLength, i = _a.i, xPosition = _a.xPosition, yPosition = _a.yPosition, val = _a.val, key = _a.key, styles = _a.styles, isVisible = _a.isVisible;
        var AxisYLabel = this.props.AxisYLabel;
        var TickLabel = function (_a) {
            var tickVal = _a.tickVal;
            var textProps = {
                alignmentBaseline: 'central',
                style: __assign({}, styles.label, { fontSize: '14px' }),
                textAnchor: 'end',
                transform: 'translate(-10 0)',
            };
            return (react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("text", __assign({}, textProps), AxisYLabel ? react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(AxisYLabel, null, tickVal) : tickVal));
        };
        var groupProps = {
            key: key,
            transform: "translate(" + xPosition + ", " + yPosition + ")",
        };
        if (!isVisible) {
            return (react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("g", __assign({}, groupProps),
                react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("rect", __assign({ width: barLength }, (i === 1 ? styles.tickFirst : styles.tick)))));
        }
        return (react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("g", __assign({}, groupProps),
            typeof val === 'number' && react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(TickLabel, { tickVal: this.formatTickVal(val) }),
            typeof val !== 'number' && react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(TickLabel, null),
            react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("rect", __assign({ width: barLength }, styles.tick))));
    };
    AxisY.prototype.render = function () {
        return (react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("g", null,
            this.getTickArray().map(this.renderTick),
            react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("rect", __assign({}, this.getRectProps()))));
    };
    AxisY.defaultProps = {
        AxisYLabel: undefined,
        count: 0,
        helper: {
            commaLargeValues: false,
            commaLargeValuesUtil: function (d) { return d; },
            hideZero: false,
        },
        highestValue: 0,
        overrideCount: false,
    };
    return AxisY;
}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component));



/***/ }),

/***/ "./src/components/Bar/GroupedBar.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GroupedBar = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

var _SingleBar = __webpack_require__("./src/components/Bar/SingleBar.tsx");

var _StackedBar = __webpack_require__("./src/components/Bar/StackedBar.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var GroupedBar =
/*#__PURE__*/
function (_React$Component) {
  _inherits(GroupedBar, _React$Component);

  function GroupedBar() {
    _classCallCheck(this, GroupedBar);

    return _possibleConstructorReturn(this, _getPrototypeOf(GroupedBar).apply(this, arguments));
  }

  _createClass(GroupedBar, [{
    key: "renderSingleBar",
    value: function renderSingleBar(barProps, index) {
      return _react.default.createElement(_SingleBar.SingleBar, _extends({
        key: "SingleBar--".concat(index)
      }, barProps));
    }
  }, {
    key: "renderStackedBar",
    value: function renderStackedBar(barProps, index) {
      return _react.default.createElement(_StackedBar.StackedBar, _extends({
        key: "StackedBar--".concat(index)
      }, barProps));
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var _this$props = this.props,
          actions = _this$props.actions,
          data = _this$props.data,
          id = _this$props.id,
          isAnimated = _this$props.isAnimated,
          isHovered = _this$props.isHovered,
          scale = _this$props.scale,
          theme = _this$props.theme,
          xOffset = _this$props.xOffset,
          yOffset = _this$props.yOffset;
      var commonGroupedBarProps = {
        actions: actions,
        id: id,
        isAnimated: isAnimated,
        isHovered: isHovered,
        scale: scale,
        theme: theme,
        yOffset: yOffset
      };
      return _react.default.createElement("g", {
        transform: "translate(".concat(xOffset, ", 0)")
      }, data.map(function (datum, index) {
        if (datum.values) {
          return _this.renderStackedBar(_objectSpread({}, commonGroupedBarProps, {
            data: datum.values,
            showBarValue: datum.showBarValue,
            xOffset: datum.offset || 0
          }), index);
        }

        if (datum.value) {
          return _this.renderSingleBar(_objectSpread({}, commonGroupedBarProps, {
            data: datum.value,
            showBarValue: datum.showBarValue,
            xOffset: datum.offset || 0
          }), index);
        }

        return null;
      }));
    }
  }]);

  return GroupedBar;
}(_react.default.Component);

exports.GroupedBar = GroupedBar;

_defineProperty(GroupedBar, "propTypes", {
  actions: _propTypes.default.shape({
    onClick: _propTypes.default.func,
    onMouseOver: _propTypes.default.func,
    onMouseOut: _propTypes.default.func
  }),
  data: _propTypes.default.arrayOf(_propTypes.default.shape({
    offset: _propTypes.default.number,
    showBarValue: _propTypes.default.object,
    values: _propTypes.default.arrayOf(_propTypes.default.shape({
      theme: _propTypes.default.shape({
        id: _propTypes.default.string,
        style: _propTypes.default.object
      }),
      value: _propTypes.default.number.isRequired
    }))
  })),
  id: _propTypes.default.string.isRequired,
  isAnimated: _propTypes.default.bool,
  isHovered: _propTypes.default.bool,
  scale: _propTypes.default.func,
  theme: _propTypes.default.shape({
    default: _propTypes.default.shape({
      fill: _propTypes.default.string,
      width: _propTypes.default.number,
      cursor: _propTypes.default.oneOf(['pointer', 'cursor'])
    }),
    easing: _propTypes.default.shape({
      opacity: _propTypes.default.string,
      x: _propTypes.default.string
    })
  }).isRequired,
  xOffset: _propTypes.default.number,
  yOffset: _propTypes.default.number
});

_defineProperty(GroupedBar, "defaultProps", {
  actions: null,
  data: null,
  isAnimated: true,
  isHovered: false,
  scale: null,
  xOffset: 0,
  yOffset: 0
});

/***/ }),

/***/ "./src/components/Bar/SingleBar.tsx":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./src/components/Svg/Rect.js
var Rect = __webpack_require__("./src/components/Svg/Rect.js");

// EXTERNAL MODULE: ./src/components/Svg/RoundedRect.js
var RoundedRect = __webpack_require__("./src/components/Svg/RoundedRect.js");

// EXTERNAL MODULE: ./src/utils/general/colours.ts
var colours = __webpack_require__("./src/utils/general/colours.ts");

// EXTERNAL MODULE: ./src/utils/general/generateRoundedRectPath.ts
var generateRoundedRectPath = __webpack_require__("./src/utils/general/generateRoundedRectPath.ts");

// CONCATENATED MODULE: ./src/utils/general/getPositiveOrZero.ts
/**
 * Returns positive or 0 given any number
 */
var getPositiveOrZero = function (num) {
    var notANumber = Number.isNaN(num);
    var negativeNumber = num <= 0;
    if (notANumber || negativeNumber) {
        return 0;
    }
    return num;
};

// CONCATENATED MODULE: ./src/components/Bar/SingleBar.tsx
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleBar", function() { return SingleBar_SingleBar; });
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};






var SingleBar_SingleBar = /** @class */ (function (_super) {
    __extends(SingleBar, _super);
    function SingleBar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SingleBar.prototype.getColorShade = function (col) {
        var color = col;
        if (color[0] !== '#') {
            color = Object(colours["d" /* rgbToHex */])(col);
        }
        if (color) {
            return Object(colours["b" /* colourShade */])(color, -0.15);
        }
        return col;
    };
    SingleBar.prototype.getHoverValue = function (styleHoverCol, themeHoverCol) {
        if (styleHoverCol && styleHoverCol !== 'transparent') {
            if (themeHoverCol) {
                return themeHoverCol;
            }
            return this.getColorShade(styleHoverCol);
        }
        return 'transparent';
    };
    /**
     * gets the fill/stroke color for the bar during hover
     * Will use theme hovers if they're available. Will
     * fall back to dimming 15% if they're not
     */
    SingleBar.prototype.getHoverColor = function (style) {
        var theme = this.props.data.theme;
        if (theme) {
            return __assign({}, style, { fill: this.getHoverValue(style.fill, theme.hoverFill), stroke: this.getHoverValue(style.stroke, theme.hoverStroke) });
        }
        return style;
    };
    /**
     * Returns the height of the bar using scale if available
     */
    SingleBar.prototype.getHeight = function (heightValue) {
        var scale = this.props.scale;
        var height = heightValue;
        if (scale) {
            height = scale(heightValue);
        }
        return getPositiveOrZero(height);
    };
    /**
     * Merges bar defined styles with the default / passed in styles
     */
    SingleBar.prototype.getStyles = function () {
        var _a = this.props, data = _a.data, theme = _a.theme;
        var styles = theme["default"];
        // Merge bar theme and prop-provided theme
        if (data && data.theme && data.theme.style) {
            styles = __assign({}, styles, data.theme.style);
        }
        styles = this.addInteractiveStyles(styles);
        return styles;
    };
    /**
     * Returns the y-location of the bar
     */
    SingleBar.prototype.getY = function (barHeight) {
        var yOffset = this.props.yOffset;
        return ((barHeight * -1) + yOffset);
    };
    /**
     * returns the x-location of the bar
     */
    SingleBar.prototype.getX = function (barWidth) {
        var xOffset = this.props.xOffset;
        return ((barWidth / 2) * -1) + xOffset;
    };
    /**
     * @TODO: Finish actions
     * returns the rect actions
     */
    SingleBar.prototype.getActions = function (computedLocation) {
        var _a = this.props, actions = _a.actions, data = _a.data;
        if (!actions) {
            return {};
        }
        var getOnMouseOver = function () {
            if (actions.onMouseOver) {
                return function () { return actions.onMouseOver && actions.onMouseOver(data, computedLocation); };
            }
            return undefined;
        };
        return __assign({}, actions, { onMouseOver: getOnMouseOver() });
    };
    /**
     * returns the props for the rect
     */
    SingleBar.prototype.getProps = function () {
        var _a;
        var _b = this.props, data = _b.data, index = _b.index, isAnimated = _b.isAnimated, isHovered = _b.isHovered;
        var style = this.getStyles();
        var width = style.width;
        var height = this.getHeight(data.value);
        var x = this.getX(style.width);
        var y = this.getY(height);
        /**
         * If the bar is stroked offset the y and height to
         * push it above the bottom axis
         */
        (_a = this.offsetYForStrokeWidth(style.strokeWidth, height, y), height = _a.height, y = _a.y);
        style = this.hideStrokeFromBase(style, width, height);
        if (isHovered) {
            style = this.getHoverColor(style);
        }
        var barProps = {
            actions: this.getActions({
                height: height,
                width: width,
                x: x,
                y: y,
            }),
            key: "single-bar--" + index,
            style: style,
            width: width,
            x: x,
        };
        var rectPoseVals = {
            height: height,
            index: index,
            y: y,
        };
        if (isAnimated) {
            barProps = __assign({}, barProps, { pose: 'pose', poseKey: rectPoseVals.height, rectPoseVals: rectPoseVals });
        }
        else {
            barProps = __assign({}, barProps, rectPoseVals);
        }
        return barProps;
    };
    /**
     * Gets the rect component based on props.
     * This could either be one of four props;
     * - Rect
     * - AnimatedRect
     * - RoundedRect
     * - AnimatedRoundedRect
     */
    SingleBar.prototype.getRectComponent = function (props) {
        var rectProps = props;
        var RectComponent = Rect["Rect"];
        /**
         * If the bar is animated, replace with a pose-animated rect
         */
        if (this.props.isAnimated) {
            RectComponent = Rect["AnimatedRect"];
        }
        /**
         * If bar has rounding, replace it with the rounded bar component
         */
        if (rectProps.style.rounding && rectProps.style.rounding > 0) {
            var heightIsZero = rectProps.rectPoseVals && rectProps.rectPoseVals.height === 0;
            RectComponent = RoundedRect["RoundedRect"];
            rectProps = __assign({}, rectProps, { rounding: rectProps.style.rounding, style: __assign({}, rectProps.style, { strokeWidth: heightIsZero ? 0 : rectProps.style.strokeWidth }) });
            rectProps = __assign({}, rectProps, { d: Object(generateRoundedRectPath["generateRoundedRectPath"])(rectProps) });
            if (this.props.isAnimated) {
                RectComponent = RoundedRect["AnimatedRoundedRect"];
            }
        }
        return {
            RectComponent: RectComponent,
            rectProps: rectProps,
        };
    };
    /**
     * sets the bar cursor based on interactivity
     */
    SingleBar.prototype.addInteractiveStyles = function (theme) {
        var actions = this.props.actions;
        var cursor = 'default';
        if (actions && actions.onClick) {
            cursor = 'pointer';
        }
        return __assign({}, theme, { cursor: cursor });
    };
    /**
     * Transforms the y and height values to take into account
     * the stroke width
     */
    SingleBar.prototype.offsetYForStrokeWidth = function (strokeWidth, heightVal, yVal) {
        var height = heightVal;
        var y = yVal;
        var strokeInt;
        if (typeof strokeWidth === 'string') {
            strokeInt = parseInt(strokeWidth, 10);
        }
        if (typeof strokeWidth === 'number') {
            strokeInt = strokeWidth;
        }
        if (strokeInt && strokeInt > 0) {
            var strokedTransform = strokeInt;
            height = getPositiveOrZero(height - strokedTransform);
            y += getPositiveOrZero((strokedTransform / 2));
        }
        return { height: height, y: y };
    };
    /**
     * Hides the stroke from the bottom of the bar if its
     * index is more than 0.
     * If index is more than 0 it's implied that it's stacked
     * and is *not* at the bottom of the stack
     */
    // tslint:disable-next-line
    SingleBar.prototype.hideStrokeFromBase = function (s, width, height) {
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        var index = this.props.index;
        var style = s;
        // Ensures the dashed line stops at the bottom of the right hand border
        // otherwise it can overhang
        var calculateDashArray = function (_a) {
            var strokeDashArray = _a.strokeDashArray, strokeLineLength = _a.strokeLineLength, topAndRightLength = _a.topAndRightLength, bottomLength = _a.bottomLength;
            var lineLength = strokeLineLength;
            return strokeDashArray
                .map(function (da) {
                var daLength = da;
                // Conditionals to tell if the line is either longer than top right or longer than the
                // top right AND bottom border lengths combined
                var lineLongerThanTopAndRight = (lineLength + da) > topAndRightLength;
                var lineLongerThanTopRightBottom = (lineLength + da) > bottomLength;
                // If the line is within the bottom area switch to 1px spacing, this will force it
                // to switch to blank before it's noticable
                if (lineLongerThanTopAndRight && !lineLongerThanTopRightBottom) {
                    daLength = 1;
                }
                lineLength += daLength;
                return daLength;
            });
        };
        // Creates a dashed stroke top, right, left. No bottom.
        var createStroke = function (strokeDashArray) {
            // Max length of the stroke line
            var maxStrokeLength = (height * 2) + (width * 2);
            // Current length of the stroke line
            var strokeLineLength = 0;
            var dashArray = [];
            // Lengths of top+right border and top+right+bottom border
            var topAndRightLength = (width + height);
            var bottomLength = topAndRightLength + width;
            // While our stroke line is less than the border length of the bar
            // tslint:disable
            while (strokeLineLength <= maxStrokeLength) {
                strokeLineLength = dashArray.reduce(function (acc, d) { return acc + d; }, 0);
                if (strokeLineLength > topAndRightLength && strokeLineLength < bottomLength) {
                    dashArray.push(0); // Line width is 0
                    dashArray.push(width); // Space width is the full width of the bar (to create an empty bottom border)
                }
                else {
                    var strokedLine = calculateDashArray({
                        strokeDashArray: strokeDashArray,
                        strokeLineLength: strokeLineLength,
                        topAndRightLength: topAndRightLength,
                        bottomLength: bottomLength,
                    });
                    strokedLine.forEach(function (da) { return dashArray.push(da); });
                }
            }
            // tslint:enable
            return dashArray;
        };
        if (style.stroke && style.strokeDasharray && index !== 0) {
            // Regex the dashArray value
            var pxRegex = /(\dpx)/gm;
            var match = pxRegex.exec(style.strokeDasharray);
            if (Array.isArray(match) && match.length) {
                var strokeDashArray = match.map(function (m) { return parseInt(m, 10); });
                var dashArray = createStroke(strokeDashArray);
                // Overwrite strokedasharray value to explicitly define each stroke/gap width
                var strokeDashArrayString = dashArray.map(function (distance) { return distance + "px"; }).join(' ');
                // tslint:disable-next-line
                style.strokeDasharray = strokeDashArrayString;
            }
        }
        return style;
    };
    SingleBar.prototype.render = function () {
        var _a = this.getRectComponent(this.getProps()), rectProps = _a.rectProps, RectComponent = _a.RectComponent;
        return (react_default.a.createElement(RectComponent, __assign({}, rectProps)));
    };
    SingleBar.defaultProps = {
        actions: undefined,
        hostRef: undefined,
        index: 0,
        isAnimated: true,
        isHovered: false,
        isInteractive: true,
        scale: undefined,
        xOffset: 0,
        yOffset: 0,
    };
    return SingleBar;
}(react_default.a.Component));



/***/ }),

/***/ "./src/components/Bar/StackedBar.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StackedBar = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

var _reactPose = _interopRequireWildcard(__webpack_require__("./node_modules/react-pose/lib/index.js"));

var _SingleBar = __webpack_require__("./src/components/Bar/SingleBar.tsx");

var _BarValueHelper = __webpack_require__("./src/components/Helpers/BarValueHelper/index.ts");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var StackGroup = _reactPose.default.g({
  pose: {
    y: function y(_ref) {
      var barYOffset = _ref.barYOffset;
      return barYOffset;
    },
    transition: {
      easing: 'linear',
      duration: 200
    }
  }
});

var StackedBar =
/*#__PURE__*/
function (_React$Component) {
  _inherits(StackedBar, _React$Component);

  function StackedBar() {
    _classCallCheck(this, StackedBar);

    return _possibleConstructorReturn(this, _getPrototypeOf(StackedBar).apply(this, arguments));
  }

  _createClass(StackedBar, [{
    key: "getBarsTheme",
    value: function getBarsTheme(index, stackLength) {
      var theme = this.props.theme;
      var barTheme = theme;

      if (index !== stackLength - 1) {
        barTheme = this.removeRounding(barTheme);
      }

      return barTheme;
    }
    /**
     * Sets rounding on the bar to 0
     * @param {object} theme
     * @returns {object} // returns modified theme
     */

  }, {
    key: "removeRounding",
    value: function removeRounding(theme) {
      return _objectSpread({}, theme, {
        default: _objectSpread({}, theme.default, {
          rounding: 0
        })
      });
    }
    /**
     * Calculates the y-offset of a specific bar
     * in the stack
     * @param {object} stack
     * @param {number} currentIndex The index of the bar you'd like to finds y value
     * @returns {number}
     */

  }, {
    key: "calculateYOffset",
    value: function calculateYOffset(stack, currentIndex) {
      var scale = this.props.scale;
      return stack.reduce(function (acc, el, index) {
        var offset = acc;

        if (index <= currentIndex && stack[index - 1]) {
          var prev = stack[index - 1];

          if (scale) {
            offset += scale(prev.value);
          } else {
            offset += prev.value;
          }
        }

        return offset;
      }, 0);
    }
  }, {
    key: "renderBarValueHelper",
    value: function renderBarValueHelper() {
      var _this$props = this.props,
          data = _this$props.data,
          yOffset = _this$props.yOffset,
          scale = _this$props.scale,
          showBarValue = _this$props.showBarValue;

      if (!showBarValue || showBarValue.isVisible === false) {
        return null;
      }

      return _react.default.createElement(_BarValueHelper.BarValueHelper, {
        data: data,
        yOffset: yOffset,
        scale: scale,
        labelAttrs: showBarValue.attrs,
        labelStyle: showBarValue.style
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var _this$props2 = this.props,
          actions = _this$props2.actions,
          data = _this$props2.data,
          id = _this$props2.id,
          isAnimated = _this$props2.isAnimated,
          isHovered = _this$props2.isHovered,
          scale = _this$props2.scale,
          xOffset = _this$props2.xOffset,
          yOffset = _this$props2.yOffset;
      var commonStackedBarProps = {
        actions: actions,
        isAnimated: isAnimated,
        isHovered: isHovered,
        id: id,
        scale: scale,
        xOffset: xOffset
      };

      if (!isAnimated) {
        return _react.default.createElement("g", null, this.renderBarValueHelper(), data.map(function (barVals, index) {
          var barYOffset = yOffset - _this.calculateYOffset(data, index);

          return _react.default.createElement(_SingleBar.SingleBar, _extends({
            key: "".concat(id, "-stack-").concat(index)
          }, commonStackedBarProps, {
            data: barVals,
            index: index,
            theme: _this.getBarsTheme(index, data.length),
            yOffset: barYOffset
          }));
        }));
      }

      return _react.default.createElement(_reactPose.PoseGroup, null, data.map(function (barVals, index) {
        var barYOffset = yOffset - _this.calculateYOffset(data, index);

        var id = barVals && barVals.theme ? barVals.theme.id : id;
        return _react.default.createElement(StackGroup, {
          pose: "pose",
          poseKey: ['pose'],
          barYOffset: barYOffset,
          key: "".concat(id, "-stack-").concat(index)
        }, _this.renderBarValueHelper(), _react.default.createElement(_SingleBar.SingleBar, _extends({
          key: "".concat(id, "-stack-").concat(index, "--child")
        }, commonStackedBarProps, {
          data: barVals,
          index: index,
          theme: _this.getBarsTheme(index, data.length)
        })));
      }));
    }
  }]);

  return StackedBar;
}(_react.default.Component);

exports.StackedBar = StackedBar;

_defineProperty(StackedBar, "propTypes", {
  actions: _propTypes.default.shape({
    onClick: _propTypes.default.func,
    onMouseOver: _propTypes.default.func,
    onMouseOut: _propTypes.default.func
  }),
  data: _propTypes.default.arrayOf(_propTypes.default.shape({
    theme: _propTypes.default.shape({
      id: _propTypes.default.string,
      style: _propTypes.default.object
    }),
    value: _propTypes.default.number.isRequired
  })),
  id: _propTypes.default.string.isRequired,
  isAnimated: _propTypes.default.bool,
  isHovered: _propTypes.default.bool,
  scale: _propTypes.default.func,
  showBarValue: _propTypes.default.bool,
  theme: _propTypes.default.shape({
    default: _propTypes.default.shape({
      fill: _propTypes.default.string,
      width: _propTypes.default.number,
      cursor: _propTypes.default.oneOf(['pointer', 'cursor'])
    }),
    easing: _propTypes.default.shape({
      opacity: _propTypes.default.string,
      x: _propTypes.default.string
    })
  }).isRequired,
  xOffset: _propTypes.default.number,
  yOffset: _propTypes.default.number
});

_defineProperty(StackedBar, "defaultProps", {
  actions: null,
  data: null,
  isHovered: false,
  isAnimated: true,
  scale: null,
  showBarValue: false,
  xOffset: 0,
  yOffset: 0
  /**
   * Gets the bar theme, removing rounding from all but the top bar
   * @param {number} index
   * @param {number} stackLength
   */

});

/***/ }),

/***/ "./src/components/Bar/index.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./src/components/Bar/GroupedBar.js
var GroupedBar = __webpack_require__("./src/components/Bar/GroupedBar.js");

// EXTERNAL MODULE: ./src/components/Bar/SingleBar.tsx + 1 modules
var SingleBar = __webpack_require__("./src/components/Bar/SingleBar.tsx");

// EXTERNAL MODULE: ./src/components/Bar/StackedBar.js
var StackedBar = __webpack_require__("./src/components/Bar/StackedBar.js");

// CONCATENATED MODULE: ./src/components/Bar/Bar.tsx
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};




var Bar_Bar = /** @class */ (function (_super) {
    __extends(Bar, _super);
    function Bar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Bar.prototype.render = function () {
        var _a = this.props, actions = _a.actions, group = _a.group, id = _a.id, isAnimated = _a.isAnimated, isHovered = _a.isHovered, scale = _a.scale, showBarValue = _a.showBarValue, theme = _a.theme, value = _a.value, values = _a.values, xOffset = _a.xOffset, yOffset = _a.yOffset;
        var commonBarProps = {
            actions: actions,
            id: id,
            isAnimated: isAnimated,
            isHovered: isHovered,
            key: id,
            scale: scale,
            showBarValue: showBarValue,
            theme: theme.bars,
            xOffset: xOffset,
            yOffset: yOffset,
        };
        if (group) {
            return (react_default.a.createElement(GroupedBar["GroupedBar"], __assign({}, commonBarProps, { data: group })));
        }
        if (values) {
            return (react_default.a.createElement(StackedBar["StackedBar"], __assign({}, commonBarProps, { data: values })));
        }
        if (value) {
            var data = value;
            if (typeof value === 'number') {
                data = { value: value };
            }
            return (react_default.a.createElement(SingleBar["SingleBar"], __assign({}, commonBarProps, { data: data })));
        }
        return null;
    };
    Bar.defaultProps = {
        isAnimated: true,
        isHovered: false,
        scale: undefined,
        value: undefined,
        values: undefined,
        xOffset: 0,
        yOffset: 0,
    };
    return Bar;
}(react_default.a.Component));


// CONCATENATED MODULE: ./src/components/Bar/index.ts
/* concated harmony reexport Bar */__webpack_require__.d(__webpack_exports__, "Bar", function() { return Bar_Bar; });



/***/ }),

/***/ "./src/components/Bars/Bars.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bars = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

var _reactPose = _interopRequireWildcard(__webpack_require__("./node_modules/react-pose/lib/index.js"));

var _Bar = __webpack_require__("./src/components/Bar/index.ts");

var _Helpers = __webpack_require__("./src/components/Helpers/index.js");

var _SlideController = __webpack_require__("./src/components/SlideController/index.ts");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var emptyGroup = {
  group: [{
    values: [{
      value: 0
    }, {
      value: 0
    }, {
      value: 0
    }, {
      value: 0
    }]
  }, {
    values: [{
      value: 0
    }, {
      value: 0
    }, {
      value: 0
    }, {
      value: 0
    }]
  }]
};
var emptyValues = {
  values: [{
    value: 0
  }, {
    value: 0
  }, {
    value: 0
  }, {
    value: 0
  }, {
    value: 0
  }]
};

var AnimateXYBarGroup = _reactPose.default.g({
  pose: {
    opacity: 1,
    x: function x(_ref) {
      var barGroupPoseVals = _ref.barGroupPoseVals;
      return barGroupPoseVals.x;
    },
    y: function y(_ref2) {
      var barGroupPoseVals = _ref2.barGroupPoseVals;
      return barGroupPoseVals.y;
    },
    transition: {
      x: {
        type: 'spring',
        stiffness: 210,
        damping: 20
      },
      y: {
        easing: 'linear',
        duration: 200
      },
      opacity: {
        duration: 200,
        ease: 'easeIn'
      }
    }
  },
  exit: {
    x: function x(_ref3) {
      var barGroupPoseVals = _ref3.barGroupPoseVals;
      var offsetDistance = 200;
      var index = barGroupPoseVals.index,
          dataLength = barGroupPoseVals.dataLength;

      if (index > dataLength / 2) {
        return barGroupPoseVals.maxX + offsetDistance;
      }

      return barGroupPoseVals.minX - offsetDistance;
    },
    opacity: 0,
    transition: {
      x: {
        type: 'spring',
        stiffness: 210,
        damping: 20
      },
      opacity: {
        duration: 200,
        ease: 'easeOut'
      }
    }
  }
});

var AnimateYBarGroup = _reactPose.default.g({
  pose: {
    x: function x(_ref4) {
      var barGroupPoseVals = _ref4.barGroupPoseVals;
      return barGroupPoseVals.x;
    },
    y: function y(_ref5) {
      var barGroupPoseVals = _ref5.barGroupPoseVals;
      return barGroupPoseVals.y;
    },
    transition: {
      x: {
        duration: 0
      },
      y: {
        duration: 0
      }
    }
  }
});

var StaticBarGroup = _reactPose.default.g({
  static: {
    x: function x(_ref6) {
      var poseVal = _ref6.poseVal;
      return poseVal.x;
    },
    y: function y(_ref7) {
      var poseVal = _ref7.poseVal;
      return poseVal.y;
    }
  }
});

var Bars =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Bars, _React$Component);

  function Bars(props) {
    var _this;

    _classCallCheck(this, Bars);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Bars).call(this, props));
    _this.state = {
      hovered: false
    };
    _this.renderBar = _this.renderBar.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Bars, [{
    key: "getBarActions",
    value: function getBarActions(barData, groupLocation, index) {
      var _this2 = this;

      var id = barData.id;
      var actions = this.props.actions;

      var barAction = _objectSpread({}, actions, barData.actions);

      var onMouseOver = function onMouseOver(data, location) {
        _this2.setState(function (prevState) {
          return _objectSpread({}, prevState, {
            hovered: id
          });
        });

        barAction.onMouseOver({
          data: _objectSpread({}, data, {
            id: id,
            x: index
          }),
          groupLocation: groupLocation,
          location: location,
          id: id
        });
      };

      var onMouseOut = function onMouseOut() {
        _this2.setState(function (prevState) {
          return _objectSpread({}, prevState, {
            hovered: false
          });
        });

        barAction.onMouseOut({
          // location,
          id: id
        });
      };

      var onClick = function onClick() {
        barAction.onClick({
          // location,
          id: id
        });
      };

      var barActions = {};

      if (barAction.onMouseOver) {
        barActions.onMouseOver = onMouseOver;
      }

      if (barAction.onMouseOut) {
        barActions.onMouseOut = onMouseOut;
      }

      if (barAction.onClick) {
        barActions.onClick = onClick;
      }

      return barActions;
    }
  }, {
    key: "renderHighlightBar",
    value: function renderHighlightBar(barData) {
      var _this$props = this.props,
          activeInnerArea = _this$props.activeInnerArea,
          helper = _this$props.helper,
          theme = _this$props.theme;

      if (helper && helper.highlight) {
        return _react.default.createElement(_Helpers.HighlightBarHelper, {
          activeInnerArea: activeInnerArea,
          data: barData,
          theme: theme,
          helper: helper.highlight
        });
      }

      return null;
    }
  }, {
    key: "renderBar",
    value: function renderBar(barData, index) {
      var _this$props2 = this.props,
          activeInnerArea = _this$props2.activeInnerArea,
          data = _this$props2.data,
          isAnimated = _this$props2.isAnimated,
          isAnimatedX = _this$props2.isAnimatedX,
          theme = _this$props2.theme;
      var xRange = activeInnerArea.scales.x.range();
      var groupLocation = {
        x: activeInnerArea.scales.x(index),
        y: activeInnerArea.top + activeInnerArea.height
      };
      var barGroupProps = {
        key: barData.id,
        pose: 'pose',
        poseKey: ['pose'],
        barGroupPoseVals: {
          minX: xRange[0],
          x: groupLocation.x,
          maxX: xRange[1],
          y: groupLocation.y,
          index: index,
          dataLength: data.length
        }
      };
      var barProps = {
        actions: this.getBarActions(barData, groupLocation, index),
        group: barData.group,
        key: barData.id,
        id: barData.id,
        isAnimated: isAnimated,
        isHovered: this.state.hovered === barData.id,
        scale: activeInnerArea.scales.y,
        showBarValue: barData.showBarValue,
        theme: theme,
        value: barData.value,
        values: barData.values
      };

      if (isAnimated && isAnimatedX) {
        return _react.default.createElement(AnimateXYBarGroup, barGroupProps, this.renderHighlightBar(barData), _react.default.createElement(_reactPose.PoseGroup, {
          animateOnMount: true,
          key: barData.id
        }, _react.default.createElement(_Bar.Bar, barProps)));
      }

      if (isAnimated) {
        return _react.default.createElement(_reactPose.PoseGroup, {
          animateOnMount: true,
          key: barData.id
        }, _react.default.createElement(AnimateYBarGroup, _extends({
          key: barProps.key
        }, barGroupProps), this.renderHighlightBar(barData), _react.default.createElement(_Bar.Bar, barProps)));
      }

      return _react.default.createElement(StaticBarGroup, {
        key: barData.id,
        pose: "static",
        poseKey: ['static'],
        poseVal: barGroupProps.barGroupPoseVals
      }, this.renderHighlightBar(barData), _react.default.createElement(_Bar.Bar, barProps));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          columns = _this$props3.columns,
          data = _this$props3.data,
          isAnimated = _this$props3.isAnimated,
          isAnimatedX = _this$props3.isAnimatedX,
          slideProps = _this$props3.slideProps;
      if (!columns || !data) return null;
      var xOffset = 0;
      var clipPathProps;

      if (slideProps && !slideProps.isDisabled) {
        xOffset = slideProps.offset;
        clipPathProps = {
          clipPath: 'url(#mask)'
        };
      }

      var animateSlideOffsetProps = {
        pose: 'pose',
        poseKey: xOffset,
        xOffset: xOffset
      };
      var barData = columns.map(function (col) {
        var colData = data && data.find(function (d) {
          return d.id === col.id;
        });
        var emptyData = 0;

        if (data[0].values) {
          emptyData = emptyValues;
        }

        if (data[0].group) {
          emptyData = emptyGroup;
        }

        var barData = _objectSpread({}, emptyData, colData);

        return _objectSpread({
          id: col.id
        }, barData);
      });

      if (isAnimated && isAnimatedX) {
        return _react.default.createElement("g", clipPathProps, _react.default.createElement(_SlideController.AnimateSlideOffset, animateSlideOffsetProps, _react.default.createElement(_reactPose.PoseGroup, null, barData.map(this.renderBar))));
      }

      return _react.default.createElement("g", clipPathProps, _react.default.createElement(_SlideController.AnimateSlideOffset, animateSlideOffsetProps, barData.map(this.renderBar)));
    }
  }]);

  return Bars;
}(_react.default.Component);

exports.Bars = Bars;

_defineProperty(Bars, "propTypes", {
  actions: _propTypes.default.shape({
    onMouseOver: _propTypes.default.func,
    onMouseOut: _propTypes.default.func,
    onClick: _propTypes.default.func
  }),
  activeInnerArea: _propTypes.default.shape({
    top: _propTypes.default.number.isRequired,
    height: _propTypes.default.number.isRequired,
    width: _propTypes.default.number.isRequired,
    scales: _propTypes.default.shape({
      x: _propTypes.default.func.isRequired,
      y: _propTypes.default.func
    }).isRequired
  }).isRequired,
  animationOffsetDistance: _propTypes.default.number,
  columns: _propTypes.default.array,
  data: _propTypes.default.array,
  isAnimated: _propTypes.default.bool,
  isAnimatedX: _propTypes.default.bool,
  helper: _propTypes.default.shape({
    highlight: _propTypes.default.shape({
      show: _propTypes.default.bool,
      callback: _propTypes.default.func
    })
  }),
  rounded: _propTypes.default.number,
  theme: _propTypes.default.object.isRequired // SHAPE

});

_defineProperty(Bars, "defaultProps", {
  actions: {
    onMouseOver: null,
    onMouseOut: null,
    onClick: null
  },
  animationOffsetDistance: 2,
  columns: [],
  data: [],
  helper: null,
  isAnimated: true,
  isAnimatedX: false,
  rounded: undefined
});

/***/ }),

/***/ "./src/components/Bars/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Bars", {
  enumerable: true,
  get: function get() {
    return _Bars.Bars;
  }
});

var _Bars = __webpack_require__("./src/components/Bars/Bars.js");

/***/ }),

/***/ "./src/components/Helpers/AreaPointsHelper/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AreaPointsHelper = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

var _lodash = _interopRequireDefault(__webpack_require__("./node_modules/lodash.merge/index.js"));

var _lodash2 = _interopRequireDefault(__webpack_require__("./node_modules/lodash.isobject/index.js"));

var _reactPose = __webpack_require__("./node_modules/react-pose/lib/index.js");

var _index = __webpack_require__("./src/components/index.ts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var AreaPointsHelper =
/*#__PURE__*/
function (_React$Component) {
  _inherits(AreaPointsHelper, _React$Component);

  function AreaPointsHelper() {
    _classCallCheck(this, AreaPointsHelper);

    return _possibleConstructorReturn(this, _getPrototypeOf(AreaPointsHelper).apply(this, arguments));
  }

  _createClass(AreaPointsHelper, [{
    key: "renderHelper",
    value: function renderHelper() {
      if (!this.props.area) {
        return null;
      }

      var _this$props = this.props,
          helper = _this$props.helper,
          helperTheme = _this$props.helperTheme,
          animation = _this$props.animation,
          area = _this$props.area;
      var areaPathPoints = area.data.map(function (set) {
        var areaId = set.id;
        return set.data.map(function (point, index) {
          // Allow callback for dots helper to support custom styling or show/hide dots

          /*
            Points helper callback
            @param {string} areaId - parent ID of a point
            @param {string} id - ID of a point
            @returns {(boolean|Object)} Returns a true or false or an Object.
            true - renders all points
            false - hides all points
            Object - custom styling of a point or points
          */
          var dotsStylesOverWrite = (0, _lodash.default)({}, helperTheme, set.styles);

          if (typeof helper.callback === 'function') {
            var helperStylesOverwrite = helper.callback(areaId, point.key);

            if ((0, _lodash2.default)(helperStylesOverwrite) || typeof helperStylesOverwrite === 'boolean') {
              if (typeof helperStylesOverwrite === 'boolean') {
                if (!helperStylesOverwrite) {
                  return null;
                }
              } else if ((0, _lodash2.default)(helperStylesOverwrite)) {
                var callbackStyle = (0, _lodash.default)({}, dotsStylesOverWrite.helpers.area.points, helperStylesOverwrite);
                dotsStylesOverWrite = _objectSpread({}, dotsStylesOverWrite, {
                  helpers: {
                    area: _objectSpread({}, dotsStylesOverWrite.helpers, {
                      points: callbackStyle
                    })
                  }
                });
              }
            } else {
              throw new Error('Returned value needs to be a valid object or a boolean');
            }
          }

          var dotProps = {
            cx: point.style.x,
            cy: point.style.y0,
            r: dotsStylesOverWrite.helpers.area.points.radius,
            opacity: dotsStylesOverWrite.helpers.area.points.opacity,
            style: dotsStylesOverWrite.helpers.area.points
          };

          var animatedDotProps = _objectSpread({}, dotProps, {
            key: index,
            poseKey: dotProps,
            dotsVal: _objectSpread({}, dotProps, {
              index: index
            })
          });

          if (animation.animate) {
            return _react.default.createElement(_index.AnimatedCircle, animatedDotProps);
          }

          return _react.default.createElement(_index.Circle, dotProps);
        });
      });

      if (animation.animate) {
        return _react.default.createElement(_reactPose.PoseGroup, {
          animateOnMount: true
        }, areaPathPoints);
      }

      return _react.default.createElement(_index.Group, null, areaPathPoints);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          helper = _this$props2.helper,
          area = _this$props2.area;

      if (!helper.show) {
        return null;
      }

      return _react.default.createElement(_index.Group, {
        id: "areapoints-".concat(area.id)
      }, this.renderHelper());
    }
  }]);

  return AreaPointsHelper;
}(_react.default.Component);

exports.AreaPointsHelper = AreaPointsHelper;

_defineProperty(AreaPointsHelper, "propTypes", {
  animation: _propTypes.default.object.isRequired,
  area: _propTypes.default.object.isRequired,
  helper: _propTypes.default.object.isRequired,
  helperTheme: _propTypes.default.object.isRequired
});

_defineProperty(AreaPointsHelper, "defaultProps", {});

/***/ }),

/***/ "./src/components/Helpers/BarValueHelper/index.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// CONCATENATED MODULE: ./src/components/Helpers/BarValueHelper/BarValueHelper.tsx
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var defaultLabelStyle = {
    fontSize: '16px',
    fontWeight: 'bold',
    textAnchor: 'middle',
};
var BarValueHelper_BarValueHelper = /** @class */ (function (_super) {
    __extends(BarValueHelper, _super);
    function BarValueHelper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BarValueHelper.prototype.getStackedLabel = function () {
        var data = this.props.data;
        var labelVal = data.reduce(function (val, datum) { return val + datum.value; }, 0);
        if (labelVal === 0) {
            return '';
        }
        return "" + labelVal;
    };
    BarValueHelper.prototype.getStackedOffset = function () {
        var _a = this.props, data = _a.data, marginBottom = _a.marginBottom, scale = _a.scale, yOffset = _a.yOffset;
        var offset = data.reduce(function (offset, datum) {
            return offset - scale(datum.value);
        }, yOffset);
        return offset - marginBottom;
    };
    BarValueHelper.prototype.render = function () {
        var style = __assign({}, defaultLabelStyle, this.props.labelStyle);
        return (react_default.a.createElement("text", __assign({ style: style, y: this.getStackedOffset() }, this.props.labelAttrs), this.getStackedLabel()));
    };
    BarValueHelper.defaultProps = {
        labelAttrs: {},
        labelStyle: defaultLabelStyle,
        marginBottom: 8,
    };
    return BarValueHelper;
}(react_default.a.Component));


// CONCATENATED MODULE: ./src/components/Helpers/BarValueHelper/index.ts
/* concated harmony reexport BarValueHelper */__webpack_require__.d(__webpack_exports__, "BarValueHelper", function() { return BarValueHelper_BarValueHelper; });



/***/ }),

/***/ "./src/components/Helpers/HighlightBarHelper/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HighlightBarHelper = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

var _lodash = _interopRequireDefault(__webpack_require__("./node_modules/lodash.isobject/index.js"));

var _Svg = __webpack_require__("./src/components/Svg/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var HighlightBarHelper =
/*#__PURE__*/
function (_React$Component) {
  _inherits(HighlightBarHelper, _React$Component);

  function HighlightBarHelper() {
    _classCallCheck(this, HighlightBarHelper);

    return _possibleConstructorReturn(this, _getPrototypeOf(HighlightBarHelper).apply(this, arguments));
  }

  _createClass(HighlightBarHelper, [{
    key: "renderHelper",
    value: function renderHelper() {
      var _this$props = this.props,
          data = _this$props.data,
          activeInnerArea = _this$props.activeInnerArea,
          theme = _this$props.theme,
          helper = _this$props.helper;
      var bars = theme.bars;
      var width = theme.bars.default.width; // Group of Bars

      if (data.group !== undefined) {
        var offsets = data.group.map(function (v) {
          var defaultWidth = theme.bars.default.width;
          var widths = v.values.map(function (value) {
            // Overwrite theme if there is any
            if (value.theme) {
              if (value.theme.style) {
                var styling = value.theme.style;
                var barStyle = Object.assign({}, bars.default, styling);
                return barStyle.width;
              }
            }

            return defaultWidth;
          }); // Returns 0 offset if nothing is defined, in case needed for calculations
          // if there is a series of bars (stacked), get the widest bar (unlikely but just to be safe)

          return {
            offset: !v.offset ? 0 : v.offset,
            width: widths.length > 0 ? Math.max.apply(Math, _toConsumableArray(widths)) : defaultWidth
          };
        }); // Find the widest width

        var maxWidth = Math.max.apply(Math, offsets.map(function (v) {
          return v.width;
        })); // Find the offsets furthest away from center (-ve and +ve) and get the objects' widths and offsets

        var calculateOffsetMixMax = function calculateOffsetMixMax(arr) {
          var minOffset = Math.min.apply(Math, arr.map(function (v) {
            return v.offset;
          }));
          var maxOffset = Math.max.apply(Math, arr.map(function (v) {
            return v.offset;
          }));
          var minOffsetObject = arr.find(function (v) {
            return v.offset === minOffset;
          });
          var maxOffsetObject = arr.find(function (v) {
            return v.offset === maxOffset;
          });
          var min = 0;
          var max = 0;

          if (minOffset < 0) {
            min = minOffsetObject.width / 2 + Math.abs(minOffsetObject.offset);
          }

          if (maxOffset > 0) {
            max = maxOffsetObject.width / 2 + Math.abs(maxOffsetObject.offset);
          }

          return {
            offsets: {
              min: minOffset,
              max: maxOffset
            },
            width: min + max
          };
        };

        var minMaxOffsets = calculateOffsetMixMax(offsets); // If there is at least one offset, use the largest offset bar width
        // Limitation: this may not be ideal if some smaller offset has wider bars

        if (offsets.some(function (v) {
          return v.offset !== 0;
        })) {
          width = minMaxOffsets.width;
        } else {
          // If there is no offset, use the widest width to fit in
          width = maxWidth;
        }
      } // @TODO Limitations: This is making an assumption the offsets are always balanced on left and right of the bar.
      // e.g. If both widths are 20 and offsets are -15 and 20 respectively, the highlight bar will not aligned and fit


      var highlightBarProps = {
        width: width,
        height: activeInnerArea.height,
        y: -1 * activeInnerArea.height,
        x: -1 * (width / 2)
      };
      var defaultBarStyles = {
        fill: theme.helpers.bar.highlight.bar.fill,
        opacity: theme.helpers.bar.highlight.bar.opacity,
        style: {
          mixBlendMode: 'multiply'
        }
      };
      var defaultBorderStyles = {
        fill: theme.helpers.bar.highlight.border.fill,
        opacity: theme.helpers.bar.highlight.border.opacity,
        height: theme.helpers.bar.highlight.border.height
      };
      var overwriteBarStyles = {};
      var overwriteBorderStyles = {};
      var isHighlight = true; // Callback

      if (typeof helper.callback === 'function') {
        var helperStylesOverwrite = helper.callback(data);

        if ((0, _lodash.default)(helperStylesOverwrite) || typeof helperStylesOverwrite === 'boolean') {
          if (!helperStylesOverwrite) {
            isHighlight = false;
          }

          if (helperStylesOverwrite.styles) {
            overwriteBarStyles = helperStylesOverwrite.styles.bar ? helperStylesOverwrite.styles.bar : {};
            overwriteBorderStyles = helperStylesOverwrite.styles.border ? helperStylesOverwrite.styles.border : {};
          }
        } else {
          isHighlight = false;
          throw new Error('Returned value needs to be a valid object');
        }
      }

      var barProps = Object.assign({}, highlightBarProps, defaultBarStyles, overwriteBarStyles);
      var borderProps = Object.assign({}, {
        width: highlightBarProps.width
      }, {
        height: theme.helpers.bar.highlight.border.height
      }, {
        x: highlightBarProps.x
      }, {
        y: highlightBarProps.y
      }, defaultBorderStyles, overwriteBorderStyles);
      return isHighlight && _react.default.createElement(_Svg.Group, null, _react.default.createElement("rect", barProps), _react.default.createElement("rect", borderProps));
    }
  }, {
    key: "render",
    value: function render() {
      var helper = this.props.helper;

      if (!helper.show) {
        return null;
      }

      return this.renderHelper();
    }
  }]);

  return HighlightBarHelper;
}(_react.default.Component);

exports.HighlightBarHelper = HighlightBarHelper;

_defineProperty(HighlightBarHelper, "propTypes", {
  activeInnerArea: _propTypes.default.object.isRequired,
  data: _propTypes.default.object.isRequired,
  theme: _propTypes.default.object,
  highlightBar: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.object]),
  helper: _propTypes.default.object
});

_defineProperty(HighlightBarHelper, "defaultProps", {
  theme: {}
});

/***/ }),

/***/ "./src/components/Helpers/HighlightHelper/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HighlightHelper = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var HighlightHelper =
/*#__PURE__*/
function (_React$Component) {
  _inherits(HighlightHelper, _React$Component);

  function HighlightHelper() {
    _classCallCheck(this, HighlightHelper);

    return _possibleConstructorReturn(this, _getPrototypeOf(HighlightHelper).apply(this, arguments));
  }

  _createClass(HighlightHelper, [{
    key: "renderHelper",
    value: function renderHelper() {
      var _this$props = this.props,
          helper = _this$props.helper,
          columns = _this$props.columns,
          helperTheme = _this$props.helperTheme,
          activeInnerArea = _this$props.activeInnerArea;
      var scales = activeInnerArea.scales,
          height = activeInnerArea.height,
          top = activeInnerArea.top;
      var offset = helper.offset;
      var startIndex = columns.findIndex(function (v) {
        return v.id === helper.start;
      });
      var endIndex = columns.findIndex(function (v) {
        return v.id === helper.end;
      });
      var startOffsetIndex = columns.findIndex(function (v) {
        return v.id === offset.min;
      });
      var endOffsetIndex = columns.findIndex(function (v) {
        return v.id === offset.max;
      });
      var highlightWidth = typeof helper.width === 'undefined' ? -1 : helper.width;

      if (startIndex < 0 || endIndex < 0) {
        return null;
      }

      var xStartLoc = scales.x(startIndex);
      var xEndLoc = scales.x(endIndex);
      var xStartOffsetLoc = typeof offset.min === 'undefined' ? 0 : scales.x(startOffsetIndex);
      var xEndOffsetLoc = typeof offset.max === 'undefined' ? 0 : scales.x(endOffsetIndex);
      var xStartPortion = xStartOffsetLoc === 0 ? 0 : Math.abs(xStartLoc - xStartOffsetLoc) / 2;
      var xEndPortion = xEndOffsetLoc === 0 ? 0 : Math.abs(xEndOffsetLoc - xEndLoc) / 2;
      var portionWidth = xEndLoc + xStartPortion + xEndPortion;
      var width = portionWidth - xStartLoc;
      var x = xStartLoc - xStartPortion;
      /*
        Allow manual definition of width, only if the start index and end index are the same.
      */

      if (highlightWidth > 0 && startIndex !== endIndex) {
        throw new Error('If you wish to use width, the start and end has to be the same');
      }

      if (highlightWidth > 0 && startIndex === endIndex) {
        width = highlightWidth;
        x = highlightWidth === 1 ? xStartLoc : xStartLoc - highlightWidth / 2;
      }

      var highlightProps = {
        width: width,
        height: height,
        x: x,
        y: top,
        fill: helperTheme.helpers.area.highlight.fill,
        opacity: helperTheme.helpers.area.highlight.opacity,
        stroke: helperTheme.helpers.area.highlight.stroke,
        strokeWidth: helperTheme.helpers.area.highlight.strokeWidth,
        style: {
          pointerEvents: 'none',
          mixBlendMode: 'multiply'
        }
      };
      return _react.default.createElement("rect", highlightProps);
    }
  }, {
    key: "render",
    value: function render() {
      var helper = this.props.helper;

      if (!helper.show) {
        return null;
      }

      return this.renderHelper();
    }
  }]);

  return HighlightHelper;
}(_react.default.Component);

exports.HighlightHelper = HighlightHelper;

_defineProperty(HighlightHelper, "propTypes", {
  activeInnerArea: _propTypes.default.object.isRequired,
  animation: _propTypes.default.object.isRequired,
  columns: _propTypes.default.array.isRequired,
  helper: _propTypes.default.object.isRequired,
  helperTheme: _propTypes.default.object.isRequired
});

_defineProperty(HighlightHelper, "defaultProps", {});

/***/ }),

/***/ "./src/components/Helpers/VerticalLocationHelper/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalLocationHelper = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

var _lodash = _interopRequireDefault(__webpack_require__("./node_modules/lodash.isobject/index.js"));

var _lodash2 = _interopRequireDefault(__webpack_require__("./node_modules/lodash.merge/index.js"));

var _lodash3 = _interopRequireDefault(__webpack_require__("./node_modules/lodash.flattendeep/index.js"));

var _utils = __webpack_require__("./src/utils/index.ts");

var _index = __webpack_require__("./src/components/index.ts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var VerticalLocationHelper =
/*#__PURE__*/
function (_React$Component) {
  _inherits(VerticalLocationHelper, _React$Component);

  function VerticalLocationHelper() {
    _classCallCheck(this, VerticalLocationHelper);

    return _possibleConstructorReturn(this, _getPrototypeOf(VerticalLocationHelper).apply(this, arguments));
  }

  _createClass(VerticalLocationHelper, [{
    key: "renderHelper",
    value: function renderHelper() {
      if (typeof this.props.activeInfo === 'undefined' || this.props.activeInfo === null || typeof this.props.activeInfo.data === 'undefined') {
        return null;
      }

      var height = this.props.activeInnerArea.height;
      var _this$props = this.props,
          activeInfo = _this$props.activeInfo,
          animation = _this$props.animation,
          animData = _this$props.animData,
          helperTheme = _this$props.helperTheme,
          helper = _this$props.helper;
      var data = activeInfo.data,
          id = activeInfo.id;

      var getAreaData = function getAreaData() {
        if (!helper.ignoreGroup) {
          return animData.map(function (v) {
            return v.data;
          });
        }

        var singleArea = animData.find(function (v) {
          return data.parentId === v.id;
        });
        return singleArea.data;
      };

      var parentArea = (0, _lodash3.default)(getAreaData()); // Default Line Props styling

      var lineProps = {
        x: 0,
        y: 0,
        height: height,
        width: helperTheme.helpers.area.vertical.line.width,
        fill: helperTheme.helpers.area.vertical.line.fill,
        opacity: helperTheme.helpers.area.vertical.line.opacity,
        style: {
          pointerEvents: 'none',
          mixBlendMode: 'multiply'
        }
      };
      var helperDots = parentArea.map(function (set) {
        var points = set.data.find(function (point) {
          return point.key === id;
        }); // Overwrites styling from helper

        var graphOverwrite = (0, _lodash2.default)({}, helperTheme, set.styles); // Allow callback for vertical helper to support custom styling

        /*
          Vertical helper callback
          @param {string} areaId - parent ID of a point
          @param {string} id - ID of a point
          @returns {(boolean|Object)} Returns a true or false or an Object.
          true - Not in use for now
          false - Not in use for now
          Object - custom styling of a point or points
        */

        var verticalStylesOverWrite = graphOverwrite;

        if (typeof helper.callback === 'function') {
          var helperStylesOverwrite = helper.callback(set.id, points.key);

          if ((0, _lodash.default)(helperStylesOverwrite) || typeof helperStylesOverwrite === 'boolean') {
            if (typeof helperStylesOverwrite === 'boolean') {// Do nothing for now. Just return default styling unless we need to overwrite something using boolean
            } else if ((0, _lodash.default)(helperStylesOverwrite)) {
              var callbackStyle = (0, _lodash2.default)({}, verticalStylesOverWrite.helpers.area.vertical, helperStylesOverwrite);
              verticalStylesOverWrite = _objectSpread({}, verticalStylesOverWrite, {
                helpers: {
                  area: _objectSpread({}, verticalStylesOverWrite.helpers, {
                    vertical: callbackStyle
                  })
                }
              });
            }
          } else {
            throw new Error('Returned value needs to be a valid object or a boolean');
          }
        }

        return {
          data: points,
          styles: verticalStylesOverWrite
        };
      }).map(function (set) {
        var setData = set.data,
            styles = set.styles;

        if (!setData) {
          return null;
        }

        var dotProps = {
          cx: setData.style.x,
          cy: setData.style.y0,
          r: styles.helpers.area.vertical.dot.radius,
          opacity: styles.helpers.area.vertical.dot.opacity,
          style: {
            stroke: styles.helpers.area.vertical.dot.stroke,
            strokeWidth: styles.helpers.area.vertical.dot.strokeWidth,
            fill: styles.helpers.area.vertical.dot.fill,
            pointerEvents: 'none'
          }
        }; // Overwrites for Line Props if there is a callback

        var lineWidth = lineProps.width > 1 ? lineProps.width / 2 : lineProps.width;
        lineProps.x = setData.style.x - lineWidth;
        lineProps.fill = styles.helpers.area.vertical.line.fill;
        lineProps.opacity = styles.helpers.area.vertical.line.opacity;
        return _react.default.createElement("circle", _extends({
          key: (0, _utils.generateId)()
        }, dotProps));
      });

      var helperLine = _react.default.createElement("rect", lineProps);

      return _react.default.createElement(_react.default.Fragment, null, helperLine, helperDots);
    }
  }, {
    key: "render",
    value: function render() {
      var top = this.props.activeInnerArea.top;
      var helper = this.props.helper;

      if (!helper.show) {
        return null;
      }

      return _react.default.createElement(_index.Group, {
        transform: "translate(0 ".concat(top, ")")
      }, this.renderHelper());
    }
  }]);

  return VerticalLocationHelper;
}(_react.default.Component);

exports.VerticalLocationHelper = VerticalLocationHelper;

_defineProperty(VerticalLocationHelper, "propTypes", {
  activeInfo: _propTypes.default.object,
  activeInnerArea: _propTypes.default.object.isRequired,
  animation: _propTypes.default.object.isRequired,
  animData: _propTypes.default.array.isRequired,
  helper: _propTypes.default.object.isRequired,
  helperTheme: _propTypes.default.object.isRequired
});

_defineProperty(VerticalLocationHelper, "defaultProps", {
  activeInfo: undefined
});

/***/ }),

/***/ "./src/components/Helpers/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AreaPointsHelper", {
  enumerable: true,
  get: function get() {
    return _AreaPointsHelper.AreaPointsHelper;
  }
});
Object.defineProperty(exports, "HighlightBarHelper", {
  enumerable: true,
  get: function get() {
    return _HighlightBarHelper.HighlightBarHelper;
  }
});
Object.defineProperty(exports, "HighlightHelper", {
  enumerable: true,
  get: function get() {
    return _HighlightHelper.HighlightHelper;
  }
});
Object.defineProperty(exports, "VerticalLocationHelper", {
  enumerable: true,
  get: function get() {
    return _VerticalLocationHelper.VerticalLocationHelper;
  }
});

var _AreaPointsHelper = __webpack_require__("./src/components/Helpers/AreaPointsHelper/index.js");

var _HighlightBarHelper = __webpack_require__("./src/components/Helpers/HighlightBarHelper/index.js");

var _HighlightHelper = __webpack_require__("./src/components/Helpers/HighlightHelper/index.js");

var _VerticalLocationHelper = __webpack_require__("./src/components/Helpers/VerticalLocationHelper/index.js");

/***/ }),

/***/ "./src/components/SlideController/AnimateSlideOffset.tsx":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AnimateSlideOffset; });
/* harmony import */ var react_pose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react-pose/lib/index.js");
/* harmony import */ var react_pose__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_pose__WEBPACK_IMPORTED_MODULE_0__);

var AnimateSlideOffset = react_pose__WEBPACK_IMPORTED_MODULE_0___default.a.g({
    pose: {
        transition: {
            x: {
                damping: 30,
                stiffness: 300,
                type: 'spring',
            },
        },
        x: function (_a) {
            var xOffset = _a.xOffset;
            return xOffset;
        },
    },
});


/***/ }),

/***/ "./src/components/SlideController/SlideNav.scss":
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__("./node_modules/typings-for-css-modules-loader/lib/index.js?!./node_modules/postcss-loader/src/index.js!./node_modules/sass-loader/lib/loader.js!./src/components/SlideController/SlideNav.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__("./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/components/SlideController/index.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/components/SlideController/AnimateSlideOffset.tsx
var AnimateSlideOffset = __webpack_require__("./src/components/SlideController/AnimateSlideOffset.tsx");

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/@buffet/icon/dist/web.js
var web = __webpack_require__("./node_modules/@buffet/icon/dist/web.js");

// EXTERNAL MODULE: ./node_modules/classnames/bind.js
var bind = __webpack_require__("./node_modules/classnames/bind.js");
var bind_default = /*#__PURE__*/__webpack_require__.n(bind);

// EXTERNAL MODULE: ./src/components/SlideController/SlideNav.scss
var SlideNav = __webpack_require__("./src/components/SlideController/SlideNav.scss");
var SlideNav_default = /*#__PURE__*/__webpack_require__.n(SlideNav);

// CONCATENATED MODULE: ./src/components/SlideController/SlideNav.tsx




var cx = bind_default.a.bind(SlideNav_default.a);
var SlideNav_SlideNav = function (props) {
    var Icon = web["Icon"];
    var inlineStyles = {
        display: 'flex',
        justifyContent: 'flex-end',
        left: props.padding.left,
        position: 'absolute',
        top: props.padding.top,
        width: "calc(100% - " + (props.padding.right + props.padding.left) + "px)",
    };
    return (react_default.a.createElement("div", { style: inlineStyles },
        react_default.a.createElement("button", { onClick: props.prev.onClick, className: cx('button'), disabled: props.prev.isDisabled, "data-testid": "damper-slide-control--" + props.id + "--button_prev" },
            react_default.a.createElement(Icon, { iconId: "chevronLeft", className: cx('icon') })),
        react_default.a.createElement("button", { onClick: props.next.onClick, className: cx('button'), disabled: props.next.isDisabled, "data-testid": "damper-slide-control--" + props.id + "--button_next" },
            react_default.a.createElement(Icon, { iconId: "chevronRight", className: cx('icon') }))));
};

// CONCATENATED MODULE: ./src/components/SlideController/SlideController.tsx
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var SlideController_SlideController = /** @class */ (function (_super) {
    __extends(SlideController, _super);
    function SlideController(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            maxOffset: _this.getMaxOffset(),
            offset: 0,
            windowWidth: null,
        };
        _this.svgRef = react_default.a.createRef();
        _this.onNext = _this.onNext.bind(_this);
        _this.onPrev = _this.onPrev.bind(_this);
        _this.updateDimensions = _this.updateDimensions.bind(_this);
        return _this;
    }
    SlideController.prototype.getMaxOffset = function () {
        var _a = this.props, children = _a.children, columnPadding = _a.columnPadding, columnWidth = _a.columnWidth;
        var svgWidth = this.svgRef && this.svgRef.current && this.svgRef.current.offsetWidth || 0;
        var child = react_default.a.Children.only(children);
        var minGraphWidth = this.getMinWidth({
            columnCount: child.props.columns.length,
            columnPadding: columnPadding,
            columnWidth: columnWidth,
            padding: child.props.padding,
        });
        var negativeMinGraphWidth = minGraphWidth * -1;
        var halfColumnWidth = columnWidth / 2;
        var visualisationArea = svgWidth - child.props.padding.left;
        return ((negativeMinGraphWidth - halfColumnWidth) + visualisationArea) - child.props.columnOffsets.right;
    };
    SlideController.prototype.updateDimensions = function () {
        var _this = this;
        this.setState(function (prevState) { return (__assign({}, prevState, { maxOffset: _this.getMaxOffset(), windowWidth: window.innerWidth })); });
    };
    SlideController.prototype.componentDidMount = function () {
        this.updateDimensions();
        window.addEventListener("resize", this.updateDimensions);
    };
    SlideController.prototype.componentWillUnmount = function () {
        window.removeEventListener("resize", this.updateDimensions);
    };
    SlideController.prototype.getMinWidth = function (_a) {
        var columnCount = _a.columnCount, columnPadding = _a.columnPadding, columnWidth = _a.columnWidth;
        return (columnCount * (columnWidth + columnPadding));
    };
    SlideController.prototype.getChildProps = function (child) {
        var _a = this.state, offset = _a.offset, windowWidth = _a.windowWidth;
        var _b = this.props, columnPadding = _b.columnPadding, columnWidth = _b.columnWidth, isDisabled = _b.isDisabled;
        var props = {
            containerWidth: this.svgRef && this.svgRef.current && this.svgRef.current.offsetWidth,
            isDisabled: isDisabled,
            minWidth: this.getMinWidth({
                columnCount: child.props.columns.length,
                columnPadding: columnPadding,
                columnWidth: columnWidth,
                padding: child.props.padding,
            }),
            offset: offset,
            windowWidth: windowWidth,
        };
        return {
            slideProps: props,
        };
    };
    SlideController.prototype.renderChildren = function () {
        var _this = this;
        var renderChild = function (child) { return react_default.a.cloneElement(child, _this.getChildProps(child)); };
        return react_default.a.Children.map(this.props.children, renderChild);
    };
    SlideController.prototype.getSlideDistance = function (currentOffset, direction) {
        var slideDistance = this.props.slideDistance;
        var maxOffset = this.state.maxOffset;
        var svgWidth = this.svgRef && this.svgRef.current && this.svgRef.current.offsetWidth || 0;
        var offset = svgWidth * (slideDistance / 100);
        // Go next, constrained to the width of the graph (don't overshoot ends)
        if (direction === 'next') {
            var nextOffset = currentOffset - offset;
            if (nextOffset < maxOffset) {
                return maxOffset;
            }
            return nextOffset;
        }
        // Go prev, constrained to graph size
        var prevOffset = currentOffset + offset;
        return prevOffset > 0 ? 0 : prevOffset;
    };
    SlideController.prototype.onNext = function () {
        var _this = this;
        this.setState(function (prevState) { return (__assign({}, prevState, { offset: _this.getSlideDistance(prevState.offset, 'next') })); });
    };
    //tslint:disable-next-line
    SlideController.prototype.onPrev = function () {
        var _this = this;
        this.setState(function (prevState) { return (__assign({}, prevState, { offset: _this.getSlideDistance(prevState.offset, 'prev') })); });
    };
    SlideController.prototype.hideSlideNav = function () {
        var _a = this.props, children = _a.children, columnPadding = _a.columnPadding, columnWidth = _a.columnWidth;
        var child = react_default.a.Children.only(children);
        var svgWidth = this.svgRef && this.svgRef.current && this.svgRef.current.offsetWidth;
        if (svgWidth) {
            var minGraphWidth = this.getMinWidth({
                columnCount: child.props.columns.length,
                columnPadding: columnPadding,
                columnWidth: columnWidth,
                padding: child.props.padding,
            });
            if (minGraphWidth > svgWidth) {
                return false;
            }
        }
        return true;
    };
    SlideController.prototype.render = function () {
        if (this.props.isDisabled) {
            return this.props.children;
        }
        var maxOffset = this.state.maxOffset;
        var hideSlideNav = this.hideSlideNav();
        var containerStyles = {
            overflow: 'hidden',
            position: 'relative',
            width: '100%',
        };
        return (react_default.a.createElement("div", { ref: this.svgRef, style: containerStyles },
            react_default.a.createElement(SlideNav_SlideNav, { id: "storybook", isVisible: true, padding: this.props.controllerPadding, next: {
                    isDisabled: hideSlideNav || this.state.offset === maxOffset,
                    onClick: this.onNext,
                }, prev: {
                    isDisabled: hideSlideNav || this.state.offset === 0,
                    onClick: this.onPrev,
                } }),
            this.renderChildren()));
    };
    SlideController.defaultProps = {
        columnPadding: 0,
        controllerPadding: {
            left: 50,
            right: 0,
            top: 28,
        },
        offset: 0,
        slideDistance: 33,
        yOffset: 0,
    };
    return SlideController;
}(react_default.a.Component));


// CONCATENATED MODULE: ./src/components/SlideController/index.ts
/* concated harmony reexport AnimateSlideOffset */__webpack_require__.d(__webpack_exports__, "AnimateSlideOffset", function() { return AnimateSlideOffset["a" /* AnimateSlideOffset */]; });
/* concated harmony reexport SlideController */__webpack_require__.d(__webpack_exports__, "SlideController", function() { return SlideController_SlideController; });




/***/ }),

/***/ "./src/components/Svg/Circle.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimatedCircle = exports.Circle = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _reactPose = _interopRequireDefault(__webpack_require__("./node_modules/react-pose/lib/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Circle = _react.default.forwardRef(function (props, ref) {
  var defaultProps = {
    ref: null,
    opacity: 1,
    onClick: null,
    onMouseMove: null,
    onMouseOver: null,
    onMouseOut: null
  };

  var mergedProps = _objectSpread({}, defaultProps, props);

  var style = mergedProps.style,
      cx = mergedProps.cx,
      cy = mergedProps.cy,
      r = mergedProps.r,
      opacity = mergedProps.opacity,
      onClick = mergedProps.onClick,
      onMouseMove = mergedProps.onMouseMove,
      onMouseOver = mergedProps.onMouseOver,
      onMouseOut = mergedProps.onMouseOut;
  var circleProps = {
    ref: ref,
    cx: cx,
    cy: cy,
    r: r,
    opacity: opacity,
    style: {
      stroke: style.stroke,
      strokeWidth: style.strokeWidth,
      strokeDasharray: style.strokeDasharray,
      fill: style.fill,
      fillOpacity: style.fillOpacity,
      pointerEvents: 'none'
    },
    onClick: onClick,
    onMouseMove: onMouseMove,
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut
  };
  return _react.default.createElement("circle", circleProps);
});

exports.Circle = Circle;
var AnimatedCircle = (0, _reactPose.default)(Circle)({
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      type: 'spring',
      stiffness: 150
    },
    delay: function delay(_ref) {
      var dotsVal = _ref.dotsVal;

      if (dotsVal.index) {
        if (dotsVal.theme) {
          return dotsVal.index * dotsVal.theme.pose.enter.delay;
        }

        return dotsVal.index * 50;
      }

      return 0;
    }
  },
  exit: {
    scale: 0,
    opacity: 0
  }
});
exports.AnimatedCircle = AnimatedCircle;

/***/ }),

/***/ "./src/components/Svg/Group.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Group = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Group = function Group(_ref) {
  var children = _ref.children,
      id = _ref.id,
      onMouseOut = _ref.onMouseOut,
      onMouseOver = _ref.onMouseOver,
      onMouseMove = _ref.onMouseMove,
      onClick = _ref.onClick,
      transform = _ref.transform;
  return _react.default.createElement("g", {
    id: id,
    onBlur: onMouseOut,
    onClick: onClick,
    onFocus: onMouseOver,
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    onMouseMove: onMouseMove,
    transform: transform
  }, children);
};

exports.Group = Group;
Group.propTypes = {
  children: _propTypes.default.node,
  id: _propTypes.default.string,
  onClick: _propTypes.default.func,
  onMouseOver: _propTypes.default.func,
  onMouseOut: _propTypes.default.func,
  onMouseMove: _propTypes.default.func,
  transform: _propTypes.default.string
};
Group.defaultProps = {
  children: null,
  id: '',
  onClick: function onClick() {},
  onMouseOver: function onMouseOver() {},
  onMouseOut: function onMouseOut() {},
  onMouseMove: function onMouseMove() {},
  transform: 'translate(0, 0)'
};

/***/ }),

/***/ "./src/components/Svg/Path.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimatedPath = exports.Path = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _reactPose = _interopRequireDefault(__webpack_require__("./node_modules/react-pose/lib/index.js"));

var _popmotion = __webpack_require__("./node_modules/popmotion/lib/index.js");

var _d3InterpolatePath = __webpack_require__("./node_modules/d3-interpolate-path/build/d3-interpolate-path.js");

var _utils = __webpack_require__("./src/utils/index.ts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var springMorphTransition = function springMorphTransition(_ref) {
  var from = _ref.from,
      to = _ref.to;
  return (0, _popmotion.spring)({
    from: 0,
    to: 1,
    stiffness: 210,
    damping: 20
  }).pipe((0, _d3InterpolatePath.interpolatePath)(from, to));
};

var Path = _react.default.forwardRef(function (props, ref) {
  var defaultProps = {
    id: '',
    ref: null,
    onClick: null,
    onMouseMove: null,
    onMouseOver: null,
    onMouseOut: null
  };

  var mergedProps = _objectSpread({}, defaultProps, props);

  var d = mergedProps.d,
      style = mergedProps.style,
      id = mergedProps.id,
      onClick = mergedProps.onClick,
      onMouseMove = mergedProps.onMouseMove,
      onMouseOver = mergedProps.onMouseOver,
      onMouseOut = mergedProps.onMouseOut;
  var pathProps = {
    d: d,
    id: id,
    style: style,
    onClick: onClick,
    onMouseMove: onMouseMove,
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    ref: ref
  };
  return _react.default.createElement("path", pathProps);
});

exports.Path = Path;
var AnimatedPath = (0, _reactPose.default)(Path)({
  enter: {
    d: function d(_ref2) {
      var posePathVal = _ref2.posePathVal;
      return (0, _utils.generatePathData)(posePathVal.data, posePathVal.theme);
    },
    delay: function delay(_ref3) {
      var posePathVal = _ref3.posePathVal;
      return posePathVal.index * posePathVal.theme.area.pose.enter.delay;
    },
    transition: springMorphTransition
  },
  pose: {
    d: function d(_ref4) {
      var posePathVal = _ref4.posePathVal;
      return (0, _utils.generatePathData)(posePathVal.data, posePathVal.theme);
    },
    transition: springMorphTransition
  },
  exit: {
    d: function d(_ref5) {
      var posePathVal = _ref5.posePathVal;
      var emptyPathData = posePathVal.data.map(function (d) {
        return _objectSpread({}, d, {
          style: _objectSpread({}, d.style, {
            y0: d.style.y1
          })
        });
      });
      return (0, _utils.generatePathData)(emptyPathData, posePathVal.theme);
    },
    delay: function delay(_ref6) {
      var posePathVal = _ref6.posePathVal;
      return posePathVal.index * posePathVal.theme.area.pose.exit.delay;
    },
    transition: springMorphTransition
  }
});
exports.AnimatedPath = AnimatedPath;

/***/ }),

/***/ "./src/components/Svg/Rect.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimatedRect = exports.Rect = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _reactPose = _interopRequireDefault(__webpack_require__("./node_modules/react-pose/lib/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Rect = _react.default.forwardRef(function (props, ref) {
  var defaultProps = {
    actions: {},
    className: '',
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    fill: 'transparent',
    stroke: 'transparent',
    strokeDasharray: 'none',
    style: {}
  };

  var mergedProps = _objectSpread({}, defaultProps, props);

  return _react.default.createElement("g", null, _react.default.createElement("rect", _extends({}, mergedProps.actions, {
    ref: ref,
    className: mergedProps.className,
    x: mergedProps.x,
    y: mergedProps.y,
    width: mergedProps.width,
    height: mergedProps.height,
    fill: mergedProps.fill,
    stroke: mergedProps.stroke,
    strokeDasharray: mergedProps.strokeDasharray,
    style: mergedProps.style
  })));
});

exports.Rect = Rect;
var AnimatedRect = (0, _reactPose.default)(Rect)({
  enter: {
    // flip: true,
    height: function height(_ref) {
      var rectPoseVals = _ref.rectPoseVals;
      return rectPoseVals.height || 0;
    },
    y: function y(_ref2) {
      var rectPoseVals = _ref2.rectPoseVals;
      return rectPoseVals.y;
    },
    delay: function delay(_ref3) {
      var rectPoseVals = _ref3.rectPoseVals;

      if (rectPoseVals.index) {
        return rectPoseVals.index * 200;
      }

      return 0;
    },
    transition: {
      easing: 'linear',
      duration: 200
    }
  },
  exit: {
    // flip: true,
    height: function height() {
      return 0;
    },
    y: function y(_ref4) {
      var rectPoseVals = _ref4.rectPoseVals;
      return rectPoseVals.y + rectPoseVals.height;
    },
    delay: function delay(_ref5) {
      var rectPoseVals = _ref5.rectPoseVals;

      if (rectPoseVals.index) {
        return rectPoseVals.index * 200;
      }

      return 0;
    },
    transition: {
      easing: 'linear',
      duration: 200
    }
  },
  pose: {
    // flip: true,
    height: function height(_ref6) {
      var rectPoseVals = _ref6.rectPoseVals;
      return rectPoseVals.height;
    },
    y: function y(_ref7) {
      var rectPoseVals = _ref7.rectPoseVals;
      return rectPoseVals.y;
    },
    transition: {
      easing: 'easeInOut',
      duration: 200
    }
  }
});
exports.AnimatedRect = AnimatedRect;

/***/ }),

/***/ "./src/components/Svg/RoundedRect.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimatedRoundedRect = exports.RoundedRect = void 0;

var _react = _interopRequireDefault(__webpack_require__("./node_modules/react/index.js"));

var _reactPose = _interopRequireDefault(__webpack_require__("./node_modules/react-pose/lib/index.js"));

var _generateRoundedRectPath = __webpack_require__("./src/utils/general/generateRoundedRectPath.ts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var RoundedRect = _react.default.forwardRef(function (props, ref) {
  var defaultProps = {
    actions: {},
    className: '',
    d: null,
    hostRef: null,
    fill: 'transparent',
    stroke: 'transparent',
    strokeDasharray: 'none',
    style: {}
  };

  var mergedProps = _objectSpread({}, defaultProps, props);

  return _react.default.createElement("g", null, _react.default.createElement("path", _extends({
    ref: ref,
    d: mergedProps.d
  }, mergedProps.actions, {
    className: mergedProps.className,
    fill: mergedProps.fill,
    stroke: mergedProps.stroke,
    strokeDasharray: mergedProps.strokeDasharray,
    style: mergedProps.style
  })));
});

exports.RoundedRect = RoundedRect;
var AnimatedRoundedRect = (0, _reactPose.default)(RoundedRect)({
  enter: {
    d: function d(props) {
      return (0, _generateRoundedRectPath.generateRoundedRectPath)(_objectSpread({}, props, {
        height: props.rectPoseVals.height,
        y: props.rectPoseVals.y
      }));
    },
    delay: function delay(_ref) {
      var rectPoseVals = _ref.rectPoseVals;

      if (rectPoseVals.index) {
        return rectPoseVals.index * 200;
      }

      return 0;
    },
    transition: {
      easing: 'linear',
      duration: 200
    }
  },
  // Exit isn't firing correctly causing stacked bars to remain in place when they shouldn't be
  // exit: {
  //   d: (props) => generateRoundedRectPath({ ...props, height: 0, y: props.rectPoseVals.y + props.rectPoseVals.height }),
  //   delay: ({ rectPoseVals }) => {
  //     if (rectPoseVals.index) {
  //       return rectPoseVals.index * 200;
  //     }
  //     return 0;
  //   },
  //   transition: {
  //     easing: 'linear',
  //     duration: 200,
  //   },
  // },
  pose: {
    d: function d(props) {
      return (0, _generateRoundedRectPath.generateRoundedRectPath)(_objectSpread({}, props, {
        height: props.rectPoseVals.height,
        y: props.rectPoseVals.y
      }));
    },
    transition: {
      easing: 'linear',
      duration: 200
    }
  }
});
exports.AnimatedRoundedRect = AnimatedRoundedRect;

/***/ }),

/***/ "./src/components/Svg/Svg.tsx":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Svg", function() { return Svg; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var Svg = /** @class */ (function (_super) {
    __extends(Svg, _super);
    function Svg() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Svg.prototype.getProportions = function (_a) {
        var width = _a.width, height = _a.height, responsive = _a.responsive;
        var proportions = {
            svg: { width: width, height: height },
            viewbox: { width: width, height: height },
        };
        if (responsive === 'redraw') {
            return {
                svg: __assign({}, proportions.svg, { width: '100%' }),
            };
        }
        if (responsive === 'scale') {
            return __assign({}, proportions, { svg: {
                    height: '100%',
                    width: '100%',
                } });
        }
        return proportions;
    };
    Svg.prototype.render = function () {
        var _a = this.props, children = _a.children, width = _a.width, height = _a.height, measureRef = _a.measureRef, responsive = _a.responsive, theme = _a.theme;
        var proportions = this.getProportions({
            height: height,
            responsive: responsive,
            width: width,
        });
        var style = {
            background: theme.container.background,
        };
        var svg = proportions.svg, viewbox = proportions.viewbox;
        var divStyle = {
            width: svg.width,
        };
        if (typeof svg.width === 'number') {
            // tslint:disable-next-line
            divStyle.width = svg.width + "px";
        }
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { style: divStyle, ref: measureRef },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", { style: style, viewBox: viewbox ? "0 0 " + viewbox.width + " " + viewbox.height : undefined, width: proportions.svg.width, height: proportions.svg.height },
                typeof children === 'function' && children({ proportions: proportions }),
                typeof children === 'object' && children)));
    };
    Svg.defaultProps = {
        responsive: 'redraw',
    };
    return Svg;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));



/***/ }),

/***/ "./src/components/Svg/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function get() {
    return _Group.Group;
  }
});
Object.defineProperty(exports, "Rect", {
  enumerable: true,
  get: function get() {
    return _Rect.Rect;
  }
});
Object.defineProperty(exports, "AnimatedCircle", {
  enumerable: true,
  get: function get() {
    return _Circle.AnimatedCircle;
  }
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return _Circle.Circle;
  }
});
Object.defineProperty(exports, "AnimatedPath", {
  enumerable: true,
  get: function get() {
    return _Path.AnimatedPath;
  }
});
Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return _Path.Path;
  }
});
Object.defineProperty(exports, "Svg", {
  enumerable: true,
  get: function get() {
    return _Svg.Svg;
  }
});

var _Group = __webpack_require__("./src/components/Svg/Group.js");

var _Rect = __webpack_require__("./src/components/Svg/Rect.js");

var _Circle = __webpack_require__("./src/components/Svg/Circle.js");

var _Path = __webpack_require__("./src/components/Svg/Path.js");

var _Svg = __webpack_require__("./src/components/Svg/Svg.tsx");

/***/ }),

/***/ "./src/components/index.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/components/Svg/index.js
var Svg = __webpack_require__("./src/components/Svg/index.js");

// EXTERNAL MODULE: ./src/components/Axis/AxisX/index.js
var AxisX = __webpack_require__("./src/components/Axis/AxisX/index.js");

// EXTERNAL MODULE: ./src/components/Axis/AxisY/AxisY.tsx
var AxisY = __webpack_require__("./src/components/Axis/AxisY/AxisY.tsx");

// CONCATENATED MODULE: ./src/components/Axis/AxisY/index.ts


// CONCATENATED MODULE: ./src/components/Axis/index.ts



// EXTERNAL MODULE: ./src/components/Bars/index.js
var Bars = __webpack_require__("./src/components/Bars/index.js");

// EXTERNAL MODULE: ./src/components/Areas/index.js
var Areas = __webpack_require__("./src/components/Areas/index.js");

// CONCATENATED MODULE: ./src/components/index.ts
/* concated harmony reexport AnimatedCircle */__webpack_require__.d(__webpack_exports__, "AnimatedCircle", function() { return Svg["AnimatedCircle"]; });
/* concated harmony reexport Circle */__webpack_require__.d(__webpack_exports__, "Circle", function() { return Svg["Circle"]; });
/* concated harmony reexport AnimatedPath */__webpack_require__.d(__webpack_exports__, "AnimatedPath", function() { return Svg["AnimatedPath"]; });
/* concated harmony reexport Path */__webpack_require__.d(__webpack_exports__, "Path", function() { return Svg["Path"]; });
/* concated harmony reexport Group */__webpack_require__.d(__webpack_exports__, "Group", function() { return Svg["Group"]; });
/* concated harmony reexport Rect */__webpack_require__.d(__webpack_exports__, "Rect", function() { return Svg["Rect"]; });
/* concated harmony reexport Svg */__webpack_require__.d(__webpack_exports__, "Svg", function() { return Svg["Svg"]; });
/* concated harmony reexport AxisX */__webpack_require__.d(__webpack_exports__, "AxisX", function() { return AxisX["AxisX"]; });
/* concated harmony reexport AxisY */__webpack_require__.d(__webpack_exports__, "AxisY", function() { return AxisY["a" /* AxisY */]; });
/* concated harmony reexport Bars */__webpack_require__.d(__webpack_exports__, "Bars", function() { return Bars["Bars"]; });
/* concated harmony reexport Areas */__webpack_require__.d(__webpack_exports__, "Areas", function() { return Areas["Areas"]; });






/***/ }),

/***/ "./src/index.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-measure/dist/index.cjs.js
var index_cjs = __webpack_require__("./node_modules/react-measure/dist/index.cjs.js");
var index_cjs_default = /*#__PURE__*/__webpack_require__.n(index_cjs);

// EXTERNAL MODULE: ./src/components/Svg/index.js
var Svg = __webpack_require__("./src/components/Svg/index.js");

// EXTERNAL MODULE: ./src/components/Axis/AxisX/index.js
var AxisX = __webpack_require__("./src/components/Axis/AxisX/index.js");

// EXTERNAL MODULE: ./src/components/Bars/index.js
var Bars = __webpack_require__("./src/components/Bars/index.js");

// EXTERNAL MODULE: ./src/components/Areas/index.js
var Areas = __webpack_require__("./src/components/Areas/index.js");

// CONCATENATED MODULE: ./src/components/ClipPath/ClipPath.tsx

var ClipPath = function (props) {
    var innerBounds = props.innerBounds, outerBounds = props.outerBounds, padding = props.padding, slideProps = props.slideProps;
    if (slideProps && !slideProps.isDisabled) {
        return (react_default.a.createElement("defs", null,
            react_default.a.createElement("clipPath", { id: "mask" },
                react_default.a.createElement("rect", { x: (outerBounds.left), y: innerBounds.top, width: outerBounds.width, height: innerBounds.height + padding.bottom, style: {
                        fill: '#ffffff',
                    } }))));
    }
    return null;
};


// EXTERNAL MODULE: ./src/components/Axis/AxisY/AxisY.tsx
var AxisY = __webpack_require__("./src/components/Axis/AxisY/AxisY.tsx");

// EXTERNAL MODULE: ./src/utils/constants/index.ts
var constants = __webpack_require__("./src/utils/constants/index.ts");

// EXTERNAL MODULE: ./src/utils/index.ts
var utils = __webpack_require__("./src/utils/index.ts");

// EXTERNAL MODULE: ./src/utils/general/registerHelpers.ts
var registerHelpers = __webpack_require__("./src/utils/general/registerHelpers.ts");

// EXTERNAL MODULE: ./src/utils/theme/registerTheme.ts + 1 modules
var registerTheme = __webpack_require__("./src/utils/theme/registerTheme.ts");

// CONCATENATED MODULE: ./src/utils/general/bracketNumberToNormalizedValue.ts
var getHighestNormalizedValue = function (num, bracket, bracketSize) {
    if (bracket === void 0) { bracket = 50; }
    if (bracketSize === void 0) { bracketSize = 50; }
    var count = num / bracket;
    if (count > 1) {
        var nextBracket = bracket + bracketSize;
        return getHighestNormalizedValue(num, nextBracket);
    }
    return bracket;
};
/**
 * Brackets the provided number to a normalized value
 */
var bracketNumberToNormalizedValue = function (num) {
    if (num <= 25) {
        var closestFive = num - (num % 5);
        return getHighestNormalizedValue(num, closestFive, 5);
    }
    if (num <= 100) {
        var closestTen = num - (num % 10);
        return getHighestNormalizedValue(num, closestTen, 10);
    }
    if (num <= 250) {
        var closestTwentyFive = num - (num % 25);
        return getHighestNormalizedValue(num, closestTwentyFive, 25);
    }
    if (num <= 1000) {
        var closestFifty = num - (num % 50);
        return getHighestNormalizedValue(num, closestFifty, 50);
    }
    var closestHundred = num - (num % 100);
    return getHighestNormalizedValue(num, closestHundred, 100);
};

// EXTERNAL MODULE: ./src/utils/general/getAreasMaxValues.ts
var getAreasMaxValues = __webpack_require__("./src/utils/general/getAreasMaxValues.ts");

// EXTERNAL MODULE: ./src/utils/general/max.ts
var max = __webpack_require__("./src/utils/general/max.ts");

// CONCATENATED MODULE: ./src/utils/general/getHighestAreaValue.ts
/**
 * Gets the highest area value of all area datapoints, includes stacked
 */
// @TODO: This should probably just be part of this file


var getHighestAreaValue = function (areas, columns) {
    if (areas) {
        var filteredAreas = Object(getAreasMaxValues["a" /* getAreasMaxValues */])({ data: areas, columns: columns });
        return Object(max["a" /* max */])(filteredAreas.map(function (set) {
            var maxVal = set.map(function (v) { return v.maxVal; });
            return Object(max["a" /* max */])(maxVal);
        }));
    }
    return 0;
};


// CONCATENATED MODULE: ./src/utils/general/getHighestBarValue.ts

/**
 * Gets the total value of a stack of bars
 */
var getHighestStackValues = function (stackedGroup) {
    var sumRows = function (sum, row) { return sum + row.value; };
    return stackedGroup.reduce(sumRows, 0);
};
/**
 * Gets the value of a group
 */
var getHighestGroupValue = function (group) {
    if (group && (group.values || group.value)) {
        return group.values ? getHighestStackValues(group.values) : group.value;
    }
    return 0;
};
/**
 * Gets the highest value of a single bar.
 * This combines stacked bar values
 */
var getHigestBarValue = function (bars) {
    if (bars) {
        return Object(max["a" /* max */])(bars, function (row) {
            if (row.group) {
                return Object(max["a" /* max */])(row.group, getHighestGroupValue);
            }
            if (row.values) {
                return getHighestStackValues(row.values);
            }
            if (typeof row.value === 'number') {
                return row.value;
            }
            if (row.value && row.value.value) {
                return row.value.value;
            }
            return 0;
        });
    }
    return 0;
};

// EXTERNAL MODULE: ./node_modules/d3-scale/dist/d3-scale.js
var d3_scale = __webpack_require__("./node_modules/d3-scale/dist/d3-scale.js");

// CONCATENATED MODULE: ./src/utils/general/getInnerArea.ts
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


/**
 * Gets the area bounds of the line/area/bars of the visualisation
 */
var getInnerAreaBounds = function (_a) {
    var outerAreaBounds = _a.outerAreaBounds, _b = _a.customColumnOffsets, customColumnOffsets = _b === void 0 ? { left: 0, right: 0 } : _b, slideProps = _a.slideProps;
    var columnOffsetsProps = __assign({}, utils["customPropTypes"].defaultColumnOffsets, customColumnOffsets);
    var columnOffsets = columnOffsetsProps.left + columnOffsetsProps.right;
    var width = outerAreaBounds.width - columnOffsets > 0 ? outerAreaBounds.width - columnOffsets : 0;
    // If the user is using the graph slider, update the width
    if (slideProps && !slideProps.isDisabled) {
        width = slideProps.minWidth;
    }
    return {
        bottom: outerAreaBounds.bottom,
        height: outerAreaBounds.height,
        left: outerAreaBounds.left + columnOffsetsProps.left,
        right: outerAreaBounds.right + columnOffsetsProps.right,
        top: outerAreaBounds.top,
        width: width,
    };
};
/**
 * Gets the d3 scales relating to the line/area/bars of the visualisation
 */
var getInnerAreaScales = function (_a) {
    var columns = _a.columns, _b = _a.customColumnOffsets, customColumnOffsets = _b === void 0 ? { left: 0, right: 0 } : _b, outerAreaBounds = _a.outerAreaBounds, maxY = _a.maxY, slideProps = _a.slideProps, theme = _a.theme;
    var columnOffsetsProps = __assign({}, utils["customPropTypes"].defaultColumnOffsets, customColumnOffsets);
    var left = columnOffsetsProps.left, right = columnOffsetsProps.right;
    var halfBarWidth = theme.bars["default"].width ? theme.bars["default"].width / 2 : 0;
    var minVal = (outerAreaBounds.left + left + halfBarWidth);
    var maxVal = (outerAreaBounds.width + outerAreaBounds.left) - (right + halfBarWidth);
    // If the user is using the graph slider, update the width
    if (slideProps && !slideProps.isDisabled) {
        maxVal = outerAreaBounds.left + slideProps.minWidth;
    }
    var xScaleLinear = Object(d3_scale["scaleLinear"])()
        .domain([0, columns.length - 1])
        .range([minVal, maxVal]);
    var xScalePoint = Object(d3_scale["scalePoint"])()
        .domain(columns.map(function (v) { return v.id; }))
        .range([minVal, maxVal]);
    var yScaleLinear = Object(d3_scale["scaleLinear"])()
        .domain([0, maxY])
        .range([0, outerAreaBounds.height]);
    var yScaleLinearInverted = Object(d3_scale["scaleLinear"])()
        .domain([0, maxY])
        .range([outerAreaBounds.height, 0]);
    return {
        x: xScaleLinear,
        x2: xScalePoint,
        y: yScaleLinear,
        yInverted: yScaleLinearInverted,
    };
};
/**
 * Returns both the inner bounds and scales
 */
var getInnerArea = function (params) {
    var columns = params.columns, customColumnOffsets = params.customColumnOffsets, maxY = params.maxY, outerAreaBounds = params.outerAreaBounds, slideProps = params.slideProps, theme = params.theme;
    return {
        bounds: getInnerAreaBounds({
            customColumnOffsets: customColumnOffsets,
            outerAreaBounds: outerAreaBounds,
            slideProps: slideProps,
        }),
        scales: getInnerAreaScales({
            columns: columns,
            customColumnOffsets: customColumnOffsets,
            maxY: maxY,
            outerAreaBounds: outerAreaBounds,
            slideProps: slideProps,
            theme: theme,
        }),
    };
};


// CONCATENATED MODULE: ./src/utils/general/getOuterArea.ts
var getOuterArea_assign = (undefined && undefined.__assign) || function () {
    getOuterArea_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return getOuterArea_assign.apply(this, arguments);
};


/**
 * Gets the area bounds of the outside of the visualisation
 */
var getOuterAreaBounds = function (_a) {
    var bounds = _a.bounds, height = _a.height, padding = _a.padding, responsive = _a.responsive, width = _a.width;
    var paddingProps = getOuterArea_assign({}, utils["customPropTypes"].defaultPadding, padding);
    var getWidth = function () {
        var paddingX = paddingProps.left + paddingProps.right;
        var nonScaledWidth = bounds.width - paddingX;
        var activeWidth = 0;
        if (responsive === constants["h" /* SCALE */]) {
            var scaledWidth = width - paddingX;
            activeWidth = scaledWidth;
        }
        if (responsive !== constants["h" /* SCALE */] && nonScaledWidth > 0) {
            activeWidth = nonScaledWidth;
        }
        return activeWidth;
    };
    return {
        bottom: paddingProps.bottom,
        height: height - (paddingProps.top + paddingProps.bottom),
        left: paddingProps.left,
        right: paddingProps.right,
        top: paddingProps.top,
        width: getWidth(),
    };
};
/**
 * Gets the d3 scales relating to the outside of the visualisation
 */
var getOuterAreaScales = function (_a) {
    var bounds = _a.bounds, columns = _a.columns, maxY = _a.maxY;
    var width = bounds.width, height = bounds.height, top = bounds.top, left = bounds.left;
    var scales = {
        x: Object(d3_scale["scaleLinear"])(),
        x2: Object(d3_scale["scalePoint"])(),
        y: Object(d3_scale["scaleLinear"])(),
        yInverted: Object(d3_scale["scaleLinear"])(),
    };
    scales.x
        .domain([0, columns.length - 1])
        .range([left, (width + left)]);
    scales.x2
        .domain(columns.map(function (v) { return v.id; }))
        .range([left, (width + left)]);
    scales.y
        .domain([0, maxY])
        .range([top, (height + top)]);
    scales.yInverted
        .domain([0, maxY])
        .range([(height + top), 0]);
    return scales;
};
/**
 * Returns both the outer bounds and scales
 */
var getOuterArea = function (params) {
    var bounds = params.bounds, height = params.height, padding = params.padding, responsive = params.responsive, width = params.width, columns = params.columns, maxY = params.maxY;
    var outerAreaBounds = getOuterAreaBounds({
        bounds: bounds,
        height: height,
        padding: padding,
        responsive: responsive,
        width: width,
    });
    return {
        bounds: outerAreaBounds,
        scales: getOuterAreaScales({
            bounds: outerAreaBounds,
            columns: columns,
            maxY: maxY,
        }),
    };
};


// CONCATENATED MODULE: ./src/visualisations/Graph/Graph/Graph.tsx
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Graph_assign = (undefined && undefined.__assign) || function () {
    Graph_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Graph_assign.apply(this, arguments);
};













var Graph_Graph = /** @class */ (function (_super) {
    __extends(Graph, _super);
    function Graph(props) {
        var _this = _super.call(this, props) || this;
        var bounds = {};
        _this.state = {
            bounds: bounds,
        };
        _this.onResize = _this.onResize.bind(_this);
        return _this;
    }
    Graph.prototype.onResize = function (_a) {
        var bounds = _a.bounds;
        this.setState(function (prevState) { return (Graph_assign({}, prevState, { bounds: bounds })); });
    };
    Graph.prototype.getActiveBars = function () {
        var _a = this.props, bars = _a.bars, columns = _a.columns;
        var activeBars = null;
        if (bars) {
            activeBars = columns.map(function (column) {
                var matchingBar = bars.find(function (bar) { return bar.id === column.id; });
                var emptyBar = { id: column.id, value: 0 };
                return matchingBar || emptyBar;
            });
        }
        return activeBars;
    };
    Graph.prototype.getActiveAreas = function () {
        var activeAreas = null;
        var _a = this.props, areas = _a.areas, columns = _a.columns;
        var removeHidden = function (dataPoint) { return columns.some(function (column) { return column.id === dataPoint.id; }); };
        if (areas) {
            activeAreas = areas.map(function (group) {
                var filteredGroup = group.data.map(function (item) {
                    var filteredItem = item.data.filter(removeHidden);
                    return Graph_assign({}, item, { data: filteredItem });
                });
                return Graph_assign({}, group, { data: filteredGroup });
            });
        }
        return activeAreas;
    };
    Graph.prototype.getHighestValue = function (areas, bars, helpers) {
        var columns = this.props.columns;
        var highestValues = {
            areas: getHighestAreaValue(areas, columns),
            bars: getHigestBarValue(bars),
        };
        var highestNum = Math.max(highestValues.bars, highestValues.areas);
        if (highestNum && helpers.axis.y.normalizeValues) {
            highestNum = bracketNumberToNormalizedValue(highestNum);
        }
        return highestNum || 0;
    };
    Graph.prototype.getSvgProps = function (_a) {
        var measureRef = _a.measureRef, theme = _a.theme;
        var _b = this.props, responsive = _b.responsive, width = _b.width, height = _b.height;
        return {
            height: height,
            measureRef: measureRef,
            responsive: responsive,
            theme: theme,
            width: width,
        };
    };
    Graph.prototype.getAreasProps = function (areaData) {
        var theme = areaData.theme, activeData = areaData.activeData, activeInnerArea = areaData.activeInnerArea, helpers = areaData.helpers;
        var _a = this.props, animation = _a.animation, columns = _a.columns, onAreaClick = _a.onAreaClick, onAreaMouseOver = _a.onAreaMouseOver, onAreaMouseOut = _a.onAreaMouseOut, slideProps = _a.slideProps;
        return {
            actions: {
                onClick: onAreaClick,
                onMouseOut: onAreaMouseOut,
                onMouseOver: onAreaMouseOver,
            },
            activeInnerArea: activeInnerArea,
            animation: animation,
            columns: columns,
            data: activeData.areas,
            helper: helpers.area,
            slideProps: slideProps,
            theme: theme,
        };
    };
    Graph.prototype.getBarsProps = function (barData) {
        var activeData = barData.activeData, activeInnerArea = barData.activeInnerArea, theme = barData.theme, helpers = barData.helpers;
        var _a = this.props, animation = _a.animation, onBarClick = _a.onBarClick, onBarMouseOver = _a.onBarMouseOver, onBarMouseOut = _a.onBarMouseOut, slideProps = _a.slideProps;
        return {
            actions: {
                onClick: onBarClick,
                onMouseOut: onBarMouseOut,
                onMouseOver: onBarMouseOver,
            },
            activeInnerArea: activeInnerArea,
            columns: this.props.columns,
            data: activeData.bars,
            helper: helpers.bar,
            isAnimated: animation !== 'none',
            isAnimatedX: helpers.bar.animateXAxis,
            slideProps: slideProps,
            theme: theme,
        };
    };
    Graph.prototype.getYAxisProps = function (yAxisData) {
        var activeOuterArea = yAxisData.activeOuterArea, highestValue = yAxisData.highestValue, theme = yAxisData.theme, helpers = yAxisData.helpers;
        var _a = this.props, yTickCount = _a.yTickCount, AxisYLabel = _a.AxisYLabel;
        return {
            AxisYLabel: AxisYLabel,
            activeOuterArea: activeOuterArea,
            count: yTickCount,
            helper: helpers.axis.y,
            highestValue: highestValue,
            theme: theme,
        };
    };
    /* Expose graph information when graph is updating or resizing */
    Graph.prototype.updateGraphInfo = function (_a) {
        var activeData = _a.activeData, activeInnerArea = _a.activeInnerArea, activeOuterArea = _a.activeOuterArea;
        this.props.onGraphInfo({
            activeData: activeData,
            activeInnerArea: activeInnerArea,
            activeOuterArea: activeOuterArea,
            bounds: this.state.bounds,
        });
    };
    Graph.prototype.boundsExist = function () {
        var bounds = this.state.bounds;
        if (bounds.height === null || bounds.width === null) {
            return false;
        }
        return true;
    };
    Graph.prototype.render = function () {
        var _this = this;
        var bounds = this.state.bounds;
        var _a = this.props, animation = _a.animation, columns = _a.columns, columnOffsets = _a.columnOffsets, customTheme = _a.customTheme, padding = _a.padding, responsive = _a.responsive, slideProps = _a.slideProps, width = _a.width, height = _a.height;
        var theme = Object(registerTheme["a" /* registerTheme */])(customTheme);
        var helpers = Object(registerHelpers["a" /* registerHelpers */])(this.props.helpers);
        var activeAreas = this.getActiveAreas();
        var activeBars = this.getActiveBars();
        var highestValue = this.getHighestValue(activeAreas, activeBars, helpers);
        var outerArea = getOuterArea({
            bounds: bounds,
            columns: columns,
            height: height,
            maxY: highestValue,
            padding: padding,
            responsive: responsive,
            width: width,
        });
        var innerArea = getInnerArea({
            columns: columns,
            customColumnOffsets: columnOffsets,
            maxY: highestValue,
            outerAreaBounds: outerArea.bounds,
            slideProps: slideProps,
            theme: theme,
        });
        var activeOuterArea = Graph_assign({}, outerArea.bounds, { scales: outerArea.scales });
        var activeInnerArea = Graph_assign({}, innerArea.bounds, { scales: innerArea.scales });
        var activeData = {
            areas: activeAreas,
            bars: activeBars,
            highestVal: highestValue,
        };
        /**
         * Notify of updates on each render
         */
        this.updateGraphInfo({ activeData: activeData, activeInnerArea: activeInnerArea, activeOuterArea: activeOuterArea });
        return (react_default.a.createElement(index_cjs_default.a, { bounds: true, onResize: this.onResize }, function (_a) {
            var measureRef = _a.measureRef;
            return (react_default.a.createElement(Svg["Svg"], Graph_assign({}, _this.getSvgProps({ measureRef: measureRef, theme: theme })), _this.boundsExist() && (react_default.a.createElement(Svg["Group"], null,
                react_default.a.createElement(ClipPath, { outerBounds: outerArea.bounds, innerBounds: innerArea.bounds, padding: padding, slideProps: slideProps }),
                react_default.a.createElement(AxisX["AxisX"], { activeOuterArea: activeOuterArea, isAnimated: animation !== 'none', data: columns, scale: innerArea.scales.x, slideProps: slideProps, theme: theme }),
                react_default.a.createElement(AxisY["a" /* AxisY */], Graph_assign({}, _this.getYAxisProps({
                    activeOuterArea: activeOuterArea,
                    helpers: helpers,
                    highestValue: highestValue,
                    theme: theme,
                }))),
                react_default.a.createElement(Bars["Bars"], Graph_assign({}, _this.getBarsProps({
                    activeData: activeData,
                    activeInnerArea: activeInnerArea,
                    helpers: helpers,
                    theme: theme,
                }))),
                react_default.a.createElement(Areas["Areas"], Graph_assign({}, _this.getAreasProps({
                    activeData: activeData,
                    activeInnerArea: activeInnerArea,
                    helpers: helpers,
                    theme: theme,
                })))))));
        }));
    };
    Graph.defaultProps = {
        AxisYLabel: null,
        animation: constants["d" /* DEFAULT_ANIMATE */],
        columnOffsets: utils["customPropTypes"].defaultColumnOffsets,
        columns: [],
        customTheme: null,
        height: 200,
        helpers: {},
        onAreaClick: function () { return undefined; },
        onAreaMouseOut: function () { return undefined; },
        onAreaMouseOver: function () { return undefined; },
        onGraphInfo: function () { return undefined; },
        padding: utils["customPropTypes"].defaultPadding,
        responsive: 'none',
        width: 600,
        yTickCount: 5,
    };
    return Graph;
}(react_default.a.Component));


// CONCATENATED MODULE: ./src/visualisations/Graph/Graph/index.ts


// CONCATENATED MODULE: ./src/visualisations/Graph/index.ts


// EXTERNAL MODULE: ./src/components/SlideController/AnimateSlideOffset.tsx
var AnimateSlideOffset = __webpack_require__("./src/components/SlideController/AnimateSlideOffset.tsx");

// CONCATENATED MODULE: ./src/visualisations/Icicle/Icicle/Cube/Cube.tsx
var Cube_assign = (undefined && undefined.__assign) || function () {
    Cube_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Cube_assign.apply(this, arguments);
};

var Cube = function (props) {
    var defaultStyle = {
        height: 40,
        width: 40,
    };
    var defaultTextStyle = {
        fontSize: '18px',
        fontWeight: 'bold',
        lineHeight: '24px',
    };
    var cubeStyle = Cube_assign({}, defaultStyle, props.cubeStyle);
    var textStyle = Cube_assign({}, defaultTextStyle, props.textStyle);
    var textOffsetY = props.textOffsetY || 8;
    return (react_default.a.createElement("g", null,
        react_default.a.createElement("rect", Cube_assign({}, cubeStyle)),
        react_default.a.createElement("text", { x: cubeStyle.width / 2, y: (cubeStyle.height / 2) + textOffsetY, textAnchor: "middle", style: textStyle }, props.label)));
};


// CONCATENATED MODULE: ./src/visualisations/Icicle/Icicle/Cubes/Cubes.tsx
var Cubes_assign = (undefined && undefined.__assign) || function () {
    Cubes_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Cubes_assign.apply(this, arguments);
};



var Cubes = function (_a) {
    var data = _a.data, slideProps = _a.slideProps, xScale = _a.xScale, yScale = _a.yScale;
    var cubeStyle = {
        height: 40,
        width: 40,
    };
    var getXOffset = function (id) {
        var offset = xScale(id);
        if (offset) {
            return offset - (cubeStyle.width / 2);
        }
        return 0;
    };
    var getYOffset = function () {
        return cubeStyle.height / 2;
    };
    var getCubeYOffset = function (index) {
        return yScale(index) - cubeStyle.height;
    };
    var xOffset = 0;
    var clipPathProps;
    if (slideProps && !slideProps.isDisabled) {
        xOffset = slideProps.offset;
        clipPathProps = {
            clipPath: 'url(#mask)',
        };
    }
    var animateSlideOffsetProps = {
        pose: 'pose',
        poseKey: xOffset,
        xOffset: xOffset,
    };
    return (react_default.a.createElement("g", Cubes_assign({}, clipPathProps),
        react_default.a.createElement(AnimateSlideOffset["a" /* AnimateSlideOffset */], Cubes_assign({}, animateSlideOffsetProps), data.map(function (_a) {
            var values = _a.values, id = _a.id;
            return (react_default.a.createElement("g", { key: id, transform: "translate(" + getXOffset(id) + ", " + getYOffset() + ")" }, values.map(function (cube, index) {
                return (react_default.a.createElement("g", { key: index + "--" + cube.value, transform: "translate(0, " + getCubeYOffset(index) + ")" },
                    react_default.a.createElement(Cube, { cubeStyle: {
                            fill: cube.isBold ? '#BFADF3' : '#E3DCFA',
                        }, key: index, label: cube.label })));
            })));
        }))));
};


// CONCATENATED MODULE: ./src/visualisations/Icicle/Icicle/Icicle.tsx
var Icicle_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Icicle_assign = (undefined && undefined.__assign) || function () {
    Icicle_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Icicle_assign.apply(this, arguments);
};










var Icicle_Icicle = /** @class */ (function (_super) {
    Icicle_extends(Icicle, _super);
    function Icicle(props) {
        var _this = _super.call(this, props) || this;
        var bounds = {};
        _this.state = {
            bounds: bounds,
        };
        _this.onResize = _this.onResize.bind(_this);
        return _this;
    }
    Icicle.prototype.onResize = function (_a) {
        var bounds = _a.bounds;
        if (bounds) {
            this.setState(function (prevState) { return (Icicle_assign({}, prevState, { bounds: bounds })); });
        }
    };
    Icicle.prototype.boundsExist = function () {
        if (this.state.bounds) {
            var bounds = this.state.bounds;
            if (bounds.height === null || bounds.width === null) {
                return false;
            }
            return true;
        }
        return false;
    };
    Icicle.prototype.getSVGWidth = function () {
        var _a = this.props, columns = _a.columns, columnOffsets = _a.columnOffsets, padding = _a.padding, 
        // responsive,
        slideProps = _a.slideProps;
        var barWidth = 40;
        var barPadding = 4;
        var inner = columns.length * (barWidth + barPadding);
        var combinedPadding = padding.left + padding.right + columnOffsets.left + columnOffsets.right;
        var width = inner + combinedPadding;
        // If using slider helper, adjust SVG width to fit screen or minWidth
        if (slideProps && !slideProps.isDisabled) {
            width = (slideProps.minWidth < slideProps.containerWidth) ? slideProps.containerWidth : slideProps.minWidth;
        }
        return width;
    };
    Icicle.prototype.getSVGHeight = function () {
        var padding = this.props.padding;
        var maxBarCount = 10;
        var barHeight = 40;
        var barYPadding = 1;
        var inner = maxBarCount * (barHeight + barYPadding);
        var combinedPadding = padding.bottom + padding.top;
        return inner + combinedPadding;
    };
    Icicle.prototype.getSvgProps = function (_a) {
        var measureRef = _a.measureRef, theme = _a.theme;
        var _b = this.props, responsive = _b.responsive, slideProps = _b.slideProps;
        var svgResponsive = responsive;
        if (slideProps && !slideProps.isDisabled) {
            svgResponsive = 'none';
        }
        return {
            height: this.getSVGHeight(),
            measureRef: measureRef,
            responsive: svgResponsive,
            theme: theme,
            width: this.getSVGWidth(),
        };
    };
    Icicle.prototype.getXAxisProps = function (_a) {
        var outerArea = _a.outerArea, scale = _a.scale, theme = _a.theme;
        var data = this.props.columns;
        var slideProps = this.props.slideProps;
        return {
            activeOuterArea: Icicle_assign({}, outerArea, outerArea.bounds),
            data: data,
            scale: scale,
            slideProps: slideProps,
            theme: theme,
        };
    };
    Icicle.prototype.getYAxisProps = function (_a) {
        var outerArea = _a.outerArea, highestValue = _a.highestValue, theme = _a.theme, helpers = _a.helpers;
        var _b = this.props, yTickCount = _b.yTickCount, AxisYLabel = _b.AxisYLabel;
        return {
            AxisYLabel: AxisYLabel,
            activeOuterArea: Icicle_assign({}, outerArea, outerArea.bounds),
            count: yTickCount,
            helper: helpers.axis.y,
            highestValue: highestValue,
            overrideCount: true,
            theme: theme,
        };
    };
    Icicle.prototype.sortValues = function (data) {
        var _this = this;
        var largeValue = this.props.largeValue;
        return data
            .map(function (datum) {
            // tslint:disable-next-line
            var limitedValues = datum.values.slice().sort(function (a, b) { return b - a; })
                .map(function (value) { return ({
                isBold: largeValue ? value >= _this.props.largeValue : false,
                label: "" + value,
                value: value,
            }); })
                .slice(0, 10);
            if (limitedValues.length === 10) {
                // tslint:disable-next-line
                limitedValues[9] = {
                    isBold: limitedValues[9].value >= _this.props.largeValue,
                    label: '...',
                    value: limitedValues[9].value,
                };
            }
            return Icicle_assign({}, datum, { values: limitedValues });
        });
    };
    Icicle.prototype.render = function () {
        var _this = this;
        var bounds = this.state.bounds;
        var _a = this.props, columns = _a.columns, columnOffsets = _a.columnOffsets, customTheme = _a.customTheme, data = _a.data, maxY = _a.maxY, padding = _a.padding, responsive = _a.responsive, slideProps = _a.slideProps, width = _a.width;
        var theme = Object(registerTheme["a" /* registerTheme */])(customTheme);
        var helpers = Object(registerHelpers["a" /* registerHelpers */])(this.props.helpers);
        var outerArea = getOuterArea({
            bounds: bounds,
            columns: columns,
            height: this.getSVGHeight(),
            maxY: maxY,
            padding: padding,
            responsive: responsive,
            width: width,
        });
        var innerArea = getInnerArea({
            columns: columns,
            customColumnOffsets: columnOffsets,
            maxY: maxY,
            outerAreaBounds: outerArea.bounds,
            slideProps: slideProps,
            theme: theme,
        });
        return (react_default.a.createElement(index_cjs_default.a, { bounds: true, onResize: this.onResize }, function (_a) {
            var measureRef = _a.measureRef;
            return (react_default.a.createElement(Svg["Svg"], Icicle_assign({}, _this.getSvgProps({ measureRef: measureRef, theme: theme })), _this.boundsExist() && (react_default.a.createElement(Svg["Group"], null,
                react_default.a.createElement(ClipPath, { outerBounds: outerArea.bounds, innerBounds: innerArea.bounds, padding: padding, slideProps: slideProps }),
                react_default.a.createElement(Cubes, { data: _this.sortValues(data), slideProps: slideProps, xScale: innerArea.scales.x2, yScale: innerArea.scales.yInverted }),
                react_default.a.createElement(AxisX["AxisX"], Icicle_assign({ isAnimated: false }, _this.getXAxisProps({
                    outerArea: outerArea,
                    scale: innerArea.scales.x,
                    theme: theme,
                }))),
                react_default.a.createElement(AxisY["a" /* AxisY */], Icicle_assign({}, _this.getYAxisProps({
                    helpers: helpers,
                    highestValue: maxY,
                    outerArea: outerArea,
                    theme: theme,
                })))))));
        }));
    };
    Icicle.defaultProps = {
        animation: constants["d" /* DEFAULT_ANIMATE */],
        columnOffsets: utils["customPropTypes"].defaultColumnOffsets,
        columns: [],
        customTheme: {
            bars: {
                "default": {
                    width: 40,
                },
            },
        },
        helpers: {},
        maxY: 10,
        padding: utils["customPropTypes"].defaultPadding,
        responsive: 'none',
        width: 600,
        yTickCount: 6,
    };
    return Icicle;
}(react_default.a.Component));


// CONCATENATED MODULE: ./src/visualisations/Icicle/Icicle/index.ts


// CONCATENATED MODULE: ./src/visualisations/Icicle/index.ts


// EXTERNAL MODULE: ./src/components/SlideController/index.ts + 2 modules
var SlideController = __webpack_require__("./src/components/SlideController/index.ts");

// CONCATENATED MODULE: ./src/index.ts
/* concated harmony reexport Graph */__webpack_require__.d(__webpack_exports__, "Graph", function() { return Graph_Graph; });
/* concated harmony reexport Icicle */__webpack_require__.d(__webpack_exports__, "Icicle", function() { return Icicle_Icicle; });
/* concated harmony reexport SlideController */__webpack_require__.d(__webpack_exports__, "SlideController", function() { return SlideController["SlideController"]; });
// Visualisations


// Helpers

// Components


/***/ }),

/***/ "./src/utils/constants/index.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ANIMATE_ALL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ANIMATE_NONE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ANIMATE_ONCHANGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return NONE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return REDRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return SCALE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return DEFAULT_ANIMATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return HELPERS; });
var ANIMATE_ALL = 'all';
var ANIMATE_NONE = 'none';
var ANIMATE_ONCHANGE = 'onchange';
var NONE = 'none';
var REDRAW = 'redraw';
var SCALE = 'scale';
var DEFAULT_ANIMATE = ANIMATE_ALL;
var HELPERS = {
    area: {
        highlight: {
            end: undefined,
            offset: {
                max: undefined,
                min: undefined,
            },
            show: false,
            start: undefined,
            styles: {},
        },
        points: {
            callback: undefined,
            show: false,
            styles: {},
        },
        vertical: {
            callback: undefined,
            ignoreGroup: false,
            show: false,
            styles: {},
        },
    },
    axis: {
        y: {
            commaLargeValues: false,
            commaLargeValuesUtil: function (num) { return new Intl.NumberFormat('en-US', { style: 'decimal' }).format(num); },
            hideZero: true,
            normalizeValues: true,
        },
    },
    bar: {
        animateXAxis: false,
        highlight: {
            callback: undefined,
            show: false,
        },
    },
};


/***/ }),

/***/ "./src/utils/general/colours.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return colourSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return colourShade; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hexToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return rgbToHex; });
/* harmony import */ var lodash_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash.range/index.js");
/* harmony import */ var lodash_range__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_range__WEBPACK_IMPORTED_MODULE_0__);

/**
 * colourSet()
 * Returns an array of colour hex strings
 * @param hex - Hexadecimal string e.g. '#0000FF' or '0000FF'
 * @param variance - Incremental luminance in percentage, lighter (positive) or darker (negative) e.g. 0.1, -0.25
 * @param set - Number of sets to return in array
 */
var colourSet = function (hex, variance, set) {
    if (variance === void 0) { variance = 0.1; }
    if (set === void 0) { set = 5; }
    if (!hex) {
        throw new Error('hexadecimal is not defined');
    }
    // tslint:disable-next-line
    var _variance = 0;
    return lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(set).reduce(function (prev) {
        var colour = colourShade(hex, _variance);
        _variance += variance;
        return prev.concat([colour]);
    }, []);
};
/**
 * colourShade()
 * Returns a colour hex string with defined luminance (in percentage)
 * @param hex - Hexadecimal string e.g. '#0000FF' or '0000FF'
 * @param lum - Luminance in percentage, lighter (positive) or darker (negative) e.g. 0.1, -0.25
 */
var colourShade = function (hex, lum) {
    if (lum === void 0) { lum = 0; }
    var luminance = lum;
    var set = 3;
    var hexadecimal = String(hex).replace(/[^0-9a-f]/gi, '');
    if (hexadecimal.length < 6) {
        hexadecimal = hexadecimal[0] + hexadecimal[0] + hexadecimal[1] + hexadecimal[1] + hexadecimal[2] + hexadecimal[2];
    }
    var rgb = lodash_range__WEBPACK_IMPORTED_MODULE_0___default()(set)
        .reduce(function (prev, curr) {
        var c = parseInt(hexadecimal.substr(curr * 2, 2), 16);
        var roundedC = Math.round(Math.min(Math.max(0, c + (c * luminance)), 255)).toString(16);
        var partial = ("00" + roundedC).substr(roundedC.length);
        return "" + prev + partial;
    }, '');
    return "#" + rgb.toUpperCase();
};
/**
 * hexToRgb()
 * Converts Hexadecimal string to RGB object
 * @param hex - Hexadecimal string. Accepts shorthand
 */
var hexToRgb = function (hex) {
    if (!hex) {
        throw new Error('Invalid hex');
    }
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    // tslint:disable
    // @ts-ignore
    var _hex = hex.replace(shorthandRegex, function (m, r, g, b) { return r + r + g + g + b + b; });
    // tslint:enable
    var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(_hex);
    if (rgb) {
        // Allow non-alphabetical sorting of rgb.
        // tslint:disable
        return {
            r: parseInt(rgb[1], 16),
            g: parseInt(rgb[2], 16),
            b: parseInt(rgb[3], 16),
        };
        // tslint:enable
    }
    return null;
};
/**
 * rgbToHex()
 * Converts RGB(A) to Hexadecimal string
 * @param rgba - RGB or RGBA string. Ignores alpha. e.g. rgba(10, 12, 13, 1)
 */
var rgbToHex = function (rgba) {
    if (!rgba) {
        throw new Error('Invalid RGB(A)');
    }
    var rgb = rgba.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    if (rgb && rgb.length === 4) {
        var str = ("0" + parseInt(rgb[1], 10).toString(16)).slice(-2) +
            ("0" + parseInt(rgb[2], 10).toString(16)).slice(-2) +
            ("0" + parseInt(rgb[3], 10).toString(16)).slice(-2);
        return "#" + str.toUpperCase();
    }
    return null;
};



/***/ }),

/***/ "./src/utils/general/generateRoundedRectPath.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateRoundedRectPath", function() { return generateRoundedRectPath; });
/**
 * Generates a rounded rectangle using a path
 * @see: https://stackoverflow.com/questions/10177985/svg-rounded-corner
 */
var generateRoundedRectPath = function (_a) {
    var rounding = _a.rounding, width = _a.width, staticHeight = _a.height, x = _a.x, staticY = _a.y, poseVals = _a.poseVals;
    var height = staticHeight;
    var y = staticY;
    if (poseVals) {
        if (poseVals.height) {
            (height = poseVals.height);
        }
        if (poseVals.y) {
            (y = poseVals.y);
        }
    }
    if (!height) {
        height = 0;
    }
    if (!y) {
        y = 0;
    }
    var constrainedRounding = rounding < height ? rounding : height;
    constrainedRounding = (constrainedRounding * 2) > width ? (width / 2) : constrainedRounding;
    var dXandY = "M" + (x + constrainedRounding) + "," + y;
    var dHorizontalTop = "h" + (width - (constrainedRounding * 2));
    var dArcRight = "a" + constrainedRounding + ", " + constrainedRounding + " 0 0 1 " + constrainedRounding + ", " + constrainedRounding;
    var dVerticalRight = "v" + (height - constrainedRounding);
    var dHorizontalBottom = "h" + width * -1;
    var dVerticalLeft = "v" + (height - constrainedRounding) * -1;
    var dArcLeft = "a" + constrainedRounding + ", " + constrainedRounding + " 0 0 1 " + constrainedRounding + ", " + constrainedRounding * -1;
    var closePath = 'z';
    return dXandY +
        dHorizontalTop +
        dArcRight +
        dVerticalRight +
        dHorizontalBottom +
        dVerticalLeft +
        dArcLeft +
        closePath;
};


/***/ }),

/***/ "./src/utils/general/getAreasMaxValues.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getAreasMaxValues; });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var defaultParams = { data: [], columns: [] };
/**
 * Gets area values aligned to the column id
 */
var getValuesAlignedToColumns = function (_a) {
    var columnId = _a.columnId, data = _a.data;
    return data.reduce(function (prev, item) {
        var _a;
        var columnMatchedData = item.data.find(function (i) { return i.id === columnId; });
        if (columnMatchedData) {
            return __assign({}, prev, (_a = {}, _a[item.id] = columnMatchedData.value, _a));
        }
        return prev;
    }, {});
};
/**
 * Returns all areas values and total for each column id
 */
var getAreasMaxValues = function (_a) {
    var _b = _a === void 0 ? defaultParams : _a, data = _b.data, columns = _b.columns;
    if (data.length) {
        return data
            .map(function (set) { return columns
            .map(function (column) {
            var columnId = column.id;
            var data = set.data;
            var val = getValuesAlignedToColumns({ columnId: columnId, data: data });
            return {
                id: columnId,
                val: val,
            };
        })
            .map(function (group) {
            var keys = Object.keys(group.val);
            var maxVal = keys.reduce(function (prev, key) { return (typeof (group.val[key]) === 'number' ? prev + group.val[key] : 0); }, 0);
            return __assign({}, group, { maxVal: maxVal });
        }); });
    }
    return [];
};


/***/ }),

/***/ "./src/utils/general/index.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./src/utils/constants/index.ts
var constants = __webpack_require__("./src/utils/constants/index.ts");

// CONCATENATED MODULE: ./src/utils/general/animation.ts

var getAnimationMode = function (mode) {
    switch (mode) {
        case constants["a" /* ANIMATE_ALL */]: return true;
        case constants["b" /* ANIMATE_NONE */]: return false;
        case constants["c" /* ANIMATE_ONCHANGE */]: return 'onchange';
        default: return (constants["d" /* DEFAULT_ANIMATE */] === 'all');
    }
};

// CONCATENATED MODULE: ./src/utils/general/getAreas.ts
/**
 * Returns D3 Areas stack structure
 */
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var getAreas = function (_a) {
    var _b = _a === void 0 ? { data: [], columns: [] } : _a, data = _b.data, columns = _b.columns, id = _b.id;
    if (data.length) {
        var sets = columns
            .map(function (column) {
            var columnid = column.id;
            // @TODO: What's this reduce doing?, can it be refactored/broken into its own function
            // to be clearer, reusable?
            var val = data.reduce(function (prev, item) {
                var _a;
                // @TODO: Datum should not be "any"
                // tslint:disable-next-line
                var _item = item.data.find(function (i) { return i.id === columnid; });
                if (_item) {
                    return __assign({}, prev, (_a = {}, _a[item.id] = _item.value, _a));
                }
                return prev;
            }, {});
            return {
                data: val,
                id: columnid,
            };
        })
            .filter(function (set) {
            if (Object.keys(set.data).length) {
                return true;
            }
            return false;
        });
        return {
            data: sets,
            id: id,
        };
    }
    return [];
};

// EXTERNAL MODULE: ./src/utils/general/getAreasMaxValues.ts
var getAreasMaxValues = __webpack_require__("./src/utils/general/getAreasMaxValues.ts");

// EXTERNAL MODULE: ./src/utils/general/max.ts
var max = __webpack_require__("./src/utils/general/max.ts");

// CONCATENATED MODULE: ./src/utils/general/getMaxVal.ts

/**
 * Gets the max value from an arrays visible values
 * If the array is not number based it will return the length instead
 */
var getMaxVal = function (_a) {
    var _b = _a === void 0 ? {} : _a, data = _b.data, key = _b.key;
    if (!data || !key) {
        throw new Error('Missing data or key');
    }
    var array = data
        .filter(function (d) { return typeof d[key] !== 'undefined'; })
        .filter(function (d) { return d.isVisible !== false; })
        .map(function (d) { return d[key]; });
    if (array.length === 0) {
        return 0;
    }
    var arrayIsAllNumbers = array.every(function (el) { return typeof el === 'number'; });
    if (arrayIsAllNumbers) {
        return Object(max["a" /* max */])(array);
    }
    return array.length - 1;
};

// CONCATENATED MODULE: ./src/utils/general/generateId.ts
var LENGTH = 1;
var PREFIX = '_';
var generateId = function (length, prefix) {
    if (length === void 0) { length = LENGTH; }
    if (prefix === void 0) { prefix = PREFIX; }
    var i = 0;
    var id = '';
    if (length <= 0) {
        throw new Error("Length must be 1 or more. Length: " + length);
    }
    // @TODO: Remove reliance on this loop
    // tslint:disable
    do {
        id += Math.random().toString(36).substr(2, 9);
        i += 1;
    } while (i < length);
    // tslint:enable
    return "" + prefix + id;
};

// EXTERNAL MODULE: ./node_modules/d3-shape/dist/d3-shape.js
var d3_shape = __webpack_require__("./node_modules/d3-shape/dist/d3-shape.js");

// CONCATENATED MODULE: ./src/utils/general/generatePathData.ts

var getCurve = function (curve) {
    switch (curve) {
        case 'curveBasis': return d3_shape["curveBasis"];
        case 'curveCardinal': return d3_shape["curveCardinal"];
        case 'curveCatmullRom': return d3_shape["curveCatmullRom"];
        case 'curveLinear': return d3_shape["curveLinear"];
        case 'curveMonotoneX': return d3_shape["curveMonotoneX"];
        case 'curveStep': return d3_shape["curveStep"];
        case 'curveStepAfter': return d3_shape["curveStepAfter"];
        case 'curveStepBefore': return d3_shape["curveStepBefore"];
        default: return d3_shape["curveMonotoneX"];
    }
};
var generatePathData = function (data, theme) {
    var getLinePathData = Object(d3_shape["line"])()
        .x(function (d) { return d.style.x; })
        .y(function (d) { return d.style.y0; })
        .curve(getCurve(theme.area.curve));
    var getAreasPathData = Object(d3_shape["area"])()
        .x(function (d) { return d.style.x; })
        .y0(function (d) { return d.style.y0; })
        .y1(function (d) { return d.style.y1; })
        .curve(getCurve(theme.area.curve));
    var isGraphFilled = (typeof theme.common.fill !== 'undefined' && theme.common.fill !== 'transparent');
    return (isGraphFilled) ? getAreasPathData(data) : getLinePathData(data);
};

// EXTERNAL MODULE: ./src/utils/general/colours.ts
var colours = __webpack_require__("./src/utils/general/colours.ts");

// CONCATENATED MODULE: ./src/utils/general/index.ts
/* concated harmony reexport getAnimationMode */__webpack_require__.d(__webpack_exports__, "e", function() { return getAnimationMode; });
/* concated harmony reexport getAreas */__webpack_require__.d(__webpack_exports__, "f", function() { return getAreas; });
/* concated harmony reexport getAreasMaxValues */__webpack_require__.d(__webpack_exports__, "g", function() { return getAreasMaxValues["a" /* getAreasMaxValues */]; });
/* concated harmony reexport getMaxVal */__webpack_require__.d(__webpack_exports__, "h", function() { return getMaxVal; });
/* concated harmony reexport generateId */__webpack_require__.d(__webpack_exports__, "c", function() { return generateId; });
/* concated harmony reexport generatePathData */__webpack_require__.d(__webpack_exports__, "d", function() { return generatePathData; });
/* concated harmony reexport colourSet */__webpack_require__.d(__webpack_exports__, "a", function() { return colours["a" /* colourSet */]; });
/* concated harmony reexport colourShade */__webpack_require__.d(__webpack_exports__, "b", function() { return colours["b" /* colourShade */]; });
/* concated harmony reexport hexToRgb */__webpack_require__.d(__webpack_exports__, "i", function() { return colours["c" /* hexToRgb */]; });
/* concated harmony reexport rgbToHex */__webpack_require__.d(__webpack_exports__, "j", function() { return colours["d" /* rgbToHex */]; });










/***/ }),

/***/ "./src/utils/general/max.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return max; });
// tslint:disable
/**
 * From D3-Array: https://github.com/d3/d3-array/blob/master/src/max.js
 */
var max = function (values, valueof) {
    var max;
    if (valueof === undefined) {
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value = values_1[_i];
            if (value != null
                && value >= value
                && (max === undefined || max < value)) {
                max = value;
            }
        }
    }
    else {
        var index = -1;
        for (var _a = 0, values_2 = values; _a < values_2.length; _a++) {
            var value = values_2[_a];
            if ((value = valueof(value, ++index, values)) != null
                && value >= value
                && (max === undefined || max < value)) {
                max = value;
            }
        }
    }
    return max;
};



/***/ }),

/***/ "./src/utils/general/registerHelpers.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return registerHelpers; });
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash.isequal/index.js");
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/lodash.merge/index.js");
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/memoize-one/dist/memoize-one.cjs.js");
/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(memoize_one__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/constants/index.ts");




/**
 * Loads default helpers and deep merge if there is a custom helper overwrite
 * @param customHelper - helper to overwrite
 */
var registerHelpers = memoize_one__WEBPACK_IMPORTED_MODULE_2___default()(function (customHelpers) {
    if (customHelpers === void 0) { customHelpers = {}; }
    return lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()({}, _constants__WEBPACK_IMPORTED_MODULE_3__[/* HELPERS */ "e"], customHelpers);
}, lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default.a);


/***/ }),

/***/ "./src/utils/index.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _proptypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/proptypes/index.js");
/* harmony import */ var _proptypes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_proptypes__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "customPropTypes", function() { return _proptypes__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _general__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/general/index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAnimationMode", function() { return _general__WEBPACK_IMPORTED_MODULE_1__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAreas", function() { return _general__WEBPACK_IMPORTED_MODULE_1__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAreasMaxValues", function() { return _general__WEBPACK_IMPORTED_MODULE_1__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMaxVal", function() { return _general__WEBPACK_IMPORTED_MODULE_1__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generateId", function() { return _general__WEBPACK_IMPORTED_MODULE_1__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generatePathData", function() { return _general__WEBPACK_IMPORTED_MODULE_1__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "colourSet", function() { return _general__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "colourShade", function() { return _general__WEBPACK_IMPORTED_MODULE_1__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexToRgb", function() { return _general__WEBPACK_IMPORTED_MODULE_1__["i"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgbToHex", function() { return _general__WEBPACK_IMPORTED_MODULE_1__["j"]; });

/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/theme/index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerTheme", function() { return _theme__WEBPACK_IMPORTED_MODULE_2__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assignPartialTheme", function() { return _theme__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/constants/index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "REDRAW", function() { return _constants__WEBPACK_IMPORTED_MODULE_3__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SCALE", function() { return _constants__WEBPACK_IMPORTED_MODULE_3__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NONE", function() { return _constants__WEBPACK_IMPORTED_MODULE_3__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HELPERS", function() { return _constants__WEBPACK_IMPORTED_MODULE_3__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ANIMATE_ALL", function() { return _constants__WEBPACK_IMPORTED_MODULE_3__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ANIMATE_NONE", function() { return _constants__WEBPACK_IMPORTED_MODULE_3__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ANIMATE_ONCHANGE", function() { return _constants__WEBPACK_IMPORTED_MODULE_3__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_ANIMATE", function() { return _constants__WEBPACK_IMPORTED_MODULE_3__["d"]; });








/***/ }),

/***/ "./src/utils/proptypes/areasShape.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.areasShape = exports.defaultAreas = void 0;

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var defaultAreas = undefined;
exports.defaultAreas = defaultAreas;
var dataShape = (0, _propTypes.shape)({
  id: _propTypes.string.isRequired,
  value: _propTypes.number
});
var areaData = (0, _propTypes.arrayOf)(dataShape); // Individual area graph

var areasDataShape = (0, _propTypes.shape)({
  id: _propTypes.string.isRequired,
  style: _propTypes.object,
  data: areaData
});
var areasData = (0, _propTypes.arrayOf)(areasDataShape); // Collection of area graphs

var areas = (0, _propTypes.shape)({
  id: _propTypes.string.isRequired,
  group: _propTypes.bool,
  data: areasData
});
var areasShape = (0, _propTypes.arrayOf)(areas);
exports.areasShape = areasShape;

/***/ }),

/***/ "./src/utils/proptypes/barsShape.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.barsShape = exports.defaultBars = void 0;

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var defaultBars = undefined;
exports.defaultBars = defaultBars;
var valueShape = (0, _propTypes.shape)({
  style: _propTypes.string,
  value: (0, _propTypes.oneOfType)([_propTypes.number, (0, _propTypes.shape)({
    value: _propTypes.number,
    theme: _propTypes.object
  })])
});
var groupShape = (0, _propTypes.shape)({
  offset: _propTypes.number,
  values: (0, _propTypes.arrayOf)(valueShape)
});
var dataShape = (0, _propTypes.shape)({
  id: _propTypes.string.isRequired,
  group: (0, _propTypes.arrayOf)(groupShape),
  values: (0, _propTypes.arrayOf)(valueShape),
  value: (0, _propTypes.oneOfType)([_propTypes.number, valueShape])
});
var data = (0, _propTypes.arrayOf)(dataShape);
var barsShape = data;
exports.barsShape = barsShape;

/***/ }),

/***/ "./src/utils/proptypes/columnOffsetsShape.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.columnOffsetsShape = exports.defaultColumnOffsets = void 0;

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var defaultColumnOffsets = {
  left: 0,
  right: 0
};
exports.defaultColumnOffsets = defaultColumnOffsets;
var columnOffsetsShape = (0, _propTypes.shape)({
  left: _propTypes.number,
  right: _propTypes.number
});
exports.columnOffsetsShape = columnOffsetsShape;

/***/ }),

/***/ "./src/utils/proptypes/columnsShape.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.columnsShape = void 0;

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var columnsShape = _propTypes.array.isRequired; // Should be arrayOf shapes

exports.columnsShape = columnsShape;

/***/ }),

/***/ "./src/utils/proptypes/customThemeShape.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.customThemeShape = void 0;

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

// @TODO: Update to use Shape
var customThemeShape = _propTypes.object;
exports.customThemeShape = customThemeShape;

/***/ }),

/***/ "./src/utils/proptypes/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "numberOrString", {
  enumerable: true,
  get: function get() {
    return _numberOrString.numberOrString;
  }
});
Object.defineProperty(exports, "defaultPadding", {
  enumerable: true,
  get: function get() {
    return _paddingShape.defaultPadding;
  }
});
Object.defineProperty(exports, "paddingShape", {
  enumerable: true,
  get: function get() {
    return _paddingShape.paddingShape;
  }
});
Object.defineProperty(exports, "barsShape", {
  enumerable: true,
  get: function get() {
    return _barsShape.barsShape;
  }
});
Object.defineProperty(exports, "defaultBars", {
  enumerable: true,
  get: function get() {
    return _barsShape.defaultBars;
  }
});
Object.defineProperty(exports, "customThemeShape", {
  enumerable: true,
  get: function get() {
    return _customThemeShape.customThemeShape;
  }
});
Object.defineProperty(exports, "columnsShape", {
  enumerable: true,
  get: function get() {
    return _columnsShape.columnsShape;
  }
});
Object.defineProperty(exports, "defaultColumnOffsets", {
  enumerable: true,
  get: function get() {
    return _columnOffsetsShape.defaultColumnOffsets;
  }
});
Object.defineProperty(exports, "columnOffsetsShape", {
  enumerable: true,
  get: function get() {
    return _columnOffsetsShape.columnOffsetsShape;
  }
});
Object.defineProperty(exports, "areasShape", {
  enumerable: true,
  get: function get() {
    return _areasShape.areasShape;
  }
});
Object.defineProperty(exports, "defaultAreas", {
  enumerable: true,
  get: function get() {
    return _areasShape.defaultAreas;
  }
});

var _numberOrString = __webpack_require__("./src/utils/proptypes/numberOrString.js");

var _paddingShape = __webpack_require__("./src/utils/proptypes/paddingShape.js");

var _barsShape = __webpack_require__("./src/utils/proptypes/barsShape.js");

var _customThemeShape = __webpack_require__("./src/utils/proptypes/customThemeShape.js");

var _columnsShape = __webpack_require__("./src/utils/proptypes/columnsShape.js");

var _columnOffsetsShape = __webpack_require__("./src/utils/proptypes/columnOffsetsShape.js");

var _areasShape = __webpack_require__("./src/utils/proptypes/areasShape.js");

/***/ }),

/***/ "./src/utils/proptypes/numberOrString.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.numberOrString = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__("./node_modules/prop-types/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var numberOrString = _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]).isRequired;

exports.numberOrString = numberOrString;

/***/ }),

/***/ "./src/utils/proptypes/paddingShape.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.paddingShape = exports.defaultPadding = void 0;

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var defaultPadding = {
  top: 40,
  right: 70,
  bottom: 50,
  left: 70
};
exports.defaultPadding = defaultPadding;
var paddingShape = (0, _propTypes.shape)({
  top: _propTypes.number,
  right: _propTypes.number,
  bottom: _propTypes.number,
  left: _propTypes.number
});
exports.paddingShape = paddingShape;

/***/ }),

/***/ "./src/utils/theme/index.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./src/utils/theme/registerTheme.ts + 1 modules
var registerTheme = __webpack_require__("./src/utils/theme/registerTheme.ts");

// EXTERNAL MODULE: ./node_modules/lodash.merge/index.js
var lodash_merge = __webpack_require__("./node_modules/lodash.merge/index.js");
var lodash_merge_default = /*#__PURE__*/__webpack_require__.n(lodash_merge);

// CONCATENATED MODULE: ./src/utils/theme/assignPartialTheme.ts

/**
 * Loads partial of the default/overwritten theme
 */
var assignPartialTheme = function (_a) {
    var _b = _a.customTheme, customTheme = _b === void 0 ? {} : _b, _c = _a.includeCommon, includeCommon = _c === void 0 ? true : _c, _d = _a.keys, keys = _d === void 0 ? [] : _d, _e = _a.theme, theme = _e === void 0 ? {} : _e;
    var _f;
    var keyCommon = 'common';
    var hasCommon = includeCommon ? Object.keys(theme).find(function (v) { return v === keyCommon; }) : '';
    var partials = Object.keys(theme)
        .filter(function (v) { return keys.find(function (i) { return v === i; }); })
        .map(function (v) {
        var _a;
        return (_a = {}, _a[v] = theme[v], _a);
    });
    var common = (hasCommon && hasCommon.length) ? (_f = {}, _f[keyCommon] = theme[keyCommon], _f) : {};
    var mergedTheme = Object.assign.apply(Object, [{}].concat(partials, [common]));
    return lodash_merge_default()({}, mergedTheme, customTheme);
};

// CONCATENATED MODULE: ./src/utils/theme/index.ts
/* concated harmony reexport registerTheme */__webpack_require__.d(__webpack_exports__, "b", function() { return registerTheme["a" /* registerTheme */]; });
/* concated harmony reexport assignPartialTheme */__webpack_require__.d(__webpack_exports__, "a", function() { return assignPartialTheme; });




/***/ }),

/***/ "./src/utils/theme/registerTheme.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash.isequal/index.js
var lodash_isequal = __webpack_require__("./node_modules/lodash.isequal/index.js");
var lodash_isequal_default = /*#__PURE__*/__webpack_require__.n(lodash_isequal);

// EXTERNAL MODULE: ./node_modules/lodash.merge/index.js
var lodash_merge = __webpack_require__("./node_modules/lodash.merge/index.js");
var lodash_merge_default = /*#__PURE__*/__webpack_require__.n(lodash_merge);

// EXTERNAL MODULE: ./node_modules/memoize-one/dist/memoize-one.cjs.js
var memoize_one_cjs = __webpack_require__("./node_modules/memoize-one/dist/memoize-one.cjs.js");
var memoize_one_cjs_default = /*#__PURE__*/__webpack_require__.n(memoize_one_cjs);

// EXTERNAL MODULE: ./node_modules/otkit-colors/token.common.js
var token_common = __webpack_require__("./node_modules/otkit-colors/token.common.js");

// CONCATENATED MODULE: ./src/theme/defaultTheme.ts
// tslint:disable

var settings = {
    fillOpacity: 1,
    fillOpacityOver: 1,
    labelX: '#333333',
    labelY: '#9B9B9B',
    primary: token_common["violetLight"],
    strokeDasharray: '10, 5',
    strokeOpacity: 1,
    strokeOpacityOver: 1,
    strokeWidth: 0,
    tickX: token_common["ashLighter"],
    tickY: token_common["ashLightest"],
    tickYFirst: token_common["ashLighter"],
};
var theme = {
    area: {
        cursor: 'default',
        // Curve Explorer: https://bl.ocks.org/d3noob/ced1b9b18bd8192d2c898884033b5529
        curve: 'curveMonotoneX',
        path: {
            eventFill: 'transparent',
            eventFillOpacity: 0,
            eventStroke: 'transparent',
            eventStrokeOpacity: 0,
            eventStrokeWidth: 12,
        },
        pose: {
            enter: {
                delay: 300,
            },
            exit: {
                delay: 200,
            },
        },
        single: {
            pose: {
                enter: {
                    delay: 50,
                },
            },
            radius: 5,
        },
        snap: ['auto', 'auto'],
    },
    axis: {
        x: {
            easing: {
                opacity: 'gentle',
                x: 'stiff',
            },
            label: {
                color: settings.labelX,
            },
            stroke: {
                fill: token_common["ashLighter"],
                height: 1,
            },
            tick: {
                fill: settings.tickX,
                height: 1,
            },
        },
        y: {
            isAnimated: false,
            label: {
                color: settings.labelY,
            },
            stroke: {
                fill: 'transparent',
                width: 1,
            },
            tick: {
                fill: settings.tickY,
                height: 1,
            },
            tickFirst: {
                fill: settings.tickYFirst,
                height: 1,
            },
        },
    },
    bar: {
        easing: {
            height: {
                damping: 40,
                stiffness: 300,
            },
            transformX: 'noWobble',
            y: {
                damping: 40,
                stiffness: 300,
            },
            yOffset: {
                damping: 40,
                stiffness: 300,
            },
        },
    },
    bars: {
        "default": {
            cursor: 'pointer',
            fill: settings.primary,
            width: 60,
        },
        easing: {
            opacity: 'gentle',
            x: 'stiff',
        },
    },
    common: {
        fill: settings.primary,
        fillOpacity: settings.fillOpacity,
        mouseOver: {
            fill: settings.primary,
            fillOpacity: settings.fillOpacityOver,
            stroke: settings.primary,
            strokeOpacity: settings.strokeOpacityOver,
        },
        stroke: token_common["ashLighter"],
        strokeDasharray: settings.strokeDasharray,
        strokeOpacity: settings.strokeOpacity,
        strokeWidth: settings.strokeWidth,
    },
    container: {
        background: 'transparent',
    },
    helpers: {
        area: {
            highlight: {
                fill: token_common["ashLightest"],
                opacity: 0.6,
                stroke: 'transparent',
                strokeWidth: 0,
            },
            points: {
                fill: '#FFFFFF',
                opacity: 1,
                pose: {
                    enter: {
                        delay: 50,
                    },
                },
                radius: 5,
                stroke: settings.primary,
                strokeWidth: 2,
            },
            vertical: {
                dot: {
                    fill: '#FFFFFF',
                    opacity: 1,
                    radius: 5,
                    stroke: settings.primary,
                    strokeWidth: 2,
                },
                line: {
                    fill: token_common["ashLighter"],
                    opacity: 1,
                    width: 1,
                },
            },
        },
        bar: {
            highlight: {
                bar: {
                    fill: token_common["ashLightest"],
                    opacity: 1,
                },
                border: {
                    fill: token_common["ashLighter"],
                    height: 3,
                    opacity: 1,
                },
            },
        },
    },
    label: {
        fontFamily: 'Arial, sans-serif',
        fontSize: '13px',
        textAnchor: 'middle',
    },
};
/* harmony default export */ var defaultTheme = (theme);

// CONCATENATED MODULE: ./src/utils/theme/registerTheme.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return registerTheme; });




/**
 * Loads default theme and deep merge if there is a custom theme overwrite
 */
var registerTheme = memoize_one_cjs_default()(function (customTheme) {
    if (customTheme === void 0) { customTheme = {}; }
    return lodash_merge_default()({}, defaultTheme, customTheme);
}, lodash_isequal_default.a);


/***/ })

/******/ });
});