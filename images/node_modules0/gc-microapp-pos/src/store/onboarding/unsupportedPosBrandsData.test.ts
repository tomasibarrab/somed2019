import { Observable } from 'rxjs/Observable';
import { SupportedPosBrand } from '../types';

import { createAsyncMockStore, posBrandMocks, sortedPosBrandMocks } from './onboarding.mocks';

import {
  fetchUnsupportedPosBrands,
  fetchUnsupportedPosBrandsEpic,
  fetchUnsupportedPosBrandsReducer,
  initialState,
  sortPosBrands,
} from './unsupportedPosBrandsData';

describe('Unsupported pos brands', () => {
  describe(' actions', () => {
    it('should create the start action', () => {
      const actual = fetchUnsupportedPosBrands.started(null);
      const expected = { payload: null, type: fetchUnsupportedPosBrands.started.type };

      expect(actual).toEqual(expected);
    });

    it('done should take an array of POS Brands', () => {
      const payload = {
        params: null,
        result: posBrandMocks,
      };
      const actual = fetchUnsupportedPosBrands.done(payload);
      const expected = { type: fetchUnsupportedPosBrands.done.type, payload };

      expect(actual).toEqual(expected);
    });
  });

  describe(' reducers', () => {
    it('should update the state to started for started action', () => {
      const action = {
        payload: null,
        type: fetchUnsupportedPosBrands.started.type,
      };
      const expected = {
        data: undefined,
        status: 'started',
      };

      const result = fetchUnsupportedPosBrandsReducer(initialState, action);
      expect(result).toEqual(expected);
    });

    it('should update the state to done for done action', () => {
      const action = {
        payload: { params: null, result: posBrandMocks },
        type: fetchUnsupportedPosBrands.done.type,
      };
      const expected = {
        data: posBrandMocks,
        status: 'done',
      };

      const result = fetchUnsupportedPosBrandsReducer(initialState, action);
      expect(result).toEqual(expected);
    });

    it('should update the state to failed for failed action', () => {
      const action = {
        payload: { error: {} },
        type: fetchUnsupportedPosBrands.failed.type,
      };
      const expected = {
        data: {},
        status: 'failed',
      };

      const result = fetchUnsupportedPosBrandsReducer(initialState, action);
      expect(result).toEqual(expected);
    });
  });

  describe(' epics', () => {
    it('pass an array of PosBrands to fetchUnsupportedPosBrands.done', () => {
      const mockResponse: Observable<SupportedPosBrand[]> = Observable.of(posBrandMocks);

      const store = createAsyncMockStore(
        { fetchUnqualifiedPosBrands: () => mockResponse },
        fetchUnsupportedPosBrandsEpic,
      );

      store.dispatch(fetchUnsupportedPosBrands.started(null));
      expect(store.getActions()).toEqual([
        fetchUnsupportedPosBrands.started(null),
        fetchUnsupportedPosBrands.done({ params: null, result: sortedPosBrandMocks }),
      ]);
    });

    it('pass an error to fetchUnsupportedPosBrands.failure', () => {
      const mockError = { error: 'some error' };
      const mockResponse: Observable<any> = Observable.throw(mockError);

      const store = createAsyncMockStore(
        { fetchUnqualifiedPosBrands: () => mockResponse },
        fetchUnsupportedPosBrandsEpic,
      );

      store.dispatch(fetchUnsupportedPosBrands.started(null));
      expect(store.getActions()).toEqual([
        fetchUnsupportedPosBrands.started(null),
        fetchUnsupportedPosBrands.failed({ params: null, error: mockError }),
      ]);
    });
  });
});
