import { Observable } from 'rxjs/Observable';
import { addNotification, removeNotificationById } from 'shared-react-smart-ui/NotificationCenter';
import { AsyncState } from '../AsyncState';
import { SupportedPosBrandsIds } from '../types';
import { deselectPosBrand, selectPosBrand } from './onboarding';
import { createAsyncMockStore, posBrandMocks, rideResponseMock } from './onboarding.mocks';
import {
  dismissSavePosBrandErrorsEpic,
  initialState,
  savePosBrand,
  savePosBrandEpic,
  savePosBrandId,
  savePosBrandReducer,
  triggerSavePosBrand,
} from './savePosBrand';

describe('Save POS brand actions', () => {
  it('should create a start action with a sales force id', () => {
    const payload = { salesForceId: 'someSalesForceId123', posBrandId: SupportedPosBrandsIds.Squirrel };
    const actual = savePosBrand.started(payload);
    const expected = { payload, type: savePosBrand.started.type };

    expect(actual).toEqual(expected);
  });

  it('should create a done action', () => {
    const payload = {
      params: { salesForceId: 'someSalesForceId123', posBrandId: SupportedPosBrandsIds.Squirrel },
      result: {},
    };
    const actual = savePosBrand.done(payload);
    const expected = { type: savePosBrand.done.type, payload };

    expect(actual).toEqual(expected);
  });

  it('should create a failed action with some kind of error', () => {
    const payload = {
      error: 'Red Alert!',
      params: { salesForceId: 'someSalesForceId123', posBrandId: SupportedPosBrandsIds.Squirrel },
    };
    const actual = savePosBrand.failed(payload);
    const expected = { type: savePosBrand.failed.type, error: true, payload };

    expect(actual).toEqual(expected);
  });
});

describe('triggerSavePosBrand', () => {
  it('should be triggered by selecting a pos', () => {
    const store = createAsyncMockStore({}, triggerSavePosBrand);

    const startPayload = {
      posBrandId: SupportedPosBrandsIds.Aloha,
      salesForceId: rideResponseMock.salesforceId,
    };

    store.dispatch(selectPosBrand(posBrandMocks[0]));
    expect(store.getActions()).toEqual([selectPosBrand(posBrandMocks[0]), savePosBrand.started(startPayload)]);
  });
});

describe('dismissSavePosBrandErrorsEpic', () => {
  it('should clear the pos brand efforts that might exist', () => {
    const store = createAsyncMockStore({}, dismissSavePosBrandErrorsEpic);

    const startPayload = { salesForceId: 'salesFORCE!', posBrandId: SupportedPosBrandsIds.Dinerware };

    store.dispatch(savePosBrand.started(startPayload));
    expect(store.getActions()).toEqual([savePosBrand.started(startPayload), removeNotificationById(savePosBrandId)]);
  });
});

describe('save pos brand epic', () => {
  it('should make an post the posBrandId to an end point with the salesForceId', () => {
    const mockResponse: Observable<any> = Observable.of({ status: 'success or something' });
    const mockApi = { postSelectedPos: jest.fn(() => mockResponse) };

    const store = createAsyncMockStore(mockApi, savePosBrandEpic);

    const startPayload = { salesForceId: 'salesFORCE!', posBrandId: SupportedPosBrandsIds.Dinerware };

    store.dispatch(savePosBrand.started(startPayload));
    expect(mockApi.postSelectedPos).toHaveBeenLastCalledWith('salesFORCE!', SupportedPosBrandsIds.Dinerware);
    expect(store.getActions()).toEqual([
      savePosBrand.started(startPayload),
      savePosBrand.done({ params: startPayload, result: {} }),
      removeNotificationById(savePosBrandId),
    ]);
  });

  it('should pass the error to the failed action', () => {
    const mockError = { error: 'something, something, dark side' };
    const mockResponse = Observable.throw(mockError);

    const store = createAsyncMockStore({ postSelectedPos: () => mockResponse }, savePosBrandEpic);

    const startPayload = { salesForceId: 'forcingSales345', posBrandId: SupportedPosBrandsIds.Impos };

    store.dispatch(savePosBrand.started(startPayload));
    expect(store.getActions()).toEqual([
      savePosBrand.started(startPayload),
      addNotification({ messageId: 'app.error.general', id: savePosBrandId }),
      savePosBrand.failed({ params: startPayload, error: mockError }),
      deselectPosBrand(),
    ]);
  });
});

describe('savePosBrand reducer', () => {
  it('should set savePosBrand to started when fetchStatus started', () => {
    const action = {
      payload: { salesForceId: 'someSalesForceId123', posBrandId: SupportedPosBrandsIds.Squirrel },
      type: savePosBrand.started.type,
    };
    const expected = { data: undefined, status: 'started' };
    const actual = savePosBrandReducer(initialState, action);

    expect(actual).toEqual(expected);
  });

  const startedStatustate: AsyncState<undefined> = { data: undefined, status: 'started' };

  it('should save if the pos is active to data and set status to "done"', () => {
    const action = {
      payload: {
        params: { salesForceId: 'someSalesForceId123', posBrandId: SupportedPosBrandsIds.Squirrel },
        result: {},
      },
      type: savePosBrand.done.type,
    };

    const expected = { data: undefined, status: 'done' };
    const actual = savePosBrandReducer(startedStatustate, action);
    expect(actual).toEqual(expected);
  });

  it('should save the error when failed', () => {
    const action = { type: savePosBrand.failed.type, payload: { error: 'thrill of night' } };
    const expected = { data: 'thrill of night', status: 'failed' };
    const actual = savePosBrandReducer(startedStatustate, action);

    expect(actual).toEqual(expected);
  });
});
