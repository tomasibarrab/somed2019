import {
  activePricesAndSignedUAFixture,
  availablePricesAndUnsignedUAFixture,
  availablePricesFixture,
  initialStateFixture,
  missingPricesFixture,
  modifiedPricingMock,
  pendingPricesAndSignedUAFixture, pricingBundleResponse,
  productAvailablePrice,
  productsLoadingAllFixture,
  productsLoadingPricesFixture,
  productsLoadingUAFixture,
  productUnsignedUA,
} from '../../../fixtures/products-store-mocks';

import { AgreementType } from '../types';
import { fetchAllProductPrices, generateReducerActionsEpics } from './product';

describe('redux product stuff', () => {
  const testproduct = generateReducerActionsEpics(AgreementType.venga_integration_host);

  describe('product generator', () => {
    it('should have actions', () => {
      expect(testproduct.actions).toHaveProperty('fetchUserAgreement');
    });
    it('should have epics', () => {
      expect(testproduct.epics).toHaveProperty('fetchProductUserAgreementEpic');
    });
    it('should have selectors', () => {
      expect(testproduct.selectors).toHaveProperty('basePrice');
    });
    it('should have a reducer', () => {
      expect(testproduct.reducer).toBeDefined();
    });
  });

  describe('generated selectors', () => {
    describe('basePrice', () => {
      it('should return \'undefined\' when loading or missing prices', () => {
        expect(testproduct.selectors.basePrice(missingPricesFixture)).toBe(undefined);
        expect(testproduct.selectors.basePrice(productsLoadingAllFixture)).toBe(undefined);
      });

      it('should return from UA the first price item that has a termLength', () => {
        expect(testproduct.selectors.basePrice(availablePricesAndUnsignedUAFixture)).toBe(modifiedPricingMock[0]);
        expect(testproduct.selectors.basePrice(productsLoadingPricesFixture)).toBe(modifiedPricingMock[0]);
      });

      it('should return from AddOns the first price item that has a termLength', () => {
        expect(testproduct.selectors.basePrice(productsLoadingUAFixture)).toBe(productAvailablePrice.bundleDetails[0]);
      });
    });

    describe('isActive', () => {
      it('should return true only when UA is active and signed', () => {
        expect(testproduct.selectors.isActive(availablePricesAndUnsignedUAFixture)).toBe(false);
        expect(testproduct.selectors.isActive(pendingPricesAndSignedUAFixture)).toBe(false);

        expect(testproduct.selectors.isActive(activePricesAndSignedUAFixture)).toBe(true);
      });
    });

    describe('isError', () => {
      it('should return true only if prices are missing', () => {
        expect(testproduct.selectors.isError(availablePricesAndUnsignedUAFixture)).toBe(false);
        expect(testproduct.selectors.isError(missingPricesFixture)).toBe(true);
      });
    });

    describe('isLoading', () => {
      it('should check loading status of product data', () => {
        expect(testproduct.selectors.isLoading(productsLoadingAllFixture)).toBe(true);
        expect(testproduct.selectors.isLoading(productsLoadingPricesFixture)).toBe(true);
        expect(testproduct.selectors.isLoading(productsLoadingUAFixture)).toBe(true);

        expect(testproduct.selectors.isLoading(missingPricesFixture)).toBe(false);
        expect(testproduct.selectors.isLoading(availablePricesFixture)).toBe(false);
        expect(testproduct.selectors.isLoading(availablePricesAndUnsignedUAFixture)).toBe(false);
      });
    });

    describe('pricing', () => {
      it('should return all pricing items if pricing loaded', () => {
        expect(testproduct.selectors.pricing(missingPricesFixture)).toBe(undefined);
        expect(testproduct.selectors.pricing(productsLoadingAllFixture)).toBe(undefined);

        expect(testproduct.selectors.pricing(productsLoadingPricesFixture)).toBe(modifiedPricingMock);
        expect(testproduct.selectors.pricing(productsLoadingUAFixture)).toBe(productAvailablePrice.bundleDetails);
      });
    });

    describe('pricingBundle', () => {
      it('should return no pricing data for missing or loading state', () => {
        expect(testproduct.selectors.pricingBundle(missingPricesFixture)).toBe(undefined);
        expect(testproduct.selectors.pricingBundle(productsLoadingAllFixture)).toBe(undefined);
      });

      it('should return original pricing data when no user agreement exists', () => {
        expect(testproduct.selectors.pricingBundle(availablePricesFixture)).toBe(productAvailablePrice);
      });

      it('should return pricing data from UA', () => {
        expect(testproduct.selectors.pricingBundle(availablePricesAndUnsignedUAFixture)).toStrictEqual({
          ...productAvailablePrice,
          bundleDetails: modifiedPricingMock,
        });
      });
    });

    describe('userAgreement', () => {
      it('should return UA if it exists', () => {
        expect(testproduct.selectors.userAgreement(productsLoadingAllFixture)).toBe(undefined);
        expect(testproduct.selectors.userAgreement(availablePricesFixture)).toBe(undefined);

        expect(testproduct.selectors.userAgreement(availablePricesAndUnsignedUAFixture)).toBe(productUnsignedUA);
      });
    });
  });

  describe('reducer', () => {
    it('should start loading the Prices', () => {
      const initialState = initialStateFixture[AgreementType.venga_integration_host];
      const finalState = testproduct.reducer(initialState, fetchAllProductPrices.started(1));

      expect(finalState).toStrictEqual({
        ...initialState,
        price: { status: 'started' },
      })
    });

    it('should finish loading the Prices', () => {
      const doneAction = fetchAllProductPrices.done({
        params: 1,
        result: pricingBundleResponse,
      });

      const initialState = initialStateFixture[AgreementType.venga_integration_host];
      const finalState = testproduct.reducer(initialState, doneAction);

      expect(finalState).toStrictEqual({
        ...initialState,
        price: { status: 'done', data: productAvailablePrice },
      });
    });

    it('should start loading the UA', () => {
      const initialState = initialStateFixture[AgreementType.venga_integration_host];
      const finalState = testproduct.reducer(initialState, testproduct.actions.fetchUserAgreement.started(1));

      expect(finalState).toStrictEqual({
        ...initialState,
        userAgreement: { status: 'started' },
      })
    });

    it('should finish loading the UA', () => {
      const doneAction = testproduct.actions.fetchUserAgreement.done({
        params: 1,
        result: productUnsignedUA,
      });

      const initialState = initialStateFixture[AgreementType.venga_integration_host];
      const finalState = testproduct.reducer(initialState, doneAction);

      expect(finalState).toStrictEqual({
        ...initialState,
        userAgreement: { status: 'done', data: productUnsignedUA },
      });
    });
  });
});
