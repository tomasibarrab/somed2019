/**
 * The flow for retrieving UAs and prices for specific products is the following:
 *
 *                                                  UAS          PRICE     STORE PRODUCT 1     STORE PRODUCT 2
 * fetchUserAgreement(reviews mgr)    (1) ---------->|             |             |                   |
 * fetchUserAgreement(host)           (2) ---------->|             |             |                   |
 * fetchPrices()                      (3) ------------------------>|             |                   |
 *                                                   |             |             |                   |
 *                                        <--- ok ---|             |             |                   |
 * reviews.fetchProductUserAgreement  (4) -------------------------------------->|                   |
 *                                                   |             |             |                   |
 *                                        <--- ok ---|             |             |                   |
 * host.fetchProductUserAgreement     (5) ---------------------------------------------------------->|
 *                                                   |             |             |                   |
 *                                        <------------ ok --------|             |                   |
 * fetchAllProductPrices.done         (6) -------------------------------------->|                   |
 *                                        \--------------------------------------------------------->|
 *
 *
 * 1) & 2) fetch UserAgreements for specific products from UA Svc
 * 3) at the same time, globally fetch add-ons for a specific RID from Pricing Svc
 * 4) & 5) dispatch generated UA .done() actions for each UAS response and update store for each product
 * 6) dispatch generic Prices .done() action with Pricing Svc response
 */

import { BaseAgreementDTO } from '@buffet/user-agreement';
import get from 'lodash/get';
import { combineReducers } from 'redux';
import { createSelector } from 'reselect';
import { actionCreatorFactory } from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';

import 'rxjs/add/observable/of';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/takeUntil';

import {
  AgreementType,
  Epic,
  State,
} from '../types';

import { fetchAllProductPrices, generateReducerActionsEpics, SingleProductState } from './product';


// ---------------------------------------------------------------------------------------------------------------------
// actions
// ---------------------------------------------------------------------------------------------------------------------

export interface UpdateAgreementPayload { product: AgreementType, agreement: BaseAgreementDTO };
const createAction = actionCreatorFactory();

const fetchUserAgreementsAndPrices = createAction('FETCH_USER_AGREEMENTS');
export const selectProduct = createAction<AgreementType>('SELECT_PRODUCT');
export const updateAgreement = createAction<UpdateAgreementPayload>('UPDATE_AGREEMENT');


export const actions = {
  fetchUserAgreementsAndPrices,
  selectProduct,
  updateAgreement,
};


// ---------------------------------------------------------------------------------------------------------------------
// generate actions, epics and reducers for different products
// ---------------------------------------------------------------------------------------------------------------------

const productHost = generateReducerActionsEpics(AgreementType.venga_integration_host);
const productReviewManager = generateReducerActionsEpics(AgreementType.venga_integration_review_manager);
const productLegacy = generateReducerActionsEpics(AgreementType.venga_legacy_customer);

const allStandardProducts = [productReviewManager, productHost];
const allProducts = [productReviewManager, productHost, productLegacy];
const allProductsMap = {
  [AgreementType.venga_integration_host]: productHost,
  [AgreementType.venga_integration_review_manager]: productReviewManager,

  // adding this to satisfy ts, since no agreement would be updated for legacy
  [AgreementType.venga_legacy_customer]: productLegacy,
};


// ---------------------------------------------------------------------------------------------------------------------
// epics
// ---------------------------------------------------------------------------------------------------------------------

// (1) (2) (3): this will trigger fetching of all user agreements and products for a given RID
const fetchUserAgreementsAndPricesEpic: Epic = (action$, store) =>
  action$
    .ofType(fetchUserAgreementsAndPrices.type)
    .map(() => ({
      rid: store.getState().currentContext.restaurant.rid,
    }))
    .flatMap(({ rid }) => [
      ...allStandardProducts.map(product => product.actions.fetchUserAgreement.started(rid)), // (1) & (2)
      fetchAllProductPrices.started(rid), // (3)
    ]);

// this will fetch products and prices for given RID
// on success, it will dispatch a .done() action that will be intercepted by the generated product epics
const fetchAllProductPricesEpic: Epic = (action$, store, { api }) =>
  action$
    .filter(fetchAllProductPrices.started.match)
    .switchMap(({ payload: rid }) =>
      api.getProductPricing(rid) // (3)
        .map(result => fetchAllProductPrices.done({ params: rid, result })) // (6)
        .catch(error => [
          fetchAllProductPrices.failed({ params: rid, error }),
        ]),
    );

const updateAgreementEpic: Epic = (action$, store) =>
  action$
    .ofType(updateAgreement.type)
    .map(({ payload }: { payload: UpdateAgreementPayload }) => allProductsMap[payload.product]
      .actions.fetchUserAgreement.done({
        params: store.getState().currentContext.restaurant.rid,
        result: payload.agreement,
      }));

export const epics = [
  fetchAllProductPricesEpic,
  fetchUserAgreementsAndPricesEpic,
  updateAgreementEpic,
  ...allStandardProducts.map(product => product.epics.fetchProductUserAgreementEpic),
];


// ---------------------------------------------------------------------------------------------------------------------
// reducers
// ---------------------------------------------------------------------------------------------------------------------

export const initialSelectedProduct: (AgreementType | null) = null;
export const selectedProductReducer = reducerWithInitialState<AgreementType | null>(initialSelectedProduct)
  // tslint:disable-next-line:no-shadowed-variable
  .case(selectProduct, (state, selectedProduct) => selectedProduct);

export interface ProductsState {
  [AgreementType.venga_integration_review_manager]: SingleProductState;
  [AgreementType.venga_integration_host]: SingleProductState;
  [AgreementType.venga_legacy_customer]: SingleProductState;
  selectedProduct: AgreementType | null;
}

// see the order of the products in allProducts
export const reducer = combineReducers<ProductsState>({
  [AgreementType.venga_integration_review_manager]: productReviewManager.reducer,
  [AgreementType.venga_integration_host]: productHost.reducer,
  [AgreementType.venga_legacy_customer]: productLegacy.reducer,
  selectedProduct: selectedProductReducer,
});


// ---------------------------------------------------------------------------------------------------------------------
// selectors
// ---------------------------------------------------------------------------------------------------------------------

const baseSelector = (state: State) => state.products;
const selectedProduct = (state: State) => state.products.selectedProduct;

const productsBasePrices = createSelector(
  baseSelector,
  state => ({
    [AgreementType.venga_integration_review_manager]: productReviewManager.selectors.basePrice(state),
    [AgreementType.venga_integration_host]: productHost.selectors.basePrice(state),
    [AgreementType.venga_legacy_customer]: productLegacy.selectors.basePrice(state),
  }),
);

const productsPriceBundles = createSelector(
  baseSelector,
  state => ({
    [AgreementType.venga_integration_review_manager]: productReviewManager.selectors.pricingBundle(state),
    [AgreementType.venga_integration_host]: productHost.selectors.pricingBundle(state),
    [AgreementType.venga_legacy_customer]: productLegacy.selectors.pricingBundle(state),
  }),
);

/**
 * Tricky, because normally all the price bundles need to be present for the app to function, unless this rid has
 * the legacy bundle, in which case the other venga bundles will be absent
 */
const productsValidPrices = createSelector(
  baseSelector,
  state => (
    !allStandardProducts.map(product => product.selectors.pricingBundle(state))
      .some(pricingBundle => pricingBundle === undefined)
    || productLegacy.selectors.pricingBundle(state) !== undefined
  ),
);

const productsUserAgreements = createSelector(
  baseSelector,
  state => (
    allStandardProducts
      .map(product => product.selectors.userAgreement(state))
      .filter(ua => ua !== undefined) as BaseAgreementDTO[]
  ),
);

const isActiveProduct = createSelector(
  baseSelector,
  (state): boolean => (
    allProducts
      .some(product => product.selectors.isActive(state))
  ),
);

const legalEntity = createSelector(
  productsUserAgreements,
  userAgreements => get(
    userAgreements.find(ua => ua.agreementDetails !== undefined),
    ['agreementDetails', 'legalEntity'],
    undefined,
  ),
);

const signedUA = createSelector(
  productsUserAgreements,
  userAgreements => userAgreements.find(ua => ua.isSigned),
);

const signedUAEmail = createSelector(
  signedUA,
  (signedUserAgreement): string | null =>
    get(signedUserAgreement, ['agreementDetails', 'signingDetails', 'userEmail'], null),
);

const isUASigned = createSelector(
  signedUA,
  signedUserAgreement => signedUserAgreement !== undefined,
);

const productsLoading = createSelector(
  baseSelector,
  (state) => (
    allProducts
      .map(product => product.selectors.isLoading(state))
      .includes(true)
  ),
);

const productsErrors = createSelector(
  baseSelector,
  (state) => (
    allProducts
      .map(product => product.selectors.isError(state))
      .includes(true)
  ),
);

const selectedProductPriceBundle = createSelector(
  productsPriceBundles,
  selectedProduct,
  (priceBundles, aSelectedProduct) => aSelectedProduct && priceBundles[aSelectedProduct] || undefined,
);

const subscriptionSkus = ['VSYS001', 'VSYS002'];
const installationSkus = ['VSAC001', 'VSAC002'];

const selectedProductSubscriptionPrice = createSelector(
  selectedProductPriceBundle,
  priceBundle => priceBundle && priceBundle.bundleDetails.find(data => subscriptionSkus.includes(data.productCode))
    || undefined,
);

const selectedProductOneTimePrice = createSelector(
  selectedProductPriceBundle,
  priceBundle => priceBundle && priceBundle.bundleDetails.find(data => installationSkus.includes(data.productCode))
    || undefined,
);


export const selectors = {
  isActiveProduct,
  isUASigned,
  legalEntity,
  productsBasePrices,
  productsErrors,
  productsLoading,
  productsPriceBundles,
  productsValidPrices,
  selectedProductOneTimePrice,
  selectedProductPriceBundle,
  selectedProductSubscriptionPrice,
  signedUAEmail,
};
