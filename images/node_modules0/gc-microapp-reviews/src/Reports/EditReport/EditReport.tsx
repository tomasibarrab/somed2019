/**
 * EditReport Components
 *
 * A connected component which relies on the store to pull in a Report model,
 * and dispatches actions to the store for updating/adding a report and cancelling out.
 *
 * Currently, the component relies on local state to hold updates to the form.
 * The main benefit is that when the component is unmounted after a cancel, the model
 * is not affected in the store, so there is no cleanup needed.
 *
 * The component also handles dispatching a different action if it's a new report
 * or an update to an existing report. When creating a new report, this component
 * also assembles the Creator and RestaurantIds from currentContext in order to satisfy
 * requirements from the Review Reports API.
 */

import { Button } from 'gca-react-components';
import React from 'react';
import { FormattedMessage, InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';
import Select from 'react-select';
import 'react-select/dist/react-select.css';
import {
  addReport,
  editNewReportToggle,
  editReportActiveUpdate,
  NewReport,
  Report,
  ReportFrequency,
  ReportType,
  UpdatedReport,
  updateReport,
} from '../../store/reports/reports';
import { State } from '../../store/types';
import './EditReport.scss';
import { emailsAreAllValid, emailsToList, sanitizeEmails } from './emailUtils';

interface SP {
  report: Report;
  userEmail: string;
  rid: number;
  isUpdating: boolean;
}

interface DP {
  editReportActiveUpdate(id: string | null): void;
  editNewReportToggle(): void;
  updateReportRequest(report: UpdatedReport): void;
  addReportRequest(report: NewReport): void;
}

interface OP {
  isCreate?: boolean;
  reportId?: string;
}

interface BaseProps extends SP, DP, OP {}
interface Props extends BaseProps, InjectedIntlProps {}

interface EditReportState extends Report {
  invalidEmails: boolean;
  RecipientsString: string;
  valid: boolean;
}

class EditReport extends React.Component<Props, EditReportState> {
  constructor(props: Props) {
    super(props);

    this.state = {
      ...props.report,
      RecipientsString: props.report.Recipients.join('\n'),
      invalidEmails: false,
      valid: false,
    };
  }

  public render() {
    const errorClass = this.state.invalidEmails ? 'error' : '';

    const frequencies = [
      { value: 'Daily', label: this.props.intl.formatMessage({ id: 'reports.daily' }) },
      { value: 'Weekly', label: this.props.intl.formatMessage({ id: 'reports.weekly' }) },
      { value: 'Monthly', label: this.props.intl.formatMessage({ id: 'reports.monthly' }) },
    ];

    const reportTypes = [
      { value: 'Detailed', label: this.props.intl.formatMessage({ id: 'reports.detailed' }) },
      { value: 'RatingsOnly', label: this.props.intl.formatMessage({ id: 'reports.ratingOnly' }) },
    ];

    const textAreaPlaceholderText = this.props.intl.formatMessage({ id: 'reports.textAreaPlaceholder' });
    const saveButtonText = this.props.isCreate ? 'reports.add' : 'reports.save';

    return (
      <tr className="gca-edit-report">
        <td>
          <Select
            clearable={false}
            name="Frequency"
            value={this.state.Frequency}
            options={frequencies}
            onChange={this.handleFrequencyChange}
          />
        </td>
        <td>
          <Select
            clearable={false}
            name="Type"
            value={this.state.Type}
            options={reportTypes}
            onChange={this.handleTypeChange}
          />
        </td>
        <td>
          <textarea
            placeholder={textAreaPlaceholderText}
            name="Recipients"
            className={errorClass}
            onChange={this.handleRecipientsChange}
            onBlur={this.handleRecipientsBlur}
            value={this.state.RecipientsString}
          />
        </td>
        <td>
          <Button theme="bare" onClick={this.handleCancelClick}>
            <FormattedMessage id="reports.cancel" />
          </Button>
          <Button
            disabled={!this.state.valid}
            busy={this.props.isUpdating}
            style={{ height: '40px', width: '100px' }}
            theme="primary"
            onClick={this.handleSaveClick}
          >
            <FormattedMessage id={saveButtonText} />
          </Button>
        </td>
      </tr>
    );
  }

  // eslint-disable-next-line no-undef
  private handleRecipientsChange = (e: React.FormEvent<HTMLTextAreaElement>) => {
    this.setState({ RecipientsString: e.currentTarget.value });
    if (this.state.invalidEmails) {
      this.setState({ invalidEmails: !emailsAreAllValid(e.currentTarget.value) });
    }
    this.validate();
  };

  // eslint-disable-next-line no-undef
  private handleRecipientsBlur = (e: React.FormEvent<HTMLTextAreaElement>) => {
    this.setState({ invalidEmails: !emailsAreAllValid(e.currentTarget.value) });
    this.validate();
  };

  private handleFrequencyChange = ({ value }: { value: ReportFrequency }) => {
    this.setState({ Frequency: value });
    this.validate();
  };

  // eslint-disable-next-line react/no-unused-prop-types
  private handleTypeChange = ({ value }: { value: ReportType }) => {
    this.setState({ Type: value });
    this.validate();
  };

  private validate = () => {
    const valid = !!this.state.Type && !!this.state.Frequency && !!this.state.Recipients;
    this.setState({ valid });
  };

  private handleCancelClick = () => {
    if (this.props.isCreate) {
      this.props.editNewReportToggle();
    } else {
      this.props.editReportActiveUpdate(null);
    }
  };

  private handleSaveClick = () => {
    if (this.props.isCreate) {
      const { Frequency, RecipientsString, Type } = this.state;

      this.props.addReportRequest({
        Creator: this.props.userEmail,
        Frequency,
        Recipients: emailsToList(sanitizeEmails(RecipientsString)),
        ReportId: 'new',
        RestaurantIds: [this.props.rid],
        Type,
      });
    } else {
      const { Frequency, RecipientsString, ReportId, RestaurantIds, Type } = this.state;

      this.props.updateReportRequest({
        Editor: this.props.userEmail,
        Frequency,
        Recipients: emailsToList(sanitizeEmails(RecipientsString)),
        ReportId,
        RestaurantIds,
        Type,
      });
    }
  };
}

function mapState(state: State, ownProps: OP) {
  let report;

  if (ownProps.reportId) {
    report = state.reports.reports[ownProps.reportId];
  } else {
    report = state.reports.newReport;
  }

  return {
    editNewReportOpen: state.reports.editNewReportOpen,
    isUpdating: state.reports.isUpdating,
    report,
    rid: state.currentContext.restaurant.rid,
    userEmail: state.currentContext.user.userName,
  };
}

const mapDispatch = {
  addReportRequest: addReport.started,
  editNewReportToggle,
  editReportActiveUpdate,
  updateReportRequest: updateReport.started,
};

export default connect<SP, DP, OP>(mapState, mapDispatch)(injectIntl<BaseProps>(EditReport));
export { EditReport as PureEditReport };
