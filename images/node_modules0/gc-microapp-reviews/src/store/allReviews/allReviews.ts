import { Action, actionCreatorFactory, Success } from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';

import { sendReviewReply } from '../../store/sharedActions';
import { Epic, State } from '../../store/types';

// --------------------------------- //
// Types
// --------------------------------- //

export interface ReviewsDTO {
  Reviews: ReviewDTO[];
  TotalCount: number;
}

/**
 * Possible keys: Ambience, Food, Noise, Overall, Service, Value
 */
export interface Rating {
  [rating: string]: number;
}

interface Category {
  Label: string;
}

export const enum From {
  Restaurant = 'Restaurant',
  Reviewer = 'Reviewer',
}

export interface Reply {
  ReplyId: string;
  ResponseDateTimeUtc: string;
  Message: string;
  From: From;
  RestaurantId: number;
  ReviewId: string;
  Name: string;
  Role: string;
}

interface ReviewDTO {
  Categories: Category[];
  CustomerNickname: string;
  DinedDateTime: string;
  Rating: Rating;
  Recommended: boolean;
  Replies?: Reply[];
  RestaurantComment: string;
  ReviewId: string;
  ReviewText: string;
  SimplifiedModerationState: string;
  SubmissionDateTimeUtc: string;
}

export interface Review extends ReviewDTO {
  HasNewReply: boolean;
  Replies: Reply[];
}

export interface Reviews {
  [reportId: string]: Review;
}

export interface ReviewsState {
  error: boolean;
  lastVisit: string;
  loading: boolean;
  page: number;
  pageSize: number;
  reviewIds: string[];
  reviews: Reviews;
  totalReviews: number;
}

// --------------------------------- //
// Actions
// --------------------------------- //

const actionCreator = actionCreatorFactory('REVIEWS');

export const fetchReviews = actionCreator('FETCH');
export const fetchReviewsRequest = actionCreator.async<{}, ReviewsDTO>('FETCH_REQUEST');
export const selectPage = actionCreator<{ selected: number }>('SELECT_PAGE');

// --------------------------------- //
// Reducer
// --------------------------------- //

import { createSelector } from 'reselect';
import { transformArrayToObject } from '../../utils/reducer-helpers';

const lastVisitLocalStorageKey = 'gcaReviewsLastVisitDate';

export const initialState: ReviewsState = {
  error: false,
  lastVisit: localStorage.getItem(lastVisitLocalStorageKey) || new Date().toISOString(),
  loading: false,
  page: 0,
  pageSize: 20,
  reviewIds: [],
  reviews: {},
  totalReviews: 0,
};

export const reviewFromDTO = (lastVisit: string) => (review: ReviewDTO): Review => {
  const Replies = review.Replies || [];
  const HasNewReply = Replies.length > 0 && Replies.some(reply => reply.ResponseDateTimeUtc > lastVisit);

  return {
    ...review,
    HasNewReply,
    Replies,
  };
};

export const allReviewsReducer = reducerWithInitialState(initialState)
  .case(fetchReviewsRequest.started, (state, payload) => ({
    ...state,
    error: false,
    loading: true,
  }))
  .caseWithAction(fetchReviewsRequest.done, (state, { payload: { result }, meta }) => {
    // Keep a reference here since we're about to update.
    const lastVisit = state.lastVisit;
    const now = new Date().toISOString();
    localStorage.setItem(lastVisitLocalStorageKey, now);

    return {
      ...state,
      error: false,
      lastVisit: now,
      loading: false,
      page: meta && meta.filtersChanged ? 0 : state.page,
      reviewIds: result.Reviews.map(review => review.ReviewId),
      reviews: transformArrayToObject(result.Reviews.map(reviewFromDTO(lastVisit)), 'ReviewId'),
      totalReviews: result.TotalCount,
    };
  })
  .case(fetchReviewsRequest.failed, (state, payload) => ({ ...state, loading: false, error: true }))
  .case(selectPage, (state, payload) => ({
    ...state,
    page: payload.selected,
  }))
  .case(sendReviewReply.done, (state, { result }) => {
    const Replies = state.reviews[result.ReviewId].Replies.concat(result);
    const review = {
      ...state.reviews[result.ReviewId],
      Replies,
    };
    const reviews = {
      ...state.reviews,
      [result.ReviewId]: review,
    };

    return {
      ...state,
      reviews,
    };
  });

// --------------------------------- //
// Selectors
// --------------------------------- //

export const baseSelector = (state: State) => state.allReviews;
export const jsSelector = createSelector(baseSelector, base => base);

export const allReviewsSelector = createSelector(jsSelector, js => {
  const empty = js.loading === false && js.error === false && js.reviewIds.length === 0;
  return Object.assign({}, js, { empty });
});

// --------------------------------- //
// Epics
// --------------------------------- //

import 'rxjs/add/observable/merge';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/retry';
import 'rxjs/add/operator/switchMap';
import { Observable } from 'rxjs/Observable';

import { buildAllReviewsQueryString } from '../../utils/api';
import { compose } from '../../utils/functional-helpers';
import * as filters from '../reviewFilters/reviewFilters';

const buildQuery = (state: State) => {
  const filtersChanged = filters.changed(state);

  const skipReviews = filtersChanged ? 0 : state.allReviews.page * state.allReviews.pageSize;

  return {
    dateFilter: filters.dateFilter.selector(state).pending,
    endDate: filters.dateRange.selector(state).pending.end,
    includeRatingsOnly: filters.includeRatingsOnly.selector(state).pending,
    numberOfReviews: state.allReviews.pageSize,
    overallRating: filters.overallRating.selector(state).pending.join(','),
    rid: state.currentContext.restaurant.rid,
    skipReviews,
    sortBy: filters.dateFilter.selector(state).pending,
    sortOrder: 'Descending',
    startDate: filters.dateRange.selector(state).pending.start,
  };
};

const getQueryStringFromStore = compose(buildAllReviewsQueryString, buildQuery);

export const allReviewsEpic: Epic = (action$, store, { api }) => {
  const makeRequest = () => {
    const state = store.getState();
    const filtersChanged = filters.changed(state);
    const rid = state.currentContext.restaurant.rid;
    const queryString = getQueryStringFromStore(state);

    const useGateway = state.featureToggles.features.featureGcaRespondToReviews !== undefined;

    const apiStream = useGateway
      ? api.fetchAllReviewsViaGateway({ queryString: `${queryString}&withReplies=true` })
      : api.fetchAllReviews({ rid, queryString });

    return apiStream
      .map(result => fetchReviewsRequest.done({ params: {}, result }, { filtersChanged }))
      .catch(response => Observable.of(fetchReviewsRequest.failed(response.err)));
  };

  return (
    action$
      // TODO: Update these actions to conform to FSA
      .filter(({ type, applyOnSet }: any) => {
        const state = store.getState();
        const hasChanged = filters.changed(state);
        const isValid = filters.valid(state);

        if (type === fetchReviews.type) {
          return true;
        }
        if (type === selectPage.type) {
          return true;
        }
        if (type === filters.APPLY_FILTERS && hasChanged && isValid) {
          return true;
        }
        if (type === filters.SET_FILTER && hasChanged && isValid && applyOnSet) {
          return true;
        }

        return false;
      })
      .switchMap(() => Observable.merge(Observable.of(fetchReviewsRequest.started({})), makeRequest()))
  );
};
