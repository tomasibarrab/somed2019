"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslint_1 = require("tslint");
const typescript_1 = require("typescript");
const is_hook_call_1 = require("./is-hook-call");
const error_messages_1 = require("./error-messages");
const is_binary_conditional_expression_1 = require("./is-binary-conditional-expression");
const is_component_or_hook_identifier_1 = require("./is-component-or-hook-identifier");
const is_react_component_decorator_1 = require("./is-react-component-decorator");
class ReactHooksNestingWalker extends tslint_1.RuleWalker {
    visitCallExpression(node) {
        if (is_hook_call_1.isHookCall(node)) {
            this.visitHookAncestor(node, node.parent);
        }
        super.visitCallExpression(node);
    }
    visitHookAncestor(hookNode, ancestor) {
        /**
         * Fail for:
         * * if statements
         * * conditional expressions (binary and ternary)
         * * switch statements
         * * iterations statements
         * * classes
         */
        if (typescript_1.isIfStatement(ancestor) ||
            typescript_1.isSwitchStatement(ancestor) ||
            typescript_1.isConditionalExpression(ancestor) ||
            is_binary_conditional_expression_1.isBinaryConditionalExpression(ancestor) ||
            typescript_1.isSourceFile(ancestor) ||
            typescript_1.isClassDeclaration(ancestor)) {
            this.addFailureAtNode(hookNode, error_messages_1.ERROR_MESSAGES[ancestor.kind]);
            return;
        }
        else if (typescript_1.isIterationStatement(ancestor, false)) {
            this.addFailureAtNode(hookNode, error_messages_1.ERROR_MESSAGES.iterationStatement);
            return;
        }
        /**
         * Finish visiting ancestors if the following node is encountered:
         * * `FunctionDeclaration`
         * * `VariableDeclaration`
         * * `FunctionExpression`
         *
         * If it not is a hook or a component, fail, as hooks cannot be nested inside arbitrary
         * functions.
         */
        if (typescript_1.isFunctionDeclaration(ancestor)) {
            /**
             * Allow using hooks inside functions that are hooks or components.
             *
             * ```ts
             * function useCustomHook() {
             *   useEffect();
             * }
             *
             * function MyComponent() {
             *   useEffect();
             * }
             * ```
             */
            if (ancestor.name && is_component_or_hook_identifier_1.isComponentOrHookIdentifier(ancestor.name)) {
                return;
            }
            // Disallow using hooks inside other kinds of functions
            this.addFailureAtNode(hookNode, error_messages_1.ERROR_MESSAGES.invalidFunctionDeclaration);
            return;
        }
        else if (typescript_1.isArrowFunction(ancestor) || typescript_1.isFunctionExpression(ancestor)) {
            /**
             * Allow declaring custom hooks and components using arrow functions and function expressions
             *
             * ```ts
             * const useCustomHook = () => {
             *   useEffect();
             * }
             *
             * const MyComponent = function() {
             *   useEffect();
             * }
             * ```
             */
            if (typescript_1.isVariableDeclaration(ancestor.parent) &&
                typescript_1.isIdentifier(ancestor.parent.name) &&
                is_component_or_hook_identifier_1.isComponentOrHookIdentifier(ancestor.parent.name)) {
                return;
            }
            /**
             * Allow using hooks when the function is passed to `React.memo` or `React.forwardRef`
             */
            if (typescript_1.isCallExpression(ancestor.parent) &&
                is_react_component_decorator_1.isReactComponentDecorator(ancestor.parent.expression)) {
                return;
            }
            // Disallow using hooks inside other kinds of functions
            this.addFailureAtNode(hookNode, error_messages_1.ERROR_MESSAGES.invalidFunctionExpression);
            return;
        }
        this.visitHookAncestor(hookNode, ancestor.parent);
    }
}
exports.ReactHooksNestingWalker = ReactHooksNestingWalker;
