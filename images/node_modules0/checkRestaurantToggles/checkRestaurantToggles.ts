import 'whatwg-fetch';

/* Interfaces */
interface FeatureToggles {
  [key: string]: string[];
}

export enum CheckType {
  all = 'all',
  any = 'any',
}

type CheckCachedToggles = (rid: number, features: string | string[], check?: CheckType) => boolean;
type CheckRestaurantToggles = (rid: number, features: string | string[], check?: CheckType) => Promise<boolean>;

// Cache feature toggles in order to not make the call each time
const cachedFeatureToggles: FeatureToggles = {};

// Cache actual requests for RID feature toggles to be reused
const ridFeatureTogglesRequests: { [key: string]: any } = {};


// A request resource that calls the Feature Manager, gets the list of features for a RID, and caches the result
function fetchAndCacheFeatureToggles(rid: string) {
  return fetch(
    `/gateway/proxies/featureManager/v3/api/restaurant/${rid}/toggles`,
    {
      credentials: 'same-origin',
    },
  )
    .then((response) => {
      // throw any 400 or 500
      if (response.status >= 400) {
        throw response;
      }
      return response.json();
    })
    .then((response: string[]) => {
      // cache the Feature Toggles for this RID
      cachedFeatureToggles[rid.toString()] = response;
    });
}

// returns the existence of a single or a list of feature toggles for a specified rid from the cached object
const checkCachedRestaurantToggles: CheckCachedToggles = (rid, features, check = CheckType.any) => {
  // get cached feature toggles for rid
  const ridFeatureToggles = cachedFeatureToggles[rid.toString()];

  if (!ridFeatureToggles) {
    return false;
  }

  // check a single feature toggle
  if (typeof features === 'string') {
    // return the existence of that feature toggle
    return ridFeatureToggles.includes(features);
  }

  if (check === CheckType.all) {
    // when checking for ALL, we need to start from a 'true' assumption, then return 'false' if any FT is not set
    return features.reduce((allPrevious, ft) => (allPrevious && ridFeatureToggles.includes(ft)), true);
  } else {
    // when checking for ANY, we need to assume 'false', then return 'true' as soon as a FT is set
    return features.reduce((anyPrevious, ft) => (anyPrevious || ridFeatureToggles.includes(ft)), false);
  }
};


/**
 * This function will call the Feature Manager API for a specific RID,
 * will collect all enabled Feature Toggles for that RID,
 * and will check the existence of ANY or ALL Feature Toggles requested.
 *
 * If the Feature Toggles were previously cached for that RID,
 * it will immediately resolve from the cached object.
 *
 * If a request is already in progress, it will reuse that resource rather than make a separate identical call.
 *
 * This function is also exported as a default.
 *
 * @param rid
 * @param features
 * @param check
 */
export const checkRestaurantToggles: CheckRestaurantToggles = (rid, features, check = CheckType.any) => {
  // immediately return from cached values for current RID
  if (typeof cachedFeatureToggles[rid.toString()] !== 'undefined') {
    return Promise.resolve(checkCachedRestaurantToggles(rid, features, check));
  }

  // if no request is in progress, start one
  if (typeof ridFeatureTogglesRequests[rid.toString()] === 'undefined') {
    ridFeatureTogglesRequests[rid.toString()] = fetchAndCacheFeatureToggles(rid.toString())
      .then(() => {
        // clear the fetching resource
        ridFeatureTogglesRequests[rid.toString()] = undefined;
      });
  }

  // use an existing request resource
  return ridFeatureTogglesRequests[rid.toString()]
    .then(() => checkCachedRestaurantToggles(rid, features, check));
};

// also make available as a default
export default checkRestaurantToggles;
