// tslint:disable:max-line-length
import {
  actions as currentContextActions,
  currentContextEpic,
  selectors as currentContextSelectors,
} from 'gca-react-components/src/redux-modules/currentContext';
import configureMockStore from 'redux-mock-store';
import { createEpicMiddleware } from 'redux-observable';
import { Observable } from 'rxjs';
import { Action, AnyAction } from 'typescript-fsa';
import UserMock from '../../../fixtures/UserMock.json';
import AsyncStatus from '../../AsyncStatus';
import {
  actions,
  initialState as INITIAL_STATE,
  myProfileEpic,
  myProfileReducer,
  selectors,
} from './myProfile';


/* eslint-disable max-len */
describe('myProfile redux-module', () => {
  const defaultState = {
    currentContext: null,
    language: null,
    myProfile: {
      ...INITIAL_STATE,
    },
  };

  const err = {
    error: 'bar',
    params: 'foo',
  };

  describe('myProfile action creators', () => {

    it('should return a properly formatted action for fetchUser.started()', () => {
      const payload = UserMock.email;
      const actual = actions.fetchUser.started(payload);
      const expected = { payload, type: actions.fetchUser.started.type };

      expect(actual).toEqual(expected);
    });

    it('should return a properly formatted action for fetchUser.done()', () => {
      const payload = { params: UserMock.email, result: UserMock };
      const actual = actions.fetchUser.done(payload);
      const expected = { type: actions.fetchUser.done.type, payload };

      expect(actual).toEqual(expected);
    });

    it('should return a properly formatted action for fetchUser.failed()', () => {
      const actual = actions.fetchUser.failed(err);
      const expected = { error: true, payload: err, type: actions.fetchUser.failed.type };

      expect(actual).toEqual(expected);
    });

    it('should return a properly formatted action for updateUser.started()', () => {
      const payload = UserMock;
      const actual = actions.updateUser.started(payload);
      const expected = { payload, type: actions.updateUser.started.type };

      expect(actual).toEqual(expected);
    });

    it('should return a properly formatted action for updateUser.done()', () => {
      const payload = UserMock;
      const actual = actions.updateUser.done(payload);
      const expected = { payload, type: actions.updateUser.done.type };

      expect(actual).toEqual(expected);
    });

    it('should return a properly formatted action for updateUser.failed()', () => {
      const actual = actions.updateUser.failed(err);
      const expected = { error: true, payload: err, type: actions.updateUser.failed.type };

      expect(actual).toEqual(expected);
    });

    it('should return a properly formatted action for resetUpdateUser', () => {
      const actual = actions.resetUpdateUser();
      const expected = { type: actions.resetUpdateUser.type };

      expect(actual).toEqual(expected);
    })
  });

  describe('myProfile selectors', () => {

    it('should return fetchUserState from the state', () => {
      expect(selectors.getFetchUserStatus(defaultState)).toEqual(AsyncStatus.Initial);
      const newState = {
        ...defaultState,
        myProfile: {
          ...INITIAL_STATE,
          fetchUserStatus: AsyncStatus.Done,
        },
      };
      expect(selectors.getFetchUserStatus(newState)).toEqual(AsyncStatus.Done);
    });

    it('should return updateUserState from the state', () => {
      expect(selectors.getUpdateUserStatus(defaultState)).toEqual(AsyncStatus.Initial);
      const newState = {
        ...defaultState,
        myProfile: {
          ...INITIAL_STATE,
          updateUserStatus: AsyncStatus.Done,
        },
      };
      expect(selectors.getUpdateUserStatus(newState)).toEqual(AsyncStatus.Done);
    });

  });

  describe('myProfile epics', () => {
    let assignMock;
    const userName = 'gca-test-monorepo@mailinator.com';
    const rid = 241;
    const basicUser = {
      email: userName,
      rid,
    }
    function createMockState(myProfileInit) {
      return {
        ...defaultState,
        currentContext: {
          isFetching: true,
          productType: 'Guest_Center',
          user: {
            rid,
            userName,
          },
        },
        myProfile: {
          ...INITIAL_STATE,
          ...myProfileInit,
        },
      };
    }

    function createAsyncMockStore(
        response: any,
        apiName: string,
        storeInit: object,
        anEpic: (action$, store, dependencies) => Observable<{}>) {
      const mockState = createMockState(storeInit);
      const mockResponse = () => Observable.of(response);
      const dependencies: any = { api: { [apiName]: mockResponse } };
      const rootEpic = (action$, store) => anEpic(action$, store, dependencies);
      const epicMiddleware = createEpicMiddleware(rootEpic);
      const mockStore = configureMockStore([epicMiddleware]);
      return mockStore(mockState);
    }

    function createMockStore(
        storeInit: object,
        anEpic: (action$, store) => Observable<{}>) {
      const mockState = createMockState(storeInit);
      const rootEpic = (action$, store) => anEpic(action$, store);
      const epicMiddleware = createEpicMiddleware(rootEpic);
      const mockStore = configureMockStore([epicMiddleware]);
      return mockStore(mockState);
    }

    beforeEach(() => {
      assignMock = jest.fn();
      window.location.assign = assignMock;
    });

    it('currentContext fetch success should trigger fetchUserEpic successfully', () => {
      const store = createAsyncMockStore(
        UserMock,
        'fetchUser',
        {
          myProfile: INITIAL_STATE,
        },
        myProfileEpic,
      );
      store.dispatch(currentContextActions.fetchCurrentContextSucceeded());
      expect(store.getActions()).toEqual([
        currentContextActions.fetchCurrentContextSucceeded(),
        actions.fetchUser.started(basicUser),
        actions.fetchUser.done({ params: basicUser, result: UserMock }),
      ]);
    });

    it('should fetch user successfully', () => {
      const store = createAsyncMockStore(
        UserMock,
        'fetchUser',
        {
          myProfile: INITIAL_STATE,
        },
        myProfileEpic,
      );
      store.dispatch(actions.fetchUser.started(UserMock.email));

      expect(store.getActions()).toEqual([
        actions.fetchUser.started(UserMock.email),
        actions.fetchUser.done({ params: UserMock.email, result: UserMock }),
      ]);
    });

    it('should update user successfully', () => {
      const store = createAsyncMockStore(
        {},
        'updateUser',
        {
          myProfile: INITIAL_STATE,
          user: UserMock,
        },
        myProfileEpic,
      );
      store.dispatch(actions.updateUser.started(UserMock));

      expect(store.getActions()).toEqual([
        actions.updateUser.started(UserMock),
        actions.updateUser.done({ params: UserMock, result: {} }),
      ]);
    });

    it('should update user email successfully', () => {
      const store = createAsyncMockStore(
        {},
        'updateUser',
        {
          myProfile: INITIAL_STATE,
          user: UserMock,
        },
        myProfileEpic,
      );

      const updatedUser = { ...UserMock, email: 'jane.bloe@me.com' };
      store.dispatch(actions.updateUser.started(updatedUser));

      expect(store.getActions()).toEqual([
        actions.updateUser.started(updatedUser),
        actions.updateUser.done({ params: updatedUser, result: {} }),
      ]);

      expect(assignMock.mock.calls[0][0]).toBe('/login');
    });
  });

  describe('myProfile reducers', () => {

    it('should set fetchUser to AsyncStatus.Started', () => {
      const initialState = { ...INITIAL_STATE, fetchUserStatus: AsyncStatus.Initial };
      const action = { type: actions.fetchUser.started.type };
      const expected = { ...INITIAL_STATE, fetchUserStatus: AsyncStatus.Started};
      const actual = myProfileReducer(initialState, action);

      expect(actual).toEqual(expected);
    });

    it('should set fetchUser to AsyncStatus.Done', () => {
      const initialState = { ...INITIAL_STATE, fetchUserStatus: AsyncStatus.Started };
      const action = { type: actions.fetchUser.done.type, payload: { params: UserMock.email, result: UserMock }  };
      const expected = { ...INITIAL_STATE, fetchUserStatus: AsyncStatus.Done, user: UserMock };
      const actual = myProfileReducer(initialState, action);

      expect(actual).toEqual(expected);
    });

    it('should set fetchUser to AsyncStatus.Failure', () => {
      const initialState = { ...INITIAL_STATE, fetchUserStatus: AsyncStatus.Started };
      const action = { type: actions.fetchUser.failed.type };
      const expected = { ...INITIAL_STATE, fetchUserStatus: AsyncStatus.Failed };
      const actual = myProfileReducer(initialState, action);

      expect(actual).toEqual(expected);
    });

    it('should set updateUser to AsyncStatus.Started', () => {
      const initialState = { ...INITIAL_STATE, updateUserStatus: AsyncStatus.Initial };
      const action = { type: actions.updateUser.started.type };
      const expected = { ...INITIAL_STATE, updateUserStatus: AsyncStatus.Started, previousUser: {} };
      const actual = myProfileReducer(initialState, action);

      expect(actual).toEqual(expected);
    });

    it('should set updateUser to AsyncStatus.Done', () => {
      const initialState = { ...INITIAL_STATE, updateUserStatus: AsyncStatus.Started };
      const action = { type: actions.updateUser.done.type, payload: { params: UserMock, result: {} } };
      const expected = { ...INITIAL_STATE, updateUserStatus: AsyncStatus.Done, user: UserMock };
      const actual = myProfileReducer(initialState, action);
    });

    it('should set updateUser to AsynchStatus.Failed', () => {
      const initialState = { ...INITIAL_STATE, updateUserStatus: AsyncStatus.Started };
      const action = { type: actions.updateUser.failed.type };
      const expected = { ...INITIAL_STATE, updateUserStatus: AsyncStatus.Failed };
      const actual = myProfileReducer(initialState, action);

      expect(actual).toEqual(expected);
    });

    it('should reset updateUserStatus', () => {
      const initialState = { ...INITIAL_STATE, updateUserStatus: AsyncStatus.Failed };
      const action = { type: actions.resetUpdateUser.type };
      const expected = { ...INITIAL_STATE, updateUserStatus: AsyncStatus.Initial };
      const actual = myProfileReducer(initialState, action);

      expect(actual).toEqual(expected);
    })
  });
});
