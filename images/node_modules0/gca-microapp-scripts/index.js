#!/usr/bin/env node
const { shell } = require('execa');
const yargs = require('yargs');
const prodWebpackConfig = require.resolve('gca-webpack-config/webpack.prod.babel.js');
const registryDevWebpackConfig = require.resolve('../gca-registry-config/webpack.dev.js');
const registryProdWebpackConfig = require.resolve('../gca-registry-config/webpack.prod.js');

const testingScript = 'cross-env NODE_ICU_DATA=../../node_modules/full-icu NODE_ENV=test jest';

const tasks = [
  {
    task: 'build',
    script: `cross-env NODE_ENV=production webpack --config ${prodWebpackConfig}`,
  },
  {
    task: 'build:stats',
    script: `mkdir -p dist || mkdir dist && cross-env NODE_ENV=production webpack --config ${prodWebpackConfig} --profile --progress --json > dist/stats.json`,
  },
  {
    task: 'reg:start',
    script: `webpack-dev-server --config ${registryDevWebpackConfig} --hot --inline`,
    description: 'Starts the registry simulator and open the browser on the first route of the micro-app',
  },
  {
    task: 'reg:build',
    script: `rimraf dist && cross-env NODE_ENV=production webpack --config ${registryProdWebpackConfig}`,
    description: 'Compile the micro-app source code into the dist directory',
  },
  {
    task: 'reg:first-time-setup',
    script: `registry init-app --server pp && registry init-app --server prod`,
    description: 'Initialize the microapp for the very first time in the Version API.',
  },
  {
    task: 'reg:upload',
    script: `registry upload && registry create-version --server pp && registry create-version --server prod`,
    description:
      'Pushes the assets for your micro-app into S3, makes the version available  in Version API, for both PP and Prod servers',
  },
  {
    task: 'reg:publish',
    script: `registry upload && registry create-version --server pp && registry create-version --server prod && registry promote --profile testing`,
    // script: `registry upload && registry create-version --server pp && registry promote --profile testing`,
    description:
      'Pushes the assets for your micro-app into S3, updates the version API database about the new versions, and promotes the new version to CI, PP',
  },
  {
    task: 'reg:promote-testing',
    script: `registry promote --profile testing`,
    description: 'Promotes the "testing" version number to all Testing environments.',
  },
  {
    task: 'reg:promote-production',
    script: `registry promote --profile production`,
    description: 'Promotes the "production" version number to the Production environment.',
  },
  {
    task: 'start',
    script: 'cross-env NODE_ENV=development yarn dev-server',
  },
  {
    task: 'start:prod',
    script: 'cross-env NODE_ENV=production yarn dev-server',
  },
  {
    task: 'test',
    script: testingScript,
  },
  {
    task: 'test:watch',
    script: `${testingScript} --watch`,
  },
  {
    task: 'i18n',
    description: 'Upload current source files and download translations',
    script: 'yarn i18n',
  },
  {
    task: 'i18n-download',
    script: 'yarn i18n-download',
  },
  {
    task: 'i18n-upload',
    script: 'yarn i18n-upload',
  },
  {
    task: 'analyze',
    script: 'webpack-bundle-analyzer dist/stats.json',
  },
  {
    task: 'prettier',
    script: 'prettier --write src/**/*.{ts,tsx,scss}',
  },
  {
    task: 'aws-publish',
    script: 'aws-publish',
  },
  {
    task: 'cy:run',
    script:
      'cross-env NODE_ENV=development concurrently --names "cypress,microapp" --kill-others --success "first" "cypress run" "yarn task start &> /dev/null"',
    description: 'Run Cypress headless on the current Microapp.',
  },
  {
    task: 'cy:open',
    script:
      'cross-env NODE_ENV=development concurrently --names "cypress,microapp" -c "bgBlue.bold,bgMagenta.bold" --kill-others-on-fail --success "first" "cypress open -P ." "yarn task start"',
    description: 'Open Cypress interactive mode for the current Microapp.',
  },
  {
    task: 'cy:reg:run',
    script:
      'cross-env NODE_ENV=development concurrently --names "cypress,microapp" --kill-others --success "first" "cypress run" "yarn task reg:start &> /dev/null"',
    description: 'Run Cypress headless on the current Registry Microapp.',
  },
  {
    task: 'cy:reg:open',
    script:
      'cross-env NODE_ENV=development concurrently --names "cypress,microapp" -c "bgBlue.bold,bgMagenta.bold" --kill-others-on-fail --success "first" "cypress open -P ." "yarn task reg:start"',
    description: 'Open Cypress interactive mode for the current Registry Microapp.',
  },
  {
    task: 'cy:init',
    script:
      'mkdir cypress && cd cypress && mkdir -p fixtures && mkdir -p integration && touch integration/index_spec.js',
    description: 'Initialize Cypress directory structure on the current microapp.',
  },
];

yargs
  .usage('task <command>')
  .demandCommand()
  .fail(function(msg, err, yargs) {
    console.error(yargs.help());
    process.exit(0);
  });

const ignoredKeys = ['_', 'help', 'version', '$0', 'dry'];

function getPassthrough(argv) {
  const scriptParts = argv._.slice(1);

  Object.keys(argv).forEach(key => {
    if (ignoredKeys.includes(key)) return false;
    scriptParts.push(`--${key}`);
    scriptParts.push(argv[key]);
  });

  return scriptParts.join(' ');
}

/*
 * Given a bash script with multiple commands like: 'registry publish', 'registry deploy', 'registry create-version', 'aws-publish'
 * Adds an argument to the beginning of the argument list of each command
 * which starts with 'registry' or 'aws-publish'
 *
 * Input:  'registry create-version --server pp'
 * Output: 'registry create-version ARGUMENT --server pp'
 * Input:  'aws-publish'
 * Output: 'aws-publish ARGUMENT'
 */
function insertArgumentToRegistryCommands(stringToAdd, sourceScript) {
  const regex = /(registry \w+-?\w*|aws-publish)/g;
  return sourceScript.replace(regex, `$& ${stringToAdd}`);
}

tasks.forEach(({ task, description = '', script }) => {
  yargs.command(
    task,
    description,
    () => {},
    argv => {
      const isDryRun = Object.keys(argv).some(value => value === 'dry');
      const finalScript = isDryRun ? insertArgumentToRegistryCommands('--dry', script) : script;
      console.log(`>>>> ${finalScript} ${getPassthrough(argv)}`);
      shell(`${finalScript} ${getPassthrough(argv)}`, { stdio: 'inherit' });
    },
  );
});

yargs.argv;
