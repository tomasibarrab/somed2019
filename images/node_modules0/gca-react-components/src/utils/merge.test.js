import deepFreeze from 'deep-freeze';
import merge from './merge';

describe('merge', () => {
  it('Should merge simple values', () => {
    const a = deepFreeze({ a: 1, b: 1 });
    const b = deepFreeze({ b: 2, c: 2 });
    expect(merge(a, b)).toEqual({ a: 1, b: 2, c: 2 });
  });

  it('Should use A values when B values are not present', () => {
    const a = deepFreeze({ a: 1 });
    const b = deepFreeze({});
    expect(merge(a, b)).toEqual({ a: 1 });
  });

  it('Should merge deep values', () => {
    const a = deepFreeze({ a: { b: 1 } });
    const b = deepFreeze({ a: { b: 2 } });
    expect(merge(a, b)).toEqual({ a: { b: 2 } });
  });

  it('Should merge mixed values', () => {
    const a = deepFreeze({ a: 1, b: { c: 1 } });
    const b = deepFreeze({ a: 2, b: { c: 2 } });
    expect(merge(a, b)).toEqual({ a: 2, b: { c: 2 } });
  });

  it('Should treat arrays as primitive values', () => {
    const a = deepFreeze({ a: [1, 2] });
    const b = deepFreeze({ a: [3, 4] });
    const result = merge(a, b);

    expect(result).toEqual({ a: [3, 4] });
  });

  it('Should clone arrays, rather than copying references', () => {
    const a = deepFreeze({ a: [1, 2] });
    const b = deepFreeze({ a: [3, 4] });
    const result = merge(a, b);

    expect(() => {
      // This should throw an error if an array was copied by reference
      result.a.push(5);
    }).not.toThrow();
  });
});
