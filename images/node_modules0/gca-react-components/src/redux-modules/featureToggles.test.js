import configureMockStore from 'redux-mock-store';
import { createEpicMiddleware } from 'redux-observable';
import { Observable } from 'rxjs';

import {
  actions,
  types,
  fetchFeatureTogglesEpic,
  featureTogglesReducer,
  initialState,
  selectors,
  getFeatureTogglesUrl,
  normalizeFeaturesResponse,
} from './featureToggles';

describe('featureToggles redux module', () => {
  describe('featureToggles reducer', () => {
    it('should return the state passed into the reducer, regardless, when the action type is unmatched', () => {
      const initial = { test: true };
      const actual = featureTogglesReducer(initial, { type: 'NO_MATCH' });
      expect(actual).toEqual(initial);
    });

    it('should set the loading state when fetching feature toggles', () => {
      const expected = { ...initialState, isFetching: true, fetchFailed: false, error: null };
      const action = { type: types.FETCH_FEATURE_TOGGLES_REQUEST };
      const actual = featureTogglesReducer(initialState, action);
      expect(actual).toEqual(expected);
    });

    it('should set the loading/error states when fetching feature toggles fails', () => {
      const error = { message: 'test-error' };
      const initial = { isFetching: true, fetchFailed: false };
      const expected = { isFetching: false, fetchFailed: true, error };
      const action = { type: types.FETCH_FEATURE_TOGGLES_FAILURE, error };
      const actual = featureTogglesReducer(initial, action);

      expect(actual).toEqual(expected);
    });

    it('should set the payload to the state when feature toggles fetch succeeds', () => {
      const payload = {
        feature1: true,
        feature2: true,
        feature3: false,
      };
      const initial = { isFetching: true, fetchFailed: false, features: {} };
      const expected = {
        isFetching: false,
        fetchFailed: false,
        features: payload,
      };

      const action = { type: types.FETCH_FEATURE_TOGGLES_SUCCESS, payload };
      const actual = featureTogglesReducer(initial, action);

      expect(actual).toEqual(expected);
    });
  });

  describe('featureToggles action creators', () => {
    it('fetchFeatureToggles should return the correct type with no payload', () => {
      expect(actions.fetchFeatureToggles()).toEqual({ type: types.FETCH_FEATURE_TOGGLES_REQUEST });
    });

    it('fetchFeatureTogglesSuccess should return the correct type with the features as payload', () => {
      const payload = { user: {}, restaurant: { rid: 123 } };
      expect(actions.fetchFeatureTogglesSuccess(payload)).toEqual({
        type: types.FETCH_FEATURE_TOGGLES_SUCCESS,
        payload,
      });
    });

    it('fetchFeatureTogglesFailure should return the correct type with no payload', () => {
      const error = { message: 'test-error' };
      expect(actions.fetchFeatureTogglesFailure(error)).toEqual({ type: types.FETCH_FEATURE_TOGGLES_FAILURE, error });
    });
  });
});

describe('fetchFeatureTogglesEpic', () => {
  const payload = { feature1: true, feature2: false };
  const fetchFeatureToggles = () => Observable.of(payload);
  const dependencies = { api: { fetchFeatureToggles } };

  const rootEpic = (action$, store) => fetchFeatureTogglesEpic(action$, store, dependencies);
  const epicMiddleware = createEpicMiddleware(rootEpic);
  const mockStore = configureMockStore([epicMiddleware]);

  let store;
  beforeEach(() => {
    store = mockStore(initialState);
  });

  afterEach(() => {
    epicMiddleware.replaceEpic(rootEpic);
  });

  it('featureToggles Success', () => {
    store.dispatch(actions.fetchFeatureToggles());

    expect(store.getActions()).toEqual([actions.fetchFeatureToggles(), actions.fetchFeatureTogglesSuccess(payload)]);
  });
});

describe('fetchFeatureTogglesEpic Error', () => {
  const error = { message: 'test-error' };
  const fetchFeatureToggles = () => Observable.throw(error);
  const dependencies = { api: { fetchFeatureToggles } };

  const rootEpic = (action$, store) => fetchFeatureTogglesEpic(action$, store, dependencies);
  const epicMiddleware = createEpicMiddleware(rootEpic);
  const mockStore = configureMockStore([epicMiddleware]);

  let store;

  beforeEach(() => {
    store = mockStore(initialState);
  });

  afterEach(() => {
    epicMiddleware.replaceEpic(rootEpic);
  });

  it('should fetch featureToggles', () => {
    store.dispatch(actions.fetchFeatureToggles());

    expect(store.getActions()).toEqual([actions.fetchFeatureToggles(), actions.fetchFeatureTogglesFailure(error)]);
  });
});

describe('featureToggles selectors', () => {
  const state = {
    featureToggles: {
      features: {
        testFeatureToggle: true,
      },
    },
  };

  it('should select entire featureToggles subtree', () => {
    const actual = selectors.featureToggles(state);
    expect(actual).toEqual(state.featureToggles);
  });

  it('should select featureToggle from subtree', () => {
    const actual = selectors.featureToggle(state, 'testFeatureToggle');
    expect(actual).toEqual(true);
  });
});

describe('getFeatureTogglesUrl', () => {
  it('should fetch URL when rid is provided', () => {
    const rid = 123;
    const result = getFeatureTogglesUrl(rid);
    expect(result).toEqual(`/gateway/proxies/featureManager/v3/api/restaurant/${rid}/toggles`);
  });
});

describe('normalizeFeaturesResponse', () => {
  it('should return a new map when called with an array of feature toggles', () => {
    const features = ['test1', 'test2'];

    const result = normalizeFeaturesResponse(features);
    expect(result).toEqual({
      test1: true,
      test2: true
    });
  });

  it('should return a map when called with a map of feature toggles', () => {
    const features = {
      test1: true,
      test2: true
    };

    const result = normalizeFeaturesResponse(features);
    expect(result).toBe(features);
  });
});

