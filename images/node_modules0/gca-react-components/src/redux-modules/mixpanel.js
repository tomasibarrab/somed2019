import { fromPromise } from 'rxjs/observable/fromPromise';
import { of } from 'rxjs/observable/of';

import { combineEpics } from 'redux-observable';
import { merge } from 'rxjs/observable/merge';
import { types as contextTypes } from '../redux-modules/currentContext';
import './rxjsOperators';

export const types = {
  MIXPANEL_INITIALIZED: 'gca/mixpanel/MIXPANEL_INITIALIZED',
  MIXPANEL_LOADED: 'gca/mixpanel/MIXPANEL_LOADED',
  MIXPANEL_LOAD_FAILED: 'gca/mixpanel/MIXPANEL_LOAD_FAILED',
  MIXPANEL_IDENTIFIED: 'gca/mixpanel/MIXPANEL_IDENTIFIED',
};

// common definitions, please use for consistencies sake
export const eventNames = {
  LOAD_PAGE: 'Load page',
  PUBLISH: 'Publish',
  CUSTOM_ACTION: 'Custom action',
};

export const actionNames = {
  CREATE: 'Create',
  READ: 'Read',
  UPDATE: 'Update',
  DELETE: 'Delete',
};

/*
 * factory method to return consistent props for Publish which includes create, update, delete etc
 * @param string feature e.g. Private Dining
 * @param string action e.g. one of the actions such as CREATE
 * @param {props} any additional props you want to add
 */
export const createPublishEvent = ({ feature, action, props = {} }) =>
  ({
    event: eventNames.PUBLISH,
    props: {
      feature,
      action,
      ...props,
    },
  });

/*
 * factory method to return consistent props for load page
 * @param string feature e.g. Private Dining
 * @param string pageName e.g. Private Dining, assigned same value as feature if omitted
 * @param {props} any additional props you want to add
 */
export const createLoadPageEvent = ({ feature, pageName, props = {} }) => {
  const resolvedPageName = !pageName ? feature : pageName;

  return {
    event: eventNames.LOAD_PAGE,
    props: {
      'Page name': resolvedPageName,
      feature,
      ...props,
    },
  };
};

/*
 * factory method to return consistent props for tracking other sorts of user initiated events, but
 * which do not directly result in a load page or publish result
 * @param string feature e.g. Private Dining
 * @param string action e.g. 'Dropdown select'
 * @param {props} any additional props you want to add
 */
export const createActionEvent = ({ feature, action, props = {} }) =>
  ({
    event: eventNames.CUSTOM_ACTION,
    props: {
      feature,
      action,
      ...props,
    },
  });

const actions = {
  mixpanelInitialized: () => ({ type: types.MIXPANEL_INITIALIZED }),
  mixpanelLoaded: () => ({ type: types.MIXPANEL_LOADED }),
  mixpanelLoadFailed: (error) => ({ type: types.MIXPANEL_LOAD_FAILED, error }),
  mixpanelIdentified: () => ({ type: types.MIXPANEL_IDENTIFIED }),
};

const asyncMixpanelInit = (mixpanel, token) =>
  new Promise((resolve, reject) => {
    try {
      mixpanel.init(token, {
        persistence: 'localStorage',
        disable_cookie: true,
        loaded() {
          resolve();
        },
      });
    } catch (error) {
      reject(error);
    }
  });

const mixpanelIdentify = (action$) =>
  action$.ofType(contextTypes.FETCH_CURRENT_CONTEXT_SUCCESS)
    .filter(() => window.mixpanel !== undefined)
    .do((action) => window.mixpanel.identify(action.payload.user.userName))
    .mapTo(actions.mixpanelIdentified());

/**
 * There are a couple sync & async things happening here.
 * Mixpanel needs to be initialized (but does *not* need to be loaded)
 * to use track & identify methods. So, we need to synchronously
 * dispatch an 'initialized' action, but we also need to dispatch
 * and action once it's loaded, which is why we have to map from
 * Observable.fromPromise. So, merge is used here to achieve this
 * mix of sync/async actions.
 */

/* eslint-disable no-underscore-dangle */
const mixpanelInit = () =>
  merge(
    fromPromise(asyncMixpanelInit(window.mixpanel, window.__mixpanelToken__))
      .mapTo(actions.mixpanelLoaded())
      .catch((error) => [actions.mixpanelLoadFailed(error)]),
    of(actions.mixpanelInitialized()),
  );

export const mixpanelEpic = combineEpics(
  mixpanelIdentify,
  mixpanelInit,
);
