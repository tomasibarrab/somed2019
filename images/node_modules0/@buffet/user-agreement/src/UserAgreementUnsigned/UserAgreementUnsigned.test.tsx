import React from 'react';
import { UserAgreementUnsigned } from './UserAgreementUnsigned';
import { IntlProvider, registerMessages } from '@buffet/intl';
import unsignedAgreementMock from '../../fixtures/unsignedUserAgreement';
import signedAgreementMock from '../../fixtures/signedUserAgreement';
import mock from 'xhr-mock';
import { mockSignAgreement } from '../../fixtures/setupMocks';

import { render, fireEvent, wait } from 'react-testing-library';

const messages = require('../../translations/en-US/user-agreement.json');
const AGREE_TEXT = 'Next';
const ASYNC_ERROR_TEXT =
  'We’re experiencing an issue our side. Please try again. If the problem persists please call OpenTable at 1-800-OPENTABLE.';
const PERMISSION_ERROR_TEXT =
  'You don’t have access to continue this process. You’ll need to contact your GuestCenter admin for permission.';

describe('UserAgreementUnsigned', async () => {
  const renderComponent = async () => {
    const updateAgreementDetails = jest.fn();
    const renderResult = render(
      <IntlProvider>
        <UserAgreementUnsigned
          agreementType="TYPE"
          context="CONTEXT"
          agreementDetails={unsignedAgreementMock.agreementDetails}
          updateAgreementDetails={updateAgreementDetails}
        />
      </IntlProvider>
    );
    return { updateAgreementDetails, renderResult };
  };

  beforeAll(() => {
    registerMessages({ ['en-US']: messages });
    jest.useFakeTimers();
  });

  afterEach(() => {
    mock.teardown();
  });

  it('should start unchecked and button disabled', async () => {
    const { renderResult, updateAgreementDetails } = await renderComponent();

    await wait(() => {
      renderResult.getByTestId('agreement-checkbox');
      renderResult.getByText(AGREE_TEXT);
      renderResult.getByText('POS Integration Addendum');
    });

    const button = renderResult.getByText(AGREE_TEXT);

    // Hacky solution: Checkbox does not surface a checked state, so we look for the unchecked hiddenCheckbox
    // TODO: Look for 'checked' attribute, should not exist
    expect(renderResult.container.querySelector('[class*="hiddenCheckbox"][aria-checked="false"]')).toBeTruthy();

    // TODO: Button should be disabled
    fireEvent.click(button);
    expect(updateAgreementDetails).not.toHaveBeenCalled();
  });

  it('should have a checked checkbox and enabled agree button, after clicking checkbox once', async () => {
    mock.setup();
    mockSignAgreement(200, signedAgreementMock.agreementDetails);
    const { renderResult, updateAgreementDetails } = await renderComponent();

    await wait(() => {
      renderResult.getByTestId('agreement-checkbox');
      renderResult.getByText(AGREE_TEXT);
      renderResult.getByText('POS Integration Addendum');
    });

    const checkbox = renderResult.getByTestId('agreement-checkbox');
    const button = renderResult.getByText(AGREE_TEXT);

    fireEvent.click(checkbox);
    // Hacky solution: Checkbox does not surface a checked state, so we look for the checked hiddenCheckbox
    // TODO: Look for 'checked' attribute, should exist
    expect(renderResult.container.querySelector('[class*="hiddenCheckbox"][aria-checked="true"]')).toBeTruthy();

    // TODO: Check for enabled button state
    fireEvent.click(button);
    await wait(() => expect(updateAgreementDetails).toHaveBeenCalled());
  });

  it('should have an unchecked checkbox and disabled agree button, after clicking checkbox twice', async () => {
    const { renderResult, updateAgreementDetails } = await renderComponent();

    await wait(() => {
      renderResult.getByTestId('agreement-checkbox');
      renderResult.getByText(AGREE_TEXT);
      renderResult.getByText('POS Integration Addendum');
    });

    const checkbox = renderResult.getByTestId('agreement-checkbox');
    const button = renderResult.getByText(AGREE_TEXT);

    fireEvent.click(checkbox);
    fireEvent.click(checkbox);

    // Hacky solution: Checkbox does not surface a checked state, so we look for the unchecked hiddenCheckbox
    expect(renderResult.container.querySelector('[class*="hiddenCheckbox"][aria-checked="false"]')).toBeTruthy();

    // TODO: Check for disabled button state
    fireEvent.click(button);
    await wait(() => expect(updateAgreementDetails).not.toHaveBeenCalled());
  });

  it('should view the terms when View Terms clicked, and hide terms when Close is clicked', async () => {
    const { renderResult } = await renderComponent();

    await wait(() => {
      renderResult.getByTestId('agreement-checkbox');
      renderResult.getByText(AGREE_TEXT);
      renderResult.getByText('POS Integration Addendum');
    });

    const viewTermsButton = renderResult.getByText('POS Integration Addendum');

    expect(renderResult.queryByTestId('userAgreementPanel')).toBeFalsy();

    fireEvent.click(viewTermsButton);

    expect(renderResult.queryByTestId('userAgreementPanel')).toBeTruthy();
    const closeButton = renderResult.getByTestId('closeButton');
    fireEvent.click(closeButton);
    jest.runAllTimers();
    expect(renderResult.queryByTestId('userAgreementPanel')).toBeFalsy();
  });

  it.skip('should enter a busy state after enabled agree button clicked', async () => {
    mock.setup();
    mockSignAgreement(200, {}, true);
    const { renderResult, updateAgreementDetails } = await renderComponent();

    await wait(() => {
      renderResult.getByTestId('agreement-checkbox');
      renderResult.getByText(AGREE_TEXT);
      renderResult.getByText('POS Integration Addendum');
    });

    const checkbox = renderResult.getByTestId('agreement-checkbox');
    const button = renderResult.getByText(AGREE_TEXT);

    fireEvent.click(checkbox);
    fireEvent.click(button);

    // Cannot yet check for busy state (Button needs to be fixed)
    // TODO: Check for button busy state
    expect(updateAgreementDetails).not.toHaveBeenCalled();
  });

  it('should show alert notification when signing fails for 500', async () => {
    mock.setup();
    mockSignAgreement(500, {});
    const { renderResult, updateAgreementDetails } = await renderComponent();

    await wait(() => {
      renderResult.getByTestId('agreement-checkbox');
      renderResult.getByText(AGREE_TEXT);
      renderResult.getByText('POS Integration Addendum');
    });

    const checkbox = renderResult.getByTestId('agreement-checkbox');
    const button = renderResult.getByText(AGREE_TEXT);

    fireEvent.click(checkbox);
    fireEvent.click(button);

    await wait(() => {
      renderResult.getByTestId('submit-error-alert');
      expect(renderResult.queryByText(ASYNC_ERROR_TEXT)).toBeTruthy();
    });

    expect(updateAgreementDetails).not.toHaveBeenCalled();
  });

  it('should show alert notification when signing fails for 401', async () => {
    mock.setup();
    mockSignAgreement(401, {});
    const { renderResult, updateAgreementDetails } = await renderComponent();

    await wait(() => {
      renderResult.getByTestId('agreement-checkbox');
      renderResult.getByText(AGREE_TEXT);
      renderResult.getByText('POS Integration Addendum');
    });

    const checkbox = renderResult.getByTestId('agreement-checkbox');
    const button = renderResult.getByText(AGREE_TEXT);

    fireEvent.click(checkbox);
    fireEvent.click(button);

    await wait(() => {
      renderResult.getByTestId('submit-error-alert');
      expect(renderResult.queryByText(PERMISSION_ERROR_TEXT)).toBeTruthy();
    });

    expect(updateAgreementDetails).not.toHaveBeenCalled();
  });
});
