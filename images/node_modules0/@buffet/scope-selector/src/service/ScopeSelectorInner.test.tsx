import React from 'react';
import { render, wait } from 'react-testing-library';
import { TestCurrentUserProvider, State as CurrentUserContextState } from '@buffet/current-user-context';
import {
  TestCurrentRestaurantProvider,
  State as CurrentRestaurantContextState
} from '@buffet/current-restaurant-context';
import {
  TestFeatureToggleProvider,
  State as FeatureToggleState,
  FeatureToggleProvider
} from '@buffet/feature-toggle-context';
import { ScopeSelectorInterface } from './ScopeSelectorInner';
import { ScopeSelectorConsumer, ScopeSelectorProvider } from './ScopeSelectorService';
import mock from 'xhr-mock';
import restaurantSearch from '../../fixtures/restaurantSearch';
import groupSearch from '../../fixtures/groupSearch';
import recentRestaurants from '../../fixtures/recentRestaurants';
import { LOCAL_STORAGE_KEY } from './RecentRestaurants';
import { mapRestaurants } from './RestaurantMapper';

const CURRENT_RID = 1906;
const CURRENT_GROUPID = 666;
const USER_ID = 'urn:ot.rest.users:135598';
const RESTAURANT_SEARCH_PATH_DEPRECTATED = '/restaurant-search/v1/restaurants';
const RESTAURANT_SEARCH_BASE_PATH = '/gateway/proxies/rgsearch/api/v2/restaurants';
const GROUP_SEARCH_BASE_PATH = '/gateway/proxies/rgsearch/api/v2/groups';

const dummyContextRestaurant = {
  rid: 123456,
  name: 'Foo',
  isTestRestaurant: false,
  address: {
    city: 'Barville',
    countryCode: 'BZ'
  }
};

const dummyUser = {
  userName: 'aselbie@opentable.com',
  firstName: 'Ramsay',
  lastName: 'Bolton',
  role: 'Chef',
  isInternalUser: false,
  otrLoginId: 123,
  urn: USER_ID
};

describe('ScopeSelectorProvider & ScopeSelectorConsumer', async () => {
  const realConsoleWarn = console.warn;

  beforeEach(() => {
    mock.setup();
    console.warn = jest.fn();
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(recentRestaurants));
  });

  afterEach(() => {
    mock.reset();
    console.warn = realConsoleWarn;
    localStorage.setItem(LOCAL_STORAGE_KEY, '');
  });

  async function initializeScenario({
    waitForResponse = true,
    restaurantPayload = restaurantSearch,
    groupPayload = groupSearch,
    userId = USER_ID,
    restaurant,
    serviceStatus = 'done',
    useGroupScope = false,
    useRealToggleProvider = false,
    globalScopeSelectorIncludeGroups = true,
    failToggleService = false
  }: any) {
    mock.post(RESTAURANT_SEARCH_PATH_DEPRECTATED, {
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(restaurantPayload)
    });

    mock.get(RESTAURANT_SEARCH_BASE_PATH, {
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(restaurantPayload)
    });

    mock.get(`${GROUP_SEARCH_BASE_PATH}?pageSize=5`, {
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(groupPayload)
    });

    const featureToggles = globalScopeSelectorIncludeGroups ? ['globalScopeSelectorIncludeGroups'] : [];
    const featureTogglesTransformed = { globalScopeSelectorIncludeGroups };

    mock.get(`/gateway/proxies/featureManager/v3/api/restaurant/${CURRENT_RID}/toggles`, {
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(featureToggles)
    });

    const result: { scopeSelector: ScopeSelectorInterface } = {} as any;

    (window as any).gcScope = useGroupScope
      ? {
          type: 'group',
          id: CURRENT_GROUPID
        }
      : {
          type: 'restaurant',
          id: CURRENT_RID
        };

    const featureToggleValue: FeatureToggleState = failToggleService
      ? {
          status: 'failed',
          data: undefined
        }
      : {
          status: 'done',
          data: featureTogglesTransformed
        };

    const userServiceValue: CurrentUserContextState = {
      status: serviceStatus,
      data: { ...dummyUser, urn: userId }
    };

    const restaurantServiceValue: CurrentRestaurantContextState = {
      status: serviceStatus,
      data: restaurant
    };

    if (useRealToggleProvider) {
      render(
        <FeatureToggleProvider>
          <TestCurrentUserProvider value={userServiceValue}>
            <TestCurrentRestaurantProvider value={restaurantServiceValue}>
              <ScopeSelectorProvider>
                <ScopeSelectorConsumer>
                  {scopeSelector => {
                    result.scopeSelector = scopeSelector;
                    return null;
                  }}
                </ScopeSelectorConsumer>
              </ScopeSelectorProvider>
            </TestCurrentRestaurantProvider>
          </TestCurrentUserProvider>
        </FeatureToggleProvider>
      );
    } else {
      render(
        <TestFeatureToggleProvider value={featureToggleValue}>
          <TestCurrentUserProvider value={userServiceValue}>
            <TestCurrentRestaurantProvider value={restaurantServiceValue}>
              <ScopeSelectorProvider>
                <ScopeSelectorConsumer>
                  {scopeSelector => {
                    result.scopeSelector = scopeSelector;
                    return null;
                  }}
                </ScopeSelectorConsumer>
              </ScopeSelectorProvider>
            </TestCurrentRestaurantProvider>
          </TestCurrentUserProvider>
        </TestFeatureToggleProvider>
      );
    }

    if (waitForResponse) {
      await wait();
    }

    if (result === undefined) {
      throw new Error('scopeSelector provided no value');
    }

    return result;
  }

  async function searchScenario({
    query = 'foo & bar',
    restaurantPayload = restaurantSearch,
    groupPayload = groupSearch,
    searchFail = false,
    waitForResponse = true,
    initialize = {}
  }) {
    const initializeResult = await initializeScenario(initialize);
    const encodedQuery = encodeURIComponent(query);
    jest.useFakeTimers();

    if (searchFail) {
      mock.post(`${RESTAURANT_SEARCH_PATH_DEPRECTATED}?query=${encodedQuery}`, {
        headers: { 'Content-Type': 'application/json' },
        status: 400,
        reason: 'Bad request',
        body: '{"error": "something bad"}'
      });

      mock.get(`${RESTAURANT_SEARCH_BASE_PATH}?query=${encodedQuery}`, {
        headers: { 'Content-Type': 'application/json' },
        status: 400,
        reason: 'Bad request',
        body: '{"error": "something bad"}'
      });

      mock.get(`${GROUP_SEARCH_BASE_PATH}?pageSize=5&query=${encodedQuery}`, {
        headers: { 'Content-Type': 'application/json' },
        status: 400,
        reason: 'Bad request',
        body: '{"error": "something bad"}'
      });
    } else {
      mock.post(`${RESTAURANT_SEARCH_PATH_DEPRECTATED}?query=${encodedQuery}`, {
        headers: { 'Content-Type': 'application/json' },
        body: restaurantPayload
      });

      mock.get(`${RESTAURANT_SEARCH_BASE_PATH}?query=${encodedQuery}`, {
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(restaurantPayload)
      });

      mock.get(`${GROUP_SEARCH_BASE_PATH}?pageSize=5&query=${encodedQuery}`, {
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...groupPayload, items: groupPayload.items.slice(0, 2) })
      });
    }

    initializeResult.scopeSelector.setSearch(query);

    jest.runOnlyPendingTimers();
    jest.useRealTimers();

    // Wait one cycle for search return
    if (waitForResponse) {
      await wait();
    }

    return initializeResult;
  }

  it('Should provide the correct restaurant data baseline when initialized', async () => {
    const result = await initializeScenario({ waitForResponse: false, userId: '0' });

    expect(result.scopeSelector).toMatchObject({
      restaurantSearchState: { status: 'started' },
      groupSearchState: { status: 'started' },
      currentSearch: '',
      ridCount: 0,
      recentRestaurants: [],
      currentRid: CURRENT_RID,
      currentGroupId: undefined
    });
  });

  it('Should provide the correct group data baseline when initialized', async () => {
    const result = await initializeScenario({ waitForResponse: false, userId: '0', useGroupScope: true });

    expect(result.scopeSelector).toMatchObject({
      restaurantSearchState: { status: 'started' },
      groupSearchState: { status: 'started' },
      currentSearch: '',
      ridCount: 0,
      recentRestaurants: [],
      currentGroupId: CURRENT_GROUPID
    });
  });

  it('Should provide the correct methods when initialized', async () => {
    const result = await initializeScenario({ waitForResponse: false });

    expect(typeof result.scopeSelector.selectRid).toBe('function');
    expect(typeof result.scopeSelector.setSearch).toBe('function');
  });

  it('Should set ridCount, groupCount and "done" status when there are many RIDs', async () => {
    const result = await initializeScenario({});

    expect(result.scopeSelector).toMatchObject({
      restaurantSearchState: { status: 'done' },
      groupSearchState: { status: 'done' },
      ridCount: 52187,
      groupCount: 5
    });
  });

  it('Should set ridCount, groupCount, results and "done" status when there are few RIDs', async () => {
    const restaurantPayload = { ...restaurantSearch, items: restaurantSearch.items.slice(0, 4), totalResults: 5 };
    const result = await initializeScenario({ restaurantPayload });

    expect(result.scopeSelector).toMatchObject({
      restaurantSearchState: { status: 'done', data: mapRestaurants(restaurantPayload.items) },
      groupSearchState: { status: 'done' },
      ridCount: 5,
      groupCount: 5
    });
  });

  it('Should set ridCount, groupCount and "init" status when there are many RIDs using deferred initialization', async () => {
    const result = await initializeScenario({ useRealToggleProvider: true });

    expect(result.scopeSelector).toMatchObject({
      restaurantSearchState: { status: 'done' },
      groupSearchState: { status: 'done' },
      ridCount: 52187,
      groupCount: 5
    });
  });

  it('Should not search groups when the toggle is false', async () => {
    const result = await initializeScenario({ globalScopeSelectorIncludeGroups: false });

    expect(result.scopeSelector).toMatchObject({
      restaurantSearchState: { status: 'done' },
      groupSearchState: { status: 'done' },
      ridCount: 52187,
      groupCount: 0
    });
  });

  it('Should not search groups when the toggles fail to load', async () => {
    const result = await initializeScenario({ failToggleService: true });

    expect(result.scopeSelector).toMatchObject({
      restaurantSearchState: { status: 'done' },
      groupSearchState: { status: 'done' },
      ridCount: 52187,
      groupCount: 0
    });
  });

  describe('Recent RIDs', async () => {
    it('Should show recent RIDs when initialized and there are many RIDs', async () => {
      const result = await initializeScenario({});

      await wait(() => {
        expect(result.scopeSelector.recentRestaurants.length).toBe(9);
      });
    });

    it('Should handle all three possible address formats when showing recent RIDs', async () => {
      const result = await initializeScenario({});

      await wait(() => {
        expect(result.scopeSelector.recentRestaurants[0]).toMatchObject({
          city: 'San Francisco',
          country: 'US'
        });

        expect(result.scopeSelector.recentRestaurants[1]).toMatchObject({
          city: 'Austin',
          country: 'US'
        });

        expect(result.scopeSelector.recentRestaurants[2]).toMatchObject({
          city: 'New York',
          country: 'US'
        });
      });
    });

    it('Should show empty recent RIDs list when there are none available', async () => {
      localStorage.removeItem(LOCAL_STORAGE_KEY);
      const result = await initializeScenario({});

      await wait(() => {
        expect(result.scopeSelector.recentRestaurants.length).toBe(0);
      });
    });

    it('Should show empty recent RIDs list when the storage is corrupted', async () => {
      localStorage.setItem(LOCAL_STORAGE_KEY, '["this is a broken storage item..."');
      const result = await initializeScenario({});

      await wait(() => {
        expect(result.scopeSelector.recentRestaurants.length).toBe(0);
      });
    });

    it('Should add the current RID to the list when initializing', async () => {
      const result = await initializeScenario({
        restaurant: dummyContextRestaurant
      });

      await wait(() => {
        expect(result.scopeSelector.recentRestaurants.length).toBe(10);
      });
    });

    it('Should add the current RID to localStorage when initializing', async () => {
      const result = await initializeScenario({
        restaurant: dummyContextRestaurant
      });

      await wait(() => {
        const data = localStorage.getItem(LOCAL_STORAGE_KEY) || '';
        expect(data.indexOf('123456') > -1).toBeTruthy();
      });
    });
  });

  describe('reset()', async () => {
    it('Should leave searchResults as is when user has few RIDs', async () => {
      const smallPayload = {
        ...restaurantSearch,
        items: restaurantSearch.items.slice(0, 5),
        totalResults: 5
      };

      const result = await initializeScenario({
        restaurantPayload: smallPayload
      });

      let restData = result.scopeSelector.restaurantSearchState.data;
      let groupData = result.scopeSelector.groupSearchState.data;
      expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
      expect(result.scopeSelector.groupSearchState.status).toBe('done');
      expect(restData).toBeDefined();
      expect(groupData).toBeDefined();

      if (restData) {
        expect(restData.length).toBe(5);
      }

      if (groupData) {
        expect(groupData.length).toBe(5);
      }

      result.scopeSelector.reset();

      await wait(() => {
        restData = result.scopeSelector.restaurantSearchState.data;
        groupData = result.scopeSelector.groupSearchState.data;
        expect(restData).toBeDefined();
        expect(groupData).toBeDefined();

        if (restData) {
          expect(restData.length).toBe(5);
        }

        if (groupData) {
          expect(groupData.length).toBe(5);
        }
      });
    });

    it('Should reset searchResults when user has many RIDs', async () => {
      const result = await searchScenario({});
      expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
      expect(result.scopeSelector.groupSearchState.status).toBe('done');
      const restData = result.scopeSelector.restaurantSearchState.data;
      let groupData = result.scopeSelector.groupSearchState.data;
      expect(restData).toBeDefined();
      expect(groupData).toBeDefined();

      if (restData) {
        expect(restData.length).toBe(10);
      }

      if (groupData) {
        expect(groupData.length).toBe(2);
      }

      result.scopeSelector.reset();
      expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
      expect(result.scopeSelector.groupSearchState.status).toBe('done');
      groupData = result.scopeSelector.groupSearchState.data;
      expect(groupData).toBeDefined();

      if (groupData) {
        expect(groupData.length).toBe(5);
      }
    });

    it('Should reset searchResults when user has many RIDs and no groups', async () => {
      const result = await searchScenario({ initialize: { globalScopeSelectorIncludeGroups: false } });
      expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
      expect(result.scopeSelector.groupSearchState.status).toBe('done');
      const restData = result.scopeSelector.restaurantSearchState.data;
      expect(restData).toBeDefined();

      if (restData) {
        expect(restData.length).toBe(10);
      }

      result.scopeSelector.reset();
      expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
      expect(result.scopeSelector.groupSearchState.status).toBe('done');
    });
  });

  describe('setSearch()', async () => {
    it('Should populate searchResults when API succeeds', async () => {
      const result = await searchScenario({ waitForResponse: false });

      expect(result.scopeSelector.restaurantSearchState.status).toBe('started');
      expect(result.scopeSelector.groupSearchState.status).toBe('started');

      await wait();

      await wait(() => {
        expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
        expect(result.scopeSelector.groupSearchState.status).toBe('done');
        const restData = result.scopeSelector.restaurantSearchState.data;
        const groupData = result.scopeSelector.groupSearchState.data;
        expect(restData).toBeDefined();
        expect(groupData).toBeDefined();

        if (restData) {
          expect(restData.length).toBe(10);
        }

        if (groupData) {
          expect(groupData.length).toBe(2);
        }
      });
    });

    it('Should not call restaurant search if there are no restaurants', async () => {
      const result = await searchScenario({
        waitForResponse: false,
        initialize: {
          restaurantPayload: {
            items: [],
            totalPages: 1,
            pageIndex: 0,
            pageSize: 10,
            totalResults: 0
          }
        }
      });

      expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
      expect(result.scopeSelector.groupSearchState.status).toBe('started');

      await wait();

      await wait(() => {
        expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
        expect(result.scopeSelector.groupSearchState.status).toBe('done');
        const restData = result.scopeSelector.restaurantSearchState.data;
        const groupData = result.scopeSelector.groupSearchState.data;
        expect(restData).toBeDefined();
        expect(groupData).toBeDefined();

        if (restData) {
          expect(restData.length).toBe(0);
        }

        if (groupData) {
          expect(groupData.length).toBe(2);
        }
      });
    });

    it('Should not call group search if there are no groups', async () => {
      const result = await searchScenario({
        waitForResponse: false,
        initialize: {
          groupPayload: {
            items: [],
            totalPages: 1,
            pageIndex: 0,
            pageSize: 5,
            totalResults: 0
          }
        }
      });

      expect(result.scopeSelector.groupSearchState.status).toBe('done');
      expect(result.scopeSelector.restaurantSearchState.status).toBe('started');

      await wait();

      await wait(() => {
        expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
        expect(result.scopeSelector.groupSearchState.status).toBe('done');
        const restData = result.scopeSelector.restaurantSearchState.data;
        const groupData = result.scopeSelector.groupSearchState.data;
        expect(restData).toBeDefined();
        expect(groupData).toBeDefined();

        if (restData) {
          expect(restData.length).toBe(10);
        }

        if (groupData) {
          expect(groupData.length).toBe(0);
        }
      });
    });

    it('Should clear search results when query is empty', async () => {
      const result = await searchScenario({ query: '' });

      await wait(() => {
        expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
        expect(result.scopeSelector.groupSearchState.status).toBe('done');
        const groupData = result.scopeSelector.groupSearchState.data;
        expect(groupData).toBeDefined();

        if (groupData) {
          expect(groupData.length).toBe(5);
        }

        const restaurantData = result.scopeSelector.restaurantSearchState.data;
        expect(restaurantData).toBeDefined();

        if (restaurantData) {
          expect(restaurantData.length).toBe(10);
        }
      });
    });

    it('Should not clear search results when there are no intial restaurants', async () => {
      const result = await searchScenario({
        query: '',
        initialize: {
          restaurantPayload: {
            items: [],
            totalPages: 1,
            pageIndex: 0,
            pageSize: 10,
            totalResults: 0
          }
        }
      });

      await wait(() => {
        expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
        expect(result.scopeSelector.groupSearchState.status).toBe('done');
        const groupData = result.scopeSelector.groupSearchState.data;
        expect(groupData).toBeDefined();

        if (groupData) {
          expect(groupData.length).toBe(5);
        }

        const restaurantData = result.scopeSelector.restaurantSearchState.data;
        expect(restaurantData).toBeDefined();

        if (restaurantData) {
          expect(restaurantData.length).toBe(0);
        }
      });
    });

    it('Should format RIDs in searchResults correctly when API succeeds', async () => {
      const result = await searchScenario({});

      await wait(() => {
        expect(result.scopeSelector.restaurantSearchState.status).toBe('done');
        const restData = result.scopeSelector.restaurantSearchState.data;
        expect(restData).toBeDefined();

        if (restData) {
          expect(restData.length).toBe(10);
          expect(restData[0]).toMatchObject({
            rid: 319,
            name: "James' Beach",
            city: 'Venice',
            country: 'US',
            isTestRestaurant: false
          });
        }
      });
    });

    xit('Should set status to "failed" when API call fails', async () => {
      const result = await searchScenario({ searchFail: true });

      await wait(() => {
        console.log(`data: ${JSON.stringify(result.scopeSelector.restaurantSearchState, null, 2)}`);
        expect(result.scopeSelector.restaurantSearchState.status).toBe('failed');
      });
    });
  });

  describe('selectRid()', async () => {
    const SELECTED_RID = 123456;
    const REDIRECT_URL = `https://gc-pp-sf.otenv.com/profile/${SELECTED_RID}`;

    const realAssign = window.location.assign;
    const realWarn = console.warn;

    afterEach(() => {
      window.location.assign = realAssign;
      console.warn = realWarn;
    });

    async function selectScenario({ assign = jest.fn() }, initializeOptions = {}) {
      const initializeResult = await initializeScenario(initializeOptions);

      window.location.assign = assign;

      mock.post('/gateway/api/account/switch/rid', {
        status: 200,
        reason: 'OK',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          redirectUrl: REDIRECT_URL,
          restaurant: {
            rid: SELECTED_RID,
            name: 'Searsucker Austin',
            isTestRestaurant: false,
            address: {
              city: 'Austin',
              countryCode: 'US'
            }
          }
        })
      });

      initializeResult.scopeSelector.selectRid(123);

      return initializeResult;
    }

    it('Should redirect based on the API response when call succeeds', async () => {
      const assign = jest.fn();
      const result = await selectScenario({ assign });

      await wait(() => {
        expect(assign).toHaveBeenCalledWith(REDIRECT_URL);
      });
    });

    it('Should add the RID to the recent list when call succeeds', async () => {
      const result = await selectScenario({});

      await wait(() => {
        expect(result.scopeSelector.recentRestaurants.length).toBe(10);
        expect(result.scopeSelector.recentRestaurants.filter(r => r.rid === SELECTED_RID).length).toBe(1);
      });
    });

    it('Should trim the recent RID list when adding a new one would go over the limit', async () => {
      const RID_TO_REMOVE = 456;
      const recentRestaurantsForUser = recentRestaurants[USER_ID];
      const overLengthList = recentRestaurantsForUser.map(rest => ({ ...rest }));
      overLengthList[9] = { ...overLengthList[0], rid: 123 };
      overLengthList[10] = { ...overLengthList[0], rid: RID_TO_REMOVE };

      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify({ [USER_ID]: overLengthList }));

      const result = await selectScenario({});

      await wait(() => {
        expect(result.scopeSelector.recentRestaurants.length).toBe(10);
        expect(result.scopeSelector.recentRestaurants.filter(r => r.rid === SELECTED_RID).length).toBe(1);
        expect(result.scopeSelector.recentRestaurants.filter(r => r.rid === RID_TO_REMOVE).length).toBe(0);
      });
    });

    it('Should set status to "failed" when API call fails', async () => {
      const result = await initializeScenario({});

      mock.post('/gateway/api/account/switch/rid', {});

      result.scopeSelector.selectRid(123);

      await wait(() => {
        expect(result.scopeSelector.restaurantSearchState.status).toBe('failed');
      });
    });

    it('Should set status to "failed" when API returns incomplete data', async () => {
      const result = await initializeScenario({});

      mock.post('/gateway/api/account/switch/rid', {
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({})
      });

      result.scopeSelector.selectRid(123);

      await wait(() => {
        expect(result.scopeSelector.restaurantSearchState.status).toBe('failed');
      });
    });

    it('Should noop when context has not yet loaded', async () => {
      const result = await selectScenario({}, { serviceStatus: 'started' });

      await wait(() => {
        expect(console.warn).toHaveBeenCalledWith('addRestaurant() was called without a userId. Aborting.');
      });
    });
  });
});
