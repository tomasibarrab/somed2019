const isEmpty = require('lodash/isEmpty');
const { fatal } = require('../../gca-registry-publish/utils/utils');

/*
* This script will help parse and validate a single app's package file that has already been loaded.
* These package helpers do not directly load manifest/package.json from the file system,
* you must open these files yourself.
*/

function validateManifestFile(manifest) {
  if (isEmpty(manifest)) fatal('Unable to read the contents of the manifest.json file.');
  if (isEmpty(manifest.name)) fatal('The manifest.json file is missing the "name" property.');
  return manifest;
}

function validatePackageFile(pkg) {
  if (isEmpty(pkg)) fatal('Unable to read the contents of the package.json file.');
  if (isNewPackageFormat(pkg)) {
    if (isEmpty(pkg.deploy.profiles) || isEmpty(pkg.deploy.profiles.testing) || isEmpty(pkg.deploy.profiles.production)) {
      fatal('Package json configuration invalid for deploy type [registry]')
    }
  }
  return pkg;
}

function isRegistryApp(pkg) {
  validatePackageFile(pkg);
  return !!(pkg.versionProd || pkg.deploy && pkg.deploy.type === 'registry');
}

function isNewPackageFormat(pkg) {
  return !!(pkg.deploy && pkg.deploy.type !== undefined);
}

// Dot separated version
function getRawPackageVersion(pkg) {
  validatePackageFile(pkg);
  return pkg.version;
}

// Dot separated version
function getRawDeployVersion(pkg, profile) {
  validatePackageFile(pkg);
  // New package.json structure, each app may opt into this logic
  if (isNewPackageFormat(pkg)) {
    if (profile === 'production') {
      return pkg.deploy.profiles.production;
    }
    return pkg.deploy.profiles.testing;
  }

  // Old
  if (profile === 'production') {
    return pkg.versionProd;
  }

  return pkg.version;
}

module.exports = {
  isRegistryApp,
  isNewPackageFormat,
  getRawPackageVersion,
  getRawDeployVersion,
  validateManifestFile,
  validatePackageFile,
};
