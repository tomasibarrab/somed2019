const chalk = require('chalk');
const columnify = require('columnify');
const semver = require('semver');
const { formatVersionSemver } = require('./load-local-package');
const { header } = require('gca-logging-helpers');

const PASS_COLORED = chalk.green('PASS');
const FAIL_COLORED = chalk.red('FAIL');
const CANCELLED_COLORED = chalk.grey('CANCELLED');

const DELTA_EMOJIS = {
  NO_VERSION_IN_CONFIG: {
    emoji: '❗',
    description: 'Missing version field in package.json',
  },
  NON_REGISTRY_APP: {
    emoji: '✖️',
    description: 'App does not have registry configuration in package.json',
  },
  APP_NOT_CREATED: {
    emoji: '❌',
    description: 'App does not exist on this Version API server',
  },
  INCREASE_VERSION: {
    emoji: '↗️',
    description: 'Version will be Promoted',
  },
  DECREASE_VERSION: {
    emoji: '↘️',
    description: 'Version will be Rolled Back',
  }
};

// Compare two versions and output the delta in form of an emoji
const getVersionDeltaEmoji = (leftVersion, rightVersion, isRegistryApp) => {
  if (!isRegistryApp) {
    return DELTA_EMOJIS.NON_REGISTRY_APP.emoji;
  }
  if (!rightVersion) {
    return DELTA_EMOJIS.NO_VERSION_IN_CONFIG.emoji;
  }
  if (!leftVersion) {
    return DELTA_EMOJIS.APP_NOT_CREATED.emoji;
  }
  if (semver.gt(leftVersion, rightVersion)) {
    return DELTA_EMOJIS.DECREASE_VERSION.emoji;
  }
  if (semver.eq(leftVersion, rightVersion)) {
    return '';
  }
  if (semver.lt(leftVersion, rightVersion)) {
    return DELTA_EMOJIS.INCREASE_VERSION.emoji;
  }
};

const showEmojiLegend = (data) => {
  const pluckUnique = key => array => Array.from(new Set(array.map(obj => obj[key])));
  const uniqueEmojis = pluckUnique('Δ')(data);

  const emojiDescriptions = Object.keys(DELTA_EMOJIS).reduce((accumulator, emojiConfigKey) => {
    const emojiConfig = DELTA_EMOJIS[emojiConfigKey];
    return {
      ...accumulator,
      [emojiConfig.emoji]: emojiConfig.description,
    }
  }, {})

  console.info('\nΔ Legend');
  uniqueEmojis.forEach((emoji) => {
    if (emoji !== '') console.info(`${emoji}  - ${emojiDescriptions[emoji]}`);
  })
  console.info('\n')
}


const printPackages = (packages) => {
  if (!packages || packages.length === 0) {
    console.log('         ~~~~~ No entries ~~~~~');
    return;
  }
  const data = packages.map(pkg => ({
    appName: pkg.name,
    currentVersion: pkg.publishedVersion,
    pkgVersion: pkg.pending ? chalk.magenta(pkg.localVersion) : pkg.localVersion,
    pkgTestingVersion: pkg.testingVersion || '',
    pkgProdVersion: pkg.productionVersion || '',
    deployType: pkg.isRegistryApp ? 'registry' : 'none',
  }));
  console.log(
    columnify(data, { columnSplitter: '  ', headingTransform: chalk.bold }),
  );
};


const printPackagesUpload = (packages) => {
  if (!packages || packages.length === 0) {
    console.log('         ~~~~~ No entries ~~~~~');
    return;
  }

  const data = packages.map(pkg => {
    const newPkgVersion = pkg.shouldUpload ? chalk.magenta(pkg.localVersion) : '';
    return {
      appName: pkg.name,
      lastUploadedVersion: pkg.publishedVersion,
      newPkgVersion,
      willUpload: pkg.shouldUpload || '',
    }
  });
  console.log(
    columnify(data, { columnSplitter: '  ', headingTransform: chalk.bold }),
  );
};

const printPackagesPromoteTesting = (packages) => {
  const data = packages.map(pkg => {
    const deltaEmoji = getVersionDeltaEmoji(
      formatVersionSemver(pkg.registryTestingVersion), // Currently in PP
      formatVersionSemver(pkg.testingVersion), // Desired by package.json
      pkg.isRegistryApp,
    );

    return registryAppOutput = {
      appName: pkg.name,
      'appExistsInPP  ': pkg.existsInPP, // true / false
      'registryPP  ': pkg.registryTestingVersion,
      Δ: deltaEmoji,
      'desiredInPP  ': pkg.testingVersion,
      shouldPromoteTesting: pkg.shouldPromoteTesting ? pkg.shouldPromoteTesting : '',
    };
  });
  console.log(
    columnify(data, { columnSplitter: '  ', headingTransform: chalk.bold }),
  );
  showEmojiLegend(data);
};

const printPackagesPromoteProduction = (packages) => {
  const data = packages.map(pkg => {
    const deltaEmoji = getVersionDeltaEmoji(
      formatVersionSemver(pkg.registryProductionVersion), // Currently in Prod
      formatVersionSemver(pkg.productionVersion), // Desired by package.json
      pkg.isRegistryApp,
    );

    return {
      appName: pkg.name,
      appExistsInProd: pkg.existsInProd, // true / false
      registryProd: pkg.registryProductionVersion,
      Δ: deltaEmoji,
      desiredInProd: pkg.productionVersion,
      shouldPromoteProduction: pkg.shouldPromoteProduction ? pkg.shouldPromoteProduction : '',
    };
  });
  console.log(
    columnify(data, { columnSplitter: '  ', headingTransform: chalk.bold }),
  );
  showEmojiLegend(data);
};

const printPackagesStatus = (packages, resultName, resultValue) => {
  if (!packages || packages.length === 0) {
    console.log('         ~~~~~ No entries ~~~~~');
    return;
  }
  const data = packages.map(pkg => ({
    appName: pkg.name,
    [resultName]: resultValue
  }));
  console.log(
    columnify(data, { columnSplitter: '  ', headingTransform: chalk.bold }),
  );
};

const printPackagesPhaseStatus = (commandName, statusColumnName, passingPackages, failingPackages, skippedPackages = []) => {
  const outputToTable = [
    ...passingPackages.map(({ name: appName }) => ({
      appName,
      [statusColumnName]: PASS_COLORED
    })),
    ...failingPackages.map(({ name: appName }) => ({
      appName,
      [statusColumnName]: FAIL_COLORED
    })),
    ...skippedPackages.map(({ name: appName }) => ({
      appName,
      [statusColumnName]: CANCELLED_COLORED,
    })),
  ];

  console.log(header(`${commandName}: Status of completed phase [${commandName}]`, { top: 1 }));
  console.log(
    columnify(outputToTable, { columnSplitter: '  ', headingTransform: chalk.bold }),
  );
};

module.exports = {
  printPackages,
  printPackagesUpload,
  printPackagesPromoteTesting,
  printPackagesPromoteProduction,
  printPackagesStatus,
  printPackagesPhaseStatus,
}