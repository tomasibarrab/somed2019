/**
 * Validator functions and related utilities. Also includes a factory to create a form validator.
 *
 * General form of a validator is a function which consumes a form value and returns `undefined` for valid values, and a
 * string in the form of a localized value key if there is an error.
 *
 * Usage: recommend this module be imported as `import * as validate from 'gca-react-components/src/utils/validate'`.
 * Then individual validators, functions can be referenced as `validate.compose()`, `validate.create()`, etc.
 */

// Errors are reported as string values or array of string values. If there is no error, an error will be `undefined`
export type ValidationError = string | string[] | undefined;
export type Validator<T> = (value: T, valueMap?: ValueMap) => ValidationError;
export type StringValidator = Validator<string | undefined>;
export interface ErrorMap { [id: string]: ValidationError };
export interface ValueMap { [id: string]: any };
export interface ValidatorsMap { [id: string]: Validator<any> };
export type FormValidator = (values: ValueMap) => ErrorMap; // returns a map of errors

/**
 * Create a composed validator which will execute all passed in validators for a provided value. Will return the first
 * error encountered, or `undefined` if none of the validators evaluate to invalid.
 */
export const compose = <T>(...validators: Array<Validator<T>>): Validator<any> => (value: T): ValidationError =>
  validators.reduce((error: ValidationError, validator: Validator<T>) => error || validator(value), undefined);

/**
 * Required field validation. Value must not be `undefined` or empty string to pass.
 */
export const required = <T extends string>(err?: string): Validator<T> =>
  (value: T): ValidationError =>
    value !== undefined && value !== '' ? undefined : err || 'validate.required';

/**
 * RegEx validator factory function
 *
 * @param {regex} a regular expression to test a string against
 * @param {string} errorMessage an error message key
 */
export function regEx(regex: RegExp, errorMessage: string): StringValidator {
  return (value: string | undefined): ValidationError => (!value || !regex.test(value))
    ? errorMessage
    : undefined;
}

//
// regex source: http://emailregex.com/
// based on: RFC 5322
//
// tslint:disable-next-line:max-line-length
const emailRegEx = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

/**
 * Email validation factory function.
 * Must not be falsy, and must pass RegEx pattern for email.
 *
 * @param {string} errorMessage (optional) an error message key
 * @return {StringValidator} a validator which will check for a syntactically correct email
 */
export const email = (err: string | undefined): StringValidator => regEx(emailRegEx, err || 'validate.email');

/**
 * Phone validation regex
 *
 * https://stackoverflow.com/questions/16699007/regular-expression-to-match-standard-10-digit-phone-number
 * (?:\+?(\d{1,3}))?   #GROUP 1: The country code. Optional.
 * [^(]*               # Only allow left paren at the beginning of the Area Code.
 * (\d{3})             # GROUP 2: The Area Code. Required.
 * [-. )]*             # Allow certain non numeric characters between the Area Code and the Exchange number
 * (\d{3})             # GROUP 3: The Exchange number. Required.
 * [-. ]*              # Allow certain non numeric characters between the Exchange number and the Subscriber number.
 * (\d{4})             # Group 4: The Subscriber Number. Required.
 * $                   # Don't allow any character after the subscriber number
 */
const phoneRegEx = /^(?:\+?(\d{1,3}))?[-. (]*(\d{3})[-. )]*(\d{3})[-. ]*(\d{4})(?: *x(\d+))?\s*$/;

export const phone = (err: string | undefined): StringValidator => regEx(phoneRegEx, err || 'validate.phone');

/**
 * Min chars validator factory function
 *
 * @param {number} min string passed to validator will be valid if greater than or equal to this value
 * @param {string} errorMessage (optional) an error message key
 * @return {StringValidator} a validator which will check for the specified min number of characters
 */
export const minChars = (min: number, err?: string): StringValidator => {
  return (value: string | undefined): ValidationError => (!value || value.length < min)
    ? err || 'validate.minChars'
    : undefined;
}

/**
 * Max chars validator factory function
 *
 * @param {number} max string passed to validator will be valid if less than or equal to this value
 * @param {string} errorMessage (optional) an error message key
 * @return {StringValidator} a validator which will check for the specified max number of characters
 */
export const maxChars = (max: number, err?: string): StringValidator => {
  return (value: string | undefined): ValidationError => (value !== '' && (!value || value.length > max))
    ? err || 'validate.maxChars'
    : undefined;
}

/**
 * Factory function to compare value of current field to value of other filed.
 *
 * @param fieldName
 * @param err
 */
export const matchField = (fieldName: string, err?: string): StringValidator => {
  return (value: string | undefined, values: ValueMap): ValidationError => (
    (value !== values[fieldName])
      ? err
      : undefined
  );
}

/**
 * A general validator which uses a provided custom function to validate a field
 *
 * @param {validtor} (val:any | undefined) => boolean. A custom function which returns true if the value is valid
 * @param {string} errorMessage  an error message key
 * @return {StringValidator} a validator which will check for a correct value as defined by the custom function
 */

export const custom = (validator: (val: any | undefined) => boolean, err: string): StringValidator => {
  return (value: any | undefined): ValidationError => validator(value) ? undefined : err;
}

/**
 * Form validator factory function.
 *
 * @param {ValidatorsMap} validators a map of `Validator`s whose keys should correspond to named form fields
 * @return {FormValidator} a function called with a map of field values which returns a corresponding map of errors if
 *  there are any, or any empty object if there are no errors
 */
export function create(validators: ValidatorsMap): FormValidator {
  return (values: ValueMap): ErrorMap => Object.keys(validators)
    .reduce((errors: ErrorMap, valueKey: string) => {
        const error: ValidationError = validators[valueKey](values[valueKey], values);
        if (error) {
          errors[valueKey] = error;
        }
        return errors;
      },
      { },
    );
}
