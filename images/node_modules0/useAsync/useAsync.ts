import React from 'react';

export const enum AsyncProgress {
  Init = 'init',
  Started = 'started',
  Done = 'done',
  Failed = 'failed',
}

export interface AsyncInitStatus {
  progress: AsyncProgress.Init;
}

export interface AsyncProgressStatus {
  progress: AsyncProgress.Started;
}

export interface AsyncDoneStatus {
  progress: AsyncProgress.Done;
}

export interface AsyncErrorStatus {
  progress: AsyncProgress.Failed;
  error: Error;
}

export type AsyncStatus = AsyncInitStatus | AsyncProgressStatus | AsyncDoneStatus | AsyncErrorStatus;

export interface AsyncError {
  statusCode?: number;
  status?: number;
  message: string | undefined;
  data: string | undefined;
}

type AnyPar = any[];

export type AsyncCall<P extends AnyPar, T> = ( ...args: P) => Promise<T>;

export type AsyncHook<F> = [ Readonly<AsyncStatus>, F ];

const getStatus = (err: AsyncError) =>
  err.statusCode !== undefined
  ? err.statusCode
  : err.status;

function isAsyncError<T>(resp: AsyncError | T): resp is AsyncError {
  const respErr = (resp as AsyncError);
  return (
    (respErr.statusCode !== undefined && respErr.statusCode !== 200) ||
    (respErr.status !== undefined && respErr.status !== 200 && typeof respErr.status !== 'string')
  );
}

export function getAsyncError(s: AsyncStatus): Error | undefined {
  return (s as AsyncErrorStatus).error;
}

/**
 * A react hook for managing the status of async calls.
 * Usage: const [ status, asyncCall ] = useAsync(myAsyncFn);
 * The status will maintain the status of the call.
 * The asyncCall is wrapper around myAsyncFn that accept the same parameters and return
 * the same promise.
 * The returned asyncCall should be used instead of the original myAsyncCall to make calls
 * inside a functional component.
 * This hook has two generic type parameters:
 * P defines the type of the parameters accepted by the async function.
 * T defines the type the Promise returned by the async function returns.
 * Both argument are inferred automatically when invoking the hook and passing a promise function.
 * @param apiFn an async function accepting any number of parameters and returning Promise<T>
 */
export function useAsync<P extends AnyPar, T>(asyncCall: AsyncCall<P, T>): AsyncHook<AsyncCall<P, T>> {
  const [ state, setState ] = React.useState<AsyncStatus>({ progress: AsyncProgress.Init });

  const apiCall = React.useCallback( (...args: P) => {
    setState({ progress: AsyncProgress.Started });
    return asyncCall(...args)
      .then(resp => {
        if (isAsyncError(resp)) {
          const code = getStatus(resp as AsyncError);
          throw new Error(`Error: ${code} - ${resp.message ? resp.message + ':' : '' } ${resp.data || ''}`);
        } else {
          setState({ progress: AsyncProgress.Done });
        }
        return resp;
      })
      .catch(err => {
        setState({ progress: AsyncProgress.Failed, error: err });
        return Promise.reject(err);
      });
  }, [asyncCall]);

  return [ state, apiCall ];
}
