/**
 *
 * App.tsx
 *
 * This component is the skeleton around the actual pages, and should only
 * contain code that should be seen on all pages. (e.g. navigation bar)
 *
 * NOTE: while this component should technically be a stateless functional
 * component (SFC), hot reloading does not currently support SFCs. If hot
 * reloading is not a necessity for you then you can refactor it and remove
 * the linting exception.
 */
// import { Layout } from '@buffet/layout';
import { AsyncContent, Layout } from 'gca-react-components';
import get from 'lodash/get';
import React from 'react';
import { InjectedIntlProps, injectIntl } from 'react-intl';
import { connect } from 'react-redux';
import { Redirect, Route, RouteComponentProps, Switch, withRouter } from 'react-router-dom';

import { selectors } from 'gca-react-components/src/redux-modules/currentContext';
import { initializeGcScope } from 'gca-react-components/src/redux-modules/initializeApp';

import { GcScope, getGcScope } from 'shared-utils/gcScope';

import Directory from '../../Directory/Directory';
import ManageRoles from '../../ManageRoles/ManageRoles'
import { State } from '../../store/types';
import UserEditor from '../../UserEditor/UserEditor';
import MainNav from '../MainNav/MainNav';
import ModalManager from '../Modals/ModalManager';

import './App.scss';


interface AppActions {
  initializeGcScope: (...args: Parameters<typeof initializeGcScope>) => void;
}

interface AppState {
  loading: boolean;
  error: boolean;
  features: { [featureName: string]: boolean; };
  scopeType: string;
}

type AppProps = AppState & AppActions & InjectedIntlProps & RouteComponentProps<{}>;

// TODO: make this work when tests ar fixed
// const Directory = React.lazy(
//   () => import(/* webpackChunkName: "Directory" */ '../../Directory/Directory'),
// );
// const UserEditor = React.lazy(
//   () => import(/* webpackChunkName: "UserEditor" */ '../../UserEditor/UserEditor'),
// );
// const ManageRoles = React.lazy(
//   () => import(/* webpackChunkName: "ManageRoles" */ '../../ManageRoles/ManageRoles'),
// );

class AppImpl extends React.Component<AppProps> {
  public componentDidMount() {
    this.props.initializeGcScope(getGcScope(window));
  }

  public render() {
    const { scopeType } = this.props;

    return (
      <AsyncContent
        isLoading={this.props.loading}
        isError={this.props.error}
        errorTitle={this.props.intl.formatMessage({ id: 'userAccounts.errorTitle' })}
        errorMessage={this.props.intl.formatMessage({ id: 'userAccounts.errorMessage' })}
      >
        <Layout title={this.props.intl.formatMessage({ id: `userAccounts.${scopeType}.title` })}>
          <MainNav />
          <section className="app-content">
            <React.Suspense fallback={<div />}>
              <Switch>
                <Route path="/access-types" component={ManageRoles} />
                <Route path="/directory/user/new" component={UserEditor} />
                <Route path="/directory/user/:userId" component={UserEditor} />
                <Route path="/directory" component={Directory} />
                <Redirect to="/directory" />
              </Switch>
            </React.Suspense>
          </section>
          <ModalManager />
        </Layout>
      </AsyncContent>
    );
  }
}

/**
 * Check if initial initialization APIs are complete.
 * Note: if the app works in a Group context there will be no featureToggle fetch.
 * This is required because the featureToggle state is incorrectly initialized
 * with isFetching set to `true`. The code below disregard the featureToggle state
 * completely unless we work in 'restaurant' mode.
 */
function isLoading(state: State) {
  return (
    selectors.isFetching(state) && !selectors.fetchFailed(state)
  ) || (
    get(state, ['scope', 'type']) === 'restaurant' &&
    get(state, ['featureToggles', 'isFetching']) &&
    !get(state, ['featureToggles', 'fetchFailed'])
  );
}

export function mapStateToProps(state: State): AppState {
  return {
    error: selectors.fetchFailed(state),
    features: get(state, ['featureToggles', 'features']),
    loading: isLoading(state) ,
    scopeType: get(state, ['appScope', 'type']),
  };
}

export const mapDispatchToProps = {
  initializeGcScope,
};

const AppIntl = injectIntl(AppImpl);
const AppConnected =
  connect<AppState, AppActions, RouteComponentProps<{}>>(mapStateToProps, mapDispatchToProps)(AppIntl);
const App = withRouter(AppConnected);

export default App;
export { AppImpl as PureApp };
