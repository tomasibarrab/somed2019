import { FormApi, FormState, Unsubscribe } from 'final-form';
import isEmpty from 'lodash/isEmpty';
import isEqual from 'lodash/isEqual';
import pickBy from 'lodash/pickBy';
import { Observable } from 'rxjs/Observable';


export interface BatchChanges {
  [ key: string ]: any;
}

export interface FormChange<T> {
  newValues: Partial<T>;
  previousValues: T;
  errors: { [field: string]: string };
}

export type FormObservable<T> = Observable<FormChange<T>>;
export type ChangesObservable = Observable<BatchChanges>

type DecoratorEpic<T> = (action$: Observable<FormChange<T>>) => Observable<BatchChanges>;

/**
 * Utility for creating a final-form decorator using a Epic like function.
 * This observe function accepts two parameters:
 * The initialValues (of type T) representing the values the final-form has been initialized with.
 * The decoratorEpic as a function receiving an action$ (an observable of FormChange<T>) and
 * returning an Observable with BatchChanges.
 * The decoratorEpic is responsible for triggering other actions and producing any changes to the
 * form values to be applied to the form automatically.
 *
 * decoratorEpic functions be used - for example - to fetch data on the fly (upon user input), or
 * to automatically fill some of the fields in a final-form.
 */
export function observe<T extends object>(initialValues: T, decoratorEpic: DecoratorEpic<T>) {
  let reactToChange = true;
  let previousValues: any = { ...initialValues as any };

  return (form: FormApi): Unsubscribe => {
    const source$ = new Observable<FormChange<T>>(subscriber => {
      return form.subscribe((p: FormState) => {
        // 1 - quits immediately if we are not set react to changes
        if (!reactToChange) {
          reactToChange = true;
          return;
        }
        // 2 - create the object with the new values
        const newValues: Partial<T> = pickBy<T>(
          p.values as T,
          (value, key) => !isEqual(previousValues[key], value)) ;

        // 3 - emits events to be parsed by the epic and captured by the subscriber
        if (!isEmpty(newValues)) {
          subscriber.next({ newValues, previousValues, errors: p.errors });
        }
      },
      { values: true, errors: true })
    });

    // Here we allow the client code to react to form events
    const subscription = decoratorEpic(source$).subscribe({
      next: (changes: BatchChanges) => {
        reactToChange = true;
        if (!isEmpty(changes)) {
          form.batch(() => {
            Object.keys(changes).forEach((cname) => {
              form.change(cname, changes[cname]);
              reactToChange = false; // Inform the caller there is no need to react to this change.
            });
          });
        }
        previousValues = { ...form.getState().values };
      },
    });
    return () => {
      subscription.unsubscribe();
    }
  }
}
