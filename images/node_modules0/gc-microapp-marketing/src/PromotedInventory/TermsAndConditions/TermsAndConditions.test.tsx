import { mount } from 'enzyme';
import React from 'react';
import { IntlProvider } from 'react-intl';
import { Provider } from 'react-redux';
import configureMockStore from 'redux-mock-store';
import { CampaignTypes, Pages } from '../../store/campaigns/campaigns.types';
import { keys } from '../../translations/bundles/marketing.json';
import { LINK_TO_SPECIALS_TERMS_V1, TERMS_AND_CONDITIONS_FORM_NAME } from '../constants';
import TermsAndConditions from './TermsAndConditions';

jest.mock('platform', () => ({
  name: 'Browser name',
  os: 'The Operating System',
}));

const createComponent = (state, campaign, incentive, confirm, linkToTerms) => {
  const store = configureMockStore()(state);

  return mount(
    <Provider store={store}>
      <IntlProvider locale="en-US" messages={keys}>
        <TermsAndConditions
          campaign={campaign}
          incentive={incentive}
          confirm={confirm}
          detailsOpen={false}
          linkToTerms={linkToTerms}
        />
      </IntlProvider>
    </Provider>,
  );
};

describe('TermsAndConditions', () => {
  /* tslint:disable:object-literal-sort-keys */
  /* It makes way less sense when you force these property names to be alphabetical. */
  const campaign = {
    type: CampaignTypes.Special,
    startDate: '2018-01-01',
    endDate: '2018-01-01',
    schedule: [
      {
        dayOfWeek: 'FRIDAY',
        endTime: '10:30:00',
        startTime: '08:00:00',
      },
    ],
    pricingTier: {
      tier: 'High',
      price: 3,
      currencyCode: 'USD',
    },
    suppressionDates: {
      custom: [],
      default: ['new_years_day'],
    },
  };

  const incentive = {
    description: 'test description',
    name: 'incentive name',
    offerTypeName: 'happy hour',
  };

  const state = {
    currentContext: { user: { firstName: 'John', lastName: 'Doe', userName: 'john.doe@example.com' } },
    form: {
      [TERMS_AND_CONDITIONS_FORM_NAME]: {
        values: {
          agreed: true,
          restaurantLegalName: 'restaurant legal name',
          name: 'John Doe',
          email: 'john.doe@example.com',
        },
      },
    },
  };

  const linkToTerms = {
    id: 'guestcampaigns.terms.opentable_client_agreement',
    link: LINK_TO_SPECIALS_TERMS_V1,
  };

  test('campaign details opens and closes', () => {
    const confirm = jest.fn();

    const wrapper = createComponent(state, campaign, incentive, confirm, linkToTerms);
    const toggle = wrapper.find('.toggle-readonly-campaign-details').first();

    let readonlyDraftCampaign = wrapper.find('.readonly-draft-campaign');
    expect(readonlyDraftCampaign.length).toEqual(0);

    toggle.simulate('click');

    readonlyDraftCampaign = wrapper.find('.readonly-draft-campaign');
    expect(readonlyDraftCampaign.length).toEqual(1);

    toggle.simulate('click');

    readonlyDraftCampaign = wrapper.find('.readonly-draft-campaign');
    expect(readonlyDraftCampaign.length).toEqual(0);
  });

  test('invalid form fields when touched && error', () => {
    const invalidFormFieldsState = {
      ...state,
      form: {
        [TERMS_AND_CONDITIONS_FORM_NAME]: {
          values: {
            agreed: false,
            restaurantLegalName: '',
            name: '',
            email: 'john.doe@example.com',
          },
          fields: {
            restaurantLegalName: {
              touched: true,
            },
          },
          syncErrors: {
            restaurantLegalName: 'required',
          },
        },
      },
    };
    const confirm = jest.fn();

    const wrapper = createComponent(invalidFormFieldsState, campaign, incentive, confirm, linkToTerms);

    const restaurantLegalNameField = wrapper.find('div.restaurant-legal-name Input[valid=false]');
    expect(restaurantLegalNameField.length).toEqual(1);
  });

  test('clicking agree and publish fires props.confirm with browser info', () => {
    const confirm = jest.fn();

    const wrapper = createComponent(state, campaign, incentive, confirm, linkToTerms);

    const publishButton = wrapper.find('button.agree-and-publish').first();

    publishButton.simulate('submit');

    expect(confirm).toHaveBeenCalled();
    expect(confirm.mock.calls[0][0].browserInfo).not.toBeUndefined();
  });
});
