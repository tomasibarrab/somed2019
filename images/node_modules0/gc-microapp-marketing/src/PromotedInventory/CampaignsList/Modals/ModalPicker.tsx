import React from 'react';

import {
    CampaignState, CampaignType, CurrentBudgetType, FetchCampaignsOptions, ModalType, Pages,
    PatchActionPayload, PatchBudgetPayload, PutSuppressionDatesPayload,
} from '../../../store/campaigns/campaigns.types';
import ApproveModal from './ApproveModal';
import BlockedDatesPickerModal from './BlockedDates/BlockedDatesPickerModal';
import ChangeOrRemoveModal from './ChangeOrRemoveModal';
import EditBudgetModal from './EditBudgetModal';
import EndModal from './EndModal';
import PauseModal from './PauseModal';

interface Props {
  campaign: CampaignType;
  closeModal: () => void;
  currentUserEmail?: string;
  fetchCampaignsRequest: (payload: FetchCampaignsOptions) => void;
  modalType: ModalType;
  pageType: Pages;
  patchBudgetRequest: (payload: PatchBudgetPayload) => void;
  patchCampaignRequest: (payload: PatchActionPayload) => void;
  putSuppressionDates: (payload: PutSuppressionDatesPayload) => void;
}

const makeCloseAndFetchIfSuccess = (
  closeModal: () => void,
  fetchCampaigns: (payload: FetchCampaignsOptions) => void,
  pageType: Pages,
): ((success: boolean) => void) => {
  return (success: boolean) => {
    closeModal();
    if (success) {
      fetchCampaigns({ pageType });
    }
  };
};

const ModalPicker: React.SFC<Props> = ({
  campaign,
  closeModal,
  currentUserEmail,
  fetchCampaignsRequest,
  modalType,
  pageType,
  patchBudgetRequest,
  patchCampaignRequest,
  putSuppressionDates,
}) => {
  /*
    In the Pause Modal, the user confirms the Pause action, which fires off
    the request to patch the campaign. They then get to the second screen of
    the modal which informs them of the pause duration. Then they either
    click the 'OK, Got It' button, the X, or outside the modal to close it,
    which then fetches campaigns again.

    If they close the modal without confirming the pause, we do not refetch
    the campaign list.

    The end modal only has a single screen/step, and the End action and the
    refetch of campaigns happen in succession in the patch Epic and then the
    fetch Epic.

    I did not have the pause action fetch campaigns in succession like the
    end action because fetching the campaign list sets 'loading' in the
    reducer which causes the 2nd screen/step of the pause modal to disappear
    along with the rest of the Campaigns component for the duration of the
    fetch. As well, it might appear strange to the user to have the list
    move behind the modal while it is still open.
  */

  const closeAndFetchIfSuccess = makeCloseAndFetchIfSuccess(closeModal, fetchCampaignsRequest, pageType);

  const { campaignId } = campaign;

  switch (modalType) {
    case ModalType.Pause:
      return (
        <PauseModal
          confirm={() =>
            patchCampaignRequest({
              campaignId,
              state: CampaignState.Paused,
            })
          }
          close={closeAndFetchIfSuccess}
        />
      );
    case ModalType.End:
      return (
        <EndModal
          confirm={() =>
            patchCampaignRequest({
              campaignId,
              refetchCampaigns: true,
              state: CampaignState.Ended,
            })
          }
          close={closeModal}
          campaign={campaign}
        />
      );
    case ModalType.EditBlockedDays:
      return <BlockedDatesPickerModal confirm={putSuppressionDates} close={closeModal} campaign={campaign} />;
    case ModalType.EditBudget:
      return (
        <EditBudgetModal
          campaignId={campaignId}
          confirm={patchBudgetRequest}
          close={closeModal}
          currentUserEmail={currentUserEmail}
        />
      );
    case ModalType.Approve:
      return <ApproveModal campaign={campaign} confirm={patchCampaignRequest} close={closeAndFetchIfSuccess} />;
    case ModalType.RequestChange:
      return <ChangeOrRemoveModal campaign={campaign} confirm={patchCampaignRequest} close={closeAndFetchIfSuccess} />;
    default:
      return null;
  }
};

export default ModalPicker;
