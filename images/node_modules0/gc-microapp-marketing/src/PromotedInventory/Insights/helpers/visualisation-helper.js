import {
  COMMON_WALKIN,
  COMMON_YOUR_NETWORK,
  COMMON_OPENTABLE_NETWORK,
  COMMON_PHONE,
  COMMON_BONUS_POINTS,
  COMMON_CUSTOM_PROMOTIONS,
  COMMON_OFFER,
  COMMON_PROMOTED_RESULTS,
  COMMON_PROMOTED_RESULTS_WITH_TARGETING,
} from './constants';

import { remapLabels, mapIntlText } from './mapping';

import _ from 'lodash';

const totalDefaultData = {
  total_actual: 0,
  total_previous: 0,
};

export const leadTimesKeys = [
  COMMON_OPENTABLE_NETWORK,
  COMMON_YOUR_NETWORK,
  COMMON_PHONE,
];
export const coversSourceKeys = [
  COMMON_WALKIN,
  COMMON_PHONE,
  COMMON_YOUR_NETWORK,
  COMMON_OPENTABLE_NETWORK,
];

export const calculateTotal = (item, keys) => (item ? keys.reduce((acc, key) => {
  const totalActual = acc.total_actual + (item[`${key}_actual`] || 0);
  const totalPrevious = acc.total_previous + (item[`${key}_previous`] || 0);
  return {
    total_actual: totalActual,
    total_previous: totalPrevious,
  };
}, totalDefaultData)
:
totalDefaultData);

export const defaultHoverBarState = {
  hoveredBarId: undefined,
  data: undefined,
  tooltip: {
    direction: 'left',
    offsetFromMouse: 10,
    dimensions: {
      width: 290,
      height: 200,
    },
    isVisible: false,
    location: {
      x: 0,
      y: 0,
    },
    tooltipProps: undefined,
  },
};

export const defaultHoverAreaState = {
  hoveredAreaId: undefined,
  tooltip: {
    direction: 'left',
    offsetFromMouse: 10,
    dimensions: {
      width: 290,
      height: 200,
    },
    isVisible: false,
    location: {
      x: 0,
      y: 0,
    },
    tooltipProps: undefined,
  },
};

export const roundPercentage = (arr, total = 100) => {
  const off = total - arr.reduce((acc, curr) => acc + Math.round(curr.value), 0);
  return _.chain(arr)
    .sortBy((item) => Math.round(item.value) - item.value)
    .map((item, i) => ({
      id: item.id,
      value: (item.value === 0) ? 0 : (Math.round(item.value) + (off > i)) - (i >= (arr.length + off)),
    }))
    .value();
};

export const getLabels = (str, intl) => {
  switch (str) {
    case 'party1-2': return '1-2';
    case 'party3-4': return '3-4';
    case 'party5-6': return '5-6';
    case 'party7-8': return '7-8';
    case 'party9-10': return '9-10';
    case 'party11+': return '11+';
    case 'min90': return ['90', intl.formatMessage({ id: 'guests.covertrends.leadtime.time.minutes' })];
    case 'hr24': return ['24', intl.formatMessage({ id: 'guests.covertrends.leadtime.time.hours' })];
    case 'day2-3': return ['2-3', intl.formatMessage({ id: 'guests.covertrends.leadtime.time.days' })];
    case 'day4-7': return ['4-7', intl.formatMessage({ id: 'guests.covertrends.leadtime.time.days' })];
    case 'day8-14': return ['8-14', intl.formatMessage({ id: 'guests.covertrends.leadtime.time.days' })];
    case 'day14+': return ['14+', intl.formatMessage({ id: 'guests.covertrends.leadtime.time.days' })];
    default: return str;
  }
};

export const getIntlLabels = (id, intl) => {
  switch (id) {
    case 'party1-2': return intl.formatMessage({ id: 'guests.covertrends.count.partySize' }, { partySize: '1-2' });
    case 'party3-4': return intl.formatMessage({ id: 'guests.covertrends.count.partySize' }, { partySize: '3-4' });
    case 'party5-6': return intl.formatMessage({ id: 'guests.covertrends.count.partySize' }, { partySize: '5-6' });
    case 'party7-8': return intl.formatMessage({ id: 'guests.covertrends.count.partySize' }, { partySize: '7-8' });
    case 'party9-10': return intl.formatMessage({ id: 'guests.covertrends.count.partySize' }, { partySize: '9-10' });
    case 'party11+': return intl.formatMessage({ id: 'guests.covertrends.count.partySize' }, { partySize: '11+' });
    case 'min90': return intl.formatMessage({ id: 'guests.covertrends.leadtime.advance.minutes' }, { time: '90' });
    case 'hr24': return intl.formatMessage({ id: 'guests.covertrends.leadtime.advance.hours' }, { time: '24' });
    case 'day2-3': return intl.formatMessage({ id: 'guests.covertrends.leadtime.advance.days' }, { time: '2-3' });
    case 'day4-7': return intl.formatMessage({ id: 'guests.covertrends.leadtime.advance.days' }, { time: '4-7' });
    case 'day8-14': return intl.formatMessage({ id: 'guests.covertrends.leadtime.advance.days' }, { time: '8-14' });
    case 'day14+': return intl.formatMessage({ id: 'guests.covertrends.leadtime.advance.days' }, { time: '14+' });
    case COMMON_WALKIN: return intl.formatMessage({ id: 'guests.common.source.walkin' });
    case COMMON_YOUR_NETWORK: return intl.formatMessage({ id: 'guests.common.source.yournetwork' });
    case COMMON_OPENTABLE_NETWORK: return intl.formatMessage({ id: 'guests.common.source.opentablenetwork' });
    case COMMON_PHONE: return intl.formatMessage({ id: 'guests.common.source.phone' });
    default: return id;
  }
};

export const mapColumns = ({ data, intl, key = 'id', labelMethod }) => data.map((v) => ({
  id: v[key],
  label: (typeof labelMethod === 'function') ? labelMethod(v[key]) : getLabels(v[key], intl),
}));

export const getPercentageDiff = (actual = 0, previous = 0) => {
  const diff = actual - previous;
  if (actual === 0 && previous === 0) {
    return 0;
  } else if (previous === 0) {
    return 100;
  }
  return (Math.abs(diff) / previous) * 100;
};

export const getCompareIcon = (diff, compare) => {
  if (diff === 0) {
    return undefined;
  }

  return {
    type: 'arrow',
    color: compare.color,
    direction: compare.direction,
    height: 16,
  };
};

export const hasEmptyData = (data, arr = ['actual', 'previous']) => {
  const isEmpty = data.map((item) => {
    const itemTotal = Object.keys(item).reduce((acc, key) => {
      const subtotal = arr.reduce((subAcc, curr) => {
        if (key.includes(curr) && !key.includes('date')) {
          const val = item[key] === null ? 0 : item[key];
          return subAcc + val;
        }
        return subAcc;
      }, 0);
      return acc + subtotal;
    }, 0);
    return itemTotal;
  });
  return isEmpty.every((item) => item === 0);
};

// filter out the unexpected data that was out of the selected date range
export const constrainToDateRange = (dates, data) => {
  if (typeof data === 'undefined') {
    return null;
  }
  return data.filter((d) => d.date_actual <= dates.endDate);
};


export const campaignKeys = [
  COMMON_BONUS_POINTS,
  COMMON_CUSTOM_PROMOTIONS,
  COMMON_OFFER,
  COMMON_PROMOTED_RESULTS,
  COMMON_PROMOTED_RESULTS_WITH_TARGETING,
];

import {
  fuchsiaLight,
  fuchsiaLightest,
  greenLight,
  red,
  ash,
} from 'otkit-colors/token.common';

export const getCompareStatus = (diff) => {
  if (diff > 0) {
    return {
      color: greenLight,
      direction: 'up',
      status: 'positive',
    };
  } else if (diff < 0) {
    return {
      color: red,
      direction: 'down',
      status: 'negative',
    };
  }

  return {
    color: ash,
    direction: undefined,
    status: 'empty',
  };
};

export const getCampaignToolTipContent = (data, intl, locale) => {
  if (!data) {
    return null;
  }

  const intlFormat = (id) => intl.formatMessage({ id });
  const intlNumber = (value) => intl.formatNumber(value);
  const icon = {
    type: 'circle',
    color: fuchsiaLight,
    radius: 8,
  };

  const intlCampaignOffer = (str) => {
    const mapIntl = remapLabels(str, locale);
    return intlFormat(mapIntlText(mapIntl));
  };

  const promoData = campaignKeys.reduce((acc, curr) => {
    const intlLabel = () => {
      switch (curr) {
        case COMMON_BONUS_POINTS: return intlFormat('guests.common.campaign.bonuspoints');
        case COMMON_CUSTOM_PROMOTIONS: return intlFormat('guests.common.campaign.custompromotions');
        case COMMON_OFFER: return intlCampaignOffer(COMMON_OFFER);
        case COMMON_PROMOTED_RESULTS: return intlFormat('guests.common.campaign.promotedresults');
        case COMMON_PROMOTED_RESULTS_WITH_TARGETING: return intlFormat('guests.common.campaign.promotedresults_targeting');
        default: return '';
      }
    };
    if (data[curr] > 0) {
      const content = {
        icon,
        label: intlLabel(curr),
        value: intlNumber(data[curr]),
      };
      acc.push(content);
      return acc;
    }
    return acc;
  }, []);

  return promoData.length > 0 ?
  {
    style: {
      backgroundColor: fuchsiaLightest,
    },
    content: promoData,
  }
  :
  null;
};

// Show decimals if there is one or omit floating points if the number is whole
export const showPercentage = (value) => {
  if (value === null || value === undefined) {
    return 0;
  }

  const check = (value - Math.floor(value)) !== 0;
  if (check) {
    return (value >= 1) ? value.toFixed(0) : value.toFixed(1);
  }
  return value.toFixed(0);
};
