import 'rxjs/add/observable/merge';
import 'rxjs/add/operator/toArray';
import '../commonRxjs';

import { selectors, User } from 'gca-react-components/src/redux-modules/currentContext';
import moment from 'moment';
import { combineEpics } from 'redux-observable';
import { Observable } from 'rxjs/Observable';

import { Action, ActionCreator, actionCreatorFactory, AsyncActionCreators } from 'typescript-fsa';
import { ReducerBuilder, reducerWithInitialState } from 'typescript-fsa-reducers';

import { CampaignType } from '../../store/campaigns/campaigns.types';
import { Epic, State } from '../types';
import {
  CampaignTotal,
  ComparativePeriod,
  CoverTrends,
  DateRange,
  Days,
  DaysOfWeek,
  FetchCoverTrendsOptions,
  FetchCoverTypesOptions,
  FetchSummaryOptions,
  Filters,
  Granularity,
  InsightsState,
  TimeRange,
} from './insights.types';
import { getCampaignTotals, getInsights } from './selectors';
import { comparativeDateSelector, dateGranularity } from './utils';

// --------------------------------- //
// Actions
// --------------------------------- //

const actionCreator = actionCreatorFactory('INSIGHTS');

export const fetchCoverTrends = actionCreator.async<FetchCoverTrendsOptions, any>('FETCH_COVER_TRENDS');
export const fetchSummaryCurrent = actionCreator.async<FetchSummaryOptions, any>('FETCH_SUMMARY_CURRENT');
export const fetchSummaryPrevious = actionCreator.async<FetchSummaryOptions, any>('FETCH_SUMMARY_PREVIOUS');
export const fetchCoverTypes = actionCreator.async<FetchCoverTypesOptions, any>('FETCH_COVER_TYPES');
export const fetchCampaigns = actionCreator.async<number[], CampaignType[], any>('FETCH_CAMPAIGNS');

export const fetchActions = {
  fetchCoverTrends,
  fetchSummaryCurrent,
  fetchSummaryPrevious,
};

export const setDateRange = actionCreator<DateRange>('SET_DATE_RANGE');
export const setDaysOfWeek = actionCreator<DaysOfWeek>('SET_DAYS_OF_WEEK');
export const setTimeRange = actionCreator<TimeRange>('SET_TIME_RANGE');
export const setCompareTo = actionCreator<ComparativePeriod>('SET_COMPARE_TO');

export const filterActions = {
  setCompareTo,
  setDateRange,
  setDaysOfWeek,
  setTimeRange,
};

export type FilterActions = typeof filterActions;

// --------------------------------- //
// Reducers
// --------------------------------- //

/* TODO: Move this date format somewhere else */
const DATE_FORMAT = 'YYYY-MM-DD';
const getInitialDateRange = () => ({
  endDate: moment().format(DATE_FORMAT), // TODO: check inclusive/exclusive dates (- 6 days?)
  startDate: moment()
    .subtract(29, 'days')
    .format(DATE_FORMAT),
});

export const initialState: InsightsState = {
  campaigns: {
    // Change from false to true
    loading: true,
  },
  coverTrends: {
    loading: true,
  },
  coverTypes: {
    loading: true,
  },
  summaryCurrent: {
    loading: true,
  },
  summaryPrevious: {
    loading: true,
  },
  // tslint:disable-next-line:object-literal-sort-keys
  filters: {
    compareTo: ComparativePeriod.PreviousPeriod,
    dateRange: getInitialDateRange(),
    daysOfWeek: Object.values(Days).reduce((accumulator, day) => ({ ...accumulator, [day]: true }), {}) as DaysOfWeek,
    timeRange: {
      endTime: undefined,
      startTime: undefined,
    },
  },
};

/* Utility Types for Reducer and Epic generation */
interface ActionDescription<T> {
  action: ActionCreator<T>;
  stateKey: string;
}

interface AsyncActionDescription<T> {
  action: AsyncActionCreators<T, any, any>;
  stateKey: string;
  includeParams?: boolean;
}

/* Takes a reducer builder, and an array of action descriptions (described above)
  and adds simple "set" reducers for each action on to the given reducer builder.
  Reducers added operate in the 'filters' section of the state */
const addSimpleReducersForSetActionsInFilters = (
  reducerBuilder: ReducerBuilder<InsightsState, InsightsState>,
  actionDescriptions: Array<ActionDescription<any>>,
) => {
  let enrichedReducer: ReducerBuilder<InsightsState, InsightsState> = reducerBuilder;

  actionDescriptions.forEach(({ action, stateKey }) => {
    enrichedReducer = enrichedReducer.case(action, (state, payload) => ({
      ...state,
      filters: {
        ...state.filters,
        [stateKey]: payload,
      } as Filters,
    }));
  });

  return enrichedReducer;
};

/* Similar to above, but adds the 3 (started, done, and failed) reducers for each async
  action */
const add3ReducersForAsyncActionsInRoot = (
  reducerBuilder: ReducerBuilder<InsightsState, InsightsState>,
  actionDescriptions: Array<AsyncActionDescription<any>>,
) => {
  let enrichedReducer: ReducerBuilder<InsightsState, InsightsState> = reducerBuilder;

  actionDescriptions.forEach(({ action, stateKey, includeParams }) => {
    enrichedReducer = enrichedReducer
      .case(action.started, (state, payload) => ({
        ...state,
        [stateKey]: {
          loading: true,
        },
      }))
      .case(action.done, (state, { result, params }) => {
        const newStateForKey: any = {
          data: result,
          loading: false,
        };
        if (includeParams) {
          newStateForKey.params = params;
        }
        return {
          ...state,
          [stateKey]: newStateForKey,
        };
      })
      .case(action.failed, state => ({
        ...state,
        [stateKey]: {
          error: true,
          loading: false,
        },
      }));
  });

  return enrichedReducer;
};

const simpleReducer = addSimpleReducersForSetActionsInFilters(reducerWithInitialState(initialState), [
  {
    action: setDateRange,
    stateKey: 'dateRange',
  },
  {
    action: setDaysOfWeek,
    stateKey: 'daysOfWeek',
  },
  {
    action: setTimeRange,
    stateKey: 'timeRange',
  },
  {
    action: setCompareTo,
    stateKey: 'compareTo',
  },
]);

export const reducer = add3ReducersForAsyncActionsInRoot(simpleReducer, [
  {
    action: fetchCoverTrends,
    includeParams: true,
    stateKey: 'coverTrends',
  },
  {
    action: fetchSummaryCurrent,
    stateKey: 'summaryCurrent',
  },
  {
    action: fetchSummaryPrevious,
    stateKey: 'summaryPrevious',
  },
  {
    action: fetchCoverTypes,
    stateKey: 'coverTypes',
  },
  {
    action: fetchCampaigns,
    stateKey: 'campaigns',
  },
]);

// --------------------------------- //
// Epics
// --------------------------------- //

const createEpic = ({
  action,
  apiFunctionName,
  payloadDefaults = {},
  payloadOverwrites = {},
}: {
  action: AsyncActionCreators<any, any, any>;
  apiFunctionName: string;
  payloadDefaults?: any;
  payloadOverwrites?: any;
}): Epic => {
  return (actions$, store, { api }) =>
    actions$.ofType(action.started.type).switchMap(({ payload }) => {
      const state: State = store.getState();
      const rid: number = selectors.rid(state);
      const options = {
        rid,
        ...payloadDefaults,
        ...payload,
        ...payloadOverwrites,
      };
      return (api as any)
        [apiFunctionName](options)
        .map((response: any) => action.done({ params: payload, result: response.data }))
        .catch(() => [action.failed({ params: payload, error: true })]);
    });
};

const mapDaysOfWeekObjOfBoolsToArray = (daysOfWeek: DaysOfWeek) =>
  Object.entries(daysOfWeek)
    .filter(([key, val]) => val)
    .map(([key, val]) => key);

const createCommonFetchOptionsFromFilters = (filters: Filters) => ({
  ...filters.timeRange,
  ...filters.dateRange,
  daysOfWeek: mapDaysOfWeekObjOfBoolsToArray(filters.daysOfWeek),
});

const createComparativeDatesFromFilters = (filters: Filters) => {
  const { compareTo } = filters;

  return comparativeDateSelector(filters.dateRange, compareTo);
};

const createGranularityFromFilters = (filters: Filters) => {
  const dg = dateGranularity(filters.dateRange);
  return { granularity: dg === Granularity.Hour ? Granularity.Day : dg };
};

const createCoverTrendsFetchOptionsFromFilters = (filters: Filters) => ({
  ...createCommonFetchOptionsFromFilters(filters),
  ...createComparativeDatesFromFilters(filters),
  ...createGranularityFromFilters(filters),
});

const createPreviousSummaryFetchOptionsFromFilters = (filters: Filters) => {
  const { comparativeStartDate, comparativeEndDate } = comparativeDateSelector(filters.dateRange, filters.compareTo);

  return {
    endDate: comparativeEndDate,
    startDate: comparativeStartDate,
    ...filters.timeRange,
    daysOfWeek: mapDaysOfWeekObjOfBoolsToArray(filters.daysOfWeek),
  };
};

/* Utility type for describing inputs to createEpic */
interface FetchActionDescription {
  action: AsyncActionCreators<any, any, any>;
  apiFunctionName: string;
  createPayloadFromFilterValues: (filters: Filters) => any;
}

const fetchActionDescriptions: FetchActionDescription[] = [
  {
    action: fetchCoverTrends,
    apiFunctionName: 'fetchCoverTrends',
    createPayloadFromFilterValues: createCoverTrendsFetchOptionsFromFilters,
  },
  {
    action: fetchSummaryCurrent,
    apiFunctionName: 'fetchReservationSummary',
    createPayloadFromFilterValues: createCommonFetchOptionsFromFilters,
  },
  {
    action: fetchSummaryPrevious,
    apiFunctionName: 'fetchReservationSummary',
    createPayloadFromFilterValues: createPreviousSummaryFetchOptionsFromFilters,
  },
  {
    action: fetchCoverTypes,
    apiFunctionName: 'fetchCoverTypes',
    createPayloadFromFilterValues: (filters: Filters) => filters.dateRange,
  },
];

const fetchEpics = fetchActionDescriptions.map(createEpic);

export const refetchDataWhenFiltersChangeEpic: Epic = (actions$, store) =>
  actions$.ofType(...Object.values(filterActions).map(({ type }) => type)).mergeMap(({ payload }) => {
    const state: State = store.getState();
    const filters: Filters = getInsights(state).filters;
    const toDispatch = fetchActionDescriptions.map(({ action, createPayloadFromFilterValues }) =>
      action.started(createPayloadFromFilterValues(filters)),
    );

    return Observable.from(toDispatch);
  });

export const triggerFetchEachCampaignDetailsEpic: Epic = (actions$, store) =>
  actions$.ofType(fetchCoverTypes.done.type).map(() => {
    const state: State = store.getState();
    const campaignTotals: CampaignTotal[] = getCampaignTotals(state);

    if (campaignTotals.length === 0) {
      return undefined;
    }
    return fetchCampaigns.started(campaignTotals.map(({ campaignId }) => campaignId));
  });

export const fetchEachCampaignDetailsEpic: Epic = (actions$, store, { api }) =>
  actions$.ofType(fetchCampaigns.started.type).mergeMap(({ payload: campaignIds }) => {
    const state: State = store.getState();
    const rid: number = selectors.rid(state);

    return Observable.merge(
      ...campaignIds.map(intCampaignId =>
        api.fetchCampaign(rid, intCampaignId).map(campaign => ({
          ...campaign,
          campaignId: intCampaignId,
          uuidCampaignId: campaign.campaignId,
        })),
      ),
    )
      .toArray()
      .map((campaigns: CampaignType[]) => fetchCampaigns.done({ params: campaignIds, result: campaigns }))
      .catch(() => [fetchCampaigns.failed({ params: campaignIds, error: true })]);
  });

export const insightsEpic = combineEpics(
  refetchDataWhenFiltersChangeEpic,
  triggerFetchEachCampaignDetailsEpic,
  fetchEachCampaignDetailsEpic,
  ...fetchEpics,
);
