import '../commonRxjs';

import { selectors, User } from 'gca-react-components/src/redux-modules/currentContext';
import { combineEpics } from 'redux-observable';
import { Observable } from 'rxjs/Observable';
import { AjaxResponse } from 'rxjs/observable/dom/AjaxObservable';
import { reduce, zip } from 'rxjs/operators';
import { Action, actionCreatorFactory } from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';

import { makeSpecialPayload } from '../../PromotedInventory/Specials/makeSpecialPayload';
import { VisibilityType } from '../../store/flexiblepricing/flexiblepricing.types';
import { Epic, State } from '../types';
import {
    CampaignState, CampaignsType, CampaignType, CampaignTypes, CreateActionPayload, CreditsModel,
    CreditsResponse, FetchCampaignsOptions, ModalType, OpenCreationTermsModalPayload,
    OpenModalPayload, Pages, PatchActionPayload, PatchBudgetPayload, PutSuppressionDatesPayload,
    SpendModel,
} from './campaigns.types';
import makeCreditsModel from './makeCreditsModel';

// --------------------------------- //
// Presentation -> Types mapping
// Challenge: Try to do it with an object
// Hint: Mapped types _look_ like they work until you go use it
// --------------------------------- //

const getCampaignTypesForPages = (pageType: Pages): CampaignTypes[] => {
  switch (pageType) {
    case Pages.CustomPromotions:
      return [CampaignTypes.CustomPromotions];
    case Pages.Specials:
      return [CampaignTypes.Special];
    case Pages.FlexiblePricing:
      return [CampaignTypes.CustomPromotions];
    default:
      // info: exclude CampaignTypes.LegacyPromotedOffer for now
      return [CampaignTypes.PromotedResults];
  }
};

// --------------------------------- //
// Actions
// --------------------------------- //

const actionCreator = actionCreatorFactory('CAMPAIGNS');

const fetchCampaigns = actionCreator.async<FetchCampaignsOptions, any>('FETCH');

// TODO: fix return type
const getCredits = actionCreator.async<any, CreditsModel>('GET_CREDITS');
// TODO: const getSpend = actionCreator.async<any, any>('GET_SPEND');

const patchCampaign = actionCreator.async<PatchActionPayload, boolean, boolean>('PATCH');
const patchBudget = actionCreator.async<PatchBudgetPayload, boolean, boolean>('PATCH_BUDGET');
const putSuppressionDates = actionCreator.async<PutSuppressionDatesPayload, boolean, boolean>('PUT_SUPPRESSION_DATES');
const openCreationTermsModal = actionCreator<OpenCreationTermsModalPayload>('OPEN_CREATION_TERMS_MODAL');
const closeCreationTermsModal = actionCreator('CLOSE_CREATION_TERMS_MODAL');
const showNotifyPopup = actionCreator('SHOW_NOTIFY_POPUP');
const hideNotifyPopup = actionCreator('HIDE_NOTIFY_POPUP');

// TODO: set return types
const openEditBudgetModal = actionCreator.async<CampaignType, any>('OPEN_EDIT_BUDGET_MODAL');

/* < Parameter Type, Success Type, Error Type > */
const createCampaign = actionCreator.async<CreateActionPayload, any>('CREATE');
export const clearCreate = actionCreator('CLEAR_CREATE');

const openModal = actionCreator<OpenModalPayload>('OPEN_MODAL');
export const closeModal = actionCreator('CLOSE_MODAL');

export const campaignSelector = (state: State): Partial<CampaignsType> => {
  const campaigns = state.campaigns;
  return campaigns;
};

const clickCallToAction = actionCreator<any>('CLICK_CALL_TO_ACTION');

export const actions = {
  clickCallToAction,
  closeCreationTermsModal,
  createCampaign,
  fetchCampaigns,
  getCredits,
  hideNotifyPopup,
  openCreationTermsModal,
  openEditBudgetModal,
  openModal,
  patchBudget,
  patchCampaign,
  putSuppressionDates,
  showNotifyPopup,
};

// --------------------------------- //
// Reducer
// --------------------------------- //

export const initialState: CampaignsType = {
  create: {
    pending: false,
  },
  error: false,
  list: [],
  loading: false,
  pageType: Pages.PromotedResults,
  success: false,
};

export const reducer = reducerWithInitialState(initialState)
  .case(fetchCampaigns.started, (state, { pageType }) => ({
    ...state,
    loading: true,
    // pageType in payload is optional, keep what's in the state if it's not present
    pageType: pageType || state.pageType,
  }))
  .case(fetchCampaigns.done, (state, { result: list }) => ({
    ...state,
    list,
    loading: false,
    success: true,
  }))
  .case(fetchCampaigns.failed, state => ({
    ...state,
    error: true,
    list: [],
    loading: false,
  }))
  .case(patchCampaign.failed, state => ({
    ...state,
    error: true,
  }))
  .case(patchBudget.failed, state => ({
    ...state,
    error: true,
  }))
  .case(patchBudget.done, (state, { params }) => {
    const { campaignId, monthlyBudget }: PatchBudgetPayload = params;
    return {
      ...state,
      list: state.list.map((campaign: CampaignType) => {
        if (campaign.campaignId === campaignId) {
          return {
            ...campaign,
            monthlyBudget,
          };
        }
        return campaign;
      }),
      loading: false,
      success: true,
    };
  })
  .case(createCampaign.started, state => ({
    ...state,
    create: {
      pending: true,
    },
  }))
  .case(createCampaign.done, state => ({
    ...state,
    create: {
      pending: false,
      success: true,
    },
  }))
  .case(createCampaign.failed, state => ({
    ...state,
    create: {
      pending: false,
      success: false,
    },
  }))
  .case(clearCreate, state => ({
    ...state,
    create: {
      pending: false,
    },
  }))
  .case(openModal, (state, { campaign, type }) => ({
    ...state,
    modal: {
      campaign,
      type,
    },
  }))
  .case(openEditBudgetModal.done, (state, { result: { campaign, currentBudget } }) => ({
    ...state,
    modal: {
      campaign,
      currentBudget,
      type: ModalType.EditBudget,
    },
  }))
  .case(closeModal, state => ({
    ...state,
    modal: undefined,
  }))
  .case(showNotifyPopup, state => ({
    ...state,
    showNotifyPopup: true,
  }))
  .case(hideNotifyPopup, state => ({
    ...state,
    showNotifyPopup: undefined,
  }))
  .case(openCreationTermsModal, (state, { formValuesSnapshot }) => ({
    ...state,
    create: {
      modal: {
        formValuesSnapshot,
      },
      pending: false,
    },
  }))
  .case(closeCreationTermsModal, state => ({
    ...state,
    create: {
      ...state.create,
      modal: undefined,
    },
  }));

// --------------------------------- //
// Epics
// --------------------------------- //

export const fetchCampaignsEpic: Epic = (action$, store, { api }) =>
  action$.ofType(fetchCampaigns.started.type).switchMap(({ payload }) => {
    const state: State = store.getState();
    const rid: number = selectors.rid(state);
    const campaignTypes: CampaignTypes[] = getCampaignTypesForPages(state.campaigns.pageType);
    if ([Pages.FlexiblePricing, Pages.CustomPromotions].includes(state.campaigns.pageType)) {
      return api
        .fetchCampaigns({ rid, types: campaignTypes, includeDetails: true })
        .mergeMap((response: { data: CampaignType[] }) => {
          const result = (response.data || []).filter(
            ({ flexiblePricingVisibility, needsDecisionMakerApproval, state: campaignState }) => {
              const isFlex =
                flexiblePricingVisibility &&
                [VisibilityType.Standard, VisibilityType.Increase].includes(flexiblePricingVisibility as any);
              if (state.campaigns.pageType === Pages.FlexiblePricing) {
                return isFlex;
              }
              // Custom Promotions - need to show custom promotions of all kinds, and also any
              // campaign needing approval Flex included
              return !isFlex || (needsDecisionMakerApproval && campaignState === CampaignState.Draft);
            },
          );
          const tasks: Array<Action<any>> = [fetchCampaigns.done({ params: payload, result })];
          return tasks;
        })
        .catch(() => [fetchCampaigns.failed({ params: payload, error: {} })]);
    }
    return api
      .fetchCampaigns({ rid, types: campaignTypes })
      .map((response: { data: CampaignsType }) => fetchCampaigns.done({ params: payload, result: response.data }))
      .catch(() => [fetchCampaigns.failed({ params: payload, error: {} })]);
  });

export const createCampaignEpic: Epic = (action$, store, { api }) =>
  action$.ofType(createCampaign.started.type).switchMap(({ payload }) => {
    const { approvalInfo, formValues, refetchCampaigns } = payload;
    const state: State = store.getState();
    const rid: number = selectors.rid(state);
    const user: User = selectors.user(state);
    const createCampaignDTO: Partial<CampaignType> = makeSpecialPayload(formValues, user, rid, approvalInfo);
    return api
      .createCampaign(rid, createCampaignDTO)
      .mergeMap(() => {
        const tasks: Array<Action<any>> = [createCampaign.done({ params: payload, result: true })];
        if (refetchCampaigns) {
          tasks.push(fetchCampaigns.started({ pageType: payload.refetchCampaigns }));
        }
        return tasks;
      })
      .catch(() => [createCampaign.failed({ params: payload, error: true })]);
  });

export const patchCampaignEpic: Epic = (action$, store, { api }) =>
  action$.ofType(patchCampaign.started.type).switchMap(({ payload }) => {
    const state: State = store.getState();
    const user: User = selectors.user(state);
    const rid: number = selectors.rid(state);
    return api
      .patchCampaign(rid, payload.campaignId, {
        campaignApprovalInfo: payload.approvalInfo,
        campaignDiscardInfo: payload.campaignDiscardInfo,
        changedByUser: user.userName,
        state: payload.state,
      })
      .mergeMap(() => {
        const tasks: Array<Action<any>> = [patchCampaign.done({ params: payload, result: true })];
        if (payload.refetchCampaigns) {
          tasks.push(fetchCampaigns.started({}));
        }
        return Observable.from(tasks);
      })
      .catch(() => [patchCampaign.failed({ params: payload, error: true })]);
  });

export const patchBudgetEpic: Epic = (action$, store, { api }) =>
  action$.ofType(patchBudget.started.type).switchMap(({ payload }) => {
    const state: State = store.getState();
    const rid: number = selectors.rid(state);
    const user: User = selectors.user(state);
    const { campaignId, monthlyBudget } = payload;
    return api
      .patchBudget(campaignId, rid, {
        changedByUser: user.userName,
        monthlyBudget,
      })
      .mergeMap(({ response: { data } }: AjaxResponse) => {
        return Observable.from([
          patchBudget.done({
            params: {
              campaignId: data.campaignId,
              changedByUser: user.userName,
              monthlyBudget: data.monthlyBudget,
            },
            result: true,
          }),
          closeModal(),
          showNotifyPopup(),
        ]);
      })
      .catch(() => [patchBudget.failed({ params: payload, error: true })]);
  });

export const getCreditsAndSpendEpic: Epic = (action$, store, { api }) =>
  action$.ofType(openEditBudgetModal.started.type).switchMap(({ payload }) => {
    const cap: number = payload.monthlyBudget;
    const rid: number = payload.rid;
    const price: number = payload.pricingTier.price;
    const campaignId: string = payload.campaignId;

    const defaultSpend: SpendModel = {
      covers: 0,
      spend: 0,
      yearMonth: '',
    };

    const credits$ = api
      .fetchCredits(rid)
      .mergeMap((response: CreditsResponse) => {
        const { creditAmount } = makeCreditsModel(response);
        return [
          {
            credits: creditAmount,
          },
        ];
      })
      .catch(() => [openEditBudgetModal.failed({ params: payload, error: 'credits failed' })]);

    const spend$ = api
      .fetchSpend(rid, campaignId)
      .map(({ data }) =>
        data.reduce(
          (acc: SpendModel, month: SpendModel) => (!acc || acc.spend < month.spend ? month : acc),
          defaultSpend,
        ),
      )
      .catch(() => [openEditBudgetModal.failed({ params: payload, error: 'spend failed' })]);

    return credits$.pipe(zip(spend$)).map(([C, S]: any[]) => {
      const { credits } = C;
      const { covers, spend } = S;
      return openEditBudgetModal.done({
        params: payload,
        result: {
          campaign: payload,
          currentBudget: {
            cap,
            covers,
            credits,
            price,
            spend,
          },
        },
      });
    });
  });

export const putSuppressionDatesEpic: Epic = (action$, store, { api }) =>
  action$.ofType(putSuppressionDates.started.type).switchMap(({ payload }) => {
    const state: State = store.getState();
    const rid: number = selectors.rid(state);
    const user: User = selectors.user(state);
    return api
      .putSuppressionDates(rid, payload.campaignId, {
        changedByUser: user.userName,
        custom: payload.custom,
        default: payload.default,
      })
      .mergeMap(() => [putSuppressionDates.done({ params: payload, result: true }), fetchCampaigns.started({})])
      .catch(() => [putSuppressionDates.failed({ params: payload, error: true })]);
  });

export const campaignsEpic = combineEpics(
  createCampaignEpic,
  fetchCampaignsEpic,
  getCreditsAndSpendEpic,
  patchBudgetEpic,
  patchCampaignEpic,
  putSuppressionDatesEpic,
);
