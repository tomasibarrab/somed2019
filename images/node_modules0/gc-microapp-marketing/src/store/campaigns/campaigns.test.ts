import 'rxjs/add/observable/throw';

import configureMockStore from 'redux-mock-store';
import { createEpicMiddleware } from 'redux-observable';
import { Observable } from 'rxjs/Observable';
import { of } from 'rxjs/observable/of';
import { actionCreatorFactory } from 'typescript-fsa';

import { State } from '../types';
import {
    actions, campaignSelector, clearCreate, closeModal, createCampaignEpic, fetchCampaignsEpic,
    getCreditsAndSpendEpic, patchBudgetEpic, patchCampaignEpic, putSuppressionDatesEpic, reducer,
} from './campaigns';
import {
    CampaignState, CampaignsType, CampaignType, CampaignTypes, ModalType, Pages,
} from './campaigns.types';

jest.mock('../../PromotedInventory/Specials/makeSpecialPayload.ts', () => ({
  makeSpecialPayload: (values: any, user: any, rid: any) => ({
    rid,
    startDate: '2020-01-01',
    user,
    values,
  }),
}));

describe('campaignSelector', () => {
  test('to match snapshot', () => {
    const campaign = { campaignId: 'abc', rid: 123 } as CampaignType;
    const campaigns = {
      list: [campaign],
      pageType: Pages.PromotedResults,
    } as CampaignsType;
    const state = { campaigns } as State;

    expect(campaignSelector(state)).toMatchSnapshot();
  });
});

describe('reducer', () => {
  const actionCreator = actionCreatorFactory('CAMPAIGNS');
  const state = {} as CampaignsType;

  test('fetchCampaigns.started keeps pageType from state if none given', () => {
    const data = reducer(state, actions.fetchCampaigns.started({}));
    expect(data).toMatchSnapshot();
  });

  test('fetchCampaigns.started sets pageType if given', () => {
    const data = reducer(
      state,
      actions.fetchCampaigns.started({
        pageType: Pages.Specials,
      }),
    );
    expect(data).toMatchSnapshot();
  });

  test('fetchCampaigns.done to match snapshot', () => {
    const payload = {
      params: {},
      result: {
        list: [],
      },
    };
    const action = { type: actions.fetchCampaigns.done.type, payload };
    expect(reducer(state, action)).toMatchSnapshot();
  });

  test('fetchCampaigns.failed to match snapshot', () => {
    const data = reducer(state, actions.fetchCampaigns.failed);
    expect(data).toMatchSnapshot();
  });

  test('patchCampaign.failed to match snapshot', () => {
    const data = reducer(state, actions.patchCampaign.failed);
    expect(data).toMatchSnapshot();
  });

  test('openModal to match snapshot', () => {
    const modalPayload = {
      campaign: {
        campaignId: 'a',
      },
      type: ModalType.End,
    };
    const data = reducer(state, actions.openModal(modalPayload as any));

    expect(data).toEqual(Object.assign({}, state, { modal: modalPayload }));
  });

  test('closeModal to match snapshot', () => {
    const data = reducer(state, closeModal());

    expect(data).toEqual(Object.assign({}, state, { modal: undefined }));
  });

  test('createCampaign.started sets pending, .done -> !pending, success', () => {
    let data = reducer(state, actions.createCampaign.started({ formValues: {} } as any));

    expect(data).toEqual(Object.assign({}, state, { create: { pending: true } }));
    data = reducer(data, actions.createCampaign.done({ params: { formValues: {} }, result: true } as any));

    expect(data).toEqual(Object.assign({}, state, { create: { pending: false, success: true } }));
  });

  test('createCampaign.started sets pending, .failed -> !pending, !success', () => {
    let data = reducer(state, actions.createCampaign.started({ formValues: {} } as any));

    expect(data).toEqual(Object.assign({}, state, { create: { pending: true } }));
    data = reducer(data, actions.createCampaign.failed({ params: { formValues: {} }, error: true } as any));

    expect(data).toEqual(Object.assign({}, state, { create: { pending: false, success: false } }));
  });

  test('clearCreate sets create: { pending: false }', () => {
    const data = reducer(state, clearCreate());

    expect(data).toEqual(Object.assign({}, state, { create: { pending: false } }));
  });
});

describe('fetchCampaignsEpic', () => {
  let testStore;

  const state = {
    campaigns: {
      pageType: Pages.PromotedResults,
    },
    currentContext: {
      restaurant: {
        rid: 123,
      },
    },
  };

  test('fetchCampaigns.done to match snapshot', () => {
    const mockCampaigns = {
      data: [],
    };
    const dependencies = { api: { fetchCampaigns: () => of(mockCampaigns) } };
    const rootEpic = (action$, store) => fetchCampaignsEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(actions.fetchCampaigns.started({}));
    expect(testStore.getActions()).toMatchSnapshot();
  });

  test('fetchCampaigns.failed to match snapshot', () => {
    const dependencies = { api: { fetchCampaigns: () => Observable.throw('error') } };
    const rootEpic = (action$, store) => fetchCampaignsEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(actions.fetchCampaigns.started({}));
    expect(testStore.getActions()).toMatchSnapshot();
  });

  describe('fetchCampaigns matching page type from state', () => {
    const customPromotionsCampaigns = {
      data: [
        { campaignId: 'a', flexiblePricingVisibility: 'standard' },
        { campaignId: 'b', flexiblePricingVisibility: 'reduce' },
        { campaignId: 'c', flexiblePricingVisibility: 'increase' },
        { campaignId: 'd' },
      ],
    };
    const nonCustomPromotionsCampaigns = {
      data: [{ campaignId: 'xyz' }],
    };
    const flexPricingPendingApprovalAndACustomPromotion = {
      data: [
        {
          campaignId: 'a',
          flexiblePricingVisibility: 'standard',
          needsDecisionMakerApproval: true,
          state: CampaignState.Draft,
        },
        { campaignId: 'b' },
      ],
    };
    const scenarios = [
      {
        description: 'should include pending FP campaigns in custom promotion pagetype fetch',
        mockCampaigns: flexPricingPendingApprovalAndACustomPromotion,
        pageType: Pages.CustomPromotions,
        result: { includeDetails: true, rid: 123, types: [CampaignTypes.CustomPromotions] },
      },
      {
        description:
          'should fetch page type Custom Promotions and NOT return campaigns that are visiblity "standard/increase"',
        mockCampaigns: customPromotionsCampaigns,
        pageType: Pages.CustomPromotions,
        result: { includeDetails: true, rid: 123, types: [CampaignTypes.CustomPromotions] },
      },
      {
        description:
          'should fetch page type Flexible Pricing and only return campaigns that visibility "standard/increase"',
        mockCampaigns: customPromotionsCampaigns,
        pageType: Pages.FlexiblePricing,
        result: { includeDetails: true, rid: 123, types: [CampaignTypes.CustomPromotions] },
      },
      {
        description: 'should fetch page type Promoted Results',
        mockCampaigns: nonCustomPromotionsCampaigns,
        pageType: Pages.PromotedResults,
        result: { rid: 123, types: [CampaignTypes.PromotedResults] },
      },
      {
        description: 'should fetch page type Specials',
        mockCampaigns: nonCustomPromotionsCampaigns,
        pageType: Pages.Specials,
        result: { rid: 123, types: [CampaignTypes.Special] },
      },
    ];
    scenarios.forEach(({ description, mockCampaigns, pageType, result }) => {
      it(description, () => {
        const dependencies = { api: { fetchCampaigns: jest.fn(() => of(mockCampaigns)) } };
        const rootEpic = (action$, store) => fetchCampaignsEpic(action$, store, dependencies as any);
        const epicMiddleware = createEpicMiddleware(rootEpic);
        const mockStore = configureMockStore([epicMiddleware]);
        testStore = mockStore({
          ...state,
          campaigns: {
            pageType,
          },
        });
        testStore.dispatch(actions.fetchCampaigns.started({}));
        expect(testStore.getActions()).toMatchSnapshot();
        expect(dependencies.api.fetchCampaigns).toHaveBeenCalledWith(result);
      });
    });
  });
});

describe('createCampaignEpic', () => {
  let testStore;

  const state = {
    currentContext: {
      restaurant: {
        rid: 123,
      },
      user: {
        firstName: 'Jackie',
        lastName: 'Chan',
        userName: 'restaurateur@example.com',
      },
    },
  };

  test('createCampaign.done to match snapshot (w/ refetch specials)', () => {
    const dependencies = { api: { createCampaign: () => of({}) } };
    const rootEpic = (action$, store) => createCampaignEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.createCampaign.started({
        formValues: {},
        refetchCampaigns: Pages.Specials,
      } as any),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });

  test('createCampaign.done to match snapshot (no refetch)', () => {
    const dependencies = { api: { createCampaign: () => of({}) } };
    const rootEpic = (action$, store) => createCampaignEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.createCampaign.started({
        formValues: {},
      } as any),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });

  test('createCampaign.failed to match snapshot', () => {
    const dependencies = { api: { createCampaign: () => Observable.throw('error') } };
    const rootEpic = (action$, store) => createCampaignEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.createCampaign.started({
        formValues: {},
      } as any),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });
});

describe('patchCampaignEpic', () => {
  let testStore;

  const state = {
    currentContext: {
      restaurant: {
        rid: 123,
      },
      user: {
        userName: 'restaurateur@example.com',
      },
    },
  };

  test('patchCampaign.done to match snapshot (w/ refetch)', () => {
    const dependencies = { api: { patchCampaign: () => of({}) } };
    const rootEpic = (action$, store) => patchCampaignEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.patchCampaign.started({
        campaignId: 'campaign-id-123abc',
        refetchCampaigns: true,
        state: 'paused',
      }),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });

  test('patchCampaign.done to match snapshot (no refetch)', () => {
    const dependencies = { api: { patchCampaign: () => of({}) } };
    const rootEpic = (action$, store) => patchCampaignEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.patchCampaign.started({
        campaignId: 'campaign-id-123abc',
        refetchCampaigns: false,
        state: 'paused',
      }),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });

  test('patchCampaign.failed to match snapshot', () => {
    const dependencies = { api: { patchCampaign: () => Observable.throw('error') } };
    const rootEpic = (action$, store) => patchCampaignEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.patchCampaign.started({
        campaignId: 'campaign-id-123abc',
        refetchCampaigns: false,
        state: 'paused',
      }),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });
});

describe('putSuppressionDatesEpic', () => {
  let testStore;

  const state = {
    currentContext: {
      restaurant: {
        rid: 123,
      },
      user: {
        userName: 'restaurateur@example.com',
      },
    },
  };

  test('putSuppressionDates.done to match snapshot (w/ refetch)', () => {
    const dependencies = { api: { putSuppressionDates: () => of({}) } };
    const rootEpic = (action$, store) => putSuppressionDatesEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.putSuppressionDates.started({
        campaignId: 'campaign-id-123abc',
        custom: [],
        default: [],
      }),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });

  test('putSuppressionDates.failed to match snapshot', () => {
    const dependencies = { api: { putSuppressionDates: () => Observable.throw('error') } };
    const rootEpic = (action$, store) => putSuppressionDatesEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.putSuppressionDates.started({
        campaignId: 'campaign-id-123abc',
        custom: [],
        default: [],
      }),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });
});

describe('patchBudgetEpic', () => {
  let testStore;

  const state = {
    currentContext: {
      restaurant: {
        rid: 123,
      },
      user: {
        userName: 'restaurateur@example.com',
      },
    },
  };

  it('should match snapshot when patchBudget success', () => {
    const mockPatchBudget = {
      response: { data: { campaignId: 'abc123', monthlyBudget: 501 } },
    };
    const dependencies = {
      api: {
        patchBudget: () => of(mockPatchBudget),
      },
    };
    const rootEpic = (action$, store) => patchBudgetEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.patchBudget.started({
        campaignId: 'campaign-id-123abc',
        changedByUser: 'jane.doe@email.com',
        monthlyBudget: 500,
      }),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });

  it('should match snapshot when patchBudget failed', () => {
    const dependencies = { api: { patchBudget: () => Observable.throw('error') } };
    const rootEpic = (action$, store) => patchBudgetEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.patchBudget.started({
        campaignId: 'campaign-id-123abc',
        changedByUser: 'jane.doe@email.com',
        monthlyBudget: 500,
      }),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });
});

describe('getCreditsAndSpendEpic', () => {
  let testStore;

  const state = {
    currentContext: {
      restaurant: {
        rid: 123,
      },
      user: {
        userName: 'restaurateur@example.com',
      },
    },
  };

  it('should match snapshot when fetchCredits and fetchSpend success', () => {
    const dependencies = {
      api: {
        fetchCredits: () =>
          of({
            activeCustomPromotion: true,
            coverPrice: 2.75,
            creditAmount: 200,
            currencyCode: 'USD',
            rid: 12345,
          }),
        fetchSpend: () =>
          of({
            data: [
              {
                covers: 9,
                spend: 3,
                yearMonth: '2019-08',
              },
              {
                covers: 15,
                spend: 5, // take the highest spend
                yearMonth: '2019-09',
              },
              {
                covers: 12,
                spend: 4,
                yearMonth: '2019-10',
              },
            ],
          }),
      },
    };
    const rootEpic = (action$, store) => getCreditsAndSpendEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.openEditBudgetModal.started({
        campaignId: 'campaign-id-123abc',
        monthlyBudget: 500,
        pricingTier: {
          price: 3,
        },
        rid: 12345,
      } as any),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });

  it('should match snapshot when fetchCredits and fetchSpend failed', () => {
    const dependencies = {
      api: {
        fetchCredits: () => Observable.throw('error'),
        fetchSpend: () => Observable.throw('error'),
      },
    };
    const rootEpic = (action$, store) => getCreditsAndSpendEpic(action$, store, dependencies as any);
    const epicMiddleware = createEpicMiddleware(rootEpic);
    const mockStore = configureMockStore([epicMiddleware]);
    testStore = mockStore({
      ...state,
    });
    testStore.dispatch(
      actions.openEditBudgetModal.started({
        campaignId: 'campaign-id-123abc',
        monthlyBudget: 500,
        pricingTier: {
          price: 3,
        },
        rid: 12345,
      } as any),
    );
    expect(testStore.getActions()).toMatchSnapshot();
  });
});
