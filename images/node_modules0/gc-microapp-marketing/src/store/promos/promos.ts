import addYears from 'date-fns/add_years';
import isFuture from 'date-fns/is_future';

import filter from 'lodash/filter';
import find from 'lodash/find';
import map from 'lodash/map';
import sortBy from 'lodash/sortBy';

import { combineEpics } from 'redux-observable';
import { createSelector } from 'reselect';
import { Action, actionCreatorFactory, Success } from 'typescript-fsa';
import { reducerWithInitialState } from 'typescript-fsa-reducers';

import { selectors } from 'gca-react-components/src/redux-modules/currentContext';
import merge from 'gca-react-components/src/utils/merge';

import { Epic, State, Store } from '../types';
import { mapFetchToStore } from './mapFetchToStore';
import { mapStoreToUpdate } from './mapStoreToUpdate';
import { PromoForm } from './promoForm';
import { Promo, Promos, RestaurantPromo, UpdatePromoBody } from './promos.types';

import '../commonRxjs';

// --------------------------------- //
// Actions
// --------------------------------- //

export const enum PromoType {
  Featured = 'Featured',
  Seasonal = 'Seasonal',
}

export const enum FlashMessage {
  Published = 'published',
  Removed = 'removed',
  Saved = 'saved',
}

export const enum Status {
  Init = 'init',
  Open = 'open',
  Failure = 'failure',
  Success = 'success',
}

const actionCreator = actionCreatorFactory('PROMOS');

export const cancelEditPromo = actionCreator('CANCEL_EDIT');
export const editPromo = actionCreator<number>('EDIT');
export const ensurePromos = actionCreator('ENSURE');
export const fetchPromos = actionCreator.async<{}, Promos>('FETCH');
export const resetFlashMessage = actionCreator('RESET_FLASH_MESSAGE');
export const updatePromo = actionCreator.async<PromoForm | null, RestaurantPromo>('UPDATE');

// --------------------------------- //
// Reducer
// --------------------------------- //

export const getFlashMessage = (currentPromo: RestaurantPromo, newPromo: RestaurantPromo) => {
  if (currentPromo.promoRestaurant === null) {
    return FlashMessage.Published;
  }

  if (newPromo.promoRestaurant === null) {
    return FlashMessage.Removed;
  }

  return FlashMessage.Saved;
};

export const initialState: Promos = {
  creditCardEnabled: false,
  currentPromoId: null,
  fetchStatus: Status.Init,
  flashMessage: null,
  metroId: 0,
  primaryLanguage: '',
  promos: {},
  saveStatus: Status.Init,
};

const updatePromoDoneHandler = (state: Promos, { result }: Success<PromoForm | null, RestaurantPromo>): Promos => {
  const id = result.id;
  const flashMessage = getFlashMessage(state.promos[id], result);

  return {
    ...state,
    currentPromoId: null,
    flashMessage,
    promos: {
      ...state.promos,
      [id]: result,
    },
    saveStatus: Status.Success,
  };
};

export const promosReducer = reducerWithInitialState(initialState)
  .case(cancelEditPromo, state => ({ ...state, currentPromoId: null, saveStatus: Status.Init }))
  .case(editPromo, (state, currentPromoId) => ({ ...state, currentPromoId }))
  .case(fetchPromos.started, state => ({ ...state, fetchStatus: Status.Open }))
  .case(fetchPromos.done, (state, { result }) => ({ ...state, fetchStatus: 'success', ...result }))
  .case(fetchPromos.failed, state => ({ ...state, fetchStatus: Status.Failure }))
  .case(resetFlashMessage, state => ({ ...state, flashMessage: null }))
  .case(updatePromo.started, state => ({ ...state, saveStatus: Status.Open }))
  .case(updatePromo.failed, state => ({ ...state, saveStatus: Status.Failure }))
  .case(updatePromo.done, updatePromoDoneHandler);

// --------------------------------- //
// Selectors
// --------------------------------- //
export function currentPromoSelector(state: State): null | RestaurantPromo {
  if (state.promos.currentPromoId !== null) {
    return find(state.promos.promos, (promo: RestaurantPromo) => promo.id === state.promos.currentPromoId) || null;
  }

  return null;
}

export const isFeaturedString = (promoType: string) => promoType === PromoType.Featured;
export const isFeatured = (promo: RestaurantPromo) => isFeaturedString(promo.promo.type);
export const isSeasonal = (promo: RestaurantPromo) => promo.promo.type === PromoType.Seasonal;
export const isJoined = ({ promoRestaurant }: RestaurantPromo) =>
  (promoRestaurant && promoRestaurant.isActive) || false;
export const isUnjoined = (promo: RestaurantPromo) => !isJoined(promo);

// base promos selector
const allPromos = (state: State) => state.promos.promos;

const allFeaturedPromos = createSelector(allPromos, promos => filter(promos, isFeatured));
export const joinedFeaturedPromos = createSelector(allFeaturedPromos, promos => promos.filter(isJoined));
export const unjoinedFeaturedPromos = createSelector(allFeaturedPromos, promos => promos.filter(isUnjoined));

export const featuredPromos = createSelector(
  joinedFeaturedPromos,
  unjoinedFeaturedPromos,
  (joinedPromos, unjoinedPromos) => ({ joinedPromos, unjoinedPromos }),
);

const allSeasonalPromos = createSelector(allPromos, promos => filter(promos, isSeasonal));
// seasonal promos should be sorted in ascending order by EventStartDate
//  e.g. Easter before July 4th
// ISO 8601 (EventStartDate) is sortable as text without any conversion.

const getAdjustedDate = (promo: RestaurantPromo) =>
  isFuture(promo.promo.eventDates.start)
    ? promo.promo.eventDates.start
    : addYears(promo.promo.eventDates.start, 1).toISOString();

const allSortedSeasonalPromos = createSelector(allSeasonalPromos, promos => sortBy(promos, getAdjustedDate));

export const joinedSeasonalPromos = createSelector(allSortedSeasonalPromos, promos => promos.filter(isJoined));
export const unjoinedSeasonalPromos = createSelector(allSortedSeasonalPromos, promos => promos.filter(isUnjoined));
export const seasonalPromos = createSelector(
  joinedSeasonalPromos,
  unjoinedSeasonalPromos,
  (joinedPromos, unjoinedPromos) => ({ joinedPromos, unjoinedPromos }),
);

// --------------------------------- //
// Epic
// --------------------------------- //

/*
 * fetchPromosEpic always fetch promos
 *  if you want to reuse existing loaded promos then use ensurePromos
 */
export const fetchPromosEpic: Epic = (action$, store, { api }) =>
  action$.ofType(fetchPromos.started.type).switchMap(() => {
    const rid = selectors.rid(store.getState());

    return api
      .fetchPromos({ rid })
      .map(mapFetchToStore)
      .map(promos => fetchPromos.done({ params: {}, result: promos }))
      .catch(() => [fetchPromos.failed({ params: {}, error: {} })]);
  });

/*
 * ensurePromosEpic don't fetch promos if already loaded
 *  (because both seasonal and featured promos are loaded at same time)
 * if want to load promos then skip this and use the fetchPromosRequest action directly
 */
export const ensurePromosEpic: Epic = (action$, store) =>
  action$
    .ofType(ensurePromos.type)
    .filter(() => store.getState().promos.fetchStatus !== 'success')
    .map(() => fetchPromos.started({}));

export const updatePromoEpic: Epic = (action$, store, { api }) =>
  action$.ofType(updatePromo.started.type).switchMap(({ payload }: Action<PromoForm>) => {
    const state = store.getState();
    const rid = selectors.rid(state);
    const pid = state.promos.currentPromoId;

    if (!pid) {
      throw new Error("currentPromoId is required, but we've gotten here without one.");
    }

    const body = mapStoreToUpdate(state, payload);

    return api
      .updatePromo({ rid, pid, body })
      .map(({ response }) => updatePromo.done({ params: payload, result: { ...response, id: pid } }))
      .catch(() => [updatePromo.failed({ params: payload, error: {} })]);
  });

export const promosEpic = combineEpics(fetchPromosEpic, updatePromoEpic, ensurePromosEpic);
